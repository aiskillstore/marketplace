name: Validate Marketplace

on:
  push:
    branches: [main]
    paths:
      # Only validate approved plugins on push to main
      # pending/** is validated via PR, no need to re-validate after merge
      - '.claude-plugin/marketplace.json'
      - 'plugins/**/.claude-plugin/plugin.json'
      - 'plugins/**/skill-report.json'
  pull_request:
    branches: [main]
    paths:
      # Validate both pending and plugins on PR (CI gate)
      - '.claude-plugin/marketplace.json'
      - 'plugins/**/.claude-plugin/plugin.json'
      - 'plugins/**/skill-report.json'
      - 'pending/**/.claude-plugin/plugin.json'
      - 'pending/**/skill-report.json'
  workflow_dispatch:

env:
  # Enable auto-fix for push, PRs, and manual triggers (set to 'false' to disable)
  AUTO_FIX_ENABLED: ${{ contains(fromJSON('["pull_request", "push", "workflow_dispatch"]'), github.event_name) }}

jobs:
  validate:
    runs-on: self-hosted
    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          repositories: marketplace,skillstore

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'

      - name: Install dependencies
        run: npm install ajv ajv-formats gray-matter

      - name: Validate marketplace.json
        run: |
          node -e "
            const Ajv = require('ajv');
            const addFormats = require('ajv-formats');
            const fs = require('fs');
            
            const ajv = new Ajv({ allErrors: true });
            addFormats(ajv);
            
            const schema = JSON.parse(fs.readFileSync('schemas/marketplace.schema.json', 'utf8'));
            const data = JSON.parse(fs.readFileSync('.claude-plugin/marketplace.json', 'utf8'));
            
            const validate = ajv.compile(schema);
            const valid = validate(data);
            
            if (!valid) {
              console.error('Validation errors:', JSON.stringify(validate.errors, null, 2));
              process.exit(1);
            }
            console.log('marketplace.json is valid');
          "

      - name: Validate all plugin.json files
        run: |
          node -e "
            const Ajv = require('ajv');
            const addFormats = require('ajv-formats');
            const fs = require('fs');
            const path = require('path');
            const { globSync } = require('fs');
            
            const ajv = new Ajv({ allErrors: true });
            addFormats(ajv);
            
            const schema = JSON.parse(fs.readFileSync('schemas/plugin.schema.json', 'utf8'));
            const validate = ajv.compile(schema);
            
            let hasErrors = false;
            
            // Find all plugin.json files
            const pluginFiles = [];
            const findPluginJsons = (dir) => {
              if (!fs.existsSync(dir)) return;
              const entries = fs.readdirSync(dir, { withFileTypes: true });
              for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                if (entry.isDirectory()) {
                  findPluginJsons(fullPath);
                } else if (entry.name === 'plugin.json') {
                  pluginFiles.push(fullPath);
                }
              }
            };
            
            findPluginJsons('plugins');
            findPluginJsons('pending');
            
            for (const file of pluginFiles) {
              try {
                const data = JSON.parse(fs.readFileSync(file, 'utf8'));
                const valid = validate(data);
                if (!valid) {
                  console.error(\`Validation errors in \${file}:\`, JSON.stringify(validate.errors, null, 2));
                  hasErrors = true;
                } else {
                  console.log(\`\${file} is valid\`);
                }
              } catch (e) {
                console.error(\`Error reading \${file}:\`, e.message);
                hasErrors = true;
              }
            }
            
            if (hasErrors) process.exit(1);
            console.log('All plugin.json files are valid');
          "

      - name: Check marketplace consistency
        id: check-consistency
        continue-on-error: true
        run: |
          node -e "
            const fs = require('fs');
            const path = require('path');
            
            const autoFixEnabled = process.env.AUTO_FIX_ENABLED === 'true';
            const marketplace = JSON.parse(fs.readFileSync('.claude-plugin/marketplace.json', 'utf8'));
            
            let hasErrors = false;
            let fixedCount = 0;
            const orphanedEntries = [];
            
            for (const plugin of marketplace.plugins) {
              const pluginPath = plugin.source;
              const manifestDir = path.join(pluginPath, '.claude-plugin');
              const manifestPath = path.join(manifestDir, 'plugin.json');
              
              // Case 1: Plugin directory doesn't exist at all
              if (!fs.existsSync(pluginPath)) {
                console.error(\`Plugin directory not found: \${pluginPath}\`);
                orphanedEntries.push(plugin.name);
                hasErrors = true;
                continue;
              }
              
              // Case 2: Plugin directory exists but manifest is missing
              if (!fs.existsSync(manifestPath)) {
                if (autoFixEnabled) {
                  console.log(\`::notice::Missing manifest for '\${plugin.name}', attempting auto-fix...\`);
                  
                  // Try to read from marketplace-entry.json if it exists
                  let manifestData;
                  const marketplaceEntryPath = path.join(pluginPath, 'marketplace-entry.json');
                  
                  if (fs.existsSync(marketplaceEntryPath)) {
                    try {
                      const entry = JSON.parse(fs.readFileSync(marketplaceEntryPath, 'utf8'));
                      manifestData = {
                        name: entry.name || plugin.name,
                        version: entry.version || plugin.version || '1.0.0',
                        description: entry.description || plugin.description,
                        author: entry.author || plugin.author,
                        repository: entry.repository || plugin.repository,
                        license: entry.license || plugin.license || 'UNKNOWN',
                        keywords: entry.keywords || plugin.keywords || []
                      };
                    } catch (e) {
                      console.error(\`Failed to parse marketplace-entry.json: \${e.message}\`);
                    }
                  }
                  
                  // Fall back to marketplace.json entry data
                  if (!manifestData) {
                    manifestData = {
                      name: plugin.name,
                      version: plugin.version || '1.0.0',
                      description: plugin.description,
                      author: plugin.author,
                      repository: plugin.repository,
                      license: plugin.license || 'UNKNOWN',
                      keywords: plugin.keywords || []
                    };
                  }
                  
                  // Create the .claude-plugin directory if it doesn't exist
                  if (!fs.existsSync(manifestDir)) {
                    fs.mkdirSync(manifestDir, { recursive: true });
                  }
                  
                  // Write the plugin.json
                  fs.writeFileSync(manifestPath, JSON.stringify(manifestData, null, 2) + '\\n');
                  console.log(\`::notice::Created plugin.json for '\${plugin.name}'\`);
                  fixedCount++;
                } else {
                  console.error(\`Plugin manifest not found: \${manifestPath}\`);
                  hasErrors = true;
                }
                continue;
              }
              
              // Case 3: Manifest exists - validate name match
              const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
              if (manifest.name !== plugin.name) {
                if (autoFixEnabled) {
                  console.log(\`::notice::Fixing name mismatch for '\${plugin.name}'...\`);
                  manifest.name = plugin.name;
                  fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2) + '\\n');
                  fixedCount++;
                } else {
                  console.error(\`Plugin name mismatch: marketplace says '\${plugin.name}' but manifest says '\${manifest.name}'\`);
                  hasErrors = true;
                }
              }
              
              console.log(\`Plugin '\${plugin.name}' is consistent\`);
            }
            
            // Report summary
            if (fixedCount > 0) {
              console.log(\`\\n::notice::Auto-fixed \${fixedCount} consistency issue(s)\`);
            }

            if (orphanedEntries.length > 0) {
              console.error(\`\\nOrphaned marketplace entries (directory missing):\`);
              orphanedEntries.forEach(name => console.error(\`  - \${name}\`));
              console.error(\`These entries should be removed from marketplace.json\`);
            }

            // Exit with code 1 if we made fixes (to trigger commit step) or if errors remain
            if (hasErrors || fixedCount > 0 || orphanedEntries.length > 0) {
              process.exit(1);
            }
            console.log('Marketplace is consistent with all plugins');
          "

      - name: Remove orphaned marketplace entries
        if: steps.check-consistency.outcome == 'failure' && env.AUTO_FIX_ENABLED == 'true'
        run: |
          node -e "
            const fs = require('fs');
            const path = require('path');
            
            const marketplacePath = '.claude-plugin/marketplace.json';
            const marketplace = JSON.parse(fs.readFileSync(marketplacePath, 'utf8'));
            
            const originalCount = marketplace.plugins.length;
            
            // Filter out plugins whose directories don't exist
            marketplace.plugins = marketplace.plugins.filter(plugin => {
              const exists = fs.existsSync(plugin.source);
              if (!exists) {
                console.log(\`::notice::Removing orphaned entry: \${plugin.name} (directory \${plugin.source} not found)\`);
              }
              return exists;
            });
            
            const removedCount = originalCount - marketplace.plugins.length;
            
            if (removedCount > 0) {
              fs.writeFileSync(marketplacePath, JSON.stringify(marketplace, null, 2) + '\\n');
              console.log(\`::notice::Removed \${removedCount} orphaned marketplace entries\`);
            } else {
              console.log('No orphaned entries to remove');
            }
          "

      - name: Re-check marketplace consistency
        if: steps.check-consistency.outcome == 'failure' && env.AUTO_FIX_ENABLED == 'true'
        id: recheck-consistency
        run: |
          node -e "
            const fs = require('fs');
            const path = require('path');
            
            const marketplace = JSON.parse(fs.readFileSync('.claude-plugin/marketplace.json', 'utf8'));
            
            let hasErrors = false;
            
            for (const plugin of marketplace.plugins) {
              const pluginPath = plugin.source;
              const manifestPath = path.join(pluginPath, '.claude-plugin', 'plugin.json');
              
              if (!fs.existsSync(pluginPath)) {
                console.error(\`Plugin directory not found: \${pluginPath}\`);
                hasErrors = true;
                continue;
              }
              
              if (!fs.existsSync(manifestPath)) {
                console.error(\`Plugin manifest not found: \${manifestPath}\`);
                hasErrors = true;
                continue;
              }
              
              const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
              if (manifest.name !== plugin.name) {
                console.error(\`Plugin name mismatch: marketplace says '\${plugin.name}' but manifest says '\${manifest.name}'\`);
                hasErrors = true;
              }
              
              console.log(\`Plugin '\${plugin.name}' is consistent\`);
            }
            
            if (hasErrors) process.exit(1);
            console.log('Marketplace is consistent with all plugins after auto-fix');
          "

      - name: Commit consistency fixes (isolated temp directory)
        if: steps.check-consistency.outcome == 'failure' && env.AUTO_FIX_ENABLED == 'true' && steps.recheck-consistency.outcome == 'success'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          
          # Determine branch name based on event type
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            BRANCH="${{ github.head_ref }}"
          else
            BRANCH="${{ github.ref_name }}"
          fi
          
          echo "Target branch: $BRANCH"
          
          # Use temp directory for clean git operations
          # This eliminates state pollution from self-hosted runners
          WORK_DIR="/tmp/marketplace-validate-${{ github.run_id }}"
          
          cleanup() {
            echo "ðŸ§¹ Cleaning up temp directory..."
            rm -rf "$WORK_DIR" 2>/dev/null || true
          }
          trap cleanup EXIT
          
          echo "ðŸ“¦ Cloning fresh repository to $WORK_DIR..."
          git clone --depth 1 --branch "$BRANCH" "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" "$WORK_DIR"
          
          # Copy updated files from checkout to fresh clone
          cp .claude-plugin/marketplace.json "$WORK_DIR/.claude-plugin/marketplace.json"
          find plugins -name "plugin.json" -exec sh -c 'mkdir -p "'"$WORK_DIR"'/$(dirname "{}")" && cp "{}" "'"$WORK_DIR"'/{}"' \; 2>/dev/null || true
          find pending -name "plugin.json" -exec sh -c 'mkdir -p "'"$WORK_DIR"'/$(dirname "{}")" && cp "{}" "'"$WORK_DIR"'/{}"' \; 2>/dev/null || true
          
          cd "$WORK_DIR"
          
          git config user.name "ai-skill-store[bot]"
          git config user.email "2628292+ai-skill-store[bot]@users.noreply.github.com"
          
          # Stage all consistency-related changes
          git add .claude-plugin/marketplace.json
          git add "plugins/**/.claude-plugin/plugin.json" 2>/dev/null || true
          git add "pending/**/.claude-plugin/plugin.json" 2>/dev/null || true
          
          # Check if there's anything to commit
          if git diff --staged --quiet; then
            echo "No consistency changes to commit"
            exit 0
          fi
          
          # Commit the staged changes
          git commit -m "fix: auto-fix marketplace consistency issues

          - Generated missing plugin.json manifests from marketplace entries
          - Removed orphaned marketplace entries (directories not found)
          - Fixed plugin name mismatches"
          
          # Push with retry for race conditions
          for i in 1 2 3; do
            if git push origin "$BRANCH"; then
              echo "::notice::Consistency fixes committed and pushed to $BRANCH"
              break
            fi
            echo "Push failed, pulling and retrying ($i/3)..."
            git pull --rebase origin "$BRANCH" || {
              git rebase --abort 2>/dev/null || true
              git reset --hard "origin/$BRANCH"
              git cherry-pick HEAD@{1} || true
            }
            sleep 2
          done

      - name: Fail if consistency errors remain
        if: steps.check-consistency.outcome == 'failure' && (env.AUTO_FIX_ENABLED != 'true' || steps.recheck-consistency.outcome == 'failure')
        run: |
          echo "::error::Marketplace consistency check failed"
          exit 1

      - name: Validate SKILL.md files have proper YAML frontmatter
        id: validate-skill-md
        continue-on-error: true
        run: |
          node -e "
            const fs = require('fs');
            const path = require('path');
            const matter = require('gray-matter');

            /**
             * Validate that content has valid SKILL.md structure (YAML frontmatter + required fields)
             * Returns array of error messages, empty if valid
             */
            function validateSkillMdContent(rawContent, dirName) {
              const errors = [];

              // Check for binary content (null bytes)
              if (rawContent.includes('\\x00')) {
                return ['File contains binary content - skipping'];
              }

              // Check for YAML frontmatter delimiters
              if (!rawContent.startsWith('---')) {
                errors.push('Missing YAML frontmatter (must start with ---)');
                return errors;
              }

              // Check for closing delimiter
              const endIndex = rawContent.indexOf('---', 3);
              if (endIndex === -1) {
                errors.push('Missing closing YAML frontmatter delimiter (---)');
                return errors;
              }

              // Check if frontmatter section has content
              const frontmatterContent = rawContent.slice(3, endIndex).trim();
              if (!frontmatterContent) {
                errors.push('Empty YAML frontmatter (no metadata found)');
                return errors;
              }

              // Parse with gray-matter for field validation
              try {
                const { data } = matter(rawContent);

                // Check required field: name
                // Per specification: lowercase alphanumeric + hyphens only, 1-64 chars
                const NAME_PATTERN = /^[a-z0-9]+(-[a-z0-9]+)*$/;
                if (!data.name) {
                  errors.push('Missing required field: name');
                } else if (typeof data.name !== 'string') {
                  errors.push('Field "name" must be a string');
                } else if (data.name.length > 64) {
                  errors.push('Field "name" exceeds 64 characters');
                } else if (!NAME_PATTERN.test(data.name)) {
                  errors.push(\`Field "name" must be lowercase alphanumeric with hyphens (got: \${data.name})\`);
                }

                // Check required field: description
                if (!data.description) {
                  errors.push('Missing required field: description');
                }
              } catch (e) {
                errors.push(\`Failed to parse YAML frontmatter: \${e.message}\`);
              }

              return errors;
            }

            const findSkillMdFiles = (dir) => {
              const files = [];
              if (!fs.existsSync(dir)) return files;
              const entries = fs.readdirSync(dir, { withFileTypes: true });
              for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                if (entry.isDirectory()) {
                  files.push(...findSkillMdFiles(fullPath));
                } else if (entry.name === 'SKILL.md') {
                  files.push(fullPath);
                }
              }
              return files;
            };

            const skillMdFiles = [...findSkillMdFiles('plugins'), ...findSkillMdFiles('pending')];
            let hasInvalidFiles = false;
            let skippedBinary = 0;

            for (const file of skillMdFiles) {
              try {
                const content = fs.readFileSync(file, 'utf8');

                // Check if content is empty or looks binary
                if (!content.trim()) {
                  console.log(\`Skipping empty file: \${file}\`);
                  skippedBinary++;
                  continue;
                }

                const dirName = path.basename(path.dirname(file));
                const validationErrors = validateSkillMdContent(content, dirName);

                if (validationErrors.length > 0) {
                  // Check if it's just a binary skip
                  if (validationErrors[0].includes('binary content')) {
                    console.log(\`Skipping binary file: \${file}\`);
                    skippedBinary++;
                    continue;
                  }

                  console.error(\`::error file=\${file}::\${validationErrors.join('; ')}\`);
                  console.error(\`  Plugin: \${file}\`);
                  for (const err of validationErrors) {
                    console.error(\`    - \${err}\`);
                  }
                  hasInvalidFiles = true;
                }
              } catch (e) {
                console.error(\`::error file=\${file}::Failed to read file: \${e.message}\`);
                hasInvalidFiles = true;
              }
            }

            if (hasInvalidFiles) {
              console.error('\\nâŒ Invalid SKILL.md files detected');
              console.error('These plugins must have proper YAML frontmatter with name and description fields.');
              process.exit(1);
            }

            console.log(\`âœ… All \${skillMdFiles.length - skippedBinary} SKILL.md files are valid (skipped \${skippedBinary} binary/empty files)\`);
          "

      - name: Download skillstore CLI for SKILL.md auto-fix
        if: steps.validate-skill-md.outcome == 'failure' && env.AUTO_FIX_ENABLED == 'true'
        id: download-cli-skillmd
        uses: ./.github/actions/download-skillstore-cli
        with:
          token: ${{ steps.app-token.outputs.token }}

      - name: Auto-fix SKILL.md validation errors
        if: steps.validate-skill-md.outcome == 'failure' && env.AUTO_FIX_ENABLED == 'true'
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          CLI_PATH: ${{ steps.download-cli-skillmd.outputs.cli-path }}
        run: |
          echo "::notice::SKILL.md validation failed. Attempting AI-powered auto-fix..."
          echo "Running AI-powered fix-md on plugins directory..."
          "$CLI_PATH" skill fix-md ./plugins || true

          echo "Running AI-powered fix-md on pending directory..."
          "$CLI_PATH" skill fix-md ./pending || true

          echo "::notice::SKILL.md auto-fix completed. Re-validating..."

      - name: Re-validate SKILL.md after auto-fix
        if: steps.validate-skill-md.outcome == 'failure' && env.AUTO_FIX_ENABLED == 'true'
        id: revalidate-skill-md
        run: |
          node -e "
            const fs = require('fs');
            const path = require('path');
            const matter = require('gray-matter');

            function validateSkillMdContent(rawContent, dirName) {
              const errors = [];
              if (rawContent.includes('\\x00')) return ['binary'];
              if (!rawContent.startsWith('---')) {
                errors.push('Missing YAML frontmatter');
                return errors;
              }
              const endIndex = rawContent.indexOf('---', 3);
              if (endIndex === -1) {
                errors.push('Missing closing YAML delimiter');
                return errors;
              }
              try {
                const { data } = matter(rawContent);
                const NAME_PATTERN = /^[a-z0-9]+(-[a-z0-9]+)*$/;
                if (!data.name) errors.push('Missing name');
                else if (!NAME_PATTERN.test(data.name)) errors.push('Invalid name format');
                if (!data.description) errors.push('Missing description');
              } catch (e) {
                errors.push('YAML parse error');
              }
              return errors;
            }

            const findSkillMdFiles = (dir) => {
              const files = [];
              if (!fs.existsSync(dir)) return files;
              const entries = fs.readdirSync(dir, { withFileTypes: true });
              for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                if (entry.isDirectory()) files.push(...findSkillMdFiles(fullPath));
                else if (entry.name === 'SKILL.md') files.push(fullPath);
              }
              return files;
            };

            const skillMdFiles = [...findSkillMdFiles('plugins'), ...findSkillMdFiles('pending')];
            let hasInvalidFiles = false;
            let fixedCount = 0;

            for (const file of skillMdFiles) {
              try {
                const content = fs.readFileSync(file, 'utf8');
                if (!content.trim()) continue;
                const dirName = path.basename(path.dirname(file));
                const errors = validateSkillMdContent(content, dirName);
                if (errors.length > 0 && errors[0] !== 'binary') {
                  console.error(\`Still invalid: \${file} - \${errors.join(', ')}\`);
                  hasInvalidFiles = true;
                } else {
                  fixedCount++;
                }
              } catch (e) {
                console.error(\`Error reading \${file}: \${e.message}\`);
                hasInvalidFiles = true;
              }
            }

            console.log(\`Validation summary: \${fixedCount}/\${skillMdFiles.length} files valid\`);
            if (hasInvalidFiles) {
              console.error('Some SKILL.md files still have validation errors after auto-fix');
              process.exit(1);
            }
            console.log('All SKILL.md files are now valid after auto-fix');
          "

      - name: Commit auto-fixed SKILL.md files
        if: steps.validate-skill-md.outcome == 'failure' && env.AUTO_FIX_ENABLED == 'true' && steps.revalidate-skill-md.outcome == 'success'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HEAD_REF: ${{ github.head_ref }}
          REF_NAME: ${{ github.ref_name }}
          EVENT_NAME: ${{ github.event_name }}
          APP_TOKEN: ${{ steps.app-token.outputs.token }}
          REPOSITORY: ${{ github.repository }}
          RUN_ID: ${{ github.run_id }}
          WORKSPACE: ${{ github.workspace }}
        run: |
          set -euo pipefail

          if [ "$EVENT_NAME" == "pull_request" ]; then
            BRANCH="$HEAD_REF"
          else
            BRANCH="$REF_NAME"
          fi

          echo "Target branch: $BRANCH"

          WORK_DIR="/tmp/marketplace-validate-skillmd-$RUN_ID"

          cleanup() {
            rm -rf "$WORK_DIR" 2>/dev/null || true
          }
          trap cleanup EXIT

          rm -rf "$WORK_DIR"
          mkdir -p "$WORK_DIR"

          git clone --depth 1 --branch "$BRANCH" \
            "https://x-access-token:${APP_TOKEN}@github.com/${REPOSITORY}.git" \
            "$WORK_DIR"

          cd "$WORK_DIR"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          for dir in plugins pending; do
            if [ -d "${WORKSPACE}/$dir" ]; then
              rsync -av --include='*/' --include='SKILL.md' --exclude='*' \
                "${WORKSPACE}/$dir/" "$WORK_DIR/$dir/" 2>/dev/null || true
            fi
          done

          if git diff --quiet && git diff --cached --quiet; then
            echo "No SKILL.md changes to commit"
            exit 0
          fi

          git add -A
          git commit -m "fix(skills): auto-fix SKILL.md frontmatter validation errors

          AI-powered fix applied by GitHub Actions workflow.
          - Added missing name/description fields
          - Fixed YAML frontmatter structure

          Co-Authored-By: Claude <noreply@anthropic.com>"

          git push origin "$BRANCH"
          echo "::notice::Successfully committed auto-fixed SKILL.md files"

      - name: Fail if SKILL.md errors remain
        if: steps.validate-skill-md.outcome == 'failure' && (env.AUTO_FIX_ENABLED != 'true' || steps.revalidate-skill-md.outcome == 'failure')
        run: |
          echo "::error::SKILL.md validation failed"
          exit 1

      - name: Validate skill-report.json files
        id: validate-skill-reports
        continue-on-error: true
        run: |
          node -e "
            const Ajv = require('ajv');
            const addFormats = require('ajv-formats');
            const fs = require('fs');
            const path = require('path');
            
            const ajv = new Ajv({ allErrors: true });
            addFormats(ajv);
            
            const schema = JSON.parse(fs.readFileSync('schemas/skill-report.schema.json', 'utf8'));
            const validate = ajv.compile(schema);
            
            let hasErrors = false;
            
            const findReportFiles = (dir) => {
              const files = [];
              if (!fs.existsSync(dir)) return files;
              const entries = fs.readdirSync(dir, { withFileTypes: true });
              for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                if (entry.isDirectory()) {
                  files.push(...findReportFiles(fullPath));
                } else if (entry.name === 'skill-report.json') {
                  files.push(fullPath);
                }
              }
              return files;
            };
            
            const reportFiles = [...findReportFiles('plugins'), ...findReportFiles('pending')];
            
            for (const file of reportFiles) {
              try {
                const data = JSON.parse(fs.readFileSync(file, 'utf8'));
                const valid = validate(data);
                if (!valid) {
                  console.error(\`Validation errors in \${file}:\`, JSON.stringify(validate.errors, null, 2));
                  hasErrors = true;
                } else {
                  console.log(\`\${file} is valid\`);
                }
              } catch (e) {
                console.error(\`Error reading \${file}:\`, e.message);
                hasErrors = true;
              }
            }
            
            if (hasErrors) process.exit(1);
            if (reportFiles.length === 0) {
              console.log('No skill-report.json files found (OK for empty marketplace)');
            } else {
              console.log('All skill-report.json files are valid');
            }
          "

      - name: Download skillstore CLI for auto-fix
        if: steps.validate-skill-reports.outcome == 'failure' && env.AUTO_FIX_ENABLED == 'true'
        id: download-cli
        uses: ./.github/actions/download-skillstore-cli
        with:
          token: ${{ steps.app-token.outputs.token }}

      - name: Auto-fix skill-report.json validation errors
        if: steps.validate-skill-reports.outcome == 'failure' && env.AUTO_FIX_ENABLED == 'true'
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          CLI_PATH: ${{ steps.download-cli.outputs.cli-path }}
        run: |
          echo "::notice::Validation failed. Attempting AI-powered auto-fix..."
          echo "Running AI-powered fix on plugins directory..."
          "$CLI_PATH" skill fix ./plugins --schema ./schemas/skill-report.schema.json || true
          
          echo "Running AI-powered fix on pending directory..."
          "$CLI_PATH" skill fix ./pending --schema ./schemas/skill-report.schema.json || true
          
          echo "::notice::Auto-fix completed. Re-validating..."

      - name: Re-validate after auto-fix
        if: steps.validate-skill-reports.outcome == 'failure' && env.AUTO_FIX_ENABLED == 'true'
        id: revalidate
        run: |
          node -e "
            const Ajv = require('ajv');
            const addFormats = require('ajv-formats');
            const fs = require('fs');
            const path = require('path');
            
            const ajv = new Ajv({ allErrors: true });
            addFormats(ajv);
            
            const schema = JSON.parse(fs.readFileSync('schemas/skill-report.schema.json', 'utf8'));
            const validate = ajv.compile(schema);
            
            let hasErrors = false;
            let fixedCount = 0;
            let totalCount = 0;
            
            const findReportFiles = (dir) => {
              const files = [];
              if (!fs.existsSync(dir)) return files;
              const entries = fs.readdirSync(dir, { withFileTypes: true });
              for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                if (entry.isDirectory()) {
                  files.push(...findReportFiles(fullPath));
                } else if (entry.name === 'skill-report.json') {
                  files.push(fullPath);
                }
              }
              return files;
            };
            
            const reportFiles = [...findReportFiles('plugins'), ...findReportFiles('pending')];
            totalCount = reportFiles.length;
            
            for (const file of reportFiles) {
              try {
                const data = JSON.parse(fs.readFileSync(file, 'utf8'));
                const valid = validate(data);
                if (!valid) {
                  console.error(\`Still invalid: \${file}\`);
                  hasErrors = true;
                } else {
                  fixedCount++;
                  console.log(\`Valid: \${file}\`);
                }
              } catch (e) {
                console.error(\`Error reading \${file}:\`, e.message);
                hasErrors = true;
              }
            }
            
            console.log(\`\nValidation summary: \${fixedCount}/\${totalCount} files valid\`);
            
            if (hasErrors) {
              console.error('Some files still have validation errors after auto-fix');
              process.exit(1);
            }
            console.log('All skill-report.json files are now valid after auto-fix');
          "

      - name: Commit auto-fixed files (isolated temp directory)
        if: steps.validate-skill-reports.outcome == 'failure' && env.AUTO_FIX_ENABLED == 'true' && steps.revalidate.outcome == 'success'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          
          # Determine branch name based on event type
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            BRANCH="${{ github.head_ref }}"
          else
            BRANCH="${{ github.ref_name }}"
          fi
          
          echo "Target branch: $BRANCH"
          
          # Use temp directory for clean git operations
          # This eliminates state pollution from self-hosted runners
          WORK_DIR="/tmp/marketplace-validate-reports-${{ github.run_id }}"
          
          cleanup() {
            echo "ðŸ§¹ Cleaning up temp directory..."
            rm -rf "$WORK_DIR" 2>/dev/null || true
          }
          trap cleanup EXIT
          
          echo "ðŸ“¦ Cloning fresh repository to $WORK_DIR..."
          git clone --depth 1 --branch "$BRANCH" "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" "$WORK_DIR"
          
          # Copy updated skill-report.json files from checkout to fresh clone
          find plugins -name "skill-report.json" -exec sh -c 'mkdir -p "'"$WORK_DIR"'/$(dirname "{}")" && cp "{}" "'"$WORK_DIR"'/{}"' \; 2>/dev/null || true
          find pending -name "skill-report.json" -exec sh -c 'mkdir -p "'"$WORK_DIR"'/$(dirname "{}")" && cp "{}" "'"$WORK_DIR"'/{}"' \; 2>/dev/null || true
          
          cd "$WORK_DIR"
          
          git config user.name "ai-skill-store[bot]"
          git config user.email "2628292+ai-skill-store[bot]@users.noreply.github.com"
          
          # Stage ALL skill-report.json changes
          git add plugins/**/skill-report.json pending/**/skill-report.json 2>/dev/null || true
          
          # Check if there's anything to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          
          # Commit the staged changes
          git commit -m "fix: auto-fix skill-report.json validation errors"
          
          # Push with retry for race conditions
          for i in 1 2 3; do
            if git push origin "$BRANCH"; then
              echo "::notice::Auto-fixed files committed and pushed to $BRANCH"
              break
            fi
            echo "Push failed, pulling and retrying ($i/3)..."
            git pull --rebase origin "$BRANCH" || {
              git rebase --abort 2>/dev/null || true
              git reset --hard "origin/$BRANCH"
              git cherry-pick HEAD@{1} || true
            }
            sleep 2
          done

      - name: Add summary
        if: always()
        run: |
          echo "## Validation Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.validate-skill-reports.outcome }}" == "success" ]; then
            echo "âœ… All skill-report.json files passed validation" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.revalidate.outcome }}" == "success" ]; then
            echo "ðŸ”§ Validation errors were automatically fixed by AI" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            if [ "${{ github.event_name }}" == "pull_request" ]; then
              echo "The fixes have been committed to this PR. Please review the changes." >> $GITHUB_STEP_SUMMARY
            else
              echo "The fixes have been committed directly to ${{ github.ref_name }}." >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âŒ Validation failed" >> $GITHUB_STEP_SUMMARY
            if [ "${{ env.AUTO_FIX_ENABLED }}" == "true" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "Auto-fix was attempted but some errors could not be resolved automatically." >> $GITHUB_STEP_SUMMARY
            fi
          fi

      - name: Fail if validation errors remain
        if: steps.validate-skill-reports.outcome == 'failure' && (env.AUTO_FIX_ENABLED != 'true' || steps.revalidate.outcome == 'failure')
        run: |
          echo "::error::skill-report.json validation failed"
          exit 1
