# GitHub Action Workflow for Skill Auditing
# Auto-sharding: switches to parallel matrix mode when skill count exceeds threshold
#
# Modes:
# - Single skill: --slug specified â†’ 1 shard
# - Simple mode: skill count < threshold â†’ 1 shard (sequential)
# - Sharded mode: skill count >= threshold â†’ N parallel shards

name: Audit Skills

on:
  workflow_dispatch:
    inputs:
      model:
        description: 'Model to use (e.g., gpt-5.2-codex:high, claude-sonnet-4.5). Auto-detects agent.'
        type: string
        default: ''
      slug:
        description: 'Audit specific skill only (leave empty for all)'
        type: string
        default: ''
      limit:
        description: 'Maximum total skills to process (leave empty for all)'
        type: string
        default: ''
      shard_size:
        description: 'Skills per shard when auto-sharding (default: 50)'
        type: string
        default: '50'
      max_parallel:
        description: 'Max parallel shards (default: 4)'
        type: string
        default: '4'
      cli_version:
        description: 'CLI version (default: latest)'
        type: string
        default: 'latest'
      dry_run:
        description: 'Preview changes without creating PR'
        type: boolean
        default: false
      failed_only:
        description: 'Only re-audit skills where AI analysis previously failed'
        type: boolean
        default: false

env:
  CLI_VERSION: ${{ inputs.cli_version || 'latest' }}
  SHARD_THRESHOLD: 50

concurrency:
  group: audit-skills
  cancel-in-progress: false

jobs:
  detect-and-plan:
    runs-on: self-hosted
    outputs:
      matrix: ${{ steps.plan.outputs.matrix }}
      total_skills: ${{ steps.plan.outputs.total_skills }}
      shard_count: ${{ steps.plan.outputs.shard_count }}
      is_sharded: ${{ steps.plan.outputs.is_sharded }}
    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ steps.app-token.outputs.token }}
          fetch-depth: 1

      - name: Discover skills and plan strategy
        id: plan
        env:
          TARGET_SLUG: ${{ inputs.slug }}
          LIMIT: ${{ inputs.limit }}
          SHARD_SIZE: ${{ inputs.shard_size || '50' }}
        run: |
          # Single skill mode
          if [ -n "$TARGET_SLUG" ]; then
            echo "ðŸ“Œ Single skill mode: $TARGET_SLUG"
            echo 'matrix={"include":[{"shard":0,"offset":0,"limit":1}]}' >> $GITHUB_OUTPUT
            echo "total_skills=1" >> $GITHUB_OUTPUT
            echo "shard_count=1" >> $GITHUB_OUTPUT
            echo "is_sharded=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Count all skills
          TOTAL=$(find skills -name "skill-report.json" -type f | wc -l | tr -d ' ')
          echo "Found $TOTAL skills in repository"
          
          # Apply limit if specified
          if [ -n "$LIMIT" ] && [ "$LIMIT" -gt 0 ] && [ "$LIMIT" -lt "$TOTAL" ]; then
            TOTAL=$LIMIT
            echo "Limiting to $TOTAL skills"
          fi
          
          if [ "$TOTAL" -eq 0 ]; then
            echo "âŒ No skills found"
            echo 'matrix={"include":[]}' >> $GITHUB_OUTPUT
            echo "total_skills=0" >> $GITHUB_OUTPUT
            echo "shard_count=0" >> $GITHUB_OUTPUT
            echo "is_sharded=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          THRESHOLD=${{ env.SHARD_THRESHOLD }}
          SIZE=$SHARD_SIZE
          
          if [ "$TOTAL" -lt "$THRESHOLD" ]; then
            # Simple mode: single shard
            echo "ðŸ“¦ Simple mode: $TOTAL skills (below threshold $THRESHOLD)"
            echo "matrix={\"include\":[{\"shard\":0,\"offset\":0,\"limit\":$TOTAL}]}" >> $GITHUB_OUTPUT
            echo "total_skills=$TOTAL" >> $GITHUB_OUTPUT
            echo "shard_count=1" >> $GITHUB_OUTPUT
            echo "is_sharded=false" >> $GITHUB_OUTPUT
          else
            # Sharded mode: parallel processing
            SHARDS=$(( (TOTAL + SIZE - 1) / SIZE ))
            echo "ðŸ”€ Sharded mode: $TOTAL skills â†’ $SHARDS shards (size=$SIZE)"
            
            MATRIX='{"include":['
            for i in $(seq 0 $((SHARDS - 1))); do
              OFFSET=$((i * SIZE))
              [ $i -gt 0 ] && MATRIX+=','
              MATRIX+="{\"shard\":$i,\"offset\":$OFFSET,\"limit\":$SIZE}"
            done
            MATRIX+=']}'
            
            echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
            echo "total_skills=$TOTAL" >> $GITHUB_OUTPUT
            echo "shard_count=$SHARDS" >> $GITHUB_OUTPUT
            echo "is_sharded=true" >> $GITHUB_OUTPUT
            
            echo "Matrix: $MATRIX"
          fi

  audit:
    needs: detect-and-plan
    if: needs.detect-and-plan.outputs.shard_count != '0'
    runs-on: self-hosted
    timeout-minutes: 120
    continue-on-error: true
    strategy:
      fail-fast: false
      max-parallel: ${{ fromJSON(inputs.max_parallel || '4') }}
      matrix: ${{ fromJSON(needs.detect-and-plan.outputs.matrix) }}
    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          # Include skillstore repo for CLI download access
          repositories: marketplace,skillstore

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ steps.app-token.outputs.token }}
          fetch-depth: 1

      - name: Download Skillstore CLI
        uses: ./.github/actions/download-skillstore-cli
        with:
          version: ${{ inputs.cli_version || 'latest' }}
          token: ${{ steps.app-token.outputs.token }}

      - name: Audit shard ${{ matrix.shard }}
        id: audit
        env:
          SKILLSTORE_AGENTS: ${{ vars.SKILLSTORE_AGENTS }}
        run: |
          echo "=== Shard ${{ matrix.shard }} ==="
          echo "Offset: ${{ matrix.offset }}"
          echo "Limit: ${{ matrix.limit }}"
          
          MODEL_FLAG=""
          if [ -n "${{ inputs.model }}" ]; then
            MODEL_FLAG="--model ${{ inputs.model }}"
          fi
          
          SLUG_FLAG=""
          if [ -n "${{ inputs.slug }}" ]; then
            SLUG_FLAG="--slug ${{ inputs.slug }}"
          fi
          
          DRY_RUN_FLAG=""
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            DRY_RUN_FLAG="--dry-run"
          fi
          
          FAILED_ONLY_FLAG=""
          if [ "${{ inputs.failed_only }}" = "true" ]; then
            FAILED_ONLY_FLAG="--failed-only"
          fi
          
          # CLI internally retries 3 times per skill on AI failures
          ./skillstore-cli skill audit ./skills \
            $MODEL_FLAG \
            $SLUG_FLAG \
            $DRY_RUN_FLAG \
            $FAILED_ONLY_FLAG \
            --offset ${{ matrix.offset }} \
            --limit ${{ matrix.limit }} \
            2>&1 | tee audit-output-${{ matrix.shard }}.log
          
          # Check for remaining failures after CLI retries
          STILL_FAILED=$(find skills -name "skill-report.json" -newer audit-output-${{ matrix.shard }}.log -exec grep -l "AI analysis failed" {} \; 2>/dev/null | wc -l | tr -d ' ') || STILL_FAILED=0
          
          # Workflow-level retry for persistent failures
          if [ "$STILL_FAILED" -gt 0 ]; then
            echo ""
            echo "ðŸ”„ Workflow retry: $STILL_FAILED skills still failed after CLI retries"
            sleep 30
            
            ./skillstore-cli skill audit ./skills \
              $MODEL_FLAG \
              $SLUG_FLAG \
              $DRY_RUN_FLAG \
              --failed-only \
              --offset ${{ matrix.offset }} \
              --limit ${{ matrix.limit }} \
              2>&1 | tee -a audit-output-${{ matrix.shard }}.log
          fi
          
          UPDATED=$(grep -c "âœ… updated" audit-output-${{ matrix.shard }}.log 2>/dev/null) || UPDATED=0
          ERRORS=$(grep -c "âŒ error" audit-output-${{ matrix.shard }}.log 2>/dev/null) || ERRORS=0
          FINAL_FAILED=$(find skills -name "skill-report.json" -exec grep -l "AI analysis failed" {} \; 2>/dev/null | wc -l | tr -d ' ') || FINAL_FAILED=0
          
          echo ""
          echo "Shard ${{ matrix.shard }} Summary:"
          echo "  Updated: $UPDATED"
          echo "  Errors: $ERRORS"
          echo "  AI failures remaining: $FINAL_FAILED"
          
          echo "updated=$UPDATED" >> $GITHUB_OUTPUT
          echo "errors=$ERRORS" >> $GITHUB_OUTPUT
          echo "still_failed=$FINAL_FAILED" >> $GITHUB_OUTPUT

      - name: Collect modified files
        id: collect
        run: |
          mkdir -p shard-output-${{ matrix.shard }}/skills
          
          # Find files modified by this shard
          MODIFIED_FILES=$(git diff --name-only -- 'skills/*/skill-report.json' 'skills/*/*/skill-report.json' 2>/dev/null || true)
          
          if [ -z "$MODIFIED_FILES" ]; then
            echo "No files modified by shard ${{ matrix.shard }}"
            echo "file_count=0" >> $GITHUB_OUTPUT
          else
            # Copy modified files preserving directory structure
            for file in $MODIFIED_FILES; do
              if [ -f "$file" ]; then
                mkdir -p "shard-output-${{ matrix.shard }}/$(dirname "$file")"
                cp "$file" "shard-output-${{ matrix.shard }}/$file"
              fi
            done
            
            FILE_COUNT=$(echo "$MODIFIED_FILES" | wc -l | tr -d ' ')
            echo "Modified files in shard ${{ matrix.shard }}: $FILE_COUNT"
            echo "$MODIFIED_FILES" | head -10
            [ "$FILE_COUNT" -gt 10 ] && echo "... and $((FILE_COUNT - 10)) more"
            echo "file_count=$FILE_COUNT" >> $GITHUB_OUTPUT
          fi
          
          # Include log file
          cp audit-output-${{ matrix.shard }}.log shard-output-${{ matrix.shard }}/

      - name: Upload shard results
        uses: actions/upload-artifact@v4
        with:
          name: audit-shard-${{ matrix.shard }}
          path: shard-output-${{ matrix.shard }}/
          retention-days: 1
          overwrite: true

      - name: Cleanup
        if: always()
        run: rm -f skillstore-cli

  # Uses fresh clone to temp directory - eliminates state pollution from self-hosted runners
  merge:
    needs: [detect-and-plan, audit]
    if: always() && needs.detect-and-plan.result == 'success' && needs.detect-and-plan.outputs.shard_count != '0'
    runs-on: self-hosted
    outputs:
      pr_url: ${{ steps.pr.outputs.pr_url }}
      updated_count: ${{ steps.pr.outputs.updated_count }}
      error_count: ${{ steps.pr.outputs.error_count }}
    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Download all shard artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: audit-shard-*
          merge-multiple: true
          path: /tmp/audit-artifacts-${{ github.run_id }}

      - name: Apply results and create PR
        id: pr
        if: inputs.dry_run != true
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          set -euo pipefail

          WORK_DIR="/tmp/marketplace-audit-${{ github.run_id }}"
          ARTIFACTS_DIR="/tmp/audit-artifacts-${{ github.run_id }}"

          cleanup() {
            echo "ðŸ§¹ Cleaning up temp directories..."
            rm -rf "$WORK_DIR" "$ARTIFACTS_DIR" 2>/dev/null || true
          }
          trap cleanup EXIT

          echo "ðŸ“¦ Cloning fresh repository to $WORK_DIR..."
          git clone --depth 1 "https://x-access-token:${{ steps.app-token.outputs.token }}@github.com/${{ github.repository }}.git" "$WORK_DIR"
          cd "$WORK_DIR"

          git config user.name "ai-skill-store[bot]"
          git config user.email "2628292+ai-skill-store[bot]@users.noreply.github.com"
          
          echo "=== Applying results from all shards ==="
          if [ -d "$ARTIFACTS_DIR/skills" ]; then
            MERGED_COUNT=$(find "$ARTIFACTS_DIR/skills" -name "skill-report.json" | wc -l | tr -d ' ')
            echo "Files to apply: $MERGED_COUNT"
            cp -r "$ARTIFACTS_DIR/skills/"* ./skills/ 2>/dev/null || true
          else
            echo "Warning: No skills directory found in merged results"
          fi
          
          TOTAL_UPDATED=0
          TOTAL_ERRORS=0
          for log in "$ARTIFACTS_DIR"/audit-output-*.log; do
            if [ -f "$log" ]; then
              COUNT=$(grep -c "âœ… updated" "$log" 2>/dev/null) || COUNT=0
              ERRORS=$(grep -c "âŒ error" "$log" 2>/dev/null) || ERRORS=0
              TOTAL_UPDATED=$((TOTAL_UPDATED + COUNT))
              TOTAL_ERRORS=$((TOTAL_ERRORS + ERRORS))
            fi
          done
          
          echo "Total updated: $TOTAL_UPDATED"
          echo "Total errors: $TOTAL_ERRORS"
          echo "updated_count=$TOTAL_UPDATED" >> $GITHUB_OUTPUT
          echo "error_count=$TOTAL_ERRORS" >> $GITHUB_OUTPUT
          
          if git diff --quiet skills/; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "No changes detected"
            exit 0
          fi
          
          echo "has_changes=true" >> $GITHUB_OUTPUT
          CHANGED_FILES=$(git diff --name-only skills/ | wc -l | tr -d ' ')
          echo "Changed files: $CHANGED_FILES"
          
          BRANCH_NAME="audit/$(date +%Y%m%d-%H%M%S)"
          SHARD_COUNT="${{ needs.detect-and-plan.outputs.shard_count }}"
          TOTAL_SKILLS="${{ needs.detect-and-plan.outputs.total_skills }}"
          IS_SHARDED="${{ needs.detect-and-plan.outputs.is_sharded }}"
          MODEL="${{ inputs.model || 'auto' }}"
          
          git checkout -b "$BRANCH_NAME"
          git add skills/*/skill-report.json
          git add skills/*/*/skill-report.json 2>/dev/null || true
          
          if [ "$IS_SHARDED" = "true" ]; then
            COMMIT_MSG="chore(audit): audit ${TOTAL_UPDATED} skills (${SHARD_COUNT} shards)"
          else
            COMMIT_MSG="chore(audit): audit ${TOTAL_UPDATED} skills"
          fi
          
          git commit -m "$COMMIT_MSG

          - Model: ${MODEL}
          - Total: ${TOTAL_SKILLS}
          - Updated: ${TOTAL_UPDATED}
          - Errors: ${TOTAL_ERRORS}"
          
          git push origin "$BRANCH_NAME"
          
          PR_BODY="## Summary

          Batch audit of skills with AI-powered security analysis.

          | Metric | Value |
          |--------|-------|
          | Total Skills | ${TOTAL_SKILLS} |"
          
          if [ "$IS_SHARDED" = "true" ]; then
            PR_BODY="$PR_BODY
          | Shards | ${SHARD_COUNT} |
          | Max Parallel | ${{ inputs.max_parallel || '4' }} |"
          fi
          
          PR_BODY="$PR_BODY
          | Updated | ${TOTAL_UPDATED} |
          | Errors | ${TOTAL_ERRORS} |
          | Model | \`${MODEL}\` |
          | CLI Version | \`${{ env.CLI_VERSION }}\` |

          ### Changes
          - Updated \`risk_factors\` field in each skill's \`skill-report.json\`
          - Risk factors detected: \`scripts\`, \`network\`, \`filesystem\`, \`env_access\`, \`external_commands\`
          - Refreshed \`security_audit\` section with latest analysis

          ### After Merge
          The \`sync-to-supabase.yml\` workflow will automatically update the database."
          
          PR_URL=$(gh pr create \
            --title "Audit: ${TOTAL_UPDATED} skills" \
            --body "$PR_BODY" \
            --base main \
            --head "$BRANCH_NAME")
          
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          echo "::notice::Created PR: $PR_URL"

      - name: Summary
        if: always()
        env:
          IS_SHARDED: ${{ needs.detect-and-plan.outputs.is_sharded }}
          SHARD_COUNT: ${{ needs.detect-and-plan.outputs.shard_count }}
          TOTAL_SKILLS: ${{ needs.detect-and-plan.outputs.total_skills }}
        run: |
          cat << EOF >> $GITHUB_STEP_SUMMARY
          ## Audit Summary
          
          **Mode:** $([ "$IS_SHARDED" = "true" ] && echo "Sharded ($SHARD_COUNT shards)" || echo "Simple")
          
          | Metric | Value |
          |--------|-------|
          | Total Skills | $TOTAL_SKILLS |
          EOF
          
          if [ "$IS_SHARDED" = "true" ]; then
            echo "| Shards | $SHARD_COUNT |" >> $GITHUB_STEP_SUMMARY
            echo "| Max Parallel | ${{ inputs.max_parallel || '4' }} |" >> $GITHUB_STEP_SUMMARY
          fi
          
          cat << EOF >> $GITHUB_STEP_SUMMARY
          | Model | \`${{ inputs.model || 'auto' }}\` |
          | Updated | ${{ steps.pr.outputs.updated_count }} |
          | Errors | ${{ steps.pr.outputs.error_count }} |
          | Dry Run | ${{ inputs.dry_run }} |
          
          EOF
          
          if [ -n "${{ steps.pr.outputs.pr_url }}" ]; then
            echo "ðŸ”— **PR Created**: ${{ steps.pr.outputs.pr_url }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "âœ… Audit workflow completed." >> $GITHUB_STEP_SUMMARY
