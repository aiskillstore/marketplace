name: Process Skill Submission

on:
  repository_dispatch:
    types: [process-submission]
  workflow_dispatch:
    inputs:
      github_url:
        description: 'GitHub URL of the skill to process'
        required: true
        type: string
      submitter_email:
        description: 'Submitter email (optional)'
        required: false
        type: string

env:
  SUBMISSION_ID: ${{ github.event.client_payload.submission_id || github.run_id }}
  GITHUB_URL: ${{ github.event.client_payload.github_url || inputs.github_url }}
  SUBMITTER_EMAIL: ${{ github.event.client_payload.submitter_email || inputs.submitter_email || 'manual@skillstore.io' }}
  AI_API_BASE: ${{ vars.AI_API_BASE || 'http://192.168.199.7:3001/v1' }}
  AI_MODEL: ${{ vars.AI_MODEL || 'gpt-5.2:high' }}
  WORK_DIR: /tmp/skill-submission-${{ github.run_id }}

jobs:
  process:
    runs-on: self-hosted
    steps:
      - name: Checkout marketplace
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup work directory
        run: |
          rm -rf "$WORK_DIR"
          mkdir -p "$WORK_DIR"
          echo "Work directory: $WORK_DIR"

      - name: Parse GitHub URL
        id: parse
        run: |
          URL="${{ env.GITHUB_URL }}"
          echo "Parsing URL: $URL"
          
          if [[ $URL =~ github\.com/([^/]+)/([^/]+)(/(tree|blob)/([^/]+)(/(.+))?)? ]]; then
            OWNER="${BASH_REMATCH[1]}"
            REPO="${BASH_REMATCH[2]}"
            BRANCH="${BASH_REMATCH[5]:-main}"
            SKILL_PATH="${BASH_REMATCH[7]:-}"
            
            if [[ "$SKILL_PATH" =~ \.(md|txt|json|yaml|yml)$ ]]; then
              SKILL_PATH=$(dirname "$SKILL_PATH")
            fi
            
            echo "owner=$OWNER" >> $GITHUB_OUTPUT
            echo "repo=$REPO" >> $GITHUB_OUTPUT
            echo "branch=$BRANCH" >> $GITHUB_OUTPUT
            echo "skill_path=$SKILL_PATH" >> $GITHUB_OUTPUT
            
            if [ -n "$SKILL_PATH" ]; then
              SLUG=$(basename "$SKILL_PATH" | tr '[:upper:]' '[:lower:]' | tr ' ' '-')
            else
              SLUG=$(echo "$REPO" | tr '[:upper:]' '[:lower:]' | tr ' ' '-')
            fi
            echo "slug=$SLUG" >> $GITHUB_OUTPUT
            
            echo "Parsed: owner=$OWNER, repo=$REPO, branch=$BRANCH, path=$SKILL_PATH, slug=$SLUG"
          else
            echo "Failed to parse GitHub URL"
            exit 1
          fi

      - name: Clone source repository
        run: |
          git clone --depth 1 --branch ${{ steps.parse.outputs.branch }} \
            "https://github.com/${{ steps.parse.outputs.owner }}/${{ steps.parse.outputs.repo }}.git" \
            $WORK_DIR/source-repo

      - name: Find SKILL.md and collect files
        id: collect
        run: |
          SKILL_PATH="${{ steps.parse.outputs.skill_path }}"
          INITIAL_SLUG="${{ steps.parse.outputs.slug }}"
          
          if [ -n "$SKILL_PATH" ]; then
            SKILL_DIR="$WORK_DIR/source-repo/$SKILL_PATH"
          else
            SKILL_DIR="$WORK_DIR/source-repo"
          fi
          
          echo "Looking for SKILL.md in: $SKILL_DIR"
          
          # Priority 1: Direct SKILL.md in target dir
          if [ -f "$SKILL_DIR/SKILL.md" ]; then
            echo "Found SKILL.md directly in target directory"
          # Priority 2: skills/slug/SKILL.md pattern
          elif [ -f "$SKILL_DIR/skills/$INITIAL_SLUG/SKILL.md" ]; then
            SKILL_DIR="$SKILL_DIR/skills/$INITIAL_SLUG"
            echo "Found SKILL.md in skills/$INITIAL_SLUG/"
          # Priority 3: Search for first SKILL.md in deeper levels
          else
            FOUND=$(find "$SKILL_DIR" -maxdepth 10 -name "SKILL.md" -type f | head -1)
            if [ -n "$FOUND" ]; then
              SKILL_DIR=$(dirname "$FOUND")
              echo "Found SKILL.md at: $SKILL_DIR"
            else
              echo "::error::No SKILL.md found in repository. This doesn't appear to be a valid skill."
              echo "Searched in: $SKILL_DIR"
              find "$SKILL_DIR" -maxdepth 10 -type f -name "*.md" | head -10
              exit 1
            fi
          fi
          
          # Extract skill name from SKILL.md frontmatter
          # Priority: 1) frontmatter name field, 2) SKILL.md parent folder name, 3) repo name
          SKILL_MD_PATH="$SKILL_DIR/SKILL.md"
          FRONTMATTER_NAME=""
          
          if [ -f "$SKILL_MD_PATH" ]; then
            # Extract name from YAML frontmatter (between --- markers)
            FRONTMATTER_NAME=$(sed -n '/^---$/,/^---$/p' "$SKILL_MD_PATH" | grep -E '^name:' | head -1 | sed 's/^name:[[:space:]]*//' | tr -d '"'"'" | xargs)
            echo "Extracted frontmatter name: '$FRONTMATTER_NAME'"
          fi
          
          if [ -n "$FRONTMATTER_NAME" ]; then
            # Slugify the frontmatter name: lowercase, replace spaces/special chars with hyphens
            SLUG=$(echo "$FRONTMATTER_NAME" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//' | sed 's/-$//')
            echo "Using slugified frontmatter name: $SLUG"
          else
            # Fallback to SKILL.md parent folder name
            FOLDER_NAME=$(basename "$SKILL_DIR")
            if [ "$FOLDER_NAME" != "source-repo" ] && [ "$FOLDER_NAME" != "." ]; then
              SLUG=$(echo "$FOLDER_NAME" | tr '[:upper:]' '[:lower:]' | tr ' ' '-')
              echo "Using SKILL.md parent folder name: $SLUG"
            else
              # Final fallback to initial slug (repo name)
              SLUG="$INITIAL_SLUG"
              echo "Using repo name as fallback: $SLUG"
            fi
          fi
          
          echo "slug=$SLUG" >> $GITHUB_OUTPUT
          echo "skill_dir=$SKILL_DIR" >> $GITHUB_OUTPUT
          echo "Final skill directory: $SKILL_DIR"
          echo "Final slug: $SLUG"
          ls -la "$SKILL_DIR"
          
          mkdir -p $WORK_DIR/skill-files
          
          # Collect text files (use xargs instead of while loop to avoid subshell issues)
          find "$SKILL_DIR" -type f \( \
            -name "*.md" -o -name "*.txt" -o -name "*.js" -o -name "*.ts" -o \
            -name "*.py" -o -name "*.sh" -o -name "*.json" -o -name "*.yaml" -o \
            -name "*.yml" -o -name "*.toml" -o -name "*.xml" -o -name "*.html" -o \
            -name "*.css" -o -name "*.sql" -o -name "*.rb" -o -name "*.go" -o \
            -name "*.rs" -o -name "*.java" -o -name "*.c" -o -name "*.cpp" \
          \) -size -50k > $WORK_DIR/files-to-copy.txt
          
          echo "Found $(wc -l < $WORK_DIR/files-to-copy.txt) text files to analyze"
          
          TOTAL_SIZE=0
          MAX_SIZE=200000
          
          while IFS= read -r file; do
            if [ -f "$file" ]; then
              SIZE=$(wc -c < "$file")
              if [ $((TOTAL_SIZE + SIZE)) -lt $MAX_SIZE ]; then
                REL_PATH="${file#$SKILL_DIR/}"
                DEST_NAME=$(echo "$REL_PATH" | tr '/' '_')
                cp "$file" "$WORK_DIR/skill-files/$DEST_NAME"
                TOTAL_SIZE=$((TOTAL_SIZE + SIZE))
                echo "  Copied: $REL_PATH ($SIZE bytes)"
              fi
            fi
          done < $WORK_DIR/files-to-copy.txt
          
          FILE_COUNT=$(ls -1 $WORK_DIR/skill-files 2>/dev/null | wc -l)
          echo "file_count=$FILE_COUNT" >> $GITHUB_OUTPUT
          echo "Collected $FILE_COUNT files (total size: $TOTAL_SIZE bytes)"
          
          if [ "$FILE_COUNT" -eq 0 ]; then
            echo "::warning::No text files found in skill directory"
          fi

      - name: Run comprehensive AI audit
        id: audit
        run: |
          SKILL_DIR="${{ steps.collect.outputs.skill_dir }}"
          SLUG="${{ steps.collect.outputs.slug }}"
          SOURCE_URL="${{ env.GITHUB_URL }}"
          
          FILE_CONTENTS=""
          TOTAL_LINES=0
          FILE_COUNT=0
          
          for file in $WORK_DIR/skill-files/*; do
            if [ -f "$file" ]; then
              FILENAME=$(basename "$file" | tr '_' '/')
              EXT="${file##*.}"
              LINES=$(wc -l < "$file")
              TOTAL_LINES=$((TOTAL_LINES + LINES))
              FILE_COUNT=$((FILE_COUNT + 1))
              CONTENT=$(cat "$file" | head -c 50000)
              FILE_CONTENTS="$FILE_CONTENTS
          
          ### File: $FILENAME ($LINES lines)
          \`\`\`$EXT
          $CONTENT
          \`\`\`"
            fi
          done
          
          IS_OFFICIAL="false"
          TRUST_LEVEL="COMMUNITY"
          if [[ "$SOURCE_URL" == *"github.com/anthropics/skills"* ]]; then
            IS_OFFICIAL="true"
            TRUST_LEVEL="OFFICIAL"
          fi
          
          AUDIT_PROMPT=$(cat << 'PROMPT_EOF'
          You are an expert system performing TWO tasks:
          1. SECURITY AUDIT
          2. CONTENT GENERATION (Based on actual code analysis)
          
          =============================================================================
          SKILL INFORMATION
          =============================================================================
          - Name: __SLUG__
          - Repository: __SOURCE_URL__
          - Total Files: __FILE_COUNT__
          - Total Lines: __TOTAL_LINES__
          - Trust Level: __TRUST_LEVEL__
          
          =============================================================================
          SOURCE CODE FILES
          =============================================================================
          __FILE_CONTENTS__
          
          =============================================================================
          TASK 1: SECURITY AUDIT (Protecting Users from Malicious Skills)
          =============================================================================
          
          __TRUST_SECTION__
          
          ## CATEGORY 1: DATA THEFT (User's sensitive information)
          
          ### 1.1 Credential Theft
          Look for code that reads:
          - ~/.ssh/* (SSH keys)
          - ~/.aws/*, ~/.azure/*, ~/.gcloud/* (Cloud credentials)
          - ~/.netrc, ~/.npmrc, ~/.pypirc (Package registry tokens)
          - ~/.gitconfig, ~/.git-credentials (Git tokens)
          - ~/.config/gh/*, ~/.claude/* (CLI tool configs)
          - Browser profiles: ~/.config/google-chrome/*, ~/Library/Application Support/Google/Chrome/*
          - Keychain/credential manager access
          
          ### 1.2 Environment Variable Harvesting
          Look for code that collects and sends:
          - os.environ / process.env bulk access
          - Specific tokens: *_TOKEN, *_KEY, *_SECRET, *_PASSWORD, *_API_KEY
          - Cloud: AWS_*, AZURE_*, GCP_*, OPENAI_API_KEY, ANTHROPIC_API_KEY
          
          ### 1.3 File Exfiltration
          Look for patterns:
          - Reading sensitive files + sending via HTTP/network
          - Base64 encoding file contents (obfuscation for exfil)
          - Zip/tar creation of user directories + upload
          - Reading user's project files and POSTing elsewhere
          
          ### 1.4 Conversation/Context Theft
          Look for:
          - Reading AI session files, history, logs
          - Capturing stdin/stdout to external destination
          - Accessing clipboard contents
          
          ## CATEGORY 2: MALICIOUS CODE EXECUTION
          
          ### 2.1 Backdoors & Remote Access
          Look for:
          - Reverse shells: socket connect + subprocess/exec
          - bind shells: socket listen + command execution
          - C2 beacons: periodic HTTP calls to hardcoded domains
          - SSH/remote access setup
          
          ### 2.2 Crypto Miners
          Look for:
          - Mining pool URLs (stratum://, pool.*, *mining*)
          - CPU/GPU intensive loops without clear purpose
          - XMRig, ccminer, or similar tool downloads
          
          ### 2.3 Persistence Mechanisms
          Look for:
          - Cron job creation (crontab, /etc/cron.*)
          - Startup scripts (~/.bashrc, ~/.zshrc, ~/.profile injection)
          - LaunchAgent/LaunchDaemon (macOS)
          - systemd service creation
          - Windows registry autorun
          
          ### 2.4 Payload Download & Execute
          Look for:
          - curl/wget + sh/bash/python execution
          - Download file + os.system/exec/eval
          - Base64 decode + exec patterns
          - Obfuscated code (excessive encoding, char codes)
          
          ## CATEGORY 3: DECEPTIVE BEHAVIORS
          
          ### 3.1 Hidden Network Calls
          Look for:
          - HTTP requests to non-obvious domains (not the skill's stated API)
          - IP addresses instead of domain names
          - Unusual ports (not 80/443)
          - DNS exfiltration patterns
          
          ### 3.2 Obfuscation Red Flags
          Look for:
          - Base64/hex encoded strings that decode to URLs or commands
          - Character code arrays: chr(104)+chr(116)+chr(116)+chr(112)
          - Reversed strings that form URLs/commands
          - Excessive use of eval/exec with string manipulation
          
          ## RISK LEVEL CRITERIA
          
          ### CRITICAL (should_block: true):
          - ANY credential file access + network send
          - ANY reverse/bind shell code
          - ANY crypto miner indicators
          - Bulk environment variable collection + exfiltration
          - Persistence mechanism installation
          - Download + execute patterns
          
          ### HIGH:
          - Network calls to suspicious/undocumented endpoints
          - Reading user files beyond stated purpose
          - Obfuscated code sections
          - Unnecessary shell=True with broad commands
          
          ### MEDIUM:
          - Broad file system access (but no exfil detected)
          - Network calls (but to reasonable APIs)
          - Subprocess usage (but for legitimate purposes)
          
          ### LOW:
          - Minor permission scope issues
          - Deprecated but non-dangerous patterns
          
          ### SAFE:
          - No data theft patterns
          - No malicious execution patterns
          - Network use matches documented purpose
          
          =============================================================================
          TASK 2: CONTENT GENERATION
          =============================================================================
          
          Generate content for marketplace listing:
          - user_title: max 60 chars, action verb + user outcome
          - value_statement: 2 sentences, problem + benefit
          - seo_keywords: 8-10 terms including platform names
          - actual_capabilities: 4-6 items based on code analysis
          - limitations: 3-4 honest boundaries
          - use_cases: 3 items with target_user, title, description
          - prompt_templates: 4 items (beginner to advanced)
          - output_examples: 1 item showing value
          - best_practices: 3 actionable tips
          - anti_patterns: 3 things to avoid
          - faq: 6 items covering compatibility, limits, integration, data safety, troubleshooting, comparison
          - technical_requirements: dependencies, permissions_needed, estimated_complexity, setup_time_minutes
          
          =============================================================================
          OUTPUT FORMAT (Return ONLY valid JSON)
          =============================================================================
          
          CRITICAL TYPE CONSTRAINTS - STRICTLY FOLLOW:
          - All "*_findings" arrays must contain STRINGS, not objects
          - "dangerous_patterns_found" must be STRING ARRAY: ["pattern1 at file:line", "pattern2 at file:line"]
          - WRONG: [{"pattern": "eval", "file": "x.py"}] 
          - CORRECT: ["eval() found in x.py:15", "exec() found in script.sh:23"]
          
          {
            "security_audit": {
              "risk_level": "safe|low|medium|high|critical",
              "should_block": false,
              "safe_to_publish": true,
              "summary": "One sentence assessment",
              "critical_findings": ["string describing finding 1", "string describing finding 2"],
              "high_findings": ["string describing finding"],
              "medium_findings": ["string describing finding"],
              "low_findings": ["string describing finding"],
              "files_analyzed": 0,
              "dangerous_patterns_found": ["pattern description with location as string"]
            },
            "content": {
              "user_title": "max 60 chars string",
              "value_statement": "2 sentence string",
              "seo_keywords": ["keyword1", "keyword2"],
              "actual_capabilities": ["capability1", "capability2"],
              "limitations": ["limitation1", "limitation2"],
              "use_cases": [{"target_user": "string", "title": "string", "description": "string"}],
              "prompt_templates": [{"level": "beginner|intermediate|advanced", "prompt": "string"}],
              "output_examples": [{"description": "string", "example": "string"}],
              "best_practices": ["practice1", "practice2"],
              "anti_patterns": ["antipattern1", "antipattern2"],
              "faq": [{"question": "string", "answer": "string"}],
              "technical_requirements": {
                "dependencies": ["dep1", "dep2"],
                "permissions_needed": ["permission1"],
                "estimated_complexity": "low|medium|high",
                "setup_time_minutes": 2
              }
            }
          }
          PROMPT_EOF
          )
          
          if [ "$IS_OFFICIAL" = "true" ]; then
            TRUST_SECTION="ðŸŸ¢ OFFICIAL SKILL - TRUSTED SOURCE
          This skill is from the OFFICIAL Anthropic repository.
          Set risk_level to 'safe', should_block to false, safe_to_publish to true.
          Skip detailed security analysis. Proceed to content generation."
          else
            TRUST_SECTION="ðŸ”´ COMMUNITY SKILL - FULL SECURITY AUDIT REQUIRED
          THREAT MODEL: Malicious skill developer attacking innocent users.
          GOAL: Detect skills that steal user data or execute malicious code.
          Analyze ALL code files thoroughly for the patterns listed above."
          fi
          
          # Use sed for single-line substitutions only
          FINAL_PROMPT=$(echo "$AUDIT_PROMPT" | \
            sed "s|__SLUG__|$SLUG|g" | \
            sed "s|__SOURCE_URL__|$SOURCE_URL|g" | \
            sed "s|__FILE_COUNT__|$FILE_COUNT|g" | \
            sed "s|__TOTAL_LINES__|$TOTAL_LINES|g" | \
            sed "s|__TRUST_LEVEL__|$TRUST_LEVEL|g")
          
          # Use bash parameter substitution for multiline values (sed can't handle newlines)
          FINAL_PROMPT="${FINAL_PROMPT/__TRUST_SECTION__/$TRUST_SECTION}"
          FINAL_PROMPT="${FINAL_PROMPT/__FILE_CONTENTS__/$FILE_CONTENTS}"
          
          echo "$FINAL_PROMPT" > $WORK_DIR/audit-prompt.txt
          
          # Define JSON schema for structured output
          RESPONSE_SCHEMA='{
            "type": "json_schema",
            "json_schema": {
              "name": "skill_audit_response",
              "strict": true,
              "schema": {
                "type": "object",
                "required": ["security_audit", "content"],
                "additionalProperties": false,
                "properties": {
                  "security_audit": {
                    "type": "object",
                    "required": ["risk_level", "should_block", "safe_to_publish", "summary"],
                    "additionalProperties": false,
                    "properties": {
                      "risk_level": { "type": "string", "enum": ["safe", "low", "medium", "high", "critical"] },
                      "should_block": { "type": "boolean" },
                      "safe_to_publish": { "type": "boolean" },
                      "summary": { "type": "string" },
                      "critical_findings": { "type": "array", "items": { "type": "string" } },
                      "high_findings": { "type": "array", "items": { "type": "string" } },
                      "medium_findings": { "type": "array", "items": { "type": "string" } },
                      "low_findings": { "type": "array", "items": { "type": "string" } },
                      "files_analyzed": { "type": "integer" },
                      "dangerous_patterns_found": { "type": "array", "items": { "type": "string" } }
                    }
                  },
                  "content": {
                    "type": "object",
                    "additionalProperties": false,
                    "properties": {
                      "user_title": { "type": "string" },
                      "value_statement": { "type": "string" },
                      "seo_keywords": { "type": "array", "items": { "type": "string" } },
                      "actual_capabilities": { "type": "array", "items": { "type": "string" } },
                      "limitations": { "type": "array", "items": { "type": "string" } },
                      "use_cases": { 
                        "type": "array", 
                        "items": { 
                          "type": "object",
                          "properties": {
                            "target_user": { "type": "string" },
                            "title": { "type": "string" },
                            "description": { "type": "string" }
                          },
                          "required": ["target_user", "title", "description"],
                          "additionalProperties": false
                        } 
                      },
                      "prompt_templates": { 
                        "type": "array", 
                        "items": { 
                          "type": "object",
                          "properties": {
                            "level": { "type": "string" },
                            "prompt": { "type": "string" }
                          },
                          "required": ["level", "prompt"],
                          "additionalProperties": false
                        } 
                      },
                      "output_examples": { 
                        "type": "array", 
                        "items": { 
                          "type": "object",
                          "properties": {
                            "description": { "type": "string" },
                            "example": { "type": "string" }
                          },
                          "required": ["description", "example"],
                          "additionalProperties": false
                        } 
                      },
                      "best_practices": { "type": "array", "items": { "type": "string" } },
                      "anti_patterns": { "type": "array", "items": { "type": "string" } },
                      "faq": { 
                        "type": "array", 
                        "items": { 
                          "type": "object",
                          "properties": {
                            "question": { "type": "string" },
                            "answer": { "type": "string" }
                          },
                          "required": ["question", "answer"],
                          "additionalProperties": false
                        } 
                      },
                      "technical_requirements": { 
                        "type": "object",
                        "additionalProperties": false,
                        "properties": {
                          "dependencies": { "type": "array", "items": { "type": "string" } },
                          "permissions_needed": { "type": "array", "items": { "type": "string" } },
                          "estimated_complexity": { "type": "string", "enum": ["low", "medium", "high"] },
                          "setup_time_minutes": { "type": "integer" }
                        },
                        "required": ["dependencies", "permissions_needed", "estimated_complexity", "setup_time_minutes"]
                      }
                    },
                    "required": ["user_title", "value_statement", "seo_keywords", "actual_capabilities", "limitations", "use_cases", "prompt_templates", "output_examples", "best_practices", "anti_patterns", "faq", "technical_requirements"]
                  }
                }
              }
            }
          }'
          
          REQUEST_BODY=$(jq -n \
            --arg model "$AI_MODEL" \
            --arg content "$FINAL_PROMPT" \
            --argjson response_format "$RESPONSE_SCHEMA" \
            '{
              model: $model,
              messages: [{ role: "user", content: $content }],
              temperature: 0.3,
              max_tokens: 100000,
              response_format: $response_format
            }')
          
          echo "Calling AI API at $AI_API_BASE..."
          
          RESPONSE=$(curl -s --max-time 300 \
            "$AI_API_BASE/chat/completions" \
            -H "Content-Type: application/json" \
            -d "$REQUEST_BODY")
          
          AI_CONTENT=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // empty')
          
          if [ -z "$AI_CONTENT" ]; then
            echo "AI API returned no content, using fallback"
            AI_CONTENT='{"security_audit":{"risk_level":"medium","should_block":false,"safe_to_publish":true,"summary":"AI analysis unavailable - manual review recommended","critical_findings":[],"high_findings":[],"medium_findings":[],"low_findings":[],"files_analyzed":0,"dangerous_patterns_found":[]},"content":{"user_title":"AI Skill","value_statement":"Extends Claude capabilities.","seo_keywords":[],"actual_capabilities":[],"limitations":[],"use_cases":[],"prompt_templates":[],"output_examples":[],"best_practices":[],"anti_patterns":[],"faq":[],"technical_requirements":{"dependencies":[],"permissions_needed":[],"estimated_complexity":"medium","setup_time_minutes":5}}}'
          fi
          
          CLEAN_JSON=$(echo "$AI_CONTENT" | sed 's/^```json//g' | sed 's/^```//g' | sed 's/```$//g')
          echo "$CLEAN_JSON" > $WORK_DIR/ai-result.json
          
          RISK_LEVEL=$(echo "$CLEAN_JSON" | jq -r '.security_audit.risk_level // "unknown"')
          SHOULD_BLOCK=$(echo "$CLEAN_JSON" | jq -r '.security_audit.should_block // false')
          
          echo "risk_level=$RISK_LEVEL" >> $GITHUB_OUTPUT
          echo "should_block=$SHOULD_BLOCK" >> $GITHUB_OUTPUT
          echo "total_lines=$TOTAL_LINES" >> $GITHUB_OUTPUT
          echo "file_count=$FILE_COUNT" >> $GITHUB_OUTPUT
          
          echo "Security audit complete: risk_level=$RISK_LEVEL, should_block=$SHOULD_BLOCK"

      - name: Build skill-report.json
        run: |
          SLUG="${{ steps.collect.outputs.slug }}"
          SOURCE_URL="${{ env.GITHUB_URL }}"
          RISK_LEVEL="${{ steps.audit.outputs.risk_level }}"
          TOTAL_LINES="${{ steps.audit.outputs.total_lines }}"
          FILE_COUNT="${{ steps.audit.outputs.file_count }}"
          
          AI_RESULT=$(cat $WORK_DIR/ai-result.json)
          
          jq -n \
            --arg generated_at "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --arg model "$AI_MODEL" \
            --arg source_url "$SOURCE_URL" \
            --arg source_ref "$(cd $WORK_DIR/source-repo && git rev-parse HEAD)" \
            --argjson ai_result "$AI_RESULT" \
            --arg total_lines "$TOTAL_LINES" \
            --arg file_count "$FILE_COUNT" \
            '{
              meta: {
                generated_at: $generated_at,
                model: $model,
                source_url: $source_url,
                source_ref: $source_ref,
                analysis_version: "2.0.0"
              },
              security_audit: ($ai_result.security_audit + {
                files_scanned: ($file_count | tonumber),
                total_lines: ($total_lines | tonumber)
              }),
              content: $ai_result.content
            }' > $WORK_DIR/skill-report.json

      - name: Package plugin
        run: |
          SLUG="${{ steps.collect.outputs.slug }}"
          SKILL_DIR="${{ steps.collect.outputs.skill_dir }}"
          PENDING_DIR="pending/$SLUG"
          
          mkdir -p "$PENDING_DIR/.claude-plugin"
          mkdir -p "$PENDING_DIR/skills/$SLUG"
          
          cp -r "$SKILL_DIR"/* "$PENDING_DIR/skills/$SLUG/"
          cp $WORK_DIR/skill-report.json "$PENDING_DIR/skill-report.json"
          
          USER_TITLE=$(jq -r '.content.user_title // ""' $WORK_DIR/skill-report.json)
          DESCRIPTION=$(jq -r '.content.value_statement // ""' $WORK_DIR/skill-report.json)
          
          if [ -z "$DESCRIPTION" ]; then
            DESCRIPTION=$(grep -A5 "^#" "$SKILL_DIR/SKILL.md" | grep -v "^#" | grep -v "^$" | head -1 | cut -c1-200)
          fi
          
          jq -n \
            --arg name "$SLUG" \
            --arg desc "$DESCRIPTION" \
            --arg homepage "https://skillstore.io/skills/$SLUG" \
            --arg repo "${{ env.GITHUB_URL }}" \
            '{
              name: $name,
              version: "1.0.0",
              description: $desc,
              author: { name: "Community" },
              homepage: $homepage,
              repository: $repo,
              license: "MIT",
              keywords: []
            }' > "$PENDING_DIR/.claude-plugin/plugin.json"
          
          jq -n \
            --arg name "$SLUG" \
            --arg desc "$DESCRIPTION" \
            --arg path "pending/$SLUG" \
            '{
              name: $name,
              version: "1.0.0",
              description: $desc,
              author: { name: "Community" },
              homepage: "https://skillstore.io/skills/\($name)",
              path: $path
            }' > "$PENDING_DIR/marketplace-entry.json"
          
          echo "Plugin packaged at $PENDING_DIR"
          ls -la "$PENDING_DIR"

      - name: Create Pull Request
        if: steps.audit.outputs.should_block != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          SLUG="${{ steps.collect.outputs.slug }}"
          SUBMISSION_ID="${{ env.SUBMISSION_ID }}"
          RISK_LEVEL="${{ steps.audit.outputs.risk_level }}"
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          BRANCH_NAME="submission/$SLUG-$SUBMISSION_ID"
          git checkout -b "$BRANCH_NAME"
          
          git add "pending/$SLUG"
          git commit -m "Add pending plugin: $SLUG [submission: $SUBMISSION_ID]"
          
          git push origin "$BRANCH_NAME"
          
          AUDIT_SUMMARY=$(jq -r '.security_audit.summary // "No summary"' "pending/$SLUG/skill-report.json")
          CRITICAL_COUNT=$(jq '.security_audit.critical_findings | length' "pending/$SLUG/skill-report.json")
          HIGH_COUNT=$(jq '.security_audit.high_findings | length' "pending/$SLUG/skill-report.json")
          
          RISK_BADGE="ðŸŸ¢"
          if [ "$RISK_LEVEL" = "critical" ]; then RISK_BADGE="ðŸ”´"; fi
          if [ "$RISK_LEVEL" = "high" ]; then RISK_BADGE="ðŸŸ "; fi
          if [ "$RISK_LEVEL" = "medium" ]; then RISK_BADGE="ðŸŸ¡"; fi
          
          PR_BODY="## New Plugin Submission: $SLUG

          **Submission ID**: \`$SUBMISSION_ID\`
          **Source**: ${{ env.GITHUB_URL }}
          **Submitter**: ${{ env.SUBMITTER_EMAIL }}

          ### Security Audit $RISK_BADGE

          **Risk Level**: \`$RISK_LEVEL\`
          **Critical Findings**: $CRITICAL_COUNT
          **High Findings**: $HIGH_COUNT

          $AUDIT_SUMMARY

          ### Review Checklist

          - [ ] Skill content is appropriate
          - [ ] Security audit findings reviewed
          - [ ] Source repository checked

          ---
          *Automated submission via skillstore.io*
          *AI Model: $AI_MODEL*"
          
          echo "$PR_BODY" > $WORK_DIR/pr-body.md
          
          gh pr create \
            --title "New plugin: $SLUG ($RISK_LEVEL risk)" \
            --body-file $WORK_DIR/pr-body.md \
            --label "pending-review" \
            --base main \
            --head "$BRANCH_NAME"

      - name: Handle blocked submission
        if: steps.audit.outputs.should_block == 'true'
        run: |
          echo "::error::Submission blocked due to security concerns"
          echo "Risk level: ${{ steps.audit.outputs.risk_level }}"
          
          AUDIT_SUMMARY=$(jq -r '.security_audit.summary // "No summary"' $WORK_DIR/skill-report.json)
          echo "Summary: $AUDIT_SUMMARY"
          
          jq '.security_audit.critical_findings' $WORK_DIR/skill-report.json
          
          exit 1
