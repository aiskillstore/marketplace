name: Reusable Skill Processing Workflow

# Shared workflow for processing skills in parallel shards
# Used by: approve-submission.yml, process-submission.yml
#
# Architecture:
#   Job 1: discover-and-plan   - Clone repo, discover skills, create matrix
#   Job 2: process (matrix)    - Process skills in parallel shards
#   Job 3: merge-and-create-pr - Combine results, create single PR

on:
  workflow_call:
    inputs:
      github_url:
        description: 'GitHub repository URL to process'
        required: true
        type: string
      submission_id:
        description: 'Unique submission identifier'
        required: true
        type: string
      model:
        description: 'AI model to use (optional)'
        required: false
        type: string
        default: ''
      cli_version:
        description: 'CLI version to use'
        required: false
        type: string
        default: 'latest'
      max_parallel:
        description: 'Maximum parallel shards'
        required: false
        type: string
        default: '6'
      is_manual_approval:
        description: 'Whether this is from manual approval workflow'
        required: false
        type: boolean
        default: false
      approved_by:
        description: 'Username who approved (for manual approvals)'
        required: false
        type: string
        default: ''
    outputs:
      pr_url:
        description: 'URL of created pull request'
        value: ${{ jobs.merge-and-create-pr.outputs.pr_url }}
      processed_count:
        description: 'Number of skills successfully processed'
        value: ${{ jobs.merge-and-create-pr.outputs.processed_count }}
      highest_risk:
        description: 'Highest security risk level found'
        value: ${{ jobs.merge-and-create-pr.outputs.highest_risk }}
    secrets:
      APP_ID:
        required: true
      APP_PRIVATE_KEY:
        required: true
      SKILLSTORE_AGENTS:
        required: false
      SUPABASE_URL:
        required: true
      SUPABASE_SERVICE_KEY:
        required: true
      SKILLSTORE_API_URL:
        required: false
      SKILLSTORE_CALLBACK_TOKEN:
        required: false

env:
  SHARD_THRESHOLD: 30
  MAX_SHARDS: 6

jobs:
  # ============================================================
  # JOB 1: DISCOVER AND PLAN
  # Clone repo, discover skills, create matrix for parallel processing
  # ============================================================
  discover-and-plan:
    runs-on: self-hosted
    timeout-minutes: 60
    outputs:
      matrix: ${{ steps.plan.outputs.matrix }}
      skill_count: ${{ steps.discover.outputs.skill_count }}
      skills_json: ${{ steps.discover.outputs.skills_json }}
      is_sharded: ${{ steps.plan.outputs.is_sharded }}
      shard_count: ${{ steps.plan.outputs.shard_count }}
      owner: ${{ steps.clone.outputs.owner }}
      repo: ${{ steps.clone.outputs.repo }}
      branch: ${{ steps.clone.outputs.branch }}
      github_url: ${{ steps.discover.outputs.github_url }}
    steps:
      - name: Notify skillstore - Processing started
        if: inputs.is_manual_approval == false
        run: |
          curl -sS -X POST "${{ secrets.SKILLSTORE_API_URL }}/api/submit/callback" \
            -H "Authorization: Bearer ${{ secrets.SKILLSTORE_CALLBACK_TOKEN }}" \
            -H "Content-Type: application/json" \
            -H "User-Agent: GitHub-Actions/SkillstoreBot" \
            -H "X-Skillstore-Callback: true" \
            -d '{
              "submission_id": "'"${{ inputs.submission_id }}"'",
              "event": "started",
              "workflow_run_id": ${{ github.run_id }},
              "workflow_run_url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }' || echo "::warning::Failed to notify skillstore"

      - name: Clone source repository
        id: clone
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          URL="${{ inputs.github_url }}"
          URL="${URL%.git}"

          # Validate GitHub URL format
          if [[ ! "$URL" =~ ^https://github\.com/[a-zA-Z0-9_-]+/[a-zA-Z0-9._-]+(/.*)?$ ]]; then
            echo "::error::Invalid GitHub URL format: $URL"
            exit 1
          fi

          if [[ "$URL" =~ github\.com[:/]([^/]+)/([^/]+) ]]; then
            OWNER="${BASH_REMATCH[1]}"
            REPO="${BASH_REMATCH[2]}"
          else
            echo "::error::Invalid GitHub URL: $URL"
            exit 1
          fi

          echo "owner=$OWNER" >> $GITHUB_OUTPUT
          echo "repo=$REPO" >> $GITHUB_OUTPUT

          # Extract skillPath from URL (e.g., /tree/master/.claude/skills/clojure-review)
          SKILL_PATH=""
          if [[ "$URL" =~ /tree/[^/]+/(.+)$ ]]; then
            SKILL_PATH="${BASH_REMATCH[1]}"

            # Validate skill path - prevent path traversal attacks
            if [[ "$SKILL_PATH" =~ \.\. ]]; then
              echo "::error::Invalid skill path (contains '..'): $SKILL_PATH"
              exit 1
            fi
            if [[ "$SKILL_PATH" =~ ^/ ]]; then
              echo "::error::Invalid skill path (absolute path not allowed): $SKILL_PATH"
              exit 1
            fi

            echo "üìç Skill path specified: $SKILL_PATH"
          fi
          echo "skill_path=$SKILL_PATH" >> $GITHUB_OUTPUT

          BRANCH=$(gh api "repos/$OWNER/$REPO" --jq '.default_branch')
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT

          SOURCE_DIR="/tmp/source-repo-${{ github.run_id }}"
          git clone --depth 1 --branch "$BRANCH" "https://github.com/$OWNER/$REPO.git" "$SOURCE_DIR"

          echo "source_dir=$SOURCE_DIR" >> $GITHUB_OUTPUT
          echo "üì¶ Cloned $OWNER/$REPO (branch: $BRANCH)"

      - name: Discover skills (fast - no AI)
        id: discover
        env:
          SKILL_PATH: ${{ steps.clone.outputs.skill_path }}
          OWNER: ${{ steps.clone.outputs.owner }}
          REPO: ${{ steps.clone.outputs.repo }}
          BRANCH: ${{ steps.clone.outputs.branch }}
          ORIGINAL_URL: ${{ inputs.github_url }}
        run: |
          SOURCE_DIR="${{ steps.clone.outputs.source_dir }}"
          CORRECTED_URL=""  # Only set when FALLBACK occurs

          # If skill_path is specified, only search within that path
          if [ -n "$SKILL_PATH" ]; then
            SEARCH_DIR="$SOURCE_DIR/$SKILL_PATH"
            echo "üìç Searching within: $SKILL_PATH"

            # FALLBACK: If specified path doesn't exist OR has no SKILL.md,
            # search entire repo for matching folder name
            if [ ! -d "$SEARCH_DIR" ] || [ -z "$(find "$SEARCH_DIR" -name "SKILL.md" -type f 2>/dev/null | head -1)" ]; then
              FOLDER_NAME=$(basename "$SKILL_PATH")
              echo "‚ö†Ô∏è No SKILL.md found at $SKILL_PATH, searching for folder '$FOLDER_NAME' in repository..."

              # Find all directories matching the folder name that contain SKILL.md
              FOUND_PATH=""
              while IFS= read -r skill_md; do
                SKILL_DIR=$(dirname "$skill_md")
                DIR_NAME=$(basename "$SKILL_DIR")
                if [ "$DIR_NAME" = "$FOLDER_NAME" ]; then
                  FOUND_PATH="$SKILL_DIR"
                  break
                fi
              done < <(find "$SOURCE_DIR" -name "SKILL.md" -type f ! -path "*/node_modules/*" ! -path "*/.git/*" 2>/dev/null)

              # FALLBACK 2: If folder name match failed, try matching SKILL.md name field
              if [ -z "$FOUND_PATH" ]; then
                echo "‚ö†Ô∏è Folder name match failed, searching by SKILL.md name field '$FOLDER_NAME'..."

                while IFS= read -r skill_md; do
                  SKILL_NAME=$(grep -E '^name:' "$skill_md" 2>/dev/null | head -1 | sed 's/name:[[:space:]]*//')
                  if [ "$SKILL_NAME" = "$FOLDER_NAME" ]; then
                    FOUND_PATH=$(dirname "$skill_md")
                    echo "‚úÖ Found skill by name field: $SKILL_NAME"
                    break
                  fi
                done < <(find "$SOURCE_DIR" -name "SKILL.md" -type f ! -path "*/node_modules/*" ! -path "*/.git/*" 2>/dev/null)
              fi

              if [ -n "$FOUND_PATH" ]; then
                RELATIVE_PATH="${FOUND_PATH#$SOURCE_DIR/}"
                echo "‚úÖ Found skill at: $RELATIVE_PATH"
                SEARCH_DIR="$FOUND_PATH"
                # FALLBACK: Correct the URL to point to the discovered path
                CORRECTED_URL="https://github.com/$OWNER/$REPO/tree/$BRANCH/$RELATIVE_PATH"
                echo "üîÑ Corrected URL: $CORRECTED_URL"
              else
                echo "‚ùå Could not find folder '$FOLDER_NAME' with SKILL.md in repository"
                SEARCH_DIR="$SOURCE_DIR/$SKILL_PATH"  # Keep original (will find 0)
              fi
            fi
          else
            SEARCH_DIR="$SOURCE_DIR"
            echo "üîç Searching entire repository"
          fi

          # Output github_url: use corrected if FALLBACK occurred, otherwise original
          if [ -n "$CORRECTED_URL" ]; then
            echo "github_url=$CORRECTED_URL" >> $GITHUB_OUTPUT
          else
            echo "github_url=$ORIGINAL_URL" >> $GITHUB_OUTPUT
          fi

          SKILLS_JSON="["
          FIRST=true

          while IFS= read -r skill_md; do
            SKILL_DIR=$(dirname "$skill_md")

            SLUG=$(grep -E '^name:' "$skill_md" 2>/dev/null | head -1 | sed 's/name:[[:space:]]*//' | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/^-*//;s/-*$//' | sed 's/--*/-/g')
            [ -z "$SLUG" ] && SLUG=$(basename "$SKILL_DIR" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/^-*//;s/-*$//')

            if [ "$FIRST" = true ]; then
              FIRST=false
            else
              SKILLS_JSON+=","
            fi
            SKILLS_JSON+="\"$SLUG\""
          done < <(find "$SEARCH_DIR" -name "SKILL.md" -type f ! -path "*/node_modules/*" ! -path "*/.git/*" ! -path "*/.venv/*" ! -path "*/venv/*" 2>/dev/null | sort)

          SKILLS_JSON+="]"

          SKILL_COUNT=$(echo "$SKILLS_JSON" | jq 'length')

          echo "skills_json=$SKILLS_JSON" >> $GITHUB_OUTPUT
          echo "skill_count=$SKILL_COUNT" >> $GITHUB_OUTPUT

          echo "üìä Discovered $SKILL_COUNT skill(s)"

      - name: Plan processing strategy
        id: plan
        env:
          SKILL_COUNT: ${{ steps.discover.outputs.skill_count }}
          SKILLS_JSON: ${{ steps.discover.outputs.skills_json }}
        run: |
          COUNT=$SKILL_COUNT
          THRESHOLD=${{ env.SHARD_THRESHOLD }}
          MAX_SHARDS=${{ env.MAX_SHARDS }}

          if [ "$COUNT" -eq 0 ]; then
            echo "‚ùå No skills found"
            echo 'matrix={"include":[]}' >> $GITHUB_OUTPUT
            echo "is_sharded=false" >> $GITHUB_OUTPUT
            echo "shard_count=0" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "$COUNT" -lt "$THRESHOLD" ]; then
            echo "üì¶ Simple mode: $COUNT skills (below threshold $THRESHOLD)"
            ESCAPED_SLUGS=$(echo "$SKILLS_JSON" | jq -r 'join(",")')
            echo "matrix={\"include\":[{\"shard\":0,\"slugs\":\"$ESCAPED_SLUGS\"}]}" >> $GITHUB_OUTPUT
            echo "is_sharded=false" >> $GITHUB_OUTPUT
            echo "shard_count=1" >> $GITHUB_OUTPUT
          else
            # Dynamic shard count
            if [ "$COUNT" -lt $((MAX_SHARDS * 5)) ]; then
              SHARDS=$(( (COUNT + 4) / 5 ))
              [ "$SHARDS" -lt 2 ] && SHARDS=2
            else
              SHARDS=$MAX_SHARDS
            fi

            echo "üîÄ Sharded mode: $COUNT skills ‚Üí $SHARDS shards (dynamic sizing)"

            BASE_SIZE=$((COUNT / SHARDS))
            REMAINDER=$((COUNT % SHARDS))

            MATRIX='{"include":['
            CURRENT_IDX=0

            for i in $(seq 0 $((SHARDS - 1))); do
              if [ $i -lt $REMAINDER ]; then
                THIS_SIZE=$((BASE_SIZE + 1))
              else
                THIS_SIZE=$BASE_SIZE
              fi

              SHARD_SLUGS=$(echo "$SKILLS_JSON" | jq -r ".[$CURRENT_IDX:$((CURRENT_IDX + THIS_SIZE))] | join(\",\")")
              CURRENT_IDX=$((CURRENT_IDX + THIS_SIZE))

              [ $i -gt 0 ] && MATRIX+=','
              MATRIX+="{\"shard\":$i,\"slugs\":\"$SHARD_SLUGS\"}"

              echo "  Shard $i: $THIS_SIZE skills"
            done
            MATRIX+=']}'

            echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
            echo "is_sharded=true" >> $GITHUB_OUTPUT
            echo "shard_count=$SHARDS" >> $GITHUB_OUTPUT
          fi

      - name: Cleanup source
        if: always()
        run: rm -rf /tmp/source-repo-${{ github.run_id }}

  # ============================================================
  # JOB 2: PROCESS (Parallel Matrix)
  # Each shard processes a subset of skills with retry logic
  # ============================================================
  process:
    needs: discover-and-plan
    if: needs.discover-and-plan.outputs.shard_count != '0'
    runs-on: self-hosted
    timeout-minutes: 1440
    continue-on-error: true
    strategy:
      fail-fast: false
      max-parallel: ${{ fromJSON(inputs.max_parallel) }}
      matrix: ${{ fromJSON(needs.discover-and-plan.outputs.matrix) }}
    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          repositories: marketplace,skillstore

      - name: Checkout marketplace
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download Skillstore CLI
        uses: ./.github/actions/download-skillstore-cli
        with:
          version: ${{ inputs.cli_version }}
          token: ${{ steps.app-token.outputs.token }}
          cache-dir: /home/runner/_work/_cache/skillstore-cli

      - name: Process shard ${{ matrix.shard }}
        id: process
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SKILLSTORE_AGENTS: ${{ secrets.SKILLSTORE_AGENTS }}
          PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
          SLUGS: ${{ matrix.slugs }}
        run: |
          echo "=== Shard ${{ matrix.shard }} ==="
          SKILL_COUNT=$(echo "$SLUGS" | tr ',' '\n' | grep -c . || echo 0)
          echo "Processing $SKILL_COUNT skill(s)"

          MODEL_FLAG=""
          if [ -n "${{ inputs.model }}" ]; then
            MODEL_FLAG="--model ${{ inputs.model }}"
          fi

          # First attempt
          set +e
          "$GITHUB_WORKSPACE/skillstore-cli" skill process "${{ needs.discover-and-plan.outputs.github_url }}" \
            --slugs "$SLUGS" \
            --output . \
            --marketplace-repo "${{ github.repository }}" \
            --skip-pr \
            $MODEL_FLAG \
            2>&1 | tee process-output-${{ matrix.shard }}.log
          FIRST_EXIT=$?
          set -e

          # Check for failed skills and retry
          FAILED_SLUGS=""
          for slug in $(echo "$SLUGS" | tr ',' '\n'); do
            [ -z "$slug" ] && continue
            FOUND=$(find pending -path "*/$slug/skill-report.json" 2>/dev/null | head -1)
            if [ -z "$FOUND" ]; then
              [ -n "$FAILED_SLUGS" ] && FAILED_SLUGS="$FAILED_SLUGS,"
              FAILED_SLUGS="$FAILED_SLUGS$slug"
            fi
          done

          # Retry failed skills once
          if [ -n "$FAILED_SLUGS" ]; then
            RETRY_COUNT=$(echo "$FAILED_SLUGS" | tr ',' '\n' | grep -c . || echo 0)
            echo ""
            echo "üîÑ Retrying $RETRY_COUNT failed skill(s): $FAILED_SLUGS"
            sleep 10

            "$GITHUB_WORKSPACE/skillstore-cli" skill process "${{ needs.discover-and-plan.outputs.github_url }}" \
              --slugs "$FAILED_SLUGS" \
              --output . \
              --marketplace-repo "${{ github.repository }}" \
              --skip-pr \
              $MODEL_FLAG \
              2>&1 | tee -a process-output-${{ matrix.shard }}.log || true
          fi

          # Collect final results
          PROCESSED=0
          ERRORS=0
          HIGHEST_RISK="safe"
          PROCESSED_SLUGS=""

          for report in $(find pending -name "skill-report.json" 2>/dev/null); do
            SLUG=$(jq -r '.meta.slug' "$report")
            RISK=$(jq -r '.security_audit.risk_level // "unknown"' "$report")

            PROCESSED_SLUGS="$PROCESSED_SLUGS,$SLUG"
            PROCESSED=$((PROCESSED + 1))

            case "$RISK" in
              critical) HIGHEST_RISK="critical" ;;
              high) [ "$HIGHEST_RISK" != "critical" ] && HIGHEST_RISK="high" ;;
              medium) [ "$HIGHEST_RISK" = "safe" ] || [ "$HIGHEST_RISK" = "low" ] && HIGHEST_RISK="medium" ;;
              low) [ "$HIGHEST_RISK" = "safe" ] && HIGHEST_RISK="low" ;;
            esac
          done

          # Count remaining failures
          for slug in $(echo "$SLUGS" | tr ',' '\n'); do
            [ -z "$slug" ] && continue
            FOUND=$(find pending -path "*/$slug/skill-report.json" 2>/dev/null | head -1)
            [ -z "$FOUND" ] && ERRORS=$((ERRORS + 1))
          done

          PROCESSED_SLUGS=$(echo "$PROCESSED_SLUGS" | sed 's/^,//')

          echo "processed=$PROCESSED" >> $GITHUB_OUTPUT
          echo "errors=$ERRORS" >> $GITHUB_OUTPUT
          echo "highest_risk=$HIGHEST_RISK" >> $GITHUB_OUTPUT
          echo "processed_slugs=$PROCESSED_SLUGS" >> $GITHUB_OUTPUT

          echo ""
          echo "üìä Shard ${{ matrix.shard }}: $PROCESSED processed, $ERRORS errors, highest risk: $HIGHEST_RISK"

      - name: Upload shard results
        uses: actions/upload-artifact@v4
        with:
          name: process-shard-${{ matrix.shard }}
          path: |
            pending/
            process-output-${{ matrix.shard }}.log
          retention-days: 1


  # ============================================================
  # JOB 3: MERGE AND CREATE PR
  # Combine all shard results and create a single PR
  # ============================================================
  merge-and-create-pr:
    needs: [discover-and-plan, process]
    if: always() && needs.discover-and-plan.outputs.shard_count != '0'
    runs-on: self-hosted
    timeout-minutes: 60
    permissions:
      contents: write  # Required for git push operations
      pull-requests: write  # Required for creating PRs
    outputs:
      pr_url: ${{ steps.create_pr.outputs.pr_url }}
      processed_count: ${{ steps.create_pr.outputs.processed_count }}
      highest_risk: ${{ steps.create_pr.outputs.highest_risk }}
    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Download all shard artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: process-shard-*
          merge-multiple: true
          path: /tmp/submission-artifacts-${{ github.run_id }}

      - name: Merge results and create PR
        id: create_pr
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          APP_TOKEN: ${{ steps.app-token.outputs.token }}
          REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail

          WORK_DIR="/tmp/marketplace-${{ github.run_id }}"
          ARTIFACTS_DIR="/tmp/submission-artifacts-${{ github.run_id }}"

          cleanup() {
            echo "üßπ Cleaning up temp directories..."
            rm -rf "$WORK_DIR" "$ARTIFACTS_DIR" 2>/dev/null || true
          }
          trap cleanup EXIT

          echo "üì¶ Cloning fresh repository to $WORK_DIR..."
          git clone --depth 1 "https://x-access-token:${APP_TOKEN}@github.com/${REPOSITORY}.git" "$WORK_DIR"
          cd "$WORK_DIR"

          git config user.name "ai-skill-store[bot]"
          git config user.email "2628292+ai-skill-store[bot]@users.noreply.github.com"

          echo "=== Merging results from all shards ==="
          mkdir -p pending
          if [ -d "$ARTIFACTS_DIR/pending" ]; then
            cp -r "$ARTIFACTS_DIR/pending/"* ./pending/ 2>/dev/null || true
          fi

          PROCESSED_COUNT=0
          HIGHEST_RISK="safe"
          PROCESSED_SKILLS=""

          for report in $(find pending -name "skill-report.json" 2>/dev/null); do
            NAMESPACED_SLUG=$(jq -r 'if .meta.source_type == "official" then .meta.slug else .meta.owner + "/" + .meta.slug end' "$report")
            RISK=$(jq -r '.security_audit.risk_level // "unknown"' "$report")

            PROCESSED_SKILLS="$PROCESSED_SKILLS,$NAMESPACED_SLUG"
            PROCESSED_COUNT=$((PROCESSED_COUNT + 1))

            case "$RISK" in
              critical) HIGHEST_RISK="critical" ;;
              high) [ "$HIGHEST_RISK" != "critical" ] && HIGHEST_RISK="high" ;;
              medium) [ "$HIGHEST_RISK" = "safe" ] || [ "$HIGHEST_RISK" = "low" ] && HIGHEST_RISK="medium" ;;
              low) [ "$HIGHEST_RISK" = "safe" ] && HIGHEST_RISK="low" ;;
            esac
          done

          PROCESSED_SKILLS="${PROCESSED_SKILLS#,}"

          TOTAL_ERRORS=0
          for log in "$ARTIFACTS_DIR"/process-output-*.log; do
            if [ -f "$log" ]; then
              ERR_COUNT=$(grep -c "‚ùå error" "$log" 2>/dev/null) || ERR_COUNT=0
              TOTAL_ERRORS=$((TOTAL_ERRORS + ERR_COUNT))
            fi
          done

          echo "üìä Merged Results:"
          echo "  Total processed: $PROCESSED_COUNT"
          echo "  Total errors: $TOTAL_ERRORS"
          echo "  Highest risk: $HIGHEST_RISK"

          if [ "$PROCESSED_COUNT" -eq 0 ]; then
            echo "::error::No skills were successfully processed"
            echo "has_results=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "has_results=true" >> $GITHUB_OUTPUT
          echo "processed_count=$PROCESSED_COUNT" >> $GITHUB_OUTPUT
          echo "skills_list=$PROCESSED_SKILLS" >> $GITHUB_OUTPUT
          echo "highest_risk=$HIGHEST_RISK" >> $GITHUB_OUTPUT
          echo "total_errors=$TOTAL_ERRORS" >> $GITHUB_OUTPUT

          REPO_NAME="${{ needs.discover-and-plan.outputs.repo }}"
          BRANCH_NAME="submission/${REPO_NAME}-${{ inputs.submission_id }}"
          IS_SHARDED="${{ needs.discover-and-plan.outputs.is_sharded }}"
          SHARD_COUNT="${{ needs.discover-and-plan.outputs.shard_count }}"
          SKILL_COUNT="${{ needs.discover-and-plan.outputs.skill_count }}"

          # Configure git remote URL with authentication token
          echo "üîë Configuring git authentication..."
          git remote set-url origin "https://x-access-token:${APP_TOKEN}@github.com/${REPOSITORY}.git"

          git push origin --delete "$BRANCH_NAME" 2>/dev/null || true

          git checkout -b "$BRANCH_NAME"
          git add pending/

          # Different commit messages for manual approval vs automatic
          if [ "${{ inputs.is_manual_approval }}" = "true" ]; then
            APPROVAL_INFO="[approved by: ${{ inputs.approved_by }}]"
          else
            APPROVAL_INFO=""
          fi

          if [ "$PROCESSED_COUNT" -eq 1 ]; then
            FIRST_SKILL=$(echo "$PROCESSED_SKILLS" | cut -d',' -f1)
            git commit -m "Add pending skill: $FIRST_SKILL [submission: ${{ inputs.submission_id }}] $APPROVAL_INFO"
            PR_TITLE="$([ "${{ inputs.is_manual_approval }}" = "true" ] && echo "[APPROVED] " || echo "")New skill: $FIRST_SKILL ($HIGHEST_RISK risk)"
          else
            git commit -m "Add $PROCESSED_COUNT pending skills from $REPO_NAME [submission: ${{ inputs.submission_id }}] $APPROVAL_INFO"
            if [ "$IS_SHARDED" = "true" ]; then
              PR_TITLE="$([ "${{ inputs.is_manual_approval }}" = "true" ] && echo "[APPROVED] " || echo "")New skills: $PROCESSED_COUNT skills from $REPO_NAME ($HIGHEST_RISK) [parallel: ${SHARD_COUNT} shards]"
            else
              PR_TITLE="$([ "${{ inputs.is_manual_approval }}" = "true" ] && echo "[APPROVED] " || echo "")New skills: $PROCESSED_COUNT skills from $REPO_NAME ($HIGHEST_RISK risk)"
            fi
          fi

          git push origin "$BRANCH_NAME"

          RISK_BADGE="üü¢"
          [ "$HIGHEST_RISK" = "critical" ] && RISK_BADGE="üî¥"
          [ "$HIGHEST_RISK" = "high" ] && RISK_BADGE="üü†"
          [ "$HIGHEST_RISK" = "medium" ] && RISK_BADGE="üü°"
          [ "$HIGHEST_RISK" = "low" ] && RISK_BADGE="üü°"

          SKILLS_TABLE="| Skill | Risk | Status |
          |-------|------|--------|"

          for report in $(find pending -name "skill-report.json" 2>/dev/null | head -50); do
            NAMESPACED_SLUG=$(jq -r 'if .meta.source_type == "official" then .meta.slug else .meta.owner + "/" + .meta.slug end' "$report")
            SKILL_RISK=$(jq -r '.security_audit.risk_level // "unknown"' "$report")
            SKILLS_TABLE="$SKILLS_TABLE
          | \`$NAMESPACED_SLUG\` | $SKILL_RISK | Ready |"
          done

          if [ "$PROCESSED_COUNT" -gt 50 ]; then
            SKILLS_TABLE="$SKILLS_TABLE
          | ... | ... | ... |
          | *and $((PROCESSED_COUNT - 50)) more* | | |"
          fi

          # Build PR body with conditional approval info
          if [ "${{ inputs.is_manual_approval }}" = "true" ]; then
            APPROVAL_SECTION="**Approved by**: @${{ inputs.approved_by }}

          "
          else
            APPROVAL_SECTION=""
          fi

          cat > pr-body.md << EOF
          ## $([ "${{ inputs.is_manual_approval }}" = "true" ] && echo "‚úÖ Approved " || echo "")Skill Submission: $REPO_NAME

          **Submission ID**: \`${{ inputs.submission_id }}\`
          **Source**: ${{ inputs.github_url }}
          ${APPROVAL_SECTION}
          ### Summary $RISK_BADGE
          - Skills discovered: $SKILL_COUNT
          - Skills processed: $PROCESSED_COUNT
          - Highest risk: $HIGHEST_RISK
          EOF

          if [ "$IS_SHARDED" = "true" ]; then
            echo "- Processing mode: **Parallel** ($SHARD_COUNT shards)" >> pr-body.md
          fi

          if [ "$TOTAL_ERRORS" -gt 0 ]; then
            echo "- ‚ö†Ô∏è Failed skills: $TOTAL_ERRORS" >> pr-body.md
          fi

          cat >> pr-body.md << EOF

          ### Skills
          $SKILLS_TABLE

          ### Review Checklist
          $([ "${{ inputs.is_manual_approval }}" = "true" ] && echo "- [x] Manual approval granted by @${{ inputs.approved_by }}" || echo "- [ ] Automated submission review")
          - [ ] All skill contents are appropriate
          - [ ] Security audit findings reviewed
          - [ ] Source repository checked

          ---
          *Processed by skillstore-cli*
          EOF

          PR_LABELS="pending-review"
          if [ "${{ inputs.is_manual_approval }}" = "true" ]; then
            PR_LABELS="$PR_LABELS,manually-approved"
          fi

          PR_URL=$(gh pr create \
            --title "$PR_TITLE" \
            --body-file pr-body.md \
            --label "$PR_LABELS" \
            --base main \
            --head "$BRANCH_NAME" 2>&1 | tail -1)

          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          echo "Created PR: $PR_URL"
