name: Release

on:
  push:
    tags:
      - 'v*'

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  release:
    runs-on: self-hosted
    permissions:
      contents: write
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      release_date: ${{ steps.changelog.outputs.release_date }}
      plugin_count: ${{ steps.changelog.outputs.plugin_count }}
      added_plugins: ${{ steps.changelog.outputs.added_plugins }}
      added_count: ${{ steps.changelog.outputs.added_count }}
      updated_plugins: ${{ steps.changelog.outputs.updated_plugins }}
      updated_count: ${{ steps.changelog.outputs.updated_count }}
      removed_count: ${{ steps.changelog.outputs.removed_count }}
      infra_changes: ${{ steps.changelog.outputs.infra_changes }}
      ai_summary: ${{ steps.ai_summary.outputs.summary }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Extract and validate version
        id: version
        run: |
          TAG="${GITHUB_REF#refs/tags/}"
          VERSION="${TAG#v}"
          
          # Validate SemVer format (with optional pre-release)
          if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$ ]]; then
            echo "::error::Invalid version format: $VERSION (expected SemVer like 1.2.3 or 1.2.3-beta.1)"
            exit 1
          fi
          
          # Check if this is a pre-release
          if [[ "$VERSION" =~ - ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
          fi
          
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Releasing: $TAG (version $VERSION)"

      - name: Get previous tag
        id: prev_tag
        run: |
          CURRENT_TAG="${{ steps.version.outputs.tag }}"
          PREV_TAG=$(git tag --sort=-version:refname | grep -v "^${CURRENT_TAG}$" | head -1 || echo "")
          echo "tag=$PREV_TAG" >> $GITHUB_OUTPUT
          if [ -n "$PREV_TAG" ]; then
            echo "Previous tag: $PREV_TAG"
          else
            echo "No previous tags found (first release)"
          fi

      - name: Sync marketplace.json from plugins directory
        id: sync_marketplace
        run: |
          echo "Syncing marketplace.json from plugins/ directory..."

          # High-performance O(1) approach: single jq invocation for ALL files
          # Uses jq's 'inputs' to stream-process files and 'input_filename' for paths
          # Scales to 100k+ plugins without shell argument limits or O(n) overhead
          cat > /tmp/sync_plugins.jq << 'JQSCRIPT'
          [inputs |
            select(.name != null) |
            {
              name: .name,
              description: (.description // ""),
              version: (.version // "1.0.0"),
              source: ("./\(input_filename | split("/")[:-1] | join("/"))")
            }
          ] | sort_by(.name)
          JQSCRIPT

          find plugins -name "marketplace-entry.json" -print0 2>/dev/null | \
            sort -z | \
            xargs -0 jq -n -f /tmp/sync_plugins.jq > /tmp/plugins_sorted.json

          PLUGIN_COUNT=$(jq 'length' /tmp/plugins_sorted.json)

          # Update marketplace.json with synced plugins
          jq --slurpfile plugins /tmp/plugins_sorted.json '.plugins = $plugins[0]' \
            .claude-plugin/marketplace.json > /tmp/marketplace_synced.json
          mv /tmp/marketplace_synced.json .claude-plugin/marketplace.json

          rm -f /tmp/plugins_sorted.json /tmp/sync_plugins.jq
          echo "Synced $PLUGIN_COUNT plugins to marketplace.json"
          echo "plugin_count=$PLUGIN_COUNT" >> $GITHUB_OUTPUT

      - name: Analyze changes since last release
        id: changelog
        env:
          PREV_TAG: ${{ steps.prev_tag.outputs.tag }}
          CURRENT_TAG: ${{ steps.version.outputs.tag }}
        run: |
          TODAY=$(date +%Y-%m-%d)

          if [ -n "$PREV_TAG" ]; then
            RANGE="${PREV_TAG}..${CURRENT_TAG}"
          else
            RANGE="${CURRENT_TAG}"
          fi

          echo "Analyzing commits in range: $RANGE"

          # High-performance O(1) approach for plugin comparison
          # Uses jq set operations instead of O(nÂ²) shell loops

          # Get current plugin count and list (single jq call)
          PLUGIN_COUNT=$(jq '.plugins | length' .claude-plugin/marketplace.json)
          jq -r '.plugins[].name' .claude-plugin/marketplace.json | sort > /tmp/current_plugins.txt

          # Build current plugin name-to-path map (single jq call)
          jq -r '.plugins[] | "\(.name)|\(.source | sub("^\\./"; ""))"' \
            .claude-plugin/marketplace.json > /tmp/current_plugin_paths.txt

          # Get previous plugins using efficient git + jq pipeline
          PREV_COUNT=0
          > /tmp/prev_plugins.txt
          > /tmp/prev_plugin_paths.txt

          if [ -n "$PREV_TAG" ]; then
            echo "Scanning plugins at ${PREV_TAG}..."

            # Get all marketplace-entry.json files at PREV_TAG in one git call
            git ls-tree -r "${PREV_TAG}" --name-only 2>/dev/null | grep "marketplace-entry.json" > /tmp/prev_entry_files.txt || true

            # Extract names efficiently using a single pass
            while IFS= read -r file; do
              [ -z "$file" ] && continue
              name=$(git show "${PREV_TAG}:${file}" 2>/dev/null | jq -r '.name // empty' 2>/dev/null)
              if [ -n "$name" ]; then
                echo "$name" >> /tmp/prev_plugins.txt
                echo "${name}|$(dirname "$file")" >> /tmp/prev_plugin_paths.txt
              fi
            done < /tmp/prev_entry_files.txt

            sort -o /tmp/prev_plugins.txt /tmp/prev_plugins.txt
            PREV_COUNT=$(wc -l < /tmp/prev_plugins.txt | tr -d ' ')
          fi

          echo "Previous tag had $PREV_COUNT plugins"

          # Calculate added/removed using comm (O(n) set difference)
          ADDED_PLUGINS=$(comm -23 /tmp/current_plugins.txt /tmp/prev_plugins.txt | paste -sd ',' -)
          ADDED_COUNT=$(comm -23 /tmp/current_plugins.txt /tmp/prev_plugins.txt | wc -l | tr -d ' ')
          REMOVED_COUNT=$(comm -13 /tmp/current_plugins.txt /tmp/prev_plugins.txt | wc -l | tr -d ' ')

          # Calculate updated plugins using git tree hash comparison
          # Only compare plugins that exist in both versions
          UPDATED_PLUGINS=""
          UPDATED_COUNT=0

          if [ -n "$PREV_TAG" ] && [ -s /tmp/prev_plugins.txt ]; then
            # Get plugins in both versions
            comm -12 /tmp/current_plugins.txt /tmp/prev_plugins.txt > /tmp/common_plugins.txt

            while IFS= read -r name; do
              [ -z "$name" ] && continue

              # Get paths from lookup tables (grep is O(1) per lookup with small result)
              curr_path=$(grep "^${name}|" /tmp/current_plugin_paths.txt | cut -d'|' -f2 | head -1)
              prev_path=$(grep "^${name}|" /tmp/prev_plugin_paths.txt | cut -d'|' -f2 | head -1)

              [ -z "$curr_path" ] || [ -z "$prev_path" ] && continue

              # Compare git tree hashes
              prev_hash=$(git rev-parse "${PREV_TAG}:${prev_path}" 2>/dev/null || echo "")
              curr_hash=$(git rev-parse "HEAD:${curr_path}" 2>/dev/null || echo "")

              if [ -n "$prev_hash" ] && [ -n "$curr_hash" ] && [ "$prev_hash" != "$curr_hash" ]; then
                [ -z "$UPDATED_PLUGINS" ] && UPDATED_PLUGINS="$name" || UPDATED_PLUGINS="${UPDATED_PLUGINS},$name"
                UPDATED_COUNT=$((UPDATED_COUNT + 1))
              fi
            done < /tmp/common_plugins.txt
          fi

          # Cleanup temp files
          rm -f /tmp/current_plugins.txt /tmp/prev_plugins.txt /tmp/current_plugin_paths.txt \
                /tmp/prev_plugin_paths.txt /tmp/prev_entry_files.txt /tmp/common_plugins.txt
          
          # Collect commit messages for infrastructure changes
          INFRA_CHANGES=""
          while IFS= read -r line; do
            [ -z "$line" ] && continue
            MSG=$(echo "$line" | cut -d' ' -f2-)
            
            if echo "$MSG" | grep -qE "^(feat|fix|chore|docs|refactor|perf|ci):"; then
              if [ -z "$INFRA_CHANGES" ]; then
                INFRA_CHANGES="$MSG"
              else
                INFRA_CHANGES="${INFRA_CHANGES}|$MSG"
              fi
            fi
          done < <(git log --oneline $RANGE 2>/dev/null || git log --oneline)
          
          {
            echo "release_date=$TODAY"
            echo "plugin_count=$PLUGIN_COUNT"
            echo "added_plugins=$ADDED_PLUGINS"
            echo "added_count=$ADDED_COUNT"
            echo "updated_plugins=$UPDATED_PLUGINS"
            echo "updated_count=$UPDATED_COUNT"
            echo "removed_count=$REMOVED_COUNT"
            echo "infra_changes=$INFRA_CHANGES"
          } >> $GITHUB_OUTPUT
          
          echo "Found: $ADDED_COUNT new, $UPDATED_COUNT updated, $REMOVED_COUNT removed"
          echo "Total plugins: $PLUGIN_COUNT"

      - name: Generate AI summary
        id: ai_summary
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          ADDED_PLUGINS="${{ steps.changelog.outputs.added_plugins }}"
          ADDED_COUNT="${{ steps.changelog.outputs.added_count }}"
          PLUGIN_COUNT="${{ steps.changelog.outputs.plugin_count }}"
          INFRA_CHANGES="${{ steps.changelog.outputs.infra_changes }}"
          
          CONTEXT="Version: v${VERSION}
          Total plugins: ${PLUGIN_COUNT}
          New plugins (${ADDED_COUNT}): ${ADDED_PLUGINS}
          Recent changes: ${INFRA_CHANGES}"
          
          PROMPT="Generate a concise 1-2 sentence release summary for AI Skillstore marketplace v${VERSION}.
          
          Context:
          ${CONTEXT}
          
          Focus on value to users. Be professional, not marketing-speak. Output only the summary text, no quotes."
          
          # Try codex CLI (available on self-hosted runner)
          RESPONSE=$(echo "$PROMPT" | timeout 30 codex exec --skip-git-repo-check --sandbox read-only \
            -m gpt-5.2 \
            -c 'model_reasoning_effort="medium"' \
            2>/dev/null || echo "")
          
          if [ -z "$RESPONSE" ]; then
            # Fallback summary
            if [ "$ADDED_COUNT" -gt 0 ]; then
              RESPONSE="Marketplace update with ${ADDED_COUNT} new plugins. Total ${PLUGIN_COUNT} plugins available."
            else
              RESPONSE="Marketplace v${VERSION} with ${PLUGIN_COUNT} plugins and infrastructure improvements."
            fi
          fi
          
          # Escape double quotes AND backticks (backticks cause command substitution in bash)
          ESCAPED=$(echo "$RESPONSE" | tr '\n' ' ' | sed 's/"/\\"/g' | sed 's/`/'"'"'/g')
          echo "summary=$ESCAPED" >> $GITHUB_OUTPUT
          echo "AI Summary: $ESCAPED"

      - name: Update marketplace.json version
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          
          jq --arg version "$VERSION" \
            '.metadata.version = $version' \
            .claude-plugin/marketplace.json > /tmp/marketplace.json
          mv /tmp/marketplace.json .claude-plugin/marketplace.json
          
          echo "Updated marketplace.json to version $VERSION"

      - name: Update CHANGELOG.md
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TODAY="${{ steps.changelog.outputs.release_date }}"
          PLUGIN_COUNT="${{ steps.changelog.outputs.plugin_count }}"
          ADDED_PLUGINS="${{ steps.changelog.outputs.added_plugins }}"
          ADDED_COUNT="${{ steps.changelog.outputs.added_count }}"
          UPDATED_COUNT="${{ steps.changelog.outputs.updated_count }}"
          INFRA_CHANGES="${{ steps.changelog.outputs.infra_changes }}"
          SUMMARY="${{ steps.ai_summary.outputs.summary }}"
          
          # Build changelog entry
          ENTRY="## [${VERSION}] - ${TODAY}\n\n"
          ENTRY+="### Summary\n\n${SUMMARY}\n\n"
          ENTRY+="### Statistics\n\n"
          ENTRY+="- Total plugins: ${PLUGIN_COUNT}\n"
          ENTRY+="- New plugins: ${ADDED_COUNT}\n"
          ENTRY+="- Updated plugins: ${UPDATED_COUNT}\n\n"
          
          if [ -n "$ADDED_PLUGINS" ] && [ "$ADDED_PLUGINS" != "" ]; then
            ENTRY+="### New Plugins\n\n"
            IFS=',' read -ra PLUGINS <<< "$ADDED_PLUGINS"
            for p in "${PLUGINS[@]}"; do
              [ -n "$p" ] && ENTRY+="- \`${p}\`\n"
            done
            ENTRY+="\n"
          fi
          
          if [ -n "$INFRA_CHANGES" ] && [ "$INFRA_CHANGES" != "" ]; then
            ENTRY+="### Changes\n\n"
            IFS='|' read -ra CHANGES <<< "$INFRA_CHANGES"
            for c in "${CHANGES[@]}"; do
              [ -n "$c" ] && ENTRY+="- ${c}\n"
            done
            ENTRY+="\n"
          fi
          
          # Create CHANGELOG if not exists
          if [ ! -f CHANGELOG.md ]; then
            cat > CHANGELOG.md << 'HEADER'
          # Changelog
          
          All notable changes to the AI Skillstore marketplace will be documented in this file.
          
          The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
          and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
          
          HEADER
          fi
          
          # Insert new entry after header
          HEADER_END=$(grep -n "^## \[" CHANGELOG.md | head -1 | cut -d: -f1 || echo "")
          
          if [ -z "$HEADER_END" ]; then
            echo -e "\n$ENTRY" >> CHANGELOG.md
          else
            {
              head -n $((HEADER_END - 1)) CHANGELOG.md
              echo ""
              echo -e "$ENTRY"
              tail -n +$HEADER_END CHANGELOG.md
            } > /tmp/CHANGELOG.md
            mv /tmp/CHANGELOG.md CHANGELOG.md
          fi
          
          echo "Updated CHANGELOG.md"

      - name: Commit version updates (isolated temp directory)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          
          VERSION="${{ steps.version.outputs.version }}"
          
          # Use temp directory for clean git operations
          # This eliminates state pollution from self-hosted runners (leftover rebase-merge, index.lock, etc.)
          WORK_DIR="/tmp/marketplace-release-${{ github.run_id }}"
          
          cleanup() {
            echo "ðŸ§¹ Cleaning up temp directory..."
            rm -rf "$WORK_DIR" 2>/dev/null || true
          }
          trap cleanup EXIT
          
          echo "ðŸ“¦ Cloning fresh repository to $WORK_DIR..."
          git clone --depth 1 "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" "$WORK_DIR"
          
          # Copy updated files from checkout to fresh clone
          cp .claude-plugin/marketplace.json "$WORK_DIR/.claude-plugin/marketplace.json"
          cp CHANGELOG.md "$WORK_DIR/CHANGELOG.md"
          
          cd "$WORK_DIR"
          
          git config user.name "ai-skill-store[bot]"
          git config user.email "2628292+ai-skill-store[bot]@users.noreply.github.com"
          
          git add .claude-plugin/marketplace.json CHANGELOG.md
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "release: v${VERSION}"
            
            # Push with retry logic for race conditions
            for i in 1 2 3; do
              if git push origin main; then
                echo "âœ… Committed version updates to main"
                break
              fi
              echo "Push failed, pulling and retrying ($i/3)..."
              git pull --rebase origin main || {
                git rebase --abort 2>/dev/null || true
                git reset --hard origin/main
                git cherry-pick HEAD@{1} || true
              }
              sleep 2
            done
          fi

      - name: Build release notes
        id: release_notes
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="${{ steps.version.outputs.tag }}"
          PREV_TAG="${{ steps.prev_tag.outputs.tag }}"
          PLUGIN_COUNT="${{ steps.changelog.outputs.plugin_count }}"
          ADDED_PLUGINS="${{ steps.changelog.outputs.added_plugins }}"
          ADDED_COUNT="${{ steps.changelog.outputs.added_count }}"
          UPDATED_COUNT="${{ steps.changelog.outputs.updated_count }}"
          REMOVED_COUNT="${{ steps.changelog.outputs.removed_count }}"
          INFRA_CHANGES="${{ steps.changelog.outputs.infra_changes }}"
          SUMMARY="${{ steps.ai_summary.outputs.summary }}"
          
          cat > /tmp/release_notes.md << EOF
          ${SUMMARY}
          
          ## Quick Install
          
          \`\`\`bash
          /plugin marketplace add aiskillstore/marketplace
          \`\`\`
          
          ## Statistics
          
          | Metric | Count |
          |--------|-------|
          | Total Plugins | ${PLUGIN_COUNT} |
          | New Plugins | ${ADDED_COUNT} |
          | Updated Plugins | ${UPDATED_COUNT} |
          | Removed Plugins | ${REMOVED_COUNT} |
          
          EOF
          
          if [ -n "$ADDED_PLUGINS" ] && [ "$ADDED_PLUGINS" != "" ]; then
            echo "## New Plugins" >> /tmp/release_notes.md
            echo "" >> /tmp/release_notes.md
            IFS=',' read -ra PLUGINS <<< "$ADDED_PLUGINS"
            for p in "${PLUGINS[@]}"; do
              [ -n "$p" ] && echo "- \`${p}\`" >> /tmp/release_notes.md
            done
            echo "" >> /tmp/release_notes.md
          fi
          
          if [ -n "$INFRA_CHANGES" ] && [ "$INFRA_CHANGES" != "" ]; then
            echo "## Changes" >> /tmp/release_notes.md
            echo "" >> /tmp/release_notes.md
            IFS='|' read -ra CHANGES <<< "$INFRA_CHANGES"
            for c in "${CHANGES[@]}"; do
              [ -n "$c" ] && echo "- ${c}" >> /tmp/release_notes.md
            done
            echo "" >> /tmp/release_notes.md
          fi
          
          cat >> /tmp/release_notes.md << EOF
          ---
          
          **Full Changelog**: $([ -n "$PREV_TAG" ] && echo "https://github.com/${{ github.repository }}/compare/${PREV_TAG}...${TAG}" || echo "https://github.com/${{ github.repository }}/commits/${TAG}")
          EOF

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          IS_PRERELEASE="${{ steps.version.outputs.is_prerelease }}"
          
          PRERELEASE_FLAG=""
          if [ "$IS_PRERELEASE" = "true" ]; then
            PRERELEASE_FLAG="--prerelease"
          fi
          
          gh release create "$TAG" \
            --title "$TAG" \
            --notes-file /tmp/release_notes.md \
            --latest \
            $PRERELEASE_FLAG
          
          echo "Created release: $TAG"

      - name: Summary
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          echo "## Release Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: v${VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "- **Plugins**: ${{ steps.changelog.outputs.plugin_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- **New**: ${{ steps.changelog.outputs.added_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- **URL**: https://github.com/${{ github.repository }}/releases/tag/v${VERSION}" >> $GITHUB_STEP_SUMMARY

  sync-to-supabase:
    needs: release
    runs-on: self-hosted
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'

      - name: Install dependencies
        run: npm install @supabase/supabase-js

      - name: Sync release to Supabase
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          node << 'EOF'
          const { createClient } = require('@supabase/supabase-js');

          const supabase = createClient(
            process.env.SUPABASE_URL,
            process.env.SUPABASE_SERVICE_KEY
          );

          async function syncRelease() {
            const version = '${{ needs.release.outputs.version }}';
            const tag = '${{ needs.release.outputs.tag }}';
            const releaseDate = '${{ needs.release.outputs.release_date }}';
            const pluginCount = parseInt('${{ needs.release.outputs.plugin_count }}', 10) || 0;
            const addedCount = parseInt('${{ needs.release.outputs.added_count }}', 10) || 0;
            const updatedCount = parseInt('${{ needs.release.outputs.updated_count }}', 10) || 0;
            const removedCount = parseInt('${{ needs.release.outputs.removed_count }}', 10) || 0;
            const addedPlugins = '${{ needs.release.outputs.added_plugins }}'.split(',').filter(Boolean);
            const updatedPlugins = '${{ needs.release.outputs.updated_plugins }}'.split(',').filter(Boolean);
            const infraChanges = '${{ needs.release.outputs.infra_changes }}'.split('|').filter(Boolean);
            const aiSummary = `${{ needs.release.outputs.ai_summary }}`;

            const changelog = {
              added_plugins: addedPlugins,
              updated_plugins: updatedPlugins,
              removed_plugins: [],
              infrastructure_changes: infraChanges
            };

            console.log('Syncing release to Supabase...');
            console.log(`  Tag: ${tag}`);
            console.log(`  Version: ${version}`);
            console.log(`  Plugins: ${pluginCount}`);
            console.log(`  Added: ${addedCount}`);
            console.log(`  Updated: ${updatedCount}`);
            console.log(`  Removed: ${removedCount}`);

            // Mark previous releases as not latest
            const { error: updateError } = await supabase
              .schema('skillstore')
              .from('releases')
              .update({ is_latest: false })
              .eq('is_latest', true);

            if (updateError) {
              console.warn('Warning: Failed to update previous releases:', updateError.message);
            }

            // Upsert new release
            const record = {
              tag: tag,
              version: version,
              release_date: releaseDate,
              skill_count: pluginCount,
              summary: aiSummary || `Marketplace ${tag}`,
              changelog: changelog,
              added_count: addedCount,
              updated_count: updatedCount,
              removed_count: removedCount,
              is_latest: true
            };

            const { error } = await supabase
              .schema('skillstore')
              .from('releases')
              .upsert(record, { 
                onConflict: 'tag',
                ignoreDuplicates: false 
              });

            if (error) {
              console.error('Error syncing to Supabase:', error.message);
              process.exit(1);
            }

            console.log(`Successfully synced ${tag} to Supabase`);
          }

          syncRelease().catch(err => {
            console.error('Sync failed:', err);
            process.exit(1);
          });
          EOF

      - name: Trigger Cloudflare Pages deployment
        run: |
          echo "Triggering Cloudflare Pages deployment for skillstore.io..."
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X POST "${{ secrets.CLOUDFLARE_DEPLOY_HOOK }}")
          if [ "$HTTP_STATUS" -eq 200 ]; then
            echo "âœ… Deployment triggered successfully"
          else
            echo "âš ï¸ Unexpected response: HTTP $HTTP_STATUS"
            exit 1
          fi

      - name: Summary
        run: |
          echo "## Sync & Deploy Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Supabase**: Release **${{ needs.release.outputs.tag }}** synced" >> $GITHUB_STEP_SUMMARY
          echo "- **Cloudflare**: skillstore.io deployment triggered" >> $GITHUB_STEP_SUMMARY
