name: Release

on:
  push:
    tags:
      - 'v*'

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  release:
    runs-on: self-hosted
    permissions:
      contents: write
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      release_date: ${{ steps.changelog.outputs.release_date }}
      skill_count: ${{ steps.changelog.outputs.skill_count }}
      added_skills: ${{ steps.changelog.outputs.added_skills }}
      added_count: ${{ steps.changelog.outputs.added_count }}
      updated_skills: ${{ steps.changelog.outputs.updated_skills }}
      updated_count: ${{ steps.changelog.outputs.updated_count }}
      removed_count: ${{ steps.changelog.outputs.removed_count }}
      infra_changes: ${{ steps.changelog.outputs.infra_changes }}
      ai_summary: ${{ steps.ai_summary.outputs.summary }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Extract and validate version
        id: version
        run: |
          TAG="${GITHUB_REF#refs/tags/}"
          VERSION="${TAG#v}"
          
          # Validate SemVer format (with optional pre-release)
          if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$ ]]; then
            echo "::error::Invalid version format: $VERSION (expected SemVer like 1.2.3 or 1.2.3-beta.1)"
            exit 1
          fi
          
          # Check if this is a pre-release
          if [[ "$VERSION" =~ - ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
          fi
          
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Releasing: $TAG (version $VERSION)"

      - name: Get previous tag
        id: prev_tag
        run: |
          CURRENT_TAG="${{ steps.version.outputs.tag }}"
          PREV_TAG=$(git tag --sort=-version:refname | grep -v "^${CURRENT_TAG}$" | head -1 || echo "")
          echo "tag=$PREV_TAG" >> $GITHUB_OUTPUT
          if [ -n "$PREV_TAG" ]; then
            echo "Previous tag: $PREV_TAG"
          else
            echo "No previous tags found (first release)"
          fi

      - name: Count skills
        id: count_skills
        run: |
          # Count skills by finding plugin.json files
          SKILL_COUNT=$(find skills -name "SKILL.md" 2>/dev/null | wc -l | tr -d ' ')
          echo "skill_count=$SKILL_COUNT" >> $GITHUB_OUTPUT
          echo "Found $SKILL_COUNT skills"

      - name: Analyze changes since last release
        id: changelog
        env:
          PREV_TAG: ${{ steps.prev_tag.outputs.tag }}
          CURRENT_TAG: ${{ steps.version.outputs.tag }}
        run: |
          TODAY=$(date +%Y-%m-%d)

          if [ -n "$PREV_TAG" ]; then
            RANGE="${PREV_TAG}..${CURRENT_TAG}"
          else
            RANGE="${CURRENT_TAG}"
          fi

          echo "Analyzing commits in range: $RANGE"

          # Get current skill count from count_skills step
          SKILL_COUNT="${{ steps.count_skills.outputs.skill_count }}"

          # Build current skill name-to-path map from plugin.json files
          > /tmp/current_skills.txt
          > /tmp/current_skill_paths.txt
          for plugin_file in $(find skills -name "SKILL.md" 2>/dev/null | sort); do
            name=$(jq -r '.name // empty' "$plugin_file" 2>/dev/null)
            if [ -n "$name" ]; then
              skill_dir=$(dirname "$(dirname "$plugin_file")")
              echo "$name" >> /tmp/current_skills.txt
              echo "${name}|${skill_dir}" >> /tmp/current_skill_paths.txt
            fi
          done
          sort -o /tmp/current_skills.txt /tmp/current_skills.txt

          # Get previous skills using efficient git + jq pipeline
          PREV_COUNT=0
          > /tmp/prev_skills.txt
          > /tmp/prev_skill_paths.txt

          if [ -n "$PREV_TAG" ]; then
            echo "Scanning skills at ${PREV_TAG}..."

            # Get all plugin.json files at PREV_TAG in one git call
            git ls-tree -r "${PREV_TAG}" --name-only 2>/dev/null | grep "SKILL\.md$" > /tmp/prev_entry_files.txt || true

            # Extract names efficiently using a single pass
            while IFS= read -r file; do
              [ -z "$file" ] && continue
              name=$(git show "${PREV_TAG}:${file}" 2>/dev/null | jq -r '.name // empty' 2>/dev/null)
              if [ -n "$name" ]; then
                skill_dir=$(dirname "$(dirname "$file")")
                echo "$name" >> /tmp/prev_skills.txt
                echo "${name}|${skill_dir}" >> /tmp/prev_skill_paths.txt
              fi
            done < /tmp/prev_entry_files.txt

            sort -o /tmp/prev_skills.txt /tmp/prev_skills.txt
            PREV_COUNT=$(wc -l < /tmp/prev_skills.txt | tr -d ' ')
          fi

          echo "Previous tag had $PREV_COUNT skills"

          # Calculate added/removed using comm (O(n) set difference)
          ADDED_SKILLS=$(comm -23 /tmp/current_skills.txt /tmp/prev_skills.txt | paste -sd ',' -)
          ADDED_COUNT=$(comm -23 /tmp/current_skills.txt /tmp/prev_skills.txt | wc -l | tr -d ' ')
          REMOVED_COUNT=$(comm -13 /tmp/current_skills.txt /tmp/prev_skills.txt | wc -l | tr -d ' ')

          # Calculate updated skills using git tree hash comparison
          # Only compare skills that exist in both versions
          UPDATED_PLUGINS=""
          UPDATED_COUNT=0

          if [ -n "$PREV_TAG" ] && [ -s /tmp/prev_skills.txt ]; then
            # Get skills in both versions
            comm -12 /tmp/current_skills.txt /tmp/prev_skills.txt > /tmp/common_skills.txt

            while IFS= read -r name; do
              [ -z "$name" ] && continue

              # Get paths from lookup tables (grep is O(1) per lookup with small result)
              curr_path=$(grep "^${name}|" /tmp/current_skill_paths.txt | cut -d'|' -f2 | head -1)
              prev_path=$(grep "^${name}|" /tmp/prev_skill_paths.txt | cut -d'|' -f2 | head -1)

              [ -z "$curr_path" ] || [ -z "$prev_path" ] && continue

              # Compare git tree hashes
              prev_hash=$(git rev-parse "${PREV_TAG}:${prev_path}" 2>/dev/null || echo "")
              curr_hash=$(git rev-parse "HEAD:${curr_path}" 2>/dev/null || echo "")

              if [ -n "$prev_hash" ] && [ -n "$curr_hash" ] && [ "$prev_hash" != "$curr_hash" ]; then
                [ -z "$UPDATED_PLUGINS" ] && UPDATED_PLUGINS="$name" || UPDATED_PLUGINS="${UPDATED_PLUGINS},$name"
                UPDATED_COUNT=$((UPDATED_COUNT + 1))
              fi
            done < /tmp/common_skills.txt
          fi

          # Cleanup temp files
          rm -f /tmp/current_skills.txt /tmp/prev_skills.txt /tmp/current_skill_paths.txt \
                /tmp/prev_skill_paths.txt /tmp/prev_entry_files.txt /tmp/common_skills.txt
          
          # Collect commit messages for infrastructure changes
          INFRA_CHANGES=""
          while IFS= read -r line; do
            [ -z "$line" ] && continue
            MSG=$(echo "$line" | cut -d' ' -f2-)
            
            if echo "$MSG" | grep -qE "^(feat|fix|chore|docs|refactor|perf|ci):"; then
              if [ -z "$INFRA_CHANGES" ]; then
                INFRA_CHANGES="$MSG"
              else
                INFRA_CHANGES="${INFRA_CHANGES}|$MSG"
              fi
            fi
          done < <(git log --oneline $RANGE 2>/dev/null || git log --oneline)
          
          {
            echo "release_date=$TODAY"
            echo "skill_count=$SKILL_COUNT"
            echo "added_skills=$ADDED_SKILLS"
            echo "added_count=$ADDED_COUNT"
            echo "updated_skills=$UPDATED_PLUGINS"
            echo "updated_count=$UPDATED_COUNT"
            echo "removed_count=$REMOVED_COUNT"
            echo "infra_changes=$INFRA_CHANGES"
          } >> $GITHUB_OUTPUT
          
          echo "Found: $ADDED_COUNT new, $UPDATED_COUNT updated, $REMOVED_COUNT removed"
          echo "Total skills: $SKILL_COUNT"

      - name: Generate AI summary
        id: ai_summary
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          ADDED_SKILLS="${{ steps.changelog.outputs.added_skills }}"
          ADDED_COUNT="${{ steps.changelog.outputs.added_count }}"
          SKILL_COUNT="${{ steps.changelog.outputs.skill_count }}"
          INFRA_CHANGES="${{ steps.changelog.outputs.infra_changes }}"
          
          CONTEXT="Version: v${VERSION}
          Total skills: ${SKILL_COUNT}
          New skills (${ADDED_COUNT}): ${ADDED_SKILLS}
          Recent changes: ${INFRA_CHANGES}"
          
          PROMPT="Generate a concise 1-2 sentence release summary for AI Skillstore marketplace v${VERSION}.
          
          Context:
          ${CONTEXT}
          
          Focus on value to users. Be professional, not marketing-speak. Output only the summary text, no quotes."
          
          # Try codex CLI (available on self-hosted runner)
          RESPONSE=$(echo "$PROMPT" | timeout 30 codex exec --skip-git-repo-check --sandbox read-only \
            -m gpt-5.2 \
            -c 'model_reasoning_effort="medium"' \
            2>/dev/null || echo "")
          
          if [ -z "$RESPONSE" ]; then
            # Fallback summary
            if [ "$ADDED_COUNT" -gt 0 ]; then
              RESPONSE="Marketplace update with ${ADDED_COUNT} new skills. Total ${SKILL_COUNT} skills available."
            else
              RESPONSE="Marketplace v${VERSION} with ${SKILL_COUNT} skills and infrastructure improvements."
            fi
          fi
          
          # Escape double quotes AND backticks (backticks cause command substitution in bash)
          ESCAPED=$(echo "$RESPONSE" | tr '\n' ' ' | sed 's/"/\\"/g' | sed 's/`/'"'"'/g')
          echo "summary=$ESCAPED" >> $GITHUB_OUTPUT
          echo "AI Summary: $ESCAPED"

      - name: Update CHANGELOG.md
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TODAY="${{ steps.changelog.outputs.release_date }}"
          SKILL_COUNT="${{ steps.changelog.outputs.skill_count }}"
          ADDED_SKILLS="${{ steps.changelog.outputs.added_skills }}"
          ADDED_COUNT="${{ steps.changelog.outputs.added_count }}"
          UPDATED_COUNT="${{ steps.changelog.outputs.updated_count }}"
          INFRA_CHANGES="${{ steps.changelog.outputs.infra_changes }}"
          SUMMARY="${{ steps.ai_summary.outputs.summary }}"
          
          # Build changelog entry
          ENTRY="## [${VERSION}] - ${TODAY}\n\n"
          ENTRY+="### Summary\n\n${SUMMARY}\n\n"
          ENTRY+="### Statistics\n\n"
          ENTRY+="- Total skills: ${SKILL_COUNT}\n"
          ENTRY+="- New skills: ${ADDED_COUNT}\n"
          ENTRY+="- Updated skills: ${UPDATED_COUNT}\n\n"
          
          if [ -n "$ADDED_SKILLS" ] && [ "$ADDED_SKILLS" != "" ]; then
            ENTRY+="### New Plugins\n\n"
            IFS=',' read -ra PLUGINS <<< "$ADDED_SKILLS"
            for p in "${PLUGINS[@]}"; do
              [ -n "$p" ] && ENTRY+="- \`${p}\`\n"
            done
            ENTRY+="\n"
          fi
          
          if [ -n "$INFRA_CHANGES" ] && [ "$INFRA_CHANGES" != "" ]; then
            ENTRY+="### Changes\n\n"
            IFS='|' read -ra CHANGES <<< "$INFRA_CHANGES"
            for c in "${CHANGES[@]}"; do
              [ -n "$c" ] && ENTRY+="- ${c}\n"
            done
            ENTRY+="\n"
          fi
          
          # Create CHANGELOG if not exists
          if [ ! -f CHANGELOG.md ]; then
            cat > CHANGELOG.md << 'HEADER'
          # Changelog
          
          All notable changes to the AI Skillstore marketplace will be documented in this file.
          
          The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
          and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
          
          HEADER
          fi
          
          # Insert new entry after header
          HEADER_END=$(grep -n "^## \[" CHANGELOG.md | head -1 | cut -d: -f1 || echo "")
          
          if [ -z "$HEADER_END" ]; then
            echo -e "\n$ENTRY" >> CHANGELOG.md
          else
            {
              head -n $((HEADER_END - 1)) CHANGELOG.md
              echo ""
              echo -e "$ENTRY"
              tail -n +$HEADER_END CHANGELOG.md
            } > /tmp/CHANGELOG.md
            mv /tmp/CHANGELOG.md CHANGELOG.md
          fi
          
          echo "Updated CHANGELOG.md"

      - name: Commit version updates (isolated temp directory)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          
          VERSION="${{ steps.version.outputs.version }}"
          
          # Use temp directory for clean git operations
          # This eliminates state pollution from self-hosted runners (leftover rebase-merge, index.lock, etc.)
          WORK_DIR="/tmp/marketplace-release-${{ github.run_id }}"
          
          cleanup() {
            echo "ðŸ§¹ Cleaning up temp directory..."
            rm -rf "$WORK_DIR" 2>/dev/null || true
          }
          trap cleanup EXIT
          
          echo "ðŸ“¦ Cloning fresh repository to $WORK_DIR..."
          git clone --depth 1 "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" "$WORK_DIR"
          
          # Copy updated files from checkout to fresh clone
          cp CHANGELOG.md "$WORK_DIR/CHANGELOG.md"

          cd "$WORK_DIR"

          git config user.name "ai-skill-store[bot]"
          git config user.email "2628292+ai-skill-store[bot]@users.noreply.github.com"

          git add CHANGELOG.md
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "release: v${VERSION}"
            
            # Push with retry logic for race conditions
            for i in 1 2 3; do
              if git push origin main; then
                echo "âœ… Committed version updates to main"
                break
              fi
              echo "Push failed, pulling and retrying ($i/3)..."
              git pull --rebase origin main || {
                git rebase --abort 2>/dev/null || true
                git reset --hard origin/main
                git cherry-pick HEAD@{1} || true
              }
              sleep 2
            done
          fi

      - name: Build release notes
        id: release_notes
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="${{ steps.version.outputs.tag }}"
          PREV_TAG="${{ steps.prev_tag.outputs.tag }}"
          SKILL_COUNT="${{ steps.changelog.outputs.skill_count }}"
          ADDED_SKILLS="${{ steps.changelog.outputs.added_skills }}"
          ADDED_COUNT="${{ steps.changelog.outputs.added_count }}"
          UPDATED_COUNT="${{ steps.changelog.outputs.updated_count }}"
          REMOVED_COUNT="${{ steps.changelog.outputs.removed_count }}"
          INFRA_CHANGES="${{ steps.changelog.outputs.infra_changes }}"
          SUMMARY="${{ steps.ai_summary.outputs.summary }}"
          
          cat > /tmp/release_notes.md << EOF
          ${SUMMARY}
          
          ## Quick Install
          
          \`\`\`bash
          /skill marketplace add aiskillstore/marketplace
          \`\`\`
          
          ## Statistics
          
          | Metric | Count |
          |--------|-------|
          | Total Skills | ${SKILL_COUNT} |
          | New Plugins | ${ADDED_COUNT} |
          | Updated Plugins | ${UPDATED_COUNT} |
          | Removed Plugins | ${REMOVED_COUNT} |
          
          EOF
          
          if [ -n "$ADDED_SKILLS" ] && [ "$ADDED_SKILLS" != "" ]; then
            echo "## New Plugins" >> /tmp/release_notes.md
            echo "" >> /tmp/release_notes.md
            IFS=',' read -ra PLUGINS <<< "$ADDED_SKILLS"
            for p in "${PLUGINS[@]}"; do
              [ -n "$p" ] && echo "- \`${p}\`" >> /tmp/release_notes.md
            done
            echo "" >> /tmp/release_notes.md
          fi
          
          if [ -n "$INFRA_CHANGES" ] && [ "$INFRA_CHANGES" != "" ]; then
            echo "## Changes" >> /tmp/release_notes.md
            echo "" >> /tmp/release_notes.md
            IFS='|' read -ra CHANGES <<< "$INFRA_CHANGES"
            for c in "${CHANGES[@]}"; do
              [ -n "$c" ] && echo "- ${c}" >> /tmp/release_notes.md
            done
            echo "" >> /tmp/release_notes.md
          fi
          
          cat >> /tmp/release_notes.md << EOF
          ---
          
          **Full Changelog**: $([ -n "$PREV_TAG" ] && echo "https://github.com/${{ github.repository }}/compare/${PREV_TAG}...${TAG}" || echo "https://github.com/${{ github.repository }}/commits/${TAG}")
          EOF

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          IS_PRERELEASE="${{ steps.version.outputs.is_prerelease }}"
          
          PRERELEASE_FLAG=""
          if [ "$IS_PRERELEASE" = "true" ]; then
            PRERELEASE_FLAG="--prerelease"
          fi
          
          gh release create "$TAG" \
            --title "$TAG" \
            --notes-file /tmp/release_notes.md \
            --latest \
            $PRERELEASE_FLAG
          
          echo "Created release: $TAG"

      - name: Summary
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          echo "## Release Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: v${VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "- **Plugins**: ${{ steps.changelog.outputs.skill_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- **New**: ${{ steps.changelog.outputs.added_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- **URL**: https://github.com/${{ github.repository }}/releases/tag/v${VERSION}" >> $GITHUB_STEP_SUMMARY

  sync-to-supabase:
    needs: release
    runs-on: self-hosted
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'

      - name: Install dependencies
        run: npm install @supabase/supabase-js

      - name: Sync release to Supabase
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          node << 'EOF'
          const { createClient } = require('@supabase/supabase-js');

          const supabase = createClient(
            process.env.SUPABASE_URL,
            process.env.SUPABASE_SERVICE_KEY
          );

          async function syncRelease() {
            const version = '${{ needs.release.outputs.version }}';
            const tag = '${{ needs.release.outputs.tag }}';
            const releaseDate = '${{ needs.release.outputs.release_date }}';
            const skillCount = parseInt('${{ needs.release.outputs.skill_count }}', 10) || 0;
            const addedCount = parseInt('${{ needs.release.outputs.added_count }}', 10) || 0;
            const updatedCount = parseInt('${{ needs.release.outputs.updated_count }}', 10) || 0;
            const removedCount = parseInt('${{ needs.release.outputs.removed_count }}', 10) || 0;
            const addedPlugins = '${{ needs.release.outputs.added_skills }}'.split(',').filter(Boolean);
            const updatedPlugins = '${{ needs.release.outputs.updated_skills }}'.split(',').filter(Boolean);
            const infraChanges = '${{ needs.release.outputs.infra_changes }}'.split('|').filter(Boolean);
            const aiSummary = `${{ needs.release.outputs.ai_summary }}`;

            const changelog = {
              added_skills: addedPlugins,
              updated_skills: updatedPlugins,
              removed_skills: [],
              infrastructure_changes: infraChanges
            };

            console.log('Syncing release to Supabase...');
            console.log(`  Tag: ${tag}`);
            console.log(`  Version: ${version}`);
            console.log(`  Plugins: ${skillCount}`);
            console.log(`  Added: ${addedCount}`);
            console.log(`  Updated: ${updatedCount}`);
            console.log(`  Removed: ${removedCount}`);

            // Mark previous releases as not latest
            const { error: updateError } = await supabase
              .schema('skillstore')
              .from('releases')
              .update({ is_latest: false })
              .eq('is_latest', true);

            if (updateError) {
              console.warn('Warning: Failed to update previous releases:', updateError.message);
            }

            // Upsert new release
            const record = {
              tag: tag,
              version: version,
              release_date: releaseDate,
              skill_count: skillCount,
              summary: aiSummary || `Marketplace ${tag}`,
              changelog: changelog,
              added_count: addedCount,
              updated_count: updatedCount,
              removed_count: removedCount,
              is_latest: true
            };

            const { error } = await supabase
              .schema('skillstore')
              .from('releases')
              .upsert(record, { 
                onConflict: 'tag',
                ignoreDuplicates: false 
              });

            if (error) {
              console.error('Error syncing to Supabase:', error.message);
              process.exit(1);
            }

            console.log(`Successfully synced ${tag} to Supabase`);
          }

          syncRelease().catch(err => {
            console.error('Sync failed:', err);
            process.exit(1);
          });
          EOF

      - name: Trigger Cloudflare Pages deployment
        run: |
          echo "Triggering Cloudflare Pages deployment for skillstore.io..."
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X POST "${{ secrets.CLOUDFLARE_DEPLOY_HOOK }}")
          if [ "$HTTP_STATUS" -eq 200 ]; then
            echo "âœ… Deployment triggered successfully"
          else
            echo "âš ï¸ Unexpected response: HTTP $HTTP_STATUS"
            exit 1
          fi

      - name: Summary
        run: |
          echo "## Sync & Deploy Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Supabase**: Release **${{ needs.release.outputs.tag }}** synced" >> $GITHUB_STEP_SUMMARY
          echo "- **Cloudflare**: skillstore.io deployment triggered" >> $GITHUB_STEP_SUMMARY
