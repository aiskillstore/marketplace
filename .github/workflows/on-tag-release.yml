name: Release

on:
  push:
    tags:
      - 'v*'

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  release:
    runs-on: self-hosted
    permissions:
      contents: write
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      release_date: ${{ steps.changelog.outputs.release_date }}
      plugin_count: ${{ steps.changelog.outputs.plugin_count }}
      added_plugins: ${{ steps.changelog.outputs.added_plugins }}
      added_count: ${{ steps.changelog.outputs.added_count }}
      updated_plugins: ${{ steps.changelog.outputs.updated_plugins }}
      updated_count: ${{ steps.changelog.outputs.updated_count }}
      removed_count: ${{ steps.changelog.outputs.removed_count }}
      infra_changes: ${{ steps.changelog.outputs.infra_changes }}
      ai_summary: ${{ steps.ai_summary.outputs.summary }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Extract and validate version
        id: version
        run: |
          TAG="${GITHUB_REF#refs/tags/}"
          VERSION="${TAG#v}"
          
          # Validate SemVer format (with optional pre-release)
          if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$ ]]; then
            echo "::error::Invalid version format: $VERSION (expected SemVer like 1.2.3 or 1.2.3-beta.1)"
            exit 1
          fi
          
          # Check if this is a pre-release
          if [[ "$VERSION" =~ - ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
          fi
          
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Releasing: $TAG (version $VERSION)"

      - name: Get previous tag
        id: prev_tag
        run: |
          CURRENT_TAG="${{ steps.version.outputs.tag }}"
          PREV_TAG=$(git tag --sort=-version:refname | grep -v "^${CURRENT_TAG}$" | head -1 || echo "")
          echo "tag=$PREV_TAG" >> $GITHUB_OUTPUT
          if [ -n "$PREV_TAG" ]; then
            echo "Previous tag: $PREV_TAG"
          else
            echo "No previous tags found (first release)"
          fi

      - name: Sync marketplace.json from plugins directory
        id: sync_marketplace
        run: |
          echo "Syncing marketplace.json from plugins/ directory..."

          # Build plugins array from plugins/ directory
          PLUGINS_JSON="[]"
          while IFS= read -r entry_file; do
            [ -z "$entry_file" ] && continue

            # Read plugin metadata
            name=$(jq -r '.name // empty' "$entry_file" 2>/dev/null)
            [ -z "$name" ] && continue

            dir=$(dirname "$entry_file")
            description=$(jq -r '.description // ""' "$entry_file" 2>/dev/null)
            version=$(jq -r '.version // "1.0.0"' "$entry_file" 2>/dev/null)

            # Build plugin entry
            PLUGIN_ENTRY=$(jq -n \
              --arg name "$name" \
              --arg description "$description" \
              --arg version "$version" \
              --arg source "./$dir" \
              '{name: $name, description: $description, version: $version, source: $source}')

            PLUGINS_JSON=$(echo "$PLUGINS_JSON" | jq --argjson plugin "$PLUGIN_ENTRY" '. + [$plugin]')
          done < <(find plugins -name "marketplace-entry.json" 2>/dev/null | sort)

          # Sort plugins by name
          PLUGINS_JSON=$(echo "$PLUGINS_JSON" | jq 'sort_by(.name)')
          PLUGIN_COUNT=$(echo "$PLUGINS_JSON" | jq 'length')

          # Update marketplace.json with synced plugins
          jq --argjson plugins "$PLUGINS_JSON" '.plugins = $plugins' \
            .claude-plugin/marketplace.json > /tmp/marketplace_synced.json
          mv /tmp/marketplace_synced.json .claude-plugin/marketplace.json

          echo "Synced $PLUGIN_COUNT plugins to marketplace.json"
          echo "plugin_count=$PLUGIN_COUNT" >> $GITHUB_OUTPUT

      - name: Analyze changes since last release
        id: changelog
        env:
          PREV_TAG: ${{ steps.prev_tag.outputs.tag }}
          CURRENT_TAG: ${{ steps.version.outputs.tag }}
        run: |
          TODAY=$(date +%Y-%m-%d)

          if [ -n "$PREV_TAG" ]; then
            RANGE="${PREV_TAG}..${CURRENT_TAG}"
          else
            RANGE="${CURRENT_TAG}"
          fi

          echo "Analyzing commits in range: $RANGE"

          # Get current plugins from synced marketplace.json
          CURRENT_PLUGINS=$(jq -r '.plugins[].name' .claude-plugin/marketplace.json 2>/dev/null | sort)
          PLUGIN_COUNT=$(echo "$CURRENT_PLUGINS" | grep -c . || echo "0")

          # Get current plugin data for path lookups
          CURRENT_PLUGIN_DATA=""
          while IFS= read -r line; do
            [ -z "$line" ] && continue
            name=$(echo "$line" | jq -r '.name')
            source=$(echo "$line" | jq -r '.source' | sed 's|^\./||')
            CURRENT_PLUGIN_DATA="${CURRENT_PLUGIN_DATA}${name}|${source}"$'\n'
          done < <(jq -c '.plugins[]' .claude-plugin/marketplace.json 2>/dev/null)

          # Get previous plugins by scanning plugins/ directory at PREV_TAG
          # This ensures consistent comparison (both from actual plugin files)
          PREV_PLUGINS=""
          if [ -n "$PREV_TAG" ]; then
            echo "Scanning plugins at ${PREV_TAG}..."
            while IFS= read -r file; do
              [ -z "$file" ] && continue
              name=$(git show "${PREV_TAG}:${file}" 2>/dev/null | jq -r '.name // empty' 2>/dev/null)
              [ -n "$name" ] && PREV_PLUGINS="${PREV_PLUGINS}${name}"$'\n'
            done < <(git ls-tree -r "${PREV_TAG}" --name-only 2>/dev/null | grep "marketplace-entry.json" || true)
            PREV_PLUGINS=$(echo "$PREV_PLUGINS" | sort | grep -v '^$')
          fi

          PREV_COUNT=$(echo "$PREV_PLUGINS" | grep -c . 2>/dev/null || echo "0")
          echo "Previous tag had $PREV_COUNT plugins"
          
          # Calculate added plugins
          ADDED_PLUGINS=""
          ADDED_COUNT=0
          
          for plugin in $CURRENT_PLUGINS; do
            if ! echo "$PREV_PLUGINS" | grep -qx "$plugin"; then
              if [ -z "$ADDED_PLUGINS" ]; then
                ADDED_PLUGINS="$plugin"
              else
                ADDED_PLUGINS="${ADDED_PLUGINS},$plugin"
              fi
              ADDED_COUNT=$((ADDED_COUNT + 1))
            fi
          done
          
          # Calculate removed plugins
          REMOVED_COUNT=0
          for plugin in $PREV_PLUGINS; do
            [ -z "$plugin" ] && continue
            if ! echo "$CURRENT_PLUGINS" | grep -qx "$plugin"; then
              REMOVED_COUNT=$((REMOVED_COUNT + 1))
            fi
          done
          
          # Calculate updated plugins (exist in both tags, but content changed)
          # Uses git tree hash comparison for efficiency
          UPDATED_PLUGINS=""
          UPDATED_COUNT=0

          if [ -n "$PREV_TAG" ]; then
            while IFS='|' read -r name curr_path; do
              [ -z "$name" ] && continue

              # Skip if not in previous plugins (it's ADDED, not UPDATED)
              if ! echo "$PREV_PLUGINS" | grep -qx "$name"; then
                continue
              fi

              # Find previous path by searching for the plugin's marketplace-entry.json at PREV_TAG
              prev_path=$(git ls-tree -r "${PREV_TAG}" --name-only 2>/dev/null | \
                grep "marketplace-entry.json" | \
                while read -r file; do
                  pname=$(git show "${PREV_TAG}:${file}" 2>/dev/null | jq -r '.name // empty' 2>/dev/null)
                  if [ "$pname" = "$name" ]; then
                    dirname "$file"
                    break
                  fi
                done)

              [ -z "$prev_path" ] && continue

              # Compare git tree hashes
              prev_hash=$(git rev-parse "${PREV_TAG}:${prev_path}" 2>/dev/null || echo "")
              curr_hash=$(git rev-parse "HEAD:${curr_path}" 2>/dev/null || echo "")

              if [ -n "$prev_hash" ] && [ -n "$curr_hash" ] && [ "$prev_hash" != "$curr_hash" ]; then
                if [ -z "$UPDATED_PLUGINS" ]; then
                  UPDATED_PLUGINS="$name"
                else
                  UPDATED_PLUGINS="${UPDATED_PLUGINS},$name"
                fi
                UPDATED_COUNT=$((UPDATED_COUNT + 1))
                echo "  Updated: $name (hash changed)"
              fi
            done <<< "$CURRENT_PLUGIN_DATA"
          fi
          
          # Collect commit messages for infrastructure changes
          INFRA_CHANGES=""
          while IFS= read -r line; do
            [ -z "$line" ] && continue
            MSG=$(echo "$line" | cut -d' ' -f2-)
            
            if echo "$MSG" | grep -qE "^(feat|fix|chore|docs|refactor|perf|ci):"; then
              if [ -z "$INFRA_CHANGES" ]; then
                INFRA_CHANGES="$MSG"
              else
                INFRA_CHANGES="${INFRA_CHANGES}|$MSG"
              fi
            fi
          done < <(git log --oneline $RANGE 2>/dev/null || git log --oneline)
          
          {
            echo "release_date=$TODAY"
            echo "plugin_count=$PLUGIN_COUNT"
            echo "added_plugins=$ADDED_PLUGINS"
            echo "added_count=$ADDED_COUNT"
            echo "updated_plugins=$UPDATED_PLUGINS"
            echo "updated_count=$UPDATED_COUNT"
            echo "removed_count=$REMOVED_COUNT"
            echo "infra_changes=$INFRA_CHANGES"
          } >> $GITHUB_OUTPUT
          
          echo "Found: $ADDED_COUNT new, $UPDATED_COUNT updated, $REMOVED_COUNT removed"
          echo "Total plugins: $PLUGIN_COUNT"

      - name: Generate AI summary
        id: ai_summary
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          ADDED_PLUGINS="${{ steps.changelog.outputs.added_plugins }}"
          ADDED_COUNT="${{ steps.changelog.outputs.added_count }}"
          PLUGIN_COUNT="${{ steps.changelog.outputs.plugin_count }}"
          INFRA_CHANGES="${{ steps.changelog.outputs.infra_changes }}"
          
          CONTEXT="Version: v${VERSION}
          Total plugins: ${PLUGIN_COUNT}
          New plugins (${ADDED_COUNT}): ${ADDED_PLUGINS}
          Recent changes: ${INFRA_CHANGES}"
          
          PROMPT="Generate a concise 1-2 sentence release summary for AI Skillstore marketplace v${VERSION}.
          
          Context:
          ${CONTEXT}
          
          Focus on value to users. Be professional, not marketing-speak. Output only the summary text, no quotes."
          
          # Try codex CLI (available on self-hosted runner)
          RESPONSE=$(echo "$PROMPT" | timeout 30 codex exec --skip-git-repo-check --sandbox read-only \
            -m gpt-5.2 \
            -c 'model_reasoning_effort="medium"' \
            2>/dev/null || echo "")
          
          if [ -z "$RESPONSE" ]; then
            # Fallback summary
            if [ "$ADDED_COUNT" -gt 0 ]; then
              RESPONSE="Marketplace update with ${ADDED_COUNT} new plugins. Total ${PLUGIN_COUNT} plugins available."
            else
              RESPONSE="Marketplace v${VERSION} with ${PLUGIN_COUNT} plugins and infrastructure improvements."
            fi
          fi
          
          # Escape double quotes AND backticks (backticks cause command substitution in bash)
          ESCAPED=$(echo "$RESPONSE" | tr '\n' ' ' | sed 's/"/\\"/g' | sed 's/`/'"'"'/g')
          echo "summary=$ESCAPED" >> $GITHUB_OUTPUT
          echo "AI Summary: $ESCAPED"

      - name: Update marketplace.json version
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          
          jq --arg version "$VERSION" \
            '.metadata.version = $version' \
            .claude-plugin/marketplace.json > /tmp/marketplace.json
          mv /tmp/marketplace.json .claude-plugin/marketplace.json
          
          echo "Updated marketplace.json to version $VERSION"

      - name: Update CHANGELOG.md
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TODAY="${{ steps.changelog.outputs.release_date }}"
          PLUGIN_COUNT="${{ steps.changelog.outputs.plugin_count }}"
          ADDED_PLUGINS="${{ steps.changelog.outputs.added_plugins }}"
          ADDED_COUNT="${{ steps.changelog.outputs.added_count }}"
          UPDATED_COUNT="${{ steps.changelog.outputs.updated_count }}"
          INFRA_CHANGES="${{ steps.changelog.outputs.infra_changes }}"
          SUMMARY="${{ steps.ai_summary.outputs.summary }}"
          
          # Build changelog entry
          ENTRY="## [${VERSION}] - ${TODAY}\n\n"
          ENTRY+="### Summary\n\n${SUMMARY}\n\n"
          ENTRY+="### Statistics\n\n"
          ENTRY+="- Total plugins: ${PLUGIN_COUNT}\n"
          ENTRY+="- New plugins: ${ADDED_COUNT}\n"
          ENTRY+="- Updated plugins: ${UPDATED_COUNT}\n\n"
          
          if [ -n "$ADDED_PLUGINS" ] && [ "$ADDED_PLUGINS" != "" ]; then
            ENTRY+="### New Plugins\n\n"
            IFS=',' read -ra PLUGINS <<< "$ADDED_PLUGINS"
            for p in "${PLUGINS[@]}"; do
              [ -n "$p" ] && ENTRY+="- \`${p}\`\n"
            done
            ENTRY+="\n"
          fi
          
          if [ -n "$INFRA_CHANGES" ] && [ "$INFRA_CHANGES" != "" ]; then
            ENTRY+="### Changes\n\n"
            IFS='|' read -ra CHANGES <<< "$INFRA_CHANGES"
            for c in "${CHANGES[@]}"; do
              [ -n "$c" ] && ENTRY+="- ${c}\n"
            done
            ENTRY+="\n"
          fi
          
          # Create CHANGELOG if not exists
          if [ ! -f CHANGELOG.md ]; then
            cat > CHANGELOG.md << 'HEADER'
          # Changelog
          
          All notable changes to the AI Skillstore marketplace will be documented in this file.
          
          The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
          and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
          
          HEADER
          fi
          
          # Insert new entry after header
          HEADER_END=$(grep -n "^## \[" CHANGELOG.md | head -1 | cut -d: -f1 || echo "")
          
          if [ -z "$HEADER_END" ]; then
            echo -e "\n$ENTRY" >> CHANGELOG.md
          else
            {
              head -n $((HEADER_END - 1)) CHANGELOG.md
              echo ""
              echo -e "$ENTRY"
              tail -n +$HEADER_END CHANGELOG.md
            } > /tmp/CHANGELOG.md
            mv /tmp/CHANGELOG.md CHANGELOG.md
          fi
          
          echo "Updated CHANGELOG.md"

      - name: Commit version updates (isolated temp directory)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          
          VERSION="${{ steps.version.outputs.version }}"
          
          # Use temp directory for clean git operations
          # This eliminates state pollution from self-hosted runners (leftover rebase-merge, index.lock, etc.)
          WORK_DIR="/tmp/marketplace-release-${{ github.run_id }}"
          
          cleanup() {
            echo "ðŸ§¹ Cleaning up temp directory..."
            rm -rf "$WORK_DIR" 2>/dev/null || true
          }
          trap cleanup EXIT
          
          echo "ðŸ“¦ Cloning fresh repository to $WORK_DIR..."
          git clone --depth 1 "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" "$WORK_DIR"
          
          # Copy updated files from checkout to fresh clone
          cp .claude-plugin/marketplace.json "$WORK_DIR/.claude-plugin/marketplace.json"
          cp CHANGELOG.md "$WORK_DIR/CHANGELOG.md"
          
          cd "$WORK_DIR"
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add .claude-plugin/marketplace.json CHANGELOG.md
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "release: v${VERSION}"
            
            # Push with retry logic for race conditions
            for i in 1 2 3; do
              if git push origin main; then
                echo "âœ… Committed version updates to main"
                break
              fi
              echo "Push failed, pulling and retrying ($i/3)..."
              git pull --rebase origin main || {
                git rebase --abort 2>/dev/null || true
                git reset --hard origin/main
                git cherry-pick HEAD@{1} || true
              }
              sleep 2
            done
          fi

      - name: Build release notes
        id: release_notes
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="${{ steps.version.outputs.tag }}"
          PREV_TAG="${{ steps.prev_tag.outputs.tag }}"
          PLUGIN_COUNT="${{ steps.changelog.outputs.plugin_count }}"
          ADDED_PLUGINS="${{ steps.changelog.outputs.added_plugins }}"
          ADDED_COUNT="${{ steps.changelog.outputs.added_count }}"
          UPDATED_COUNT="${{ steps.changelog.outputs.updated_count }}"
          REMOVED_COUNT="${{ steps.changelog.outputs.removed_count }}"
          INFRA_CHANGES="${{ steps.changelog.outputs.infra_changes }}"
          SUMMARY="${{ steps.ai_summary.outputs.summary }}"
          
          cat > /tmp/release_notes.md << EOF
          ${SUMMARY}
          
          ## Quick Install
          
          \`\`\`bash
          /plugin marketplace add aiskillstore/marketplace
          \`\`\`
          
          ## Statistics
          
          | Metric | Count |
          |--------|-------|
          | Total Plugins | ${PLUGIN_COUNT} |
          | New Plugins | ${ADDED_COUNT} |
          | Updated Plugins | ${UPDATED_COUNT} |
          | Removed Plugins | ${REMOVED_COUNT} |
          
          EOF
          
          if [ -n "$ADDED_PLUGINS" ] && [ "$ADDED_PLUGINS" != "" ]; then
            echo "## New Plugins" >> /tmp/release_notes.md
            echo "" >> /tmp/release_notes.md
            IFS=',' read -ra PLUGINS <<< "$ADDED_PLUGINS"
            for p in "${PLUGINS[@]}"; do
              [ -n "$p" ] && echo "- \`${p}\`" >> /tmp/release_notes.md
            done
            echo "" >> /tmp/release_notes.md
          fi
          
          if [ -n "$INFRA_CHANGES" ] && [ "$INFRA_CHANGES" != "" ]; then
            echo "## Changes" >> /tmp/release_notes.md
            echo "" >> /tmp/release_notes.md
            IFS='|' read -ra CHANGES <<< "$INFRA_CHANGES"
            for c in "${CHANGES[@]}"; do
              [ -n "$c" ] && echo "- ${c}" >> /tmp/release_notes.md
            done
            echo "" >> /tmp/release_notes.md
          fi
          
          cat >> /tmp/release_notes.md << EOF
          ---
          
          **Full Changelog**: $([ -n "$PREV_TAG" ] && echo "https://github.com/${{ github.repository }}/compare/${PREV_TAG}...${TAG}" || echo "https://github.com/${{ github.repository }}/commits/${TAG}")
          EOF

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          IS_PRERELEASE="${{ steps.version.outputs.is_prerelease }}"
          
          PRERELEASE_FLAG=""
          if [ "$IS_PRERELEASE" = "true" ]; then
            PRERELEASE_FLAG="--prerelease"
          fi
          
          gh release create "$TAG" \
            --title "$TAG" \
            --notes-file /tmp/release_notes.md \
            --latest \
            $PRERELEASE_FLAG
          
          echo "Created release: $TAG"

      - name: Summary
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          echo "## Release Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: v${VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "- **Plugins**: ${{ steps.changelog.outputs.plugin_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- **New**: ${{ steps.changelog.outputs.added_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- **URL**: https://github.com/${{ github.repository }}/releases/tag/v${VERSION}" >> $GITHUB_STEP_SUMMARY

  sync-to-supabase:
    needs: release
    runs-on: self-hosted
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'

      - name: Install dependencies
        run: npm install @supabase/supabase-js

      - name: Sync release to Supabase
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          node << 'EOF'
          const { createClient } = require('@supabase/supabase-js');

          const supabase = createClient(
            process.env.SUPABASE_URL,
            process.env.SUPABASE_SERVICE_KEY
          );

          async function syncRelease() {
            const version = '${{ needs.release.outputs.version }}';
            const tag = '${{ needs.release.outputs.tag }}';
            const releaseDate = '${{ needs.release.outputs.release_date }}';
            const pluginCount = parseInt('${{ needs.release.outputs.plugin_count }}', 10) || 0;
            const addedCount = parseInt('${{ needs.release.outputs.added_count }}', 10) || 0;
            const updatedCount = parseInt('${{ needs.release.outputs.updated_count }}', 10) || 0;
            const removedCount = parseInt('${{ needs.release.outputs.removed_count }}', 10) || 0;
            const addedPlugins = '${{ needs.release.outputs.added_plugins }}'.split(',').filter(Boolean);
            const updatedPlugins = '${{ needs.release.outputs.updated_plugins }}'.split(',').filter(Boolean);
            const infraChanges = '${{ needs.release.outputs.infra_changes }}'.split('|').filter(Boolean);
            const aiSummary = `${{ needs.release.outputs.ai_summary }}`;

            const changelog = {
              added_plugins: addedPlugins,
              updated_plugins: updatedPlugins,
              removed_plugins: [],
              infrastructure_changes: infraChanges
            };

            console.log('Syncing release to Supabase...');
            console.log(`  Tag: ${tag}`);
            console.log(`  Version: ${version}`);
            console.log(`  Plugins: ${pluginCount}`);
            console.log(`  Added: ${addedCount}`);
            console.log(`  Updated: ${updatedCount}`);
            console.log(`  Removed: ${removedCount}`);

            // Mark previous releases as not latest
            const { error: updateError } = await supabase
              .schema('skillstore')
              .from('releases')
              .update({ is_latest: false })
              .eq('is_latest', true);

            if (updateError) {
              console.warn('Warning: Failed to update previous releases:', updateError.message);
            }

            // Upsert new release
            const record = {
              tag: tag,
              version: version,
              release_date: releaseDate,
              skill_count: pluginCount,
              summary: aiSummary || `Marketplace ${tag}`,
              changelog: changelog,
              added_count: addedCount,
              updated_count: updatedCount,
              removed_count: removedCount,
              is_latest: true
            };

            const { error } = await supabase
              .schema('skillstore')
              .from('releases')
              .upsert(record, { 
                onConflict: 'tag',
                ignoreDuplicates: false 
              });

            if (error) {
              console.error('Error syncing to Supabase:', error.message);
              process.exit(1);
            }

            console.log(`Successfully synced ${tag} to Supabase`);
          }

          syncRelease().catch(err => {
            console.error('Sync failed:', err);
            process.exit(1);
          });
          EOF

      - name: Trigger Cloudflare Pages deployment
        run: |
          echo "Triggering Cloudflare Pages deployment for skillstore.io..."
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X POST "${{ secrets.CLOUDFLARE_DEPLOY_HOOK }}")
          if [ "$HTTP_STATUS" -eq 200 ]; then
            echo "âœ… Deployment triggered successfully"
          else
            echo "âš ï¸ Unexpected response: HTTP $HTTP_STATUS"
            exit 1
          fi

      - name: Summary
        run: |
          echo "## Sync & Deploy Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Supabase**: Release **${{ needs.release.outputs.tag }}** synced" >> $GITHUB_STEP_SUMMARY
          echo "- **Cloudflare**: skillstore.io deployment triggered" >> $GITHUB_STEP_SUMMARY
