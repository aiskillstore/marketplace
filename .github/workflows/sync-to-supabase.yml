name: Sync to Supabase (Incremental)

on:
  push:
    branches: [main]
    paths:
      - 'plugins/**'
  workflow_dispatch:
    inputs:
      full_sync:
        description: 'Force full sync (ignore incremental)'
        type: boolean
        default: false

jobs:
  sync:
    runs-on: self-hosted
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install @supabase/supabase-js

      - name: Detect changed plugins
        id: changes
        run: |
          if [ "${{ inputs.full_sync }}" = "true" ]; then
            echo "Full sync requested"
            CHANGED=$(ls -1 plugins/ 2>/dev/null | tr '\n' ' ')
            echo "mode=full" >> $GITHUB_OUTPUT
          else
            CHANGED=$(git diff HEAD~1 --name-only 2>/dev/null | \
              grep '^plugins/' | \
              cut -d'/' -f2 | \
              sort -u | \
              tr '\n' ' ')
            echo "mode=incremental" >> $GITHUB_OUTPUT
          fi
          
          echo "changed_plugins=$CHANGED" >> $GITHUB_OUTPUT
          
          if [ -z "$CHANGED" ]; then
            echo "No plugins to sync"
            echo "skip_sync=true" >> $GITHUB_OUTPUT
          else
            echo "Plugins to sync: $CHANGED"
            echo "skip_sync=false" >> $GITHUB_OUTPUT
          fi

      - name: Sync plugins to Supabase
        if: steps.changes.outputs.skip_sync != 'true'
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
          CHANGED_PLUGINS: ${{ steps.changes.outputs.changed_plugins }}
          SYNC_MODE: ${{ steps.changes.outputs.mode }}
        run: |
          node << 'EOF'
          const { createClient } = require('@supabase/supabase-js');
          const fs = require('fs');
          const path = require('path');

          const supabase = createClient(
            process.env.SUPABASE_URL,
            process.env.SUPABASE_SERVICE_KEY
          );

          async function syncPlugins() {
            const changedPlugins = process.env.CHANGED_PLUGINS.trim().split(/\s+/).filter(Boolean);
            const mode = process.env.SYNC_MODE;
            
            console.log(`Sync mode: ${mode}`);
            console.log(`Syncing ${changedPlugins.length} plugin(s): ${changedPlugins.join(', ')}`);

            let synced = 0;
            let errors = 0;

            for (const slug of changedPlugins) {
              const pluginPath = `plugins/${slug}`;
              const reportPath = path.join(pluginPath, 'skill-report.json');
              const manifestPath = path.join(pluginPath, '.claude-plugin', 'plugin.json');
              const entryPath = path.join(pluginPath, 'marketplace-entry.json');

              if (!fs.existsSync(pluginPath)) {
                console.log(`Skipping ${slug}: directory not found`);
                continue;
              }

              let skillReport = null;
              let manifest = null;
              let entry = null;

              if (fs.existsSync(reportPath)) {
                skillReport = JSON.parse(fs.readFileSync(reportPath, 'utf8'));
              }
              if (fs.existsSync(manifestPath)) {
                manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
              }
              if (fs.existsSync(entryPath)) {
                entry = JSON.parse(fs.readFileSync(entryPath, 'utf8'));
              }

              if (!skillReport && !entry) {
                console.log(`Skipping ${slug}: no skill-report.json or marketplace-entry.json`);
                continue;
              }

              // Helper: Map security audit risk_level to skills table enum
              // skills.risk_level allows: low, medium, high
              // security_audit.risk_level allows: critical, high, medium, low, safe
              function mapRiskLevel(auditLevel) {
                const mapping = {
                  'safe': 'low',
                  'low': 'low', 
                  'medium': 'medium',
                  'high': 'high',
                  'critical': 'high'
                };
                return mapping[auditLevel] || 'low';
              }

              // ============================================================
              // 1. SYNC TO skills TABLE (main skill record)
              // ============================================================
              const skillRecord = {
                slug: slug,
                
                // Basic info - prefer skill-report, fallback to entry
                name: skillReport?.skill?.name || entry?.name || slug,
                canonical_name: slug,
                description: skillReport?.skill?.description || entry?.description || '',
                summary: skillReport?.skill?.summary || '',
                icon: skillReport?.skill?.icon || null,
                
                // Categorization - default to 'productivity' (must match skillstore.categories table)
                category: skillReport?.skill?.category || 'productivity',
                tags: skillReport?.skill?.tags || entry?.keywords || [],
                supported_tools: skillReport?.skill?.supported_tools || entry?.supported_tools || ['claude', 'codex', 'claude-code'],
                
                // Version & licensing
                version: skillReport?.skill?.version || entry?.version || '1.0.0',
                license: skillReport?.skill?.license || entry?.license || 'MIT',
                
                // Author info
                author_name: entry?.author?.name || skillReport?.skill?.author || 'Community',
                author_email: entry?.author?.email || null,
                
                // URLs & paths
                repository: entry?.repository || skillReport?.meta?.source_url || null,
                source_ref: skillReport?.meta?.source_ref || 'main',
                plugin_path: pluginPath,
                skill_report_url: `https://github.com/aiskillstore/marketplace/blob/main/${pluginPath}/skill-report.json`,
                homepage: `https://skillstore.io/skills/${slug}`,
                
                // File structure (from skill-report.json)
                file_structure: skillReport?.file_structure || null,
                
                // Language (default to English)
                language: 'en',
                
                // Marketplace source
                marketplace_source: 'aiskillstore',
                
                // Risk assessment (mapped from security audit)
                risk_level: mapRiskLevel(skillReport?.security_audit?.risk_level),
                risk_factors: skillReport?.skill?.risk_factors || [],
                
                // Publishing status
                status: 'approved',
                published_at: new Date().toISOString(),
                updated_at: new Date().toISOString(),
              };

              // Upsert skill record
              const { data: skillData, error: skillError } = await supabase
                .schema('skillstore')
                .from('skills')
                .upsert(skillRecord, { onConflict: 'slug' })
                .select('id')
                .single();

              if (skillError) {
                console.error(`Error syncing skill ${slug}: ${skillError.message}`);
                errors++;
                continue;
              }

              const skillId = skillData.id;
              console.log(`✅ Synced skill: ${slug} (id: ${skillId})`);

              // ============================================================
              // 2. SYNC TO skill_ai_content TABLE (rich AI-generated content)
              // ============================================================
              if (skillReport?.content) {
                const extraContent = {
                  meta: {
                    schema_version: skillReport.schema_version || null,
                    generated_at: skillReport.meta?.generated_at || null,
                    analysis_version: skillReport.meta?.analysis_version || null,
                    model: skillReport.meta?.model || null,
                    trust_level: skillReport.meta?.trust_level || null,
                  },
                };

                const aiContentRecord = {
                  skill_id: skillId,
                  
                  // Basic AI content
                  user_title: skillReport.content.user_title || '',
                  value_statement: skillReport.content.value_statement || '',
                  seo_keywords: skillReport.content.seo_keywords || [],
                  
                  // Structured content
                  use_cases: skillReport.content.use_cases || [],
                  prompt_templates: skillReport.content.prompt_templates || [],
                  output_examples: skillReport.content.output_examples || [],
                  faq: skillReport.content.faq || [],
                  
                  // Lists
                  best_practices: skillReport.content.best_practices || [],
                  anti_patterns: skillReport.content.anti_patterns || [],
                  actual_capabilities: skillReport.content.actual_capabilities || [],
                  limitations: skillReport.content.limitations || [],
                  
                  // Extra content (JSONB for display-only metadata)
                  extra_content: extraContent,
                  
                  // Versioning
                  content_version: 1,
                  updated_at: new Date().toISOString(),
                };

                const { error: aiError } = await supabase
                  .schema('skillstore')
                  .from('skill_ai_content')
                  .upsert(aiContentRecord, { onConflict: 'skill_id' });

                if (aiError) {
                  console.error(`  ⚠️ Error syncing AI content for ${slug}: ${aiError.message}`);
                } else {
                  console.log(`  ✅ Synced AI content for ${slug}`);
                }
              }

              // ============================================================
              // 3. SYNC TO skill_security_audit TABLE (security analysis)
              // ============================================================
              if (skillReport?.security_audit) {
                const audit = skillReport.security_audit;
                
                const auditRecord = {
                  skill_id: skillId,
                  version: 1,
                  
                  // Risk assessment
                  risk_level: audit.risk_level || 'low',
                  is_blocked: audit.is_blocked ?? false,
                  safe_to_publish: audit.safe_to_publish ?? true,
                  summary: audit.summary || '',
                  
                  // Findings by severity
                  critical_findings: audit.critical_findings || [],
                  high_findings: audit.high_findings || [],
                  medium_findings: audit.medium_findings || [],
                  low_findings: audit.low_findings || [],
                  
                  // Patterns detected
                  dangerous_patterns: audit.dangerous_patterns || [],
                  
                  // Metrics
                  files_scanned: audit.files_scanned || 0,
                  total_lines: audit.total_lines || 0,
                  
                  // Audit metadata
                  audit_model: audit.audit_model || 'claude',
                  audited_at: audit.audited_at || new Date().toISOString(),
                };

                // Delete existing audit and insert new one (simpler than upsert for this table)
                await supabase
                  .schema('skillstore')
                  .from('skill_security_audit')
                  .delete()
                  .eq('skill_id', skillId);

                const { error: auditError } = await supabase
                  .schema('skillstore')
                  .from('skill_security_audit')
                  .insert(auditRecord);

                if (auditError) {
                  console.error(`  ⚠️ Error syncing security audit for ${slug}: ${auditError.message}`);
                } else {
                  console.log(`  ✅ Synced security audit for ${slug}`);
                }
              }

              synced++;
            }

            console.log(`\n========================================`);
            console.log(`Sync complete: ${synced} synced, ${errors} errors`);
            console.log(`========================================`);
            
            if (errors > 0) {
              process.exit(1);
            }
          }

          syncPlugins().catch(err => {
            console.error('Sync failed:', err);
            process.exit(1);
          });
          EOF

      - name: Report sync status
        run: |
          echo "::notice::Sync completed - Mode: ${{ steps.changes.outputs.mode }}, Plugins: ${{ steps.changes.outputs.changed_plugins }}"
