name: On PR Merge - Approve Plugin

on:
  pull_request:
    types: [closed]
    branches: [main]

jobs:
  approve-plugin:
    if: github.event.pull_request.merged == true && contains(github.event.pull_request.labels.*.name, 'pending-review')
    runs-on: self-hosted
    steps:
      - name: Checkout repository (for pending plugins detection)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'

      - name: Find pending plugins to approve
        id: find_pending
        run: |
          PLUGIN_PATHS=""
          PLUGIN_NAMES=""
          
          for entry_file in $(find pending -name "marketplace-entry.json" 2>/dev/null); do
            PLUGIN_DIR=$(dirname "$entry_file")
            PLUGIN_PATHS="$PLUGIN_PATHS $PLUGIN_DIR"
            
            # Extract plugin name for commit message
            NAME=$(jq -r '.name' "$entry_file" 2>/dev/null || basename "$PLUGIN_DIR")
            PLUGIN_NAMES="$PLUGIN_NAMES /$NAME"
          done
          
          echo "plugin_paths=$PLUGIN_PATHS" >> $GITHUB_OUTPUT
          echo "plugin_names=$PLUGIN_NAMES" >> $GITHUB_OUTPUT
          echo "Found pending plugins:$PLUGIN_PATHS"

      - name: Process plugins and commit (isolated temp directory)
        if: steps.find_pending.outputs.plugin_paths != ''
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          set -euo pipefail
          
          # Use temp directory for clean git operations
          # This eliminates state pollution from self-hosted runners (leftover rebase-merge, index.lock, etc.)
          WORK_DIR="/tmp/marketplace-approve-${{ github.run_id }}"
          
          cleanup() {
            echo "üßπ Cleaning up temp directory..."
            rm -rf "$WORK_DIR" 2>/dev/null || true
          }
          trap cleanup EXIT
          
          echo "üì¶ Cloning fresh repository to $WORK_DIR..."
          git clone --depth 1 "https://x-access-token:${{ steps.app-token.outputs.token }}@github.com/${{ github.repository }}.git" "$WORK_DIR"
          cd "$WORK_DIR"

          git config user.name "ai-skill-store[bot]"
          git config user.email "2628292+ai-skill-store[bot]@users.noreply.github.com"
          
          echo "=== Moving plugins from pending to plugins ==="
          for PENDING_DIR in ${{ steps.find_pending.outputs.plugin_paths }}; do
            if [ -d "$PENDING_DIR" ] && [ -f "$PENDING_DIR/marketplace-entry.json" ]; then
              # Use 'source' field for directory path (e.g., "./plugins/payloadcms/payload")
              # 'name' field must stay hyphenated for plugin.json schema compliance
              SOURCE_PATH=$(jq -r '.source' "$PENDING_DIR/marketplace-entry.json")
              # Strip "./" prefix: "./plugins/payloadcms/payload" -> "plugins/payloadcms/payload"
              TARGET_DIR="${SOURCE_PATH#./}"
              
              echo "Moving $PENDING_DIR to $TARGET_DIR (source: $SOURCE_PATH)"
              
              mkdir -p "$(dirname "$TARGET_DIR")"
              
              if [ -d "$TARGET_DIR" ]; then
                rm -rf "$TARGET_DIR"
              fi
              
              mv "$PENDING_DIR" "$TARGET_DIR"
            fi
          done
          
          echo "=== Updating marketplace.json ==="
          # High-performance O(1) approach: single jq call to merge all new/updated plugins
          # Instead of O(n) file read/writes per plugin

          # Collect all new marketplace entries into NDJSON
          find plugins -name "marketplace-entry.json" -newer .claude-plugin/marketplace.json 2>/dev/null \
            | xargs -r cat > /tmp/new_entries.ndjson || true

          # If no newer files found, check if any entries exist at all (first run)
          if [ ! -s /tmp/new_entries.ndjson ]; then
            find plugins -name "marketplace-entry.json" 2>/dev/null \
              | xargs -r cat > /tmp/new_entries.ndjson || true
          fi

          if [ -s /tmp/new_entries.ndjson ]; then
            # Count entries for logging
            ENTRY_COUNT=$(wc -l < /tmp/new_entries.ndjson | tr -d ' ')
            echo "Processing $ENTRY_COUNT plugin entries..."

            # Single jq call: merge new entries with existing, handling both add and update
            # Uses reduce to upsert each new entry by name
            jq -s --slurpfile new /tmp/new_entries.ndjson '
              .[0] as $base |
              ($new | flatten) as $entries |
              $base | .plugins = (
                reduce $entries[] as $entry (
                  .plugins;
                  if any(.[]; .name == $entry.name)
                  then map(if .name == $entry.name then $entry else . end)
                  else . + [$entry]
                  end
                )
              )
            ' .claude-plugin/marketplace.json > /tmp/marketplace_merged.json

            mv /tmp/marketplace_merged.json .claude-plugin/marketplace.json
            rm -f /tmp/new_entries.ndjson
          fi

          echo "Updated marketplace.json:"
          jq '.plugins | length' .claude-plugin/marketplace.json
          
          echo "=== Committing and pushing ==="
          # Stage all changes including deletions from pending/
          git add -A
          
          # Remove empty pending directory
          if [ -d "pending" ] && [ -z "$(ls -A pending 2>/dev/null)" ]; then
            rmdir pending 2>/dev/null || true
            git add -A
          fi
          
          PLUGINS="${{ steps.find_pending.outputs.plugin_names }}"
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Approve plugins:$PLUGINS"
            
            # Push with retry for race conditions
            for i in 1 2 3; do
              if git push origin main; then
                echo "‚úÖ Successfully pushed to main"
                break
              fi
              echo "Push failed, pulling latest and retrying ($i/3)..."
              git pull --rebase origin main || {
                # If rebase fails, abort and retry with fresh state
                git rebase --abort 2>/dev/null || true
                git reset --hard origin/main
                git cherry-pick HEAD@{1} || true
              }
              sleep 2
            done
          fi

      - name: Extract submission ID from PR body
        id: extract_submission
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          # Extract submission ID from PR body: **Submission ID**: `UUID`
          # Use grep with PCRE or sed to extract UUID pattern
          SUBMISSION_ID=$(echo "$PR_BODY" | grep -oE 'Submission ID.*`[0-9a-f-]{36}`' | grep -oE '[0-9a-f-]{36}' || echo "")
          echo "submission_id=$SUBMISSION_ID" >> $GITHUB_OUTPUT
          if [ -n "$SUBMISSION_ID" ]; then
            echo "üìã Found submission ID: $SUBMISSION_ID"
          else
            echo "‚ö†Ô∏è No submission ID found in PR body"
          fi

      - name: Notify skillstore - Merged
        if: steps.extract_submission.outputs.submission_id != ''
        env:
          SUBMISSION_ID: ${{ steps.extract_submission.outputs.submission_id }}
          SKILLSTORE_API_URL: ${{ secrets.SKILLSTORE_API_URL }}
          SKILLSTORE_CALLBACK_TOKEN: ${{ secrets.SKILLSTORE_CALLBACK_TOKEN }}
          PR_URL: ${{ github.event.pull_request.html_url }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          MERGED_BY: ${{ github.event.pull_request.merged_by.login }}
        run: |
          echo "üì§ Notifying skillstore: submission $SUBMISSION_ID merged"
          curl -sS -X POST "$SKILLSTORE_API_URL/api/submit/callback" \
            -H "Authorization: Bearer $SKILLSTORE_CALLBACK_TOKEN" \
            -H "Content-Type: application/json" \
            -H "User-Agent: GitHub-Actions/SkillstoreBot" \
            -H "X-Skillstore-Callback: true" \
            -d '{
              "submission_id": "'"$SUBMISSION_ID"'",
              "event": "merged",
              "pr_url": "'"$PR_URL"'",
              "pr_number": '"$PR_NUMBER"',
              "merged_by": "'"$MERGED_BY"'",
              "workflow_run_id": ${{ github.run_id }},
              "workflow_run_url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }' || echo "::warning::Failed to notify skillstore"
