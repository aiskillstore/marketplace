{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-04T05:33:11.610Z",
    "slug": "wshobson-microservices-patterns",
    "source_url": "https://github.com/wshobson/agents/tree/main/plugins/backend-development/skills/microservices-patterns",
    "source_ref": "main",
    "model": "codex",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "fa4bfd6c9de32d3efbb2de99d46ac37d8c79da9acd10940ba4d5930f4c7b07de",
    "tree_hash": "2088d3501a9fce0d45e359c2661aaebe995fbf7c3e3f18d005f2cd8d3b5e9860"
  },
  "skill": {
    "name": "microservices-patterns",
    "description": "Design microservices architectures with service boundaries, event-driven communication, and resilience patterns. Use when building distributed systems, decomposing monoliths, or implementing microservices.",
    "summary": "Design microservices architectures with service boundaries, event-driven communication, and resilien...",
    "icon": "ðŸ§©",
    "version": "1.0.0",
    "author": "wshobson",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "microservices",
      "architecture",
      "distributed-systems",
      "resilience",
      "patterns"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Only documentation files are present. Network interactions appear only in example code blocks in SKILL.md. No executable scripts or data access were found.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 164,
            "line_end": 175
          },
          {
            "file": "SKILL.md",
            "line_start": 221,
            "line_end": 254
          },
          {
            "file": "SKILL.md",
            "line_start": 281,
            "line_end": 305
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 3,
    "total_lines": 785,
    "audit_model": "codex",
    "audited_at": "2026-01-04T05:33:11.610Z"
  },
  "content": {
    "user_title": "Design microservices patterns with confidence",
    "value_statement": "Teams struggle to define service boundaries and reliable communication. This skill provides clear patterns and examples for resilient microservices.",
    "seo_keywords": [
      "microservices patterns",
      "service decomposition",
      "event driven architecture",
      "API gateway",
      "saga pattern",
      "circuit breaker",
      "distributed systems",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Explain service decomposition by business capability, subdomains, and strangler fig",
      "Describe synchronous REST, gRPC, and GraphQL communication options",
      "Outline asynchronous messaging with Kafka, queues, and pub/sub",
      "Provide API gateway aggregation and circuit breaker examples",
      "Explain database per service and saga transaction patterns",
      "Describe resilience patterns such as retries, backoff, and bulkheads"
    ],
    "limitations": [
      "No runnable code or deployment automation",
      "No vendor specific cloud configuration or service discovery setup",
      "Examples are templates and require adaptation",
      "Does not assess your existing system architecture"
    ],
    "use_cases": [
      {
        "target_user": "Backend architect",
        "title": "Decompose a monolith",
        "description": "Identify bounded contexts, service ownership, and migration steps with the strangler pattern."
      },
      {
        "target_user": "Platform engineer",
        "title": "Design resilient calls",
        "description": "Choose retries, circuit breakers, and bulkheads for stable inter service communication."
      },
      {
        "target_user": "Product team lead",
        "title": "Plan event flows",
        "description": "Define events and consumers for order, payment, and inventory workflows."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic boundaries",
        "scenario": "Small team leaving a monolith",
        "prompt": "Propose microservice boundaries for an ecommerce monolith with orders, payments, and inventory. Include data ownership and contracts."
      },
      {
        "title": "Communication choice",
        "scenario": "Mix of sync and async needs",
        "prompt": "Recommend synchronous and asynchronous patterns for order creation, payment, and inventory reservation. Explain tradeoffs."
      },
      {
        "title": "Saga design",
        "scenario": "Distributed transaction flow",
        "prompt": "Design a saga for order fulfillment with steps, compensations, and failure handling. Use clear step names."
      },
      {
        "title": "Resilience review",
        "scenario": "High latency services in production",
        "prompt": "Suggest circuit breaker, retry, and bulkhead strategies for three services. Include thresholds and timeouts."
      }
    ],
    "output_examples": [
      {
        "input": "Design service boundaries and communication for a subscription platform",
        "output": [
          "Services: Billing, Subscription, Customer, Notification",
          "Events: SubscriptionCreated, PaymentFailed, RenewalDue",
          "Use a saga for renewals with compensation on payment failure",
          "API gateway aggregates customer and subscription views"
        ]
      }
    ],
    "best_practices": [
      "Align services with business capabilities and bounded contexts",
      "Prefer asynchronous events when you need loose coupling",
      "Add circuit breakers and retries to every cross service call"
    ],
    "anti_patterns": [
      "Sharing a single database across services",
      "Making all service communication synchronous",
      "Skipping compensation logic in distributed transactions"
    ],
    "faq": [
      {
        "question": "Is this compatible with Claude, Codex, and Claude Code?",
        "answer": "Yes. It is a text based skill that works in those platforms."
      },
      {
        "question": "What are the limits of the examples?",
        "answer": "Examples are templates and omit details like authentication, observability, and deployment."
      },
      {
        "question": "Can it fit my existing stack?",
        "answer": "Yes. Patterns are stack agnostic and can be adapted to your languages and frameworks."
      },
      {
        "question": "Does it access or store my data?",
        "answer": "No. It provides guidance only and does not read files or send network requests."
      },
      {
        "question": "What if the guidance feels too complex?",
        "answer": "Start with a small service split and add patterns incrementally."
      },
      {
        "question": "How is this different from generic advice?",
        "answer": "It focuses on specific microservices patterns with concrete examples and tradeoffs."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
