{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-05T16:54:30.950Z",
    "slug": "wshobson-async-python-patterns",
    "source_url": "https://github.com/wshobson/agents/tree/main/plugins/python-development/skills/async-python-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "92c333c184463b8b3f22fadc6340b4c9943726f5e333d5ebb665f248ffb06c3c",
    "tree_hash": "4cab544983a28f539123fac92f8603bcf193b89318764efb966b6be378f4d525"
  },
  "skill": {
    "name": "async-python-patterns",
    "description": "Master Python asyncio, concurrent programming, and async/await patterns for high-performance applications. Use when building async APIs, concurrent systems, or I/O-bound applications requiring non-blocking operations.",
    "summary": "Master Python asyncio, concurrent programming, and async/await patterns for high-performance applica...",
    "icon": "âš¡",
    "version": "1.0.0",
    "author": "wshobson",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "python",
      "asyncio",
      "concurrency",
      "performance",
      "async-await"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Documentation-only skill containing Python async programming patterns. No executable code, network access, or security risks identified.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 4,
    "total_lines": 916,
    "audit_model": "claude",
    "audited_at": "2026-01-05T16:54:30.949Z"
  },
  "content": {
    "user_title": "Master Async Python Programming",
    "value_statement": "Build high-performance Python applications with async/await patterns. Learn concurrent programming techniques for scalable I/O-bound systems.",
    "seo_keywords": [
      "async python",
      "asyncio",
      "concurrent programming",
      "async await",
      "python performance",
      "non-blocking I/O",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Explains asyncio event loop mechanics",
      "Demonstrates async/await syntax patterns",
      "Shows concurrent task execution with gather()",
      "Covers error handling in async code",
      "Provides real-world examples for web scraping and APIs"
    ],
    "limitations": [
      "Educational content only - no code execution",
      "Python 3.7+ required for examples",
      "Focuses on I/O-bound patterns, not CPU-bound"
    ],
    "use_cases": [
      {
        "target_user": "Python developers",
        "title": "Build Async Web APIs",
        "description": "Create FastAPI and aiohttp applications with proper async patterns for handling concurrent requests"
      },
      {
        "target_user": "Data engineers",
        "title": "Concurrent Data Processing",
        "description": "Implement parallel I/O operations for database queries, file processing, and API calls"
      },
      {
        "target_user": "DevOps engineers",
        "title": "Async Automation Scripts",
        "description": "Write efficient automation tools that handle multiple network operations concurrently"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Async Pattern",
        "scenario": "Creating your first async function",
        "prompt": "Show me how to create a simple async function that fetches data with asyncio.sleep() to simulate network delay"
      },
      {
        "title": "Concurrent Requests",
        "scenario": "Making multiple API calls efficiently",
        "prompt": "Demonstrate how to make 10 HTTP requests concurrently using asyncio.gather() with proper error handling"
      },
      {
        "title": "Producer-Consumer Queue",
        "scenario": "Processing tasks with async queues",
        "prompt": "Create a producer-consumer pattern using asyncio.Queue for processing 100 items with 5 workers"
      },
      {
        "title": "WebSocket Server",
        "scenario": "Building real-time applications",
        "prompt": "Design an async WebSocket server that handles multiple clients and broadcasts messages to all connected users"
      }
    ],
    "output_examples": [
      {
        "input": "Show me how to fetch multiple URLs concurrently with timeout handling",
        "output": [
          "Use asyncio.gather() with asyncio.wait_for() for timeout control",
          "Create aiohttp ClientSession with connection pooling",
          "Handle both successful responses and timeouts gracefully",
          "Return results with status codes and error information"
        ]
      }
    ],
    "best_practices": [
      "Always use asyncio.run() as the entry point for async applications",
      "Implement proper error handling with try/except blocks in async functions",
      "Use connection pools and semaphores to limit concurrent operations"
    ],
    "anti_patterns": [
      "Never use time.sleep() in async code - always use asyncio.sleep()",
      "Don't forget to await coroutines or they won't execute",
      "Avoid mixing blocking I/O operations with async code"
    ],
    "faq": [
      {
        "question": "Which Python versions support asyncio?",
        "answer": "Python 3.4+ has asyncio, but Python 3.7+ recommended for async/await syntax and asyncio.run()"
      },
      {
        "question": "When should I use async vs threads?",
        "answer": "Use async for I/O-bound operations, threads for CPU-bound tasks that block the event loop"
      },
      {
        "question": "Can I use async with Django?",
        "answer": "Django 3.0+ supports async views, but use Django 4.1+ for full async ORM support"
      },
      {
        "question": "How do I debug async code?",
        "answer": "Use asyncio debug mode, proper logging, and tools like aiomonitor for production debugging"
      },
      {
        "question": "What's the difference between asyncio.create_task() and asyncio.gather()?",
        "answer": "create_task() schedules a single coroutine, gather() runs multiple coroutines concurrently and waits for all"
      },
      {
        "question": "Is this skill compatible with Jupyter notebooks?",
        "answer": "Yes, but use asyncio.run() carefully in notebooks - consider using nest_asyncio for nested event loops"
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
