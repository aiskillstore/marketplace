{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-02T00:06:46.047Z",
    "slug": "wshobson-cqrs-implementation",
    "source_url": "https://github.com/wshobson/agents/tree/main/plugins/backend-development/skills/cqrs-implementation",
    "source_ref": "main",
    "model": "codex",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "7867a8fc60c7002b8e485ae288f0d300d7f01da96c48ec6a9acc12775b925df1",
    "tree_hash": "c34c6978d2bf07d1681fd4a52c595debb41646765578a5815298ed790ab1a62a"
  },
  "skill": {
    "name": "cqrs-implementation",
    "description": "Implement Command Query Responsibility Segregation for scalable architectures. Use when separating read and write models, optimizing query performance, or building event-sourced systems.",
    "summary": "Implement Command Query Responsibility Segregation for scalable architectures. Use when separating r...",
    "icon": "ðŸ§­",
    "version": "1.0.0",
    "license": "unknown",
    "category": "coding",
    "tags": [
      "cqrs",
      "event-sourcing",
      "architecture",
      "backend"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "No data theft, exfiltration, or malicious execution patterns detected. Content is instructional templates and guidance for CQRS design.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 552,
    "audit_model": "codex",
    "audited_at": "2026-01-02T00:06:46.047Z"
  },
  "content": {
    "user_title": "Implement CQRS for scalable backend services",
    "value_statement": "Many systems struggle with mixed read and write workloads. This skill shows how to separate models and handlers for performance and clarity.",
    "seo_keywords": [
      "CQRS",
      "event sourcing",
      "command bus",
      "query bus",
      "FastAPI CQRS",
      "projection",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Explain CQRS architecture and component roles",
      "Provide command and query handler templates",
      "Show a FastAPI CQRS API example",
      "Describe read model synchronization flow",
      "Outline eventual consistency query handling"
    ],
    "limitations": [
      "Does not include a complete event store implementation",
      "Does not provide database schema or migrations",
      "Requires adaptation to your stack and domain model"
    ],
    "use_cases": [
      {
        "target_user": "Backend engineers",
        "title": "Split read and write paths",
        "description": "Design separate command and query workflows for a busy service."
      },
      {
        "target_user": "Platform teams",
        "title": "Optimize reporting queries",
        "description": "Build denormalized read models for fast dashboards."
      },
      {
        "target_user": "Architects",
        "title": "Introduce event sourcing",
        "description": "Draft event driven read model projections and consistency flow."
      }
    ],
    "prompt_templates": [
      {
        "title": "CQRS overview",
        "scenario": "New to CQRS",
        "prompt": "Explain CQRS and when I should use it for a web service."
      },
      {
        "title": "Command handlers",
        "scenario": "Create write path",
        "prompt": "Draft command and command handler templates for order creation and cancellation."
      },
      {
        "title": "Query handlers",
        "scenario": "Build read models",
        "prompt": "Provide query and query handler templates for order lookups with pagination."
      },
      {
        "title": "Consistency strategy",
        "scenario": "Read after write",
        "prompt": "Show a pattern for eventual consistency and read your writes behavior."
      }
    ],
    "output_examples": [
      {
        "input": "Give me a CQRS plan for an order system with read heavy queries.",
        "output": [
          "Separate command and query models with dedicated handlers",
          "Use a command bus for write requests and a query bus for reads",
          "Project events into a denormalized order view table",
          "Add a consistency check for read after write flows"
        ]
      }
    ],
    "best_practices": [
      "Validate commands before state changes",
      "Denormalize read models for query speed",
      "Version events to support evolution"
    ],
    "anti_patterns": [
      "Querying in command handlers",
      "Sharing the same schema for read and write models",
      "Ignoring consistency requirements"
    ],
    "faq": [
      {
        "question": "Is this compatible with any language or framework?",
        "answer": "Yes. The guidance is architectural and the templates are in Python for reference."
      },
      {
        "question": "What are the limits of this skill?",
        "answer": "It does not include storage setup, migrations, or a full event store implementation."
      },
      {
        "question": "How do I integrate it with my service?",
        "answer": "Map the command, query, and projection templates to your existing domain and data stores."
      },
      {
        "question": "Does it access my data or environment?",
        "answer": "No. It provides static guidance and code patterns only."
      },
      {
        "question": "What if my read model is stale?",
        "answer": "Use the consistency handler pattern and define acceptable lag or retries."
      },
      {
        "question": "How is this different from basic CRUD?",
        "answer": "It separates read and write concerns to improve scalability and clarity."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
