{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-02T00:06:46.047Z",
    "slug": "wshobson-cqrs-implementation",
    "source_url": "https://github.com/wshobson/agents/tree/main/plugins/backend-development/skills/cqrs-implementation",
    "source_ref": "main",
    "model": "codex",
    "analysis_version": "2.0.0",
    "source_type": "community"
  },
  "skill": {
    "name": "cqrs-implementation",
    "description": "Implement Command Query Responsibility Segregation for scalable architectures. Use when separating read and write models, optimizing query performance, or building event-sourced systems.",
    "summary": "Implement Command Query Responsibility Segregation for scalable architectures. Use when separating r...",
    "icon": "ðŸ§­",
    "version": "1.0.0",
    "license": "unknown",
    "category": "coding",
    "tags": [
      "cqrs",
      "event-sourcing",
      "architecture",
      "backend"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "No data theft, exfiltration, or malicious executionration, or malicious execution patterns detected. The skill is instructional content with code templates and references.",
    "risk_factors": [
      "network"
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 3,
    "total_lines": 746,
    "audit_model": "codex",
    "audited_at": "2026-01-03T02:21:49.131Z"
  },
  "content": {
    "user_title": "Implement CQRS for scalable backend services",
    "value_statement": "Mixed read and write workloads can slow systems and complicate designs. This skill shows how to separate models and handlers for performance and clarity.",
    "seo_keywords": [
      "CQRS",
      "event sourcing",
      "command bus",
      "query bus",
      "FastAPI CQRS",
      "projection",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Explain CQRS architecture and component roles",
      "Provide command and command handler templates",
      "Provide query and query handler templates with pagination",
      "Show a FastAPI CQRS API example",
      "Describe read model synchronization and consistency handling"
    ],
    "limitations": [
      "Does not include a full event store implementation",
      "Does not provide database schema or migrations",
      "Requires adaptation to a specific stack and domain model"
    ],
    "use_cases": [
      {
        "target_user": "Backend engineers",
        "title": "Split read and write paths",
        "description": "Design separate command and query workflows for a busy service."
      },
      {
        "target_user": "Platform teams",
        "title": "Optimize reporting queries",
        "description": "Build denormalized read models for fast dashboards and analytics."
      },
      {
        "target_user": "Software architects",
        "title": "Introduce event sourcing",
        "description": "Draft event driven projections and consistency strategies for new systems."
      }
    ],
    "prompt_templates": [
      {
        "title": "CQRS overview",
        "scenario": "New to CQRS",
        "prompt": "Explain CQRS and when to use it for a web service with read heavy traffic."
      },
      {
        "title": "Command templates",
        "scenario": "Create write path",
        "prompt": "Draft command and command handler templates for order creation and cancellation."
      },
      {
        "title": "Query templates",
        "scenario": "Build read models",
        "prompt": "Provide query and query handler templates for order lookups with pagination."
      },
      {
        "title": "Consistency plan",
        "scenario": "Read after write",
        "prompt": "Show a pattern for eventual consistency and read your writes behavior."
      }
    ],
    "output_examples": [
      {
        "input": "Give me a CQRS plan for an order system with read heavy queries.",
        "output": [
          "Separate command and query models with dedicated handlers",
          "Use a command bus for write requests and a query bus for reads",
          "Project events into a denormalized order view table",
          "Add a consistency check for read after write flows"
        ]
      }
    ],
    "best_practices": [
      "Validate commands before state changes",
      "Denormalize read models for query speed",
      "Version events to support evolution"
    ],
    "anti_patterns": [
      "Querying in command handlers",
      "Sharing one schema for read and write models",
      "Ignoring consistency requirements"
    ],
    "faq": [
      {
        "question": "Is this compatible with any language or framework?",
        "answer": "Yes. The guidance is architectural and the templates are in Python for reference."
      },
      {
        "question": "What are the limits of this skill?",
        "answer": "It does not include storage setup, migrations, or a full event store implementation."
      },
      {
        "question": "How do I integrate it with my service?",
        "answer": "Map the command, query, and projection templates to your domain and data stores."
      },
      {
        "question": "Does it access my data or environment?",
        "answer": "No. It provides static guidance and code patterns only."
      },
      {
        "question": "What if my read model is stale?",
        "answer": "Use the consistency handler pattern and define acceptable lag or retries."
      },
      {
        "question": "How is this different from basic CRUD?",
        "answer": "It separates read and write concerns to improve scalability and clarity."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
