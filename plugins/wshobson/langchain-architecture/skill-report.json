{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-02T00:37:42.287Z",
    "slug": "wshobson-langchain-architecture",
    "source_url": "https://github.com/wshobson/agents/tree/main/plugins/llm-application-dev/skills/langchain-architecture",
    "source_ref": "main",
    "model": "codex",
    "analysis_version": "2.0.0",
    "source_type": "community"
  },
  "skill": {
    "name": "langchain-architecture",
    "description": "Design LLM applications using the LangChain framework with agents, memory, and tool integration patterns. Use when building LangChain applications, implementing AI agents, or creating complex LLM workflows.",
    "summary": "Design LLM applications using the LangChain framework with agents, memory, and tool integration patt...",
    "icon": "ðŸ§±",
    "version": "1.0.0",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "langchain",
      "agents",
      "architecture",
      "llm"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "No code patterns indicate data theft, exfiltration, or malicious execution. Content is instructional and aligns with the stated purpose.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 338,
    "audit_model": "codex",
    "audited_at": "2026-01-02T00:37:42.287Z"
  },
  "content": {
    "user_title": "Design LangChain LLM architectures",
    "value_statement": "You need a clear structure for agents, chains, and memory in LangChain. This skill provides proven patterns, examples, and testing guidance.",
    "seo_keywords": [
      "LangChain architecture",
      "LLM agents",
      "RAG pipelines",
      "Claude",
      "Codex",
      "Claude Code",
      "memory management",
      "tool integration",
      "agent workflows"
    ],
    "actual_capabilities": [
      "Explain agent types and when to use each",
      "Show chain composition patterns with examples",
      "Describe memory options and selection guidance",
      "Outline RAG document processing flow",
      "Provide callback and observability patterns",
      "Include testing and performance optimization tips"
    ],
    "limitations": [
      "Does not run or validate LangChain code",
      "Does not include API keys or deployment steps",
      "Examples are illustrative and may need adaptation",
      "No direct integration with external services"
    ],
    "use_cases": [
      {
        "target_user": "Startup engineer",
        "title": "Plan a production agent",
        "description": "Map an agent, tools, memory, and error handling for a new product feature."
      },
      {
        "target_user": "ML engineer",
        "title": "Design a RAG workflow",
        "description": "Choose loaders, splitters, vector stores, and retrievers for document QA."
      },
      {
        "target_user": "Tech lead",
        "title": "Standardize architecture",
        "description": "Create a reusable LangChain blueprint for team projects and reviews."
      }
    ],
    "prompt_templates": [
      {
        "title": "Agent basics",
        "scenario": "Beginner planning an agent",
        "prompt": "Explain which LangChain agent type fits a customer support assistant with tool use and short chat history."
      },
      {
        "title": "Chain design",
        "scenario": "Intermediate multi-step task",
        "prompt": "Propose a SequentialChain for extracting entities, analyzing them, and summarizing results, with inputs and outputs."
      },
      {
        "title": "RAG blueprint",
        "scenario": "Intermediate retrieval setup",
        "prompt": "Outline a RAG pipeline with loaders, text splitting, embeddings, vector store, and retrieval QA chain."
      },
      {
        "title": "Advanced architecture",
        "scenario": "Complex system design",
        "prompt": "Design a production LangChain architecture with callbacks, memory strategy, testing plan, and performance optimizations."
      }
    ],
    "output_examples": [
      {
        "input": "Design a LangChain RAG pipeline for internal docs",
        "output": [
          "Loader selection: choose a directory loader for structured files",
          "Chunking plan: split by 1000 characters with overlap",
          "Vector store: store embeddings and enable retriever access",
          "QA chain: use RetrievalQA with source documents returned"
        ]
      }
    ],
    "best_practices": [
      "Match memory type to conversation length and cost",
      "Add callbacks for monitoring and error visibility",
      "Test tool selection and memory persistence"
    ],
    "anti_patterns": [
      "Using unlimited buffer memory in long sessions",
      "Vague tool descriptions that confuse agents",
      "Skipping error handling in agent execution"
    ],
    "faq": [
      {
        "question": "Is this compatible with Claude, Codex, and Claude Code?",
        "answer": "Yes. The guidance is model agnostic and works with those platforms."
      },
      {
        "question": "What are the limits of this skill?",
        "answer": "It provides architecture guidance and examples, not runnable code or deployments."
      },
      {
        "question": "How do I integrate it with my project?",
        "answer": "Use the patterns to design agents, chains, memory, and RAG components for your app."
      },
      {
        "question": "Does it access or store my data?",
        "answer": "No. It contains static guidance and does not access user data."
      },
      {
        "question": "What if my agent fails to choose the right tool?",
        "answer": "Refine tool descriptions, add tests, and use callbacks to debug actions."
      },
      {
        "question": "How does this compare to generic LangChain docs?",
        "answer": "It focuses on architecture patterns, examples, and practical design choices."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}