{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-02T01:28:33.851Z",
    "slug": "wshobson-vector-index-tuning",
    "source_url": "https://github.com/wshobson/agents/tree/main/plugins/llm-application-dev/skills/vector-index-tuning",
    "source_ref": "main",
    "model": "codex",
    "analysis_version": "2.0.0",
    "source_type": "community"
  },
  "skill": {
    "name": "vector-index-tuning",
    "description": "Optimize vector index performance for latency, recall, and memory. Use when tuning HNSW parameters, selecting quantization strategies, or scaling vector search infrastructure.",
    "summary": "Optimize vector index performance for latency, recall, and memory. Use when tuning HNSW parameters, ...",
    "icon": "üîç",
    "version": "1.0.0",
    "license": "MIT",
    "category": "data",
    "tags": [
      "vector-search",
      "hnsw",
      "quantization",
      "performance"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "No data theft, exfiltration, or malicious execution patterns are present. The content is instructional and limited to local tuning templates and guidance.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 521,
    "audit_model": "codex",
    "audited_at": "2026-01-02T01:28:33.851Z"
  },
  "content": {
    "user_title": "Optimize vector index tuning for speed and recall",
    "value_statement": "Vector search feels slow or costly when indexes are misconfigured. This skill provides tuning templates and heuristics to improve latency, recall, and memory use.",
    "seo_keywords": [
      "vector index tuning",
      "HNSW parameters",
      "quantization strategies",
      "Qdrant optimization",
      "ANN benchmarks",
      "Claude",
      "Codex",
      "Claude Code",
      "vector search performance"
    ],
    "actual_capabilities": [
      "Benchmark HNSW parameter grids and compute recall metrics",
      "Recommend HNSW settings based on scale and recall targets",
      "Apply scalar, product, and binary quantization strategies",
      "Estimate memory usage for index and vector storage",
      "Configure Qdrant collections and search parameters for tuning"
    ],
    "limitations": [
      "Requires representative queries and ground truth for accurate recall",
      "Templates assume Python and specific libraries like hnswlib and sklearn",
      "Does not automate deployment or index lifecycle management",
      "Heuristics may need adjustment for specific datasets"
    ],
    "use_cases": [
      {
        "target_user": "ML engineer",
        "title": "Tune ANN for recall",
        "description": "Find HNSW settings that meet recall targets without breaking latency budgets."
      },
      {
        "target_user": "Search platform lead",
        "title": "Reduce memory footprint",
        "description": "Evaluate quantization options and estimate storage tradeoffs at scale."
      },
      {
        "target_user": "Data engineer",
        "title": "Plan index scaling",
        "description": "Select index types and configs for millions to billions of vectors."
      }
    ],
    "prompt_templates": [
      {
        "title": "Quick HNSW sweep",
        "scenario": "Small dataset baseline",
        "prompt": "Benchmark HNSW M and efSearch for 200k vectors and target recall 0.95. Suggest the best balanced configuration."
      },
      {
        "title": "Quantization choice",
        "scenario": "Memory reduction plan",
        "prompt": "Compare fp16, int8, and product quantization for 10M vectors of 768 dims. Summarize memory and recall impacts."
      },
      {
        "title": "Qdrant config",
        "scenario": "Balanced production setup",
        "prompt": "Create Qdrant collection settings for balanced recall and speed with 5M vectors. Include HNSW and quantization configs."
      },
      {
        "title": "Monitoring plan",
        "scenario": "Performance regression guard",
        "prompt": "Define metrics and a testing loop to track latency percentiles and recall drift for weekly index updates."
      }
    ],
    "output_examples": [
      {
        "input": "Suggest HNSW parameters for 1M vectors with 0.95 recall and under 10 ms latency.",
        "output": [
          "Recommended M: 32 and efConstruction: 200 for build quality",
          "Set efSearch to 128 to target 0.95 recall",
          "Estimate memory overhead with M at 32 and validate with a small benchmark"
        ]
      }
    ],
    "best_practices": [
      "Benchmark with real queries and a ground truth set",
      "Start with defaults, then tune one parameter at a time",
      "Track recall and latency percentiles after each change"
    ],
    "anti_patterns": [
      "Tuning without measuring recall against ground truth",
      "Changing multiple parameters at once without controls",
      "Ignoring memory overhead when increasing M or efSearch"
    ],
    "faq": [
      {
        "question": "What platforms does this skill support?",
        "answer": "It provides general guidance and includes Qdrant examples. It works with Claude, Codex, and Claude Code."
      },
      {
        "question": "What are the main limits of the templates?",
        "answer": "They are Python examples and require data, queries, and libraries to run."
      },
      {
        "question": "Can I integrate this into my pipeline?",
        "answer": "Yes. Use the templates as building blocks in your benchmarking or CI jobs."
      },
      {
        "question": "Does it access or send my data?",
        "answer": "No. The skill content is static and does not include data collection or network calls."
      },
      {
        "question": "What if results are noisy or unstable?",
        "answer": "Increase query samples, fix random seeds, and separate build from search timing."
      },
      {
        "question": "How does this compare to a generic tuning guide?",
        "answer": "It adds concrete templates, parameter ranges, and memory estimation formulas."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}