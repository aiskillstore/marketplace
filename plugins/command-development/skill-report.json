{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2025-12-31T05:43:54.787Z",
    "slug": "command-development",
    "source_url": "https://github.com/anthropics/claude-code/tree/main/plugins/plugin-dev/skills/command-development",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "trust_level": "official"
  },
  "skill": {
    "name": "Command Development",
    "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
    "summary": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a ...",
    "icon": "âš¡",
    "version": "0.2.0",
    "author": "Anthropic",
    "license": "Not specified",
    "category": "development",
    "tags": [
      "slash-commands",
      "workflow-automation",
      "claude-code",
      "command-development",
      "yaml-frontmatter",
      "plugin-development",
      "developer-tools",
      "productivity",
      "automation",
      "interactive-commands"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is an official Anthropic skill providing documentation and guidance. No executable code, malicious patterns, or security risks detected. Content is purely educational.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 11,
    "total_lines": 7237,
    "audit_model": "claude",
    "audited_at": "2025-12-31T05:43:54.785Z"
  },
  "content": {
    "user_title": "Slash Command Development for Claude Code",
    "value_statement": "Master the creation of reusable slash commands that streamline your Claude Code workflows with dynamic arguments, file references, bash execution, and interactive user prompts.",
    "seo_keywords": [
      "claude code commands",
      "slash commands",
      "command development",
      "yaml frontmatter",
      "dynamic arguments",
      "bash execution",
      "plugin development",
      "workflow automation",
      "interactive commands",
      "AskUserQuestion",
      "command templates",
      "claude code plugins"
    ],
    "actual_capabilities": [
      "Create slash commands with Markdown and YAML frontmatter",
      "Use dynamic arguments ($1, $2, $ARGUMENTS) for flexible command invocation",
      "Reference files with @ syntax to include content in commands",
      "Execute bash commands inline with !` syntax for dynamic context",
      "Configure command behavior with frontmatter fields (description, allowed-tools, model, argument-hint)",
      "Organize commands with namespaces and subdirectories",
      "Create plugin-specific commands using ${CLAUDE_PLUGIN_ROOT}",
      "Build interactive commands with AskUserQuestion tool",
      "Integrate commands with plugin agents, skills, and hooks",
      "Validate inputs and handle errors gracefully",
      "Design multi-step workflows and command sequences",
      "Test commands with comprehensive validation strategies"
    ],
    "limitations": [
      "Commands are executed by Claude, not as standalone scripts",
      "Bash execution requires appropriate allowed-tools permissions",
      "Plugin commands require plugin installation to be available",
      "Interactive commands depend on AskUserQuestion tool availability",
      "Command complexity should balance reusability with maintainability",
      "Performance depends on command design and bash execution overhead"
    ],
    "use_cases": [
      {
        "title": "Code Review Automation",
        "description": "Create a slash command that reviews code for security vulnerabilities, quality issues, and best practices with one invocation",
        "target_user": "Developers who frequently review pull requests or code changes"
      },
      {
        "title": "Deployment Workflows",
        "description": "Build environment-specific deployment commands that validate configuration, run tests, and deploy with appropriate safety checks",
        "target_user": "DevOps engineers and developers managing deployments"
      },
      {
        "title": "Documentation Generation",
        "description": "Generate standardized documentation from templates for API endpoints, components, or modules",
        "target_user": "Technical writers and developers maintaining project documentation"
      },
      {
        "title": "Interactive Setup Wizards",
        "description": "Create multi-step configuration commands that guide users through setup with questions and validation",
        "target_user": "Plugin authors and teams onboarding new developers"
      },
      {
        "title": "Testing Workflows",
        "description": "Execute test suites for specific files or patterns and analyze results with contextual recommendations",
        "target_user": "QA engineers and developers running tests frequently"
      },
      {
        "title": "Plugin Command Development",
        "description": "Build plugin-specific commands that leverage plugin scripts, templates, configurations, and integration with agents/skills",
        "target_user": "Plugin developers creating reusable functionality"
      }
    ],
    "prompt_templates": [
      {
        "title": "Simple Code Review Command",
        "prompt": "Create a slash command named '/review' that reviews code in the current repository for code quality, potential bugs, and best practices. It should check readability, consistent style, logic errors, edge cases, and appropriate error handling.",
        "scenario": "When you need a quick command to review code without arguments"
      },
      {
        "title": "File-Specific Analysis Command",
        "prompt": "Create a slash command '/analyze-file [file-path]' that takes a file path as argument, reads the file, and performs comprehensive security analysis checking for SQL injection, XSS, authentication issues, and insecure data handling.",
        "scenario": "When you need to analyze specific files with targeted security checks"
      },
      {
        "title": "Deployment Command with Validation",
        "prompt": "Create a slash command '/deploy [environment] [version]' that validates the environment (dev/staging/prod), loads environment-specific configuration from ${CLAUDE_PLUGIN_ROOT}/config/{environment}.json, and executes deployment with pre-deployment checks and smoke tests.",
        "scenario": "When you need a safe deployment workflow with validation"
      },
      {
        "title": "Interactive Setup Command",
        "prompt": "Create a slash command '/setup' that uses AskUserQuestion to interactively gather: 1) deployment platform (AWS/GCP/Azure/Local), 2) number of environments needed (Single/Standard/Complete), 3) features to enable (auto-scaling, monitoring, CI/CD, backups) with multi-select. Generate configuration file based on answers.",
        "scenario": "When you need to guide users through configuration with explanations"
      },
      {
        "title": "Multi-Script Workflow Command",
        "prompt": "Create a slash command '/full-audit [directory]' that executes three plugin scripts sequentially: security-scan.sh, perf-analyze.sh, and best-practices.sh from ${CLAUDE_PLUGIN_ROOT}/scripts/. Analyze all results and create a comprehensive report with critical issues, performance opportunities, and overall health score.",
        "scenario": "When you need to orchestrate multiple analysis tools"
      }
    ],
    "output_examples": [
      {
        "input": "User invokes: /review",
        "output": "Claude reads the command file, executes any bash commands (like git diff), and reviews code according to the command's instructions, providing specific feedback with file and line references for quality issues, potential bugs, and best practice violations."
      },
      {
        "input": "User invokes: /deploy staging v1.2.3",
        "output": "Claude substitutes $1=staging and $2=v1.2.3, loads the staging configuration file, validates the environment, checks cluster status via kubectl, and proceeds with deployment following the command's workflow, reporting status at each step."
      },
      {
        "input": "User invokes: /setup",
        "output": "Claude presents interactive questions using AskUserQuestion tool, allowing the user to select deployment platform, environment strategy, and features. After gathering answers, Claude generates a configuration file (.claude/plugin-name.local.md) with YAML frontmatter containing all selections."
      }
    ],
    "best_practices": [
      "Write commands as instructions FOR Claude (agent consumption), not messages TO users",
      "Use single responsibility principle - one command, one clear purpose",
      "Always provide argument-hint when commands accept arguments",
      "Use the most restrictive allowed-tools setting that works (e.g., Bash(git:*) not Bash(*))",
      "Validate inputs early and provide helpful error messages",
      "Use ${CLAUDE_PLUGIN_ROOT} for all plugin-internal paths to ensure portability",
      "Document command purpose, arguments, and requirements in comments",
      "Keep descriptions under 60 characters for clean /help display",
      "Test commands across different environments and edge cases",
      "Use haiku model for simple/fast commands, sonnet for standard, opus for complex analysis",
      "Design interactive commands with clear question structure and helpful option descriptions",
      "Handle missing files and failed bash commands gracefully",
      "Organize commands with namespaces when you have 15+ commands"
    ],
    "anti_patterns": [
      "Writing command content as messages TO users instead of instructions FOR Claude",
      "Using relative paths instead of ${CLAUDE_PLUGIN_ROOT} in plugin commands",
      "Forgetting to specify allowed-tools for commands that use Bash execution",
      "Creating overly broad tool permissions like Bash(*) when specific filters work",
      "Not validating required arguments before processing",
      "Hardcoding plugin paths that break across installations",
      "Using generic command names that conflict (like /test or /run)",
      "Creating complex multi-purpose commands instead of focused single-purpose ones",
      "Writing descriptions longer than 60 characters that clutter /help output",
      "Using AskUserQuestion for simple values better handled as command arguments",
      "Not documenting arguments with argument-hint",
      "Leaving TODO comments or debug code in distributed commands"
    ],
    "faq": [
      {
        "question": "What's the difference between $ARGUMENTS and $1, $2, $3?",
        "answer": "$ARGUMENTS captures all arguments as a single string, while $1, $2, $3 are positional arguments. Use $ARGUMENTS when you want the entire argument list as one value, use positional arguments when you need to reference specific arguments individually."
      },
      {
        "question": "When should I use the @ syntax for file references?",
        "answer": "Use @ syntax (like @$1 or @path/to/file) when you want Claude to read and include the file's contents in the command context. This is useful for reviewing files, comparing files, or using files as input to analysis."
      },
      {
        "question": "What's the purpose of the !` syntax for bash execution?",
        "answer": "The !` syntax executes bash commands and includes their output in the command prompt before Claude processes it. This is useful for gathering dynamic context like git status, current branch, or environment information that informs Claude's response."
      },
      {
        "question": "When should I use AskUserQuestion instead of command arguments?",
        "answer": "Use AskUserQuestion for: 1) multiple choice decisions needing explanation, 2) complex options requiring context, 3) multi-select scenarios, 4) preference gathering. Use command arguments for: 1) simple values, 2) known inputs, 3) scriptable workflows, 4) fast invocations."
      },
      {
        "question": "How do I make my plugin commands work across different installations?",
        "answer": "Always use ${CLAUDE_PLUGIN_ROOT} for plugin-internal paths. This environment variable resolves to the absolute path of the plugin directory, ensuring commands work regardless of where the plugin is installed."
      },
      {
        "question": "What's the difference between project, user, and plugin commands?",
        "answer": "Project commands (.claude/commands/) are shared with your team and project-specific. User commands (~/.claude/commands/) are personal and available everywhere. Plugin commands (plugin-name/commands/) are bundled with plugins and available when the plugin is installed."
      },
      {
        "question": "How do I restrict which bash commands a command can execute?",
        "answer": "Use the allowed-tools frontmatter field with specific filters like 'Bash(git:*)' for only git commands, 'Bash(npm:*)' for only npm commands, etc. Avoid 'Bash(*)' which allows all bash commands."
      },
      {
        "question": "Can commands integrate with plugin agents and skills?",
        "answer": "Yes! Commands can reference plugin agents by name (Claude will use the Task tool to launch them) and invoke plugin skills by mentioning them in the command prompt. This enables powerful multi-component workflows."
      },
      {
        "question": "How do I organize commands when I have many of them?",
        "answer": "Use subdirectories for namespacing when you have 15+ commands. For example, commands/ci/, commands/git/, commands/docs/ create logical groupings shown as (project:ci), (project:git), (project:docs) in /help."
      },
      {
        "question": "What model should I specify for my command?",
        "answer": "Use 'haiku' for fast, simple commands; 'sonnet' for standard workflows (default); 'opus' for complex analysis requiring deep understanding. Most commands work well without specifying a model and inherit from the conversation."
      }
    ],
    "technical_requirements": {
      "dependencies": [
        "Claude Code CLI",
        "Bash shell (for commands using bash execution)",
        "Git (for commands using git commands)",
        "Node.js (for plugin commands executing Node scripts)",
        "Plugin-specific dependencies (varies by plugin)"
      ],
      "permissions": [
        "Read access to command files (.claude/commands/)",
        "Tool permissions based on allowed-tools frontmatter",
        "Bash execution permissions (if using !` syntax)",
        "File read permissions (if using @ syntax)",
        "AskUserQuestion tool access (for interactive commands)"
      ],
      "complexity": "intermediate"
    }
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "plugin-commands.md",
          "type": "file",
          "path": "examples/plugin-commands.md"
        },
        {
          "name": "simple-commands.md",
          "type": "file",
          "path": "examples/simple-commands.md"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "advanced-workflows.md",
          "type": "file",
          "path": "references/advanced-workflows.md"
        },
        {
          "name": "documentation-patterns.md",
          "type": "file",
          "path": "references/documentation-patterns.md"
        },
        {
          "name": "frontmatter-reference.md",
          "type": "file",
          "path": "references/frontmatter-reference.md"
        },
        {
          "name": "interactive-commands.md",
          "type": "file",
          "path": "references/interactive-commands.md"
        },
        {
          "name": "marketplace-considerations.md",
          "type": "file",
          "path": "references/marketplace-considerations.md"
        },
        {
          "name": "plugin-features-reference.md",
          "type": "file",
          "path": "references/plugin-features-reference.md"
        },
        {
          "name": "testing-strategies.md",
          "type": "file",
          "path": "references/testing-strategies.md"
        }
      ]
    },
    {
      "name": "README.md",
      "type": "file",
      "path": "README.md"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}