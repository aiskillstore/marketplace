{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2025-12-30T14:29:51.541Z",
    "slug": "plugin-settings",
    "source_url": "https://github.com/anthropics/claude-code/tree/main/plugins/plugin-dev/skills/plugin-settings",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "trust_level": "official"
  },
  "skill": {
    "name": "Plugin Settings",
    "description": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", \"user-configurable plugin\", \".local.md files\", \"plugin state files\", \"read YAML frontmatter\", \"per-project plugin settings\", or wants to make plugin behavior configurable. Documents the .claude/plugin-name.local.md pattern for storing plugin-specific configuration with YAML frontmatter and markdown content.",
    "summary": "This skill should be used when the user asks about \"plugin settings\", \"store plugin configuration\", ...",
    "icon": "⚙️",
    "version": "0.1.0",
    "author": "Anthropic",
    "license": "MIT",
    "category": "development",
    "tags": [
      "plugin",
      "configuration",
      "yaml",
      "settings",
      "frontmatter",
      "state-management",
      "hooks"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is an official Anthropic skill providing documentation and examples for plugin configuration patterns. All example scripts follow security best practices including input validation, path traversal checks, and atomic file operations.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 8,
    "total_lines": 1978,
    "audit_model": "claude",
    "audited_at": "2025-12-30T14:29:51.540Z"
  },
  "content": {
    "user_title": "Plugin Settings Management Pattern",
    "value_statement": "Learn how to create user-configurable Claude Code plugins that store per-project settings using YAML frontmatter files, enabling dynamic behavior customization without code changes.",
    "seo_keywords": [
      "plugin configuration",
      "yaml frontmatter",
      "claude code settings",
      "per-project config",
      "plugin state management",
      "bash yaml parsing",
      "local settings files",
      "hook configuration"
    ],
    "actual_capabilities": [
      "Documents the .claude/plugin-name.local.md pattern for storing plugin configuration",
      "Provides bash parsing techniques for extracting YAML frontmatter and markdown bodies",
      "Includes working examples from real plugins (multi-agent-swarm, ralph-wiggum)",
      "Offers utility scripts for validating and parsing settings files",
      "Demonstrates configuration-driven hook behavior with enable/disable patterns",
      "Shows how to create, read, and update settings files from commands and hooks",
      "Provides templates for common configuration patterns (feature flags, agent state, validation modes)"
    ],
    "limitations": [
      "Settings changes require Claude Code restart to take effect (hooks can't be hot-swapped)",
      "Limited to bash/sed/awk parsing techniques (more complex YAML requires yq)",
      "Files must follow strict .claude/*.local.md naming convention",
      "No automatic validation of settings schema",
      "Manual gitignore configuration required to prevent committing local settings"
    ],
    "use_cases": [
      {
        "title": "Configuration-Driven Validation Hooks",
        "description": "Create a hook that reads validation strictness from a settings file, allowing users to toggle between strict/standard/lenient modes without editing hook code",
        "target_user": "Plugin developers building security or validation tools"
      },
      {
        "title": "Multi-Agent Coordination State",
        "description": "Store agent-specific task assignments, dependencies, and coordinator session info to enable autonomous agent swarms working on different parts of a project",
        "target_user": "Teams using multi-agent workflows for parallel development"
      },
      {
        "title": "Iterative Loop Configuration",
        "description": "Configure autonomous loops with max iterations, completion promises, and dynamic prompts stored in markdown body for tasks like fixing linting errors",
        "target_user": "Users automating repetitive refactoring or cleanup tasks"
      },
      {
        "title": "Per-Project Plugin Toggles",
        "description": "Allow users to enable/disable plugins on a per-project basis without modifying global hooks.json configuration",
        "target_user": "Developers working across multiple projects with different tooling needs"
      }
    ],
    "prompt_templates": [
      {
        "title": "Create Plugin Settings File",
        "prompt": "Create a settings file at .claude/my-plugin.local.md that stores enabled status (true/false), validation mode (strict/standard/lenient), and max file size (1000000 bytes). Ask me for my preferences first.",
        "scenario": "When setting up a new plugin for the first time in a project"
      },
      {
        "title": "Read and Apply Settings in Hook",
        "prompt": "Help me write a hook that reads .claude/security-scan.local.md and only runs if enabled: true. It should extract the strictness_level field and apply different validation rules based on whether it's set to 'strict' or 'standard'.",
        "scenario": "When implementing configuration-driven hook behavior"
      },
      {
        "title": "Parse Settings for Agent State",
        "prompt": "Show me how to extract the task_number, pr_number, and coordinator_session fields from .claude/multi-agent-swarm.local.md in a bash hook, then send a notification to the coordinator session.",
        "scenario": "When building multi-agent coordination systems"
      },
      {
        "title": "Validate Settings File Structure",
        "prompt": "Run the validate-settings.sh script on my .claude/my-plugin.local.md file to check if the YAML frontmatter is properly formatted.",
        "scenario": "When debugging settings file parsing issues"
      }
    ],
    "output_examples": [
      {
        "input": "Create a basic plugin settings file",
        "output": "Created .claude/my-plugin.local.md:\n---\nenabled: true\nmode: standard\nmax_file_size: 1000000\n---\n\n# Plugin Configuration\n\nYour plugin is configured with standard validation mode.\nEdit this file and restart Claude Code to apply changes."
      },
      {
        "input": "Parse the 'enabled' field from settings",
        "output": "FRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \".claude/my-plugin.local.md\")\nENABLED=$(echo \"$FRONTMATTER\" | grep '^enabled:' | sed 's/enabled: *//')\n\nif [[ \"$ENABLED\" == \"true\" ]]; then\n  # Plugin is enabled\nfi"
      }
    ],
    "best_practices": [
      "Always use quick-exit pattern: check if settings file exists before parsing to avoid errors",
      "Use atomic file updates with temp files when modifying settings (mv prevents corruption)",
      "Strip surrounding quotes from YAML values to handle both quoted and unquoted formats",
      "Provide sensible defaults when settings file doesn't exist",
      "Add .claude/*.local.md to .gitignore to prevent committing user-local configuration",
      "Document that settings changes require Claude Code restart in plugin README",
      "Validate field values and handle missing/corrupt files gracefully",
      "Use the enabled: true/false pattern for easy plugin activation control",
      "Cache parsed frontmatter if reading multiple fields to avoid redundant parsing"
    ],
    "anti_patterns": [
      "Don't use hardcoded absolute paths - always use relative .claude/ paths",
      "Don't use sed -i for in-place updates - can corrupt files if interrupted",
      "Don't leave variables unquoted in bash - always use \"$VARIABLE\"",
      "Don't assume fields exist - check for empty values and provide defaults",
      "Don't skip validation - sanitize user input before writing to settings files",
      "Don't use non-atomic updates that can leave files in inconsistent state",
      "Don't forget to document the restart requirement for settings changes"
    ],
    "faq": [
      {
        "question": "Why use .local.md files instead of JSON or pure YAML?",
        "answer": "The .local.md format combines structured configuration (YAML frontmatter) with human-readable documentation (markdown body). The .local suffix clearly indicates user-local files that shouldn't be committed. Markdown bodies can store prompts or task descriptions that get fed back to Claude."
      },
      {
        "question": "Do settings changes take effect immediately?",
        "answer": "No, settings changes require restarting Claude Code. Hooks are loaded at startup and cannot be hot-swapped within a session. Exit and restart Claude Code after editing settings files."
      },
      {
        "question": "How do I parse complex YAML structures like lists or nested objects?",
        "answer": "For simple lists, use string matching. For proper array/object parsing, install yq (brew install yq) and use: echo \"$FRONTMATTER\" | yq -o json '.field'. The skill focuses on sed/grep/awk for maximum compatibility."
      },
      {
        "question": "Can multiple plugins share the same settings file?",
        "answer": "No, each plugin should have its own .claude/plugin-name.local.md file. This prevents conflicts and makes it clear which plugin owns which settings."
      },
      {
        "question": "What happens if the settings file is corrupted or missing?",
        "answer": "Good hooks use the quick-exit pattern: if the file doesn't exist, exit 0 immediately and use defaults. Always validate parsed values and fall back to defaults if validation fails."
      },
      {
        "question": "How do I update settings from within a running hook?",
        "answer": "Use atomic updates: write to a temp file with unique name (${FILE}.tmp.$$), then use mv to atomically replace the original. This prevents corruption if the process is interrupted."
      }
    ],
    "technical_requirements": {
      "dependencies": [
        "bash",
        "sed",
        "awk",
        "grep",
        "jq (optional for JSON construction)",
        "yq (optional for complex YAML)"
      ],
      "permissions": [
        "read/write access to .claude/ directory"
      ],
      "complexity": "intermediate"
    }
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "create-settings-command.md",
          "type": "file",
          "path": "examples/create-settings-command.md"
        },
        {
          "name": "example-settings.md",
          "type": "file",
          "path": "examples/example-settings.md"
        },
        {
          "name": "read-settings-hook.sh",
          "type": "file",
          "path": "examples/read-settings-hook.sh"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "parsing-techniques.md",
          "type": "file",
          "path": "references/parsing-techniques.md"
        },
        {
          "name": "real-world-examples.md",
          "type": "file",
          "path": "references/real-world-examples.md"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "parse-frontmatter.sh",
          "type": "file",
          "path": "scripts/parse-frontmatter.sh"
        },
        {
          "name": "validate-settings.sh",
          "type": "file",
          "path": "scripts/validate-settings.sh"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}