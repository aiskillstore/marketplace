class Fiber < Object
  def self.[]: (Symbol) -> untyped

  def self.[]=: [A] (Symbol, A) -> A

  def self.blocking: [T] () { (Fiber) -> T } -> T

  def self.blocking?: () -> untyped

  def self.current: () -> Fiber

  def self.current_scheduler: () -> untyped?

  def self.schedule: () { () -> void } -> Fiber

  def self.scheduler: () -> untyped?

  def self.set_scheduler: (untyped) -> untyped

  def self.yield: (*untyped) -> untyped

  def initialize: (?blocking: boolish, ?storage: true | Hash[interned, untyped] | nil) { (?) -> void } -> void

  def alive?: () -> bool

  def backtrace: (?Integer start, ?Integer count) -> Array[String]?
               | (Range[Integer]) -> Array[String]?

  def backtrace_locations: (?Integer start, ?Integer count) -> Array[Thread::Backtrace::Location]?
                         | (Range[Integer]) -> Array[Thread::Backtrace::Location]?

  def blocking?: () -> bool

  alias inspect to_s

  def kill: () -> nil

  def raise: (?string msg, ?cause: Exception?) -> untyped
           | (_Exception, ?string msg, ?Array[string] | Array[Thread::Backtrace::Location] | nil backtrace, ?cause: Exception?) -> untyped

  def resume: (*untyped) -> untyped

  def storage: () -> Hash[interned, untyped]

  def storage=: (Hash[interned, untyped]) -> Hash[interned, untyped]

  def to_s: () -> untyped

  def transfer: (*untyped) -> untyped
end
