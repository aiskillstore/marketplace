class Struct[Elem]
  include Enumerable[Elem]

  type index = String | Symbol | int

  def self.new: (string? classname, *interned fields, ?keyword_init: boolish?) ?{ (singleton(Struct)) [self: singleton(Struct)] -> void } -> untyped
              | (Symbol field1, *interned fields, ?keyword_init: boolish?) ?{ (singleton(Struct)) [self: singleton(Struct)] -> void } -> untyped

  def self.members: () -> Array[Symbol]

  def self.keyword_init?: () -> bool?

  def ==: (untyped other) -> bool

  def eql?: (untyped other) -> bool

  def hash: () -> Integer

  def inspect: () -> String

  alias to_s inspect

  def to_a: () -> Array[Elem]

  def to_h: () -> Hash[Symbol, Elem]
          | [K, V] () { (Symbol key, Elem value) -> [K, V] } -> Hash[K, V]

  alias values to_a

  def size: () -> Integer

  alias length size

  def each: () -> Enumerator[Elem, self]
          | () { (Elem value) -> void } -> self

  def each_pair: () -> Enumerator[[Symbol, Elem], self]
               | () { ([Symbol, Elem] key_value) -> void } -> self

  def []: (index name_or_position) -> Elem

  def []=: (index name_or_position, Elem value) -> Elem

  def select: () -> Enumerator[Elem, Array[Elem]]
            | () { (Elem value) -> boolish } -> Array[Elem]

  alias filter select

  def values_at: (*int | range[int?] positions) -> Array[Elem]

  def members: () -> Array[Symbol]

  def dig: (index name_or_position) -> Elem
         | (index name_or_position, untyped, *untyped) -> untyped

  alias deconstruct to_a

  def deconstruct_keys: (Array[index & Hash::_Key]? indices) -> Hash[index & Hash::_Key, Elem]
end
