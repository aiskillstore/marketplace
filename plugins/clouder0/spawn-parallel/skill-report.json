{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T12:44:27.997Z",
    "slug": "clouder0-spawn-parallel",
    "source_url": "https://github.com/Clouder0/dotagent/tree/main/.claude/skills/spawn-parallel",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "c1895c6aae82ec2f41ba79bb4aa149682c9205017c21331d449c5e5f028f0b2d",
    "tree_hash": "e31e3013474ccb2dd1aedba139dacd7d06d81be3e75a8cf10a04fe554f949f19"
  },
  "skill": {
    "name": "spawn-parallel",
    "description": "Pattern for spawning parallel subagents efficiently. Use when you need multiple independent tasks done concurrently.",
    "summary": "Pattern for spawning parallel subagents efficiently. Use when you need multiple independent tasks do...",
    "icon": "⚡",
    "version": "1.0.0",
    "author": "Clouder0",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "parallel",
      "concurrency",
      "subagents",
      "orchestration"
    ],
    "supported_tools": [
      "claude",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a documentation-only skill that explains patterns for parallel subagent spawning. It contains no executable code, network calls, or file operations. The skill describes best practices for coordinating multiple AI agents safely.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 146,
    "audit_model": "claude",
    "audited_at": "2026-01-10T12:44:27.997Z"
  },
  "content": {
    "user_title": "Spawn Parallel Subagents Efficiently",
    "value_statement": "Running multiple AI tasks sequentially wastes time. This pattern lets you spawn parallel subagents to work concurrently, dramatically reducing total execution time.",
    "seo_keywords": [
      "parallel subagents",
      "Claude parallel",
      "concurrent AI tasks",
      "dotagent",
      "spawn parallel",
      "multi-agent orchestration",
      "Claude Code parallel",
      "AI concurrency"
    ],
    "actual_capabilities": [
      "Spawn multiple subagents in parallel using single response",
      "Coordinate independent tasks without conflicts",
      "Handle failures with retry strategies",
      "Define clear file ownership boundaries per agent"
    ],
    "limitations": [
      "Requires independent tasks with no data dependencies",
      "Cannot modify same files across parallel agents",
      "Limited to dotagent ecosystem agents",
      "Results collected only after all agents complete"
    ],
    "use_cases": [
      {
        "target_user": "Developers",
        "title": "Parallel Code Exploration",
        "description": "Explore authentication, API routes, and database models simultaneously to understand codebase structure faster."
      },
      {
        "target_user": "DevOps Engineers",
        "title": "Multi-Service Deployment",
        "description": "Deploy frontend, backend, and database changes concurrently while maintaining service boundaries."
      },
      {
        "target_user": "QA Teams",
        "title": "Parallel Test Execution",
        "description": "Run unit tests, integration tests, and security scans in parallel to speed up CI/CD pipelines."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Parallel Spawn",
        "scenario": "Run 3 independent exploration tasks",
        "prompt": "Spawn 3 explorer agents to analyze src/auth, src/api, and src/db concurrently. Return findings as compact JSON."
      },
      {
        "title": "Mixed Agent Types",
        "scenario": "Implement with different boundaries",
        "prompt": "Spawn implementer for user validation (owns validators/) and email service (owns services/) with read-only access to shared types."
      },
      {
        "title": "Failure Recovery",
        "scenario": "Handle agent failures gracefully",
        "prompt": "Spawn parallel agents with retry logic. If any fail after 3 attempts, record failure and continue with successful agents."
      },
      {
        "title": "Advanced Coordination",
        "scenario": "Complex multi-stage parallel workflow",
        "prompt": "Spawn explorers to find issues, then spawn implementers to fix them in parallel, with contract-resolver for conflicts."
      }
    ],
    "output_examples": [
      {
        "input": "Spawn 3 parallel explorers for auth, API, and database analysis",
        "output": [
          "✓ Authentication explorer: Found 5 auth middlewares, 3 providers",
          "✓ API explorer: Discovered 12 endpoints, 2 rate limiters",
          "✓ Database explorer: Identified 8 models, 3 relationships",
          "Total time: 45 seconds (vs 2+ minutes sequential)"
        ]
      }
    ],
    "best_practices": [
      "Define clear file ownership boundaries to prevent conflicts between parallel agents",
      "Use haiku model for fast exploration tasks and sonnet for complex implementation work",
      "Always validate outputs and handle failures before proceeding with dependent tasks"
    ],
    "anti_patterns": [
      "Spawning agents that modify the same files - causes conflicts and data loss",
      "Creating dependencies between parallel tasks - defeats concurrency benefits",
      "Ignoring failure handling - one failed agent should not stop the entire batch"
    ],
    "faq": [
      {
        "question": "Which subagent types can I spawn in parallel?",
        "answer": "explorer, implementer, verifier, and tester agents. Use explorer for fast scouting, implementer for coding, verifier for checking work."
      },
      {
        "question": "How many parallel agents can I spawn at once?",
        "answer": "No hard limit, but practical maximum is 5-10 agents. More agents create diminishing returns and increase coordination overhead."
      },
      {
        "question": "Can parallel agents share data or files?",
        "answer": "Yes, with read-only access to shared resources. Each agent should have exclusive write access to prevent conflicts."
      },
      {
        "question": "What happens if one agent fails?",
        "answer": "Other agents continue running. Failed agents are retried up to 3 times with enhanced context before being recorded as failed."
      },
      {
        "question": "How do I prevent agents from conflicting?",
        "answer": "Define clear file ownership in boundaries, use contracts for shared interfaces, and ensure tasks are truly independent."
      },
      {
        "question": "Is this compatible with standard Claude Code agents?",
        "answer": "No, this pattern uses custom dotagent agents (lowercase names). Built-in Claude Code agents like Explore have different behavior."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
