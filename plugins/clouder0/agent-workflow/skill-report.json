{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T12:25:21.060Z",
    "slug": "clouder0-agent-workflow",
    "source_url": "https://github.com/Clouder0/dotagent/tree/main/.claude/skills/agent-workflow",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "e6ed059be1000d14dbfc5719d233d84eb602cf822bf9aecd8619170bab5b8a84",
    "tree_hash": "8c2300e9fefa144c665b9d50c672d2753cde3ebb1096e99cf25b87615552d617"
  },
  "skill": {
    "name": "agent-workflow",
    "description": "Multi-agent development workflow system. Load when orchestrating development tasks, spawning subagents, or managing workflow phases.",
    "summary": "Multi-agent development workflow system. Load when orchestrating development tasks, spawning subagen...",
    "icon": "ðŸ”„",
    "version": "1.0.0",
    "author": "Clouder0",
    "license": "MIT",
    "category": "productivity",
    "tags": [
      "workflow",
      "multi-agent",
      "orchestration",
      "development",
      "automation"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing only markdown content. No executable code, scripts, network calls, or filesystem access beyond reading its own file. Defines workflow patterns for a multi-agent system.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 130,
    "audit_model": "claude",
    "audited_at": "2026-01-10T12:25:21.060Z"
  },
  "content": {
    "user_title": "Manage multi-agent development workflows",
    "value_statement": "Complex development projects often require coordination across multiple specialized agents. This skill provides a structured workflow system to orchestrate requirements gathering, architectural design, implementation, verification, and continuous learning phases.",
    "seo_keywords": [
      "Claude Code workflow",
      "multi-agent orchestration",
      "AI development automation",
      "agent spawning",
      "workflow management",
      "task delegation",
      "parallel development",
      "CI/CD automation",
      "Claude",
      "Codex"
    ],
    "actual_capabilities": [
      "Manages five-phase development workflow: REQUIREMENTS, ARCHITECTURE, IMPLEMENTATION, VERIFICATION, REFLECTION",
      "Spawns specialized subagents (PM, architect, executor, qa, explorer, implementer, verifier)",
      "Coordinates multi-agent collaboration through hierarchical tier system",
      "Handles workflow phase transitions and state persistence"
    ],
    "limitations": [
      "Requires Dotagent framework to execute agent spawning",
      "Does not execute code directly - provides orchestration patterns only",
      "Built-in Claude Code agents must be used separately from custom dotagent types"
    ],
    "use_cases": [
      {
        "target_user": "Tech leads",
        "title": "Coordinate complex projects",
        "description": "Break down large features into parallel work streams managed by specialized agents"
      },
      {
        "target_user": "DevOps engineers",
        "title": "Automate development pipelines",
        "description": "Implement verification and testing phases that run independently of implementation"
      },
      {
        "target_user": "Engineering managers",
        "title": "Track team progress",
        "description": "Use reflection phase to capture learnings and improve future workflow iterations"
      }
    ],
    "prompt_templates": [
      {
        "title": "Start new project",
        "scenario": "Begin a complex development task",
        "prompt": "Load the agent-workflow skill. Start the REQUIREMENTS phase for: [describe your project]. Output requirements to memory/reports/requirements.json"
      },
      {
        "title": "Parallel architecture",
        "scenario": "Design solution with multiple architects",
        "prompt": "Load agent-workflow. Transition to ARCHITECTURE phase. Spawn 3 architect subagents with different perspectives (performance-focused, security-focused, maintainability-focused). Synthesize their designs."
      },
      {
        "title": "Implement with verification",
        "scenario": "Execute implementation with parallel testing",
        "prompt": "Load agent-workflow. Enter IMPLEMENTATION phase. Spawn executor to coordinate implementers. Parallel to this, spawn qa to prepare verification tests."
      },
      {
        "title": "Continuous improvement",
        "scenario": "Review and improve after completion",
        "prompt": "Load agent-workflow. Enter REFLECTION phase. Analyze what worked in the previous workflow. Identify 3 improvements for future iterations. Output to memory/reflections/"
      }
    ],
    "output_examples": [
      {
        "input": "Load agent-workflow and start the REQUIREMENTS phase for building a REST API",
        "output": [
          "Phase: REQUIREMENTS - Starting requirements gathering",
          "Agent: PM - Spawned for requirements collection",
          "Tasks: Define API endpoints, data models, authentication requirements, performance targets",
          "Output: memory/reports/requirements.json"
        ]
      }
    ],
    "best_practices": [
      "Use the appropriate tier agent for each task tier to avoid overloading simple agents",
      "Transition through phases sequentially to maintain workflow integrity",
      "Always complete the REFLECTION phase to capture learnings for future improvements"
    ],
    "anti_patterns": [
      "Spawning complex tasks in tier-2 (focused worker) agents meant for single tasks",
      "Skipping the REQUIREMENTS phase leads to unclear implementation goals",
      "Using built-in Claude Code agents interchangeably with custom dotagent types"
    ],
    "faq": [
      {
        "question": "What is the difference between custom dotagent types and built-in Claude Code agents?",
        "answer": "Custom types (pm, architect, executor) are framework-specific with defined roles. Built-in types (Explore, Plan, general-purpose) are always available in Claude Code."
      },
      {
        "question": "Can I skip workflow phases?",
        "answer": "Phases can be skipped but it may cause issues. Requirements define implementation goals. Verification catches bugs. Reflection captures learnings."
      },
      {
        "question": "How many subagents can I spawn?",
        "answer": "The system supports multiple parallel subagents per phase. Use judgment to avoid overwhelming the context window."
      },
      {
        "question": "Is my workflow data saved between sessions?",
        "answer": "State is persisted to memory/state/phase.json. Reflection outputs go to memory/reflections/ for cross-task learning."
      },
      {
        "question": "What happens if a subagent fails?",
        "answer": "The contract-resolver agent handles blocked tasks. It can escalate, re-scope, or escalate issues back to human operators."
      },
      {
        "question": "How does this compare to using multiple ConversationMode sessions?",
        "answer": "This provides structured coordination with phase management, state persistence, and specialized agent definitions rather than independent parallel conversations."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
