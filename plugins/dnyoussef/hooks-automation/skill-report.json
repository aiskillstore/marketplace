{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T13:14:19.878Z",
    "slug": "dnyoussef-hooks-automation",
    "source_url": "https://github.com/DNYoussef/ai-chrome-extension/tree/main/.claude/skills/hooks-automation",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "65fa3b4a38ec231c3e74110cc0d48d1063a53f4a9ddaea8924b0efd757cbd99e",
    "tree_hash": "f4de95ec5233ae953ea77e6e19256716793cb2b8ae316402df27cdaedcac0136"
  },
  "skill": {
    "name": "Hooks Automation",
    "description": "Automated coordination, formatting, and learning from Claude Code operations using intelligent hooks with MCP integration. Includes pre/post task hooks, session management, Git integration, memory coordination, and neural pattern training for enhanced development workflows.",
    "summary": "Automated coordination, formatting, and learning from Claude Code operations using intelligent hooks...",
    "icon": "ü™ù",
    "version": "1.0.0",
    "author": "DNYoussef",
    "license": "MIT",
    "category": "coordination",
    "tags": [
      "hooks",
      "automation",
      "coordination",
      "mcp",
      "workflows"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill is a pure documentation file describing a CLI-based hook automation system. It contains no executable code, only markdown documentation for using claude-flow commands. The documented tool operates on project-local configuration files (.claude/settings.json) and uses standard MCP tool protocols for coordination.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 1202,
    "audit_model": "claude",
    "audited_at": "2026-01-10T13:14:19.878Z"
  },
  "content": {
    "user_title": "Automate Claude Code operations with intelligent hooks",
    "value_statement": "Manual coordination of multi-agent workflows wastes time and creates inconsistencies. This skill provides automated pre and post operation hooks that validate, format, track, and learn from every Claude Code operation. It enables seamless agent spawning, session persistence, and pattern learning across your development workflow.",
    "seo_keywords": [
      "Claude Code hooks",
      "claude-flow automation",
      "MCP integration",
      "Claude automation",
      "swarm coordination",
      "agent orchestration",
      "Claude Code workflow",
      "Codex hooks automation",
      "Claude Code CLI tools"
    ],
    "actual_capabilities": [
      "Pre and post operation hooks for validation, formatting, and memory storage",
      "Automatic agent spawning and assignment based on task type",
      "Session state persistence and cross-session memory coordination",
      "Git integration hooks for commit quality gates and testing",
      "MCP tool integration for swarm coordination and neural pattern training",
      "Custom hook creation for specialized workflow automation"
    ],
    "limitations": [
      "Requires claude-flow CLI installation and configuration",
      "Hooks execute via external npx commands, not inline code",
      "Memory coordination depends on configured MCP servers",
      "Neural pattern training requires connected MCP tools"
    ],
    "use_cases": [
      {
        "target_user": "Multi-agent development teams",
        "title": "Coordinate agent swarms",
        "description": "Automate handoffs between specialized agents with shared memory and progress tracking."
      },
      {
        "target_user": "Quality-focused developers",
        "title": "Enforce code quality gates",
        "description": "Run validation, formatting, and tests automatically before and after every code change."
      },
      {
        "target_user": "Large project maintainers",
        "title": "Track long-term patterns",
        "description": "Persist session state and learn from successful refactoring and debugging patterns."
      }
    ],
    "prompt_templates": [
      {
        "title": "Initialize hooks",
        "scenario": "Set up hook automation for a new project",
        "prompt": "Use the hooks automation skill to initialize the hooks system for my project. Configure pre-edit, pre-task, and post-edit hooks with automatic agent assignment and memory storage."
      },
      {
        "title": "Create custom hook",
        "scenario": "Add specialized validation to workflow",
        "prompt": "Create a custom quality check hook that validates complexity and security before allowing edits to TypeScript files. Register it in .claude/settings.json."
      },
      {
        "title": "Multi-agent workflow",
        "scenario": "Coordinate backend and frontend agents",
        "prompt": "Start a session with hooks enabled. Spawn backend and frontend agents. Use post-edit hooks to share implementation details between agents via memory coordination."
      },
      {
        "title": "Debug with session restore",
        "scenario": "Resume interrupted debugging work",
        "prompt": "Restore the previous debugging session. Load context from memory. Continue debugging the memory leak issue with hooks tracking progress."
      }
    ],
    "output_examples": [
      {
        "input": "Initialize hooks automation for my React project with pre-edit validation and auto-formatting",
        "output": [
          "Initialized hooks configuration in .claude/settings.json",
          "Pre-edit hook: validates syntax, checks protected files, auto-assigns agents",
          "Post-edit hook: formats code with Prettier, stores changes in memory, trains patterns",
          "Session hooks: automatically save state on end, restore context on start"
        ]
      }
    ],
    "best_practices": [
      "Configure hooks early in the project lifecycle to establish consistent workflow patterns",
      "Use memory keys with clear namespaces (e.g., auth/, api/, components/) for organized coordination",
      "Set appropriate timeouts in configuration to prevent hooks from blocking the main flow"
    ],
    "anti_patterns": [
      "Overloading hooks with heavy synchronous operations that slow down every interaction",
      "Storing sensitive data like credentials or tokens in memory keys without encryption",
      "Ignoring hook errors without continueOnError which can block valid operations"
    ],
    "faq": [
      {
        "question": "Does this skill work with Claude Code directly?",
        "answer": "Yes. Configure hooks in .claude/settings.json to run claude-flow commands before and after Claude Code operations."
      },
      {
        "question": "What MCP servers are supported?",
        "answer": "claude-flow, ruv-swarm, and flow-nexus MCP servers for swarm coordination and memory persistence."
      },
      {
        "question": "Can I use hooks without MCP tools?",
        "answer": "Basic hooks work standalone. Memory coordination and neural training require connected MCP servers."
      },
      {
        "question": "Is my code data safe with memory coordination?",
        "answer": "Memory is stored locally via MCP tools. Configure namespaces and TTLs to control data retention."
      },
      {
        "question": "Why are my hooks not executing?",
        "answer": "Check .claude/settings.json syntax, verify claude-flow is in PATH, and enable debug mode to troubleshoot."
      },
      {
        "question": "How does this compare to pre-commit hooks?",
        "answer": "Hooks work at Claude Code level, not just Git. They coordinate agents, store memory, and track patterns beyond commits."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
