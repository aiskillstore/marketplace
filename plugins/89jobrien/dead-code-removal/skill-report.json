{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T09:26:10.599Z",
    "slug": "89jobrien-dead-code-removal",
    "source_url": "https://github.com/89jobrien/steve/tree/main/steve/skills/dead-code-removal",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "4e4588ad8f57062cc8de6267d0a93b49cb80f28e3005e61aa1769495257b7d50",
    "tree_hash": "0c3d9766aab3b4151abff65f10eeb0e827a1feea2370fe30a82b40cc5a48b1a9"
  },
  "skill": {
    "name": "dead-code-removal",
    "description": "Detects and safely removes unused code (imports, functions, classes) across multiple languages. Use after refactoring, when removing features, or before production deployment. Includes safety checks and validation.",
    "summary": "Detects and safely removes unused code (imports, functions, classes) across multiple languages. Use ...",
    "icon": "ðŸ§¹",
    "version": "1.0.1",
    "author": "Joseph OBrien",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "code cleanup",
      "refactoring",
      "optimization",
      "static analysis"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill contains a Python helper script for AST-based import analysis and documentation. The script only reads files passed as arguments and outputs JSON analysis results. No network calls, no credential access, no persistence mechanisms. Filesystem access is necessary for a code analysis tool and matches the stated purpose.",
    "risk_factor_evidence": [
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "scripts/find-unused-imports.py",
            "line_start": 1,
            "line_end": 109
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "scripts/find-unused-imports.py",
            "line_start": 48,
            "line_end": 51
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 435,
    "audit_model": "claude",
    "audited_at": "2026-01-10T09:26:10.599Z"
  },
  "content": {
    "user_title": "Remove Dead Code Safely",
    "value_statement": "Unused code bloats projects and increases maintenance costs. This skill detects unused imports, functions, and classes across multiple languages with safety checks that preserve critical code.",
    "seo_keywords": [
      "dead code removal",
      "unused import detection",
      "code cleanup",
      "Claude Code skill",
      "code refactoring",
      "static analysis",
      "code optimization",
      "bundle size reduction",
      "code quality"
    ],
    "actual_capabilities": [
      "Detects unused imports in Python files using AST parsing",
      "Identifies unused functions and classes across codebases",
      "Builds dependency graphs to map code relationships",
      "Preserves framework patterns and entry points",
      "Creates backups before removing code",
      "Validates changes with syntax checks"
    ],
    "limitations": [
      "Does not execute code or run tests automatically",
      "Cannot detect dynamically referenced code in all cases",
      "Limited to languages with static analysis support",
      "May miss runtime-only references without full context"
    ],
    "use_cases": [
      {
        "target_user": "Software Developers",
        "title": "Clean Up After Refactoring",
        "description": "Remove unused code left behind after feature development or refactoring sessions."
      },
      {
        "target_user": "DevOps Engineers",
        "title": "Reduce Bundle Size",
        "description": "Identify and remove dead code before deployment to reduce bundle size and improve performance."
      },
      {
        "target_user": "Code Reviewers",
        "title": "Maintain Code Quality",
        "description": "Find and report unused code during code reviews to keep the codebase lean."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Cleanup",
        "scenario": "Remove all unused code",
        "prompt": "Find and remove all unused imports and functions in this project. Use conservative mode and create a backup first."
      },
      {
        "title": "Specific Directory",
        "scenario": "Clean a specific folder",
        "prompt": "Clean up dead code in the src/utils/ directory. Identify unused imports and functions but ask before removing."
      },
      {
        "title": "Import Analysis",
        "scenario": "Find unused imports",
        "prompt": "Use the find-unused-imports.py script to analyze src/ and find all unused imports. Show me the results."
      },
      {
        "title": "Safety Review",
        "scenario": "Safe removal with checks",
        "prompt": "Analyze the codebase for unused code. Apply safety checks for dynamic usage patterns like getattr, eval, and dynamic imports before removing anything."
      }
    ],
    "output_examples": [
      {
        "input": "Remove unused imports and functions from src/utils/helpers.py",
        "output": [
          "Analysis of src/utils/helpers.py:",
          "- 8 imports found, 3 unused",
          "- Unused: os (line 2), json (line 3), timedelta (line 5)",
          "- 2 functions analyzed, 0 unused",
          "- Safe to remove: All 3 imports",
          "Validation: Syntax check passed, no dynamic usage detected"
        ]
      }
    ],
    "best_practices": [
      "Always run tests after removing code to verify nothing breaks",
      "Create backups before batch removals to enable quick rollback",
      "Preserve framework patterns like routes, components, and controllers"
    ],
    "anti_patterns": [
      "Removing code without understanding its purpose or dependencies",
      "Skipping safety checks for dynamic usage patterns",
      "Batch removing without incremental validation"
    ],
    "faq": [
      {
        "question": "Which languages does this skill support?",
        "answer": "Python, JavaScript, TypeScript, Java, Go, and Rust with language-specific detection patterns."
      },
      {
        "question": "What safety checks are performed before removal?",
        "answer": "Checks for dynamic imports, reflection usage, framework patterns, and entry point references."
      },
      {
        "question": "Does this skill modify files directly?",
        "answer": "The skill recommends changes and creates backups but prompts before applying removals."
      },
      {
        "question": "Is my code data safe?",
        "answer": "The skill only reads files for analysis. No data is sent externally or stored beyond local backups."
      },
      {
        "question": "What happens if removal breaks my code?",
        "answer": "Backups are created before changes. You can restore from the backup directory if issues occur."
      },
      {
        "question": "How is this different from linters?",
        "answer": "This skill performs deeper dependency analysis across files, not just local syntax checks."
      }
    ]
  },
  "file_structure": [
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "find-unused-imports.py",
          "type": "file",
          "path": "scripts/find-unused-imports.py"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
