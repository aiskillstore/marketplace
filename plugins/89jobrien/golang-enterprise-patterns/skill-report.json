{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T09:28:24.896Z",
    "slug": "89jobrien-golang-enterprise-patterns",
    "source_url": "https://github.com/89jobrien/steve/tree/main/steve/skills/golang-enterprise-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "e260a79b8ebf66a1c89d90c3fb089d9cfb9f470bec89784655a949081472a3fa",
    "tree_hash": "1760e3c8216de07e86caf3cb5df0a5c95a086c89b149fceb1eaca8c8a06c5a41"
  },
  "skill": {
    "name": "golang-enterprise-patterns",
    "description": "Enterprise-level Go architecture patterns including clean architecture, hexagonal architecture, DDD, and production-ready application structure.",
    "summary": "Enterprise-level Go architecture patterns including clean architecture, hexagonal architecture, DDD,...",
    "icon": "ðŸ”·",
    "version": "1.0.1",
    "author": "Joseph OBrien",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "golang",
      "architecture",
      "enterprise",
      "clean-code",
      "ddd"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a documentation-only skill containing architectural guidance for Go applications. No executable code, network calls, filesystem access, or command execution. Pure informational content.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 362,
    "audit_model": "claude",
    "audited_at": "2026-01-10T09:28:24.896Z"
  },
  "content": {
    "user_title": "Apply Enterprise Go Architecture Patterns",
    "value_statement": "Building scalable Go applications requires proven architectural patterns. This skill provides guidance on clean architecture, hexagonal architecture, and DDD principles for production-ready code.",
    "seo_keywords": [
      "golang enterprise patterns",
      "clean architecture golang",
      "hexagonal architecture go",
      "domain driven design golang",
      "go architecture patterns",
      "golang best practices",
      "claude code",
      "claude",
      "codex"
    ],
    "actual_capabilities": [
      "Guides clean architecture implementation with layer structure",
      "Explains hexagonal architecture with ports and adapters",
      "Provides Domain-Driven Design patterns for Go",
      "Shows dependency injection patterns for testable code",
      "Documents error handling and configuration patterns"
    ],
    "limitations": [
      "Does not generate code files automatically",
      "Does not execute or test Go code",
      "Does not integrate with build tools or CI/CD",
      "Does not provide project scaffolding"
    ],
    "use_cases": [
      {
        "target_user": "Backend Engineers",
        "title": "Design Enterprise Systems",
        "description": "Architect scalable Go services using clean architecture principles and layered design patterns."
      },
      {
        "target_user": "Tech Leads",
        "title": "Establish Team Standards",
        "description": "Define consistent project structure and coding patterns across development teams."
      },
      {
        "target_user": "DevOps Engineers",
        "title": "Understand Code Organization",
        "description": "Comprehend application structure to improve deployment and monitoring strategies."
      }
    ],
    "prompt_templates": [
      {
        "title": "New Service",
        "scenario": "Starting a new Go microservice",
        "prompt": "Help me design a new Go microservice using clean architecture. What folder structure should I use and how should I organize the layers?"
      },
      {
        "title": "Refactor Code",
        "scenario": "Improving existing codebase",
        "prompt": "How do I refactor a legacy Go application to use hexagonal architecture? Show me the port and adapter pattern."
      },
      {
        "title": "DDD Implementation",
        "scenario": "Applying domain-driven design",
        "prompt": "Explain how to implement domain-driven design in Go. What are aggregate roots and how do I use them?"
      },
      {
        "title": "Error Handling",
        "scenario": "Managing errors gracefully",
        "prompt": "What are the best error handling patterns for enterprise Go applications? Show me how to create custom error types."
      }
    ],
    "output_examples": [
      {
        "input": "Help me design a new Go microservice using clean architecture",
        "output": [
          "â€¢ Organize code with cmd/, internal/, and pkg/ directories",
          "â€¢ Place business logic in internal/domain layer",
          "â€¢ Implement use cases in internal/application layer",
          "â€¢ Create adapters in internal/infrastructure layer",
          "â€¢ Define HTTP handlers in internal/interfaces layer",
          "â€¢ Ensure dependencies flow inward only",
          "â€¢ Use interfaces to decouple layers"
        ]
      }
    ],
    "best_practices": [
      "Keep domain layer pure with no framework dependencies",
      "Define small, focused interfaces for better testability",
      "Apply dependency inversion by depending on abstractions",
      "Fail fast by validating at system boundaries"
    ],
    "anti_patterns": [
      "Do not mix infrastructure concerns with domain logic",
      "Avoid tight coupling between layers",
      "Do not bypass interfaces with direct dependencies",
      "Avoid God objects that handle multiple responsibilities"
    ],
    "faq": [
      {
        "question": "Is this skill compatible with Go 1.22+?",
        "answer": "Yes. All patterns work with Go 1.22 and later versions including generics support."
      },
      {
        "question": "What is the maximum project size this handles?",
        "answer": "Patterns scale from small services to large monorepos with hundreds of packages."
      },
      {
        "question": "Does it integrate with frameworks like Gin or Echo?",
        "answer": "Yes. Framework integrations belong in infrastructure adapters, keeping domain pure."
      },
      {
        "question": "Does this skill collect or store any data?",
        "answer": "No. This is a read-only guidance skill that processes no user data or files."
      },
      {
        "question": "Why is my code not following the patterns?",
        "answer": "Patterns require intentional design. Review layer responsibilities and ensure dependencies flow inward only."
      },
      {
        "question": "How is this different from standard Go practices?",
        "answer": "Enterprise patterns add structure for large teams. Simple projects may not need all layers."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
