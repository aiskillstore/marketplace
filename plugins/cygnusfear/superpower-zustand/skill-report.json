{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T13:04:23.568Z",
    "slug": "cygnusfear-superpower-zustand",
    "source_url": "https://github.com/Cygnusfear/claude-stuff/tree/main/skills/superpower-zustand",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "5ff68790d2526bba50115dabfdbbd23f9e52e975aa0f7699bc2cca70f2c7a2e7",
    "tree_hash": "542b659257aa2c6c79f0fc27f1953a979b3ff3b46812e72d8db01e4f212f71df"
  },
  "skill": {
    "name": "superpower-zustand",
    "description": "MANDATORY for creating Zustand stores. This skill is required when users request state management, creating stores, or mention Zustand. Do NOT create Zustand stores without this skill - all stores must use the required StoreBuilder pattern with immer middleware and factory pattern separation",
    "summary": "MANDATORY for creating Zustand stores. This skill is required when users request state management, c...",
    "icon": "⚡",
    "version": "1.0.0",
    "author": "Cygnusfear",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "zustand",
      "react",
      "state-management",
      "typescript",
      "immer"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill provides a TypeScript utility for creating Zustand stores with standardized patterns. It contains no network calls, file system access, or code execution capabilities. The code is a clean implementation of a state management pattern wrapper.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 3,
    "total_lines": 276,
    "audit_model": "claude",
    "audited_at": "2026-01-10T13:04:23.568Z"
  },
  "content": {
    "user_title": "Create Type-Safe Zustand Stores with Standardized Patterns",
    "value_statement": "Building Zustand stores without consistent patterns leads to messy, hard-to-maintain state management. This skill enforces a standardized StoreBuilder pattern that separates state from actions, integrates immer for immutable updates, and provides optional persistence.",
    "seo_keywords": [
      "zustand",
      "react state management",
      "typescript stores",
      "immer middleware",
      "claude code",
      "claude",
      "codex",
      "persist state",
      "factory pattern"
    ],
    "actual_capabilities": [
      "Creates standardized Zustand stores using StoreBuilder pattern",
      "Integrates immer middleware for immutable state updates",
      "Supports optional localStorage/sessionStorage persistence",
      "Provides both reactive hooks and non-reactive get/set access",
      "Enforces type-safe separation of state and actions",
      "Exports factory pattern for clean action definitions"
    ],
    "limitations": [
      "Requires TypeScript for full type safety benefits",
      "Only works with Zustand state management library",
      "Persistence limited to browser storage APIs",
      "Must follow specific pattern structure"
    ],
    "use_cases": [
      {
        "target_user": "React developers",
        "title": "Standardize State Management",
        "description": "Enforce consistent patterns across your React application's state stores with type-safe factory patterns."
      },
      {
        "target_user": "TypeScript users",
        "title": "Type-Safe State Updates",
        "description": "Build stores with full TypeScript support and immer integration for immutable updates without boilerplate."
      },
      {
        "target_user": "App developers",
        "title": "Persist User Preferences",
        "description": "Create persistent stores that save user settings and preferences across browser sessions."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Counter Store",
        "scenario": "Create a simple counter store",
        "prompt": "Create a Zustand store for a counter with count state and increment/decrement actions using the StoreBuilder pattern"
      },
      {
        "title": "User Preferences",
        "scenario": "Persist theme and language settings",
        "prompt": "Build a persistent store for user preferences including theme (light/dark) and language with localStorage persistence"
      },
      {
        "title": "Async Todo Store",
        "scenario": "Handle async operations",
        "prompt": "Create a todo store with async fetchTodos action, loading state, and error handling using StoreBuilder pattern"
      },
      {
        "title": "Complex Nested State",
        "scenario": "Manage nested object state",
        "prompt": "Implement a store with nested user profile state including settings, preferences, and metadata using immer mutations"
      }
    ],
    "output_examples": [
      {
        "input": "Create a theme store with light/dark mode toggle that persists to localStorage",
        "output": [
          "✓ StoreBuilder initialized with theme state",
          "✓ Type-safe actions for setTheme created",
          "✓ localStorage persistence configured",
          "✓ Factory pattern separates state from actions",
          "✓ Immer enables direct state mutations",
          "✓ React hook exported for component usage"
        ]
      }
    ],
    "best_practices": [
      "Always separate state types from action types using Omit<T, 'actions'>",
      "Use immer-style mutations in set callbacks (mutate draft, don't return objects)",
      "Include persistence config only when state should survive page refreshes",
      "Export descriptive hook names following use[StoreName]Store convention"
    ],
    "anti_patterns": [
      "Never define actions in the initial state object",
      "Don't return new state objects from set callbacks",
      "Avoid accessing store state directly without proper typing",
      "Never skip the StoreBuilder pattern for direct Zustand create() calls"
    ],
    "faq": [
      {
        "question": "Is this compatible with all Zustand versions?",
        "answer": "The pattern works with Zustand v4+ and requires the persist and immer middleware packages."
      },
      {
        "question": "Can I use this outside React components?",
        "answer": "Yes, the StoreBuilder exposes get() and set() functions for non-reactive access anywhere in your code."
      },
      {
        "question": "How does persistence work?",
        "answer": "Persistence uses Zustand's persist middleware with localStorage by default, supporting version migration and partial state persistence."
      },
      {
        "question": "Why must I separate state from actions?",
        "answer": "Separation enables cleaner code organization, better type inference, and follows the factory pattern for maintainability."
      },
      {
        "question": "What if I need async actions?",
        "answer": "Define async functions in createFactory, update loading state before operations, and handle errors with try-catch blocks."
      },
      {
        "question": "How do I migrate existing stores?",
        "answer": "Refactor by extracting state from actions, wrap with StoreBuilder, and test persistence migration if version changes."
      }
    ]
  },
  "file_structure": [
    {
      "name": "assets",
      "type": "dir",
      "path": "assets",
      "children": [
        {
          "name": "storebuilder.ts",
          "type": "file",
          "path": "assets/storebuilder.ts"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "pattern-guide.md",
          "type": "file",
          "path": "references/pattern-guide.md"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
