{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T14:44:38.695Z",
    "slug": "emasoft-ghe-requirements",
    "source_url": "https://github.com/Emasoft/ghe-marketplace/tree/main/plugins/ghe/skills/ghe-requirements",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "1a0117a415aafd4633e25d69ebc9185359a22fbd3bb94604019b8bbaac0b787a",
    "tree_hash": "0bde3aa0b628453c0de397ff9d312937cd41d6d399a3709e742d4efa4d434a8e"
  },
  "skill": {
    "name": "ghe-requirements",
    "description": "This skill should be used when creating, updating, linking, or versioning requirements for GitHub Elements threads. Use when user mentions requirements, specs, REQ files, or when starting feature development. Provides the requirements folder structure, versioning system, and SERENA backup protocols.",
    "summary": "This skill should be used when creating, updating, linking, or versioning requirements for GitHub El...",
    "icon": "ðŸ“‹",
    "version": "1.0.0",
    "author": "Emasoft",
    "license": "MIT",
    "category": "documentation",
    "tags": [
      "requirements",
      "project-management",
      "versioning"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a pure prompt-based documentation skill containing only markdown guidelines and templates for requirements management. No executable code, no network calls, no filesystem manipulation beyond normal AI assistant operations. The bash examples shown are illustrative documentation only.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 327,
    "audit_model": "claude",
    "audited_at": "2026-01-10T14:44:38.695Z"
  },
  "content": {
    "user_title": "Manage GitHub Elements Requirements",
    "value_statement": "Projects struggle with disconnected requirements that drift from implementation. This skill enforces structured requirements management with version tracking, template enforcement, and automatic SERENA backup to keep specifications aligned throughout the development lifecycle.",
    "seo_keywords": [
      "requirements management",
      "GitHub Elements",
      "project specifications",
      "version control",
      "serena backup",
      "acceptance criteria",
      "feature requirements",
      "documentation",
      "Claude Code",
      "project management"
    ],
    "actual_capabilities": [
      "Creates structured REQ markdown files with standardized template format",
      "Implements semantic versioning for requirements (major.minor.patch)",
      "Links requirements to GitHub issues with automatic status tracking",
      "Backs up requirements to SERENA memory bank for persistence",
      "Validates requirements linkage before DEV phase begins",
      "Organizes requirements by epic and wave structure"
    ],
    "limitations": [
      "Does not execute bash commands - provides documentation only",
      "Does not integrate with external APIs or services",
      "Does not generate code implementations from requirements",
      "Does not validate test coverage automatically"
    ],
    "use_cases": [
      {
        "target_user": "Project Managers",
        "title": "Enforce Requirements Standards",
        "description": "Create standardized requirements with templates that all team members must follow for consistent documentation."
      },
      {
        "target_user": "Developers",
        "title": "Link Work to Specifications",
        "description": "Start feature development by linking to approved requirements, ensuring implementation matches user expectations."
      },
      {
        "target_user": "Quality Engineers",
        "title": "Verify Acceptance Criteria",
        "description": "Check that requirements contain testable acceptance criteria before development begins."
      }
    ],
    "prompt_templates": [
      {
        "title": "Create New Requirement",
        "scenario": "Starting a new feature specification",
        "prompt": "Create a new requirements file for [FEATURE NAME] in epic [N] wave [W]. The feature should [BRIEF DESCRIPTION]."
      },
      {
        "title": "Version Update",
        "scenario": "Updating an existing requirement",
        "prompt": "Update REQ-[XXX] from version [X.Y.Z] to [X.Y.Z+1] because [REASON]. Document the changes in the revision history."
      },
      {
        "title": "Link to Issue",
        "scenario": "Connecting requirements to GitHub",
        "prompt": "Create a DEV thread for REQ-[XXX] and link the requirements file in the issue body with current version and acceptance criteria."
      },
      {
        "title": "Validate Requirements",
        "scenario": "Checking specification completeness",
        "prompt": "Review REQ-[XXX] for completeness. Verify it has user story, acceptance criteria, technical requirements, atomic changes, and test requirements defined."
      }
    ],
    "output_examples": [
      {
        "input": "Create a requirements file for a user authentication feature",
        "output": [
          "Creating REQUIREMENTS/epic-5/wave-2/REQ-042-user-authentication.md",
          "Using standard template with user story, acceptance criteria, and technical requirements",
          "Status set to draft - requires approval before DEV phase"
        ]
      }
    ],
    "best_practices": [
      "Always get requirements approved before starting DEV phase work",
      "Update requirements version when acceptance criteria change (major bump)",
      "Link every DEV thread to its primary requirement file",
      "Back up requirements to SERENA after any modification"
    ],
    "anti_patterns": [
      "Starting development without linking to approved requirements",
      "Modifying acceptance criteria without versioning the requirement",
      "Skipping the atomic changes breakdown",
      "Forgetting to update linked issues when requirements change"
    ],
    "faq": [
      {
        "question": "How is requirement versioning different from code versioning?",
        "answer": "Requirements use semantic versioning where major bumps indicate breaking acceptance criteria changes, minor adds new criteria, and patch fixes clarifications."
      },
      {
        "question": "What happens if requirements change during development?",
        "answer": "Update the requirement file, bump the version, and notify all linked issues. The DEV thread must be updated to reflect new acceptance criteria."
      },
      {
        "question": "Can I create requirements without epics or waves?",
        "answer": "Yes. Use the standalone folder for independent requirements not part of any epic-wave structure. File naming remains REQ-XXX-feature.md."
      },
      {
        "question": "How does SERENA backup work?",
        "answer": "Requirements are copied to .serena/memories/requirements/ for persistent memory bank storage, preserving context across sessions."
      },
      {
        "question": "What validation commands are available?",
        "answer": "Check requirements linked in issue, verify file exists, and compare linked version against current file version to catch drift."
      },
      {
        "question": "How does this integrate with thread managers?",
        "answer": "Hephaestus verifies requirements before claiming, Artemis checks tests match requirements, and Hera validates acceptance criteria in review."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
