{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2025-12-30T14:30:48.976Z",
    "slug": "plugin-structure",
    "source_url": "https://github.com/anthropics/claude-code/tree/main/plugins/plugin-dev/skills/plugin-structure",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "trust_level": "official"
  },
  "skill": {
    "name": "Plugin Structure",
    "description": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand plugin structure\", \"organize plugin components\", \"set up plugin.json\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"add commands/agents/skills/hooks\", \"configure auto-discovery\", or needs guidance on plugin directory layout, manifest configuration, component organization, file naming conventions, or Claude Code plugin architecture best practices.",
    "summary": "This skill should be used when the user asks to \"create a plugin\", \"scaffold a plugin\", \"understand ...",
    "icon": "ðŸ”Œ",
    "version": "0.1.0",
    "author": "Anthropic",
    "license": "Not specified",
    "category": "development",
    "tags": [
      "plugins",
      "architecture",
      "structure",
      "claude-code",
      "development",
      "manifest",
      "components",
      "organization"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Official Anthropic skill containing documentation and examples only. No executable code, external connections, or security risks detected. All content is educational reference material.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 7,
    "total_lines": 3146,
    "audit_model": "claude",
    "audited_at": "2025-12-30T14:30:48.975Z"
  },
  "content": {
    "user_title": "Plugin Structure & Architecture Guide",
    "value_statement": "Learn how to create well-organized, maintainable Claude Code plugins with proper directory structure, manifest configuration, and component organization following best practices.",
    "seo_keywords": [
      "claude code plugin",
      "plugin structure",
      "plugin.json",
      "plugin architecture",
      "component organization",
      "auto-discovery",
      "plugin manifest",
      "claude plugin development",
      "plugin best practices"
    ],
    "actual_capabilities": [
      "Provides complete plugin directory structure patterns (minimal, standard, and advanced)",
      "Explains plugin.json manifest configuration with all fields and validation rules",
      "Documents component organization for commands, agents, skills, hooks, and MCP servers",
      "Teaches portable path references using ${CLAUDE_PLUGIN_ROOT}",
      "Covers auto-discovery mechanisms for all component types",
      "Includes three complete working plugin examples (minimal, standard, advanced)",
      "Details file naming conventions and path resolution rules",
      "Provides troubleshooting guidance for common plugin issues"
    ],
    "limitations": [
      "Documentation-focused skill without executable scaffolding tools",
      "Does not automatically generate plugin boilerplate code",
      "Requires manual implementation of described patterns",
      "Does not validate existing plugin structures automatically"
    ],
    "use_cases": [
      {
        "title": "Creating Your First Plugin",
        "description": "Use the minimal plugin example to scaffold a simple plugin with a single command, understanding the bare minimum requirements.",
        "target_user": "Developers new to Claude Code plugin development"
      },
      {
        "title": "Structuring Production Plugins",
        "description": "Follow the standard plugin pattern to organize commands, agents, skills, and hooks with proper metadata for distribution.",
        "target_user": "Developers building plugins for teams or public distribution"
      },
      {
        "title": "Enterprise Plugin Architecture",
        "description": "Implement the advanced plugin pattern with MCP integration, shared libraries, multi-environment configs, and security automation.",
        "target_user": "Enterprise teams building complex DevOps or CI/CD automation"
      },
      {
        "title": "Organizing Existing Plugins",
        "description": "Refactor messy plugin structures using component organization patterns and best practices for maintainability.",
        "target_user": "Developers maintaining existing plugin codebases"
      },
      {
        "title": "Configuring Plugin Manifest",
        "description": "Learn all plugin.json fields, validation rules, and path resolution for proper plugin metadata and component loading.",
        "target_user": "Anyone setting up or troubleshooting plugin.json configuration"
      }
    ],
    "prompt_templates": [
      {
        "title": "Scaffold New Plugin",
        "prompt": "Help me create a new Claude Code plugin called [PLUGIN_NAME] that [DESCRIPTION]. What directory structure should I use?",
        "scenario": "Starting a new plugin project from scratch"
      },
      {
        "title": "Add Component Type",
        "prompt": "I have an existing plugin and want to add [commands/agents/skills/hooks]. How should I organize these and what goes in plugin.json?",
        "scenario": "Extending an existing plugin with new components"
      },
      {
        "title": "Fix Plugin Discovery Issues",
        "prompt": "My plugin's [commands/agents/skills] aren't being discovered by Claude Code. Can you help me troubleshoot the structure?",
        "scenario": "Debugging auto-discovery problems"
      },
      {
        "title": "Convert to Portable Paths",
        "prompt": "My plugin uses hardcoded paths. Help me convert all path references to use ${CLAUDE_PLUGIN_ROOT} for portability.",
        "scenario": "Making a plugin portable across different installations"
      },
      {
        "title": "Refactor Plugin Structure",
        "prompt": "My plugin has grown messy with [NUMBER] components. How should I reorganize it following best practices?",
        "scenario": "Refactoring a growing plugin for better maintainability"
      }
    ],
    "output_examples": [
      {
        "input": "Create a minimal plugin structure for a 'hello-world' plugin",
        "output": "Creates directory structure:\nhello-world/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â””â”€â”€ plugin.json (with name: \"hello-world\")\nâ””â”€â”€ commands/\n    â””â”€â”€ hello.md (with frontmatter and greeting command)\n\nExplains that this is the simplest working plugin with auto-discovery."
      },
      {
        "input": "What fields should I include in plugin.json for a production plugin?",
        "output": "Provides complete manifest example with: name (required), version, description, author object with name/email/url, homepage, repository, license (MIT/Apache-2.0), and keywords array. Explains semantic versioning and SPDX license identifiers."
      },
      {
        "input": "How do I organize a plugin with multiple command categories?",
        "output": "Shows hierarchical structure with separate directories (commands/ci/, commands/deployment/, commands/management/) and explains how to register them in plugin.json commands array. Includes when to use flat vs categorized vs hierarchical patterns."
      }
    ],
    "best_practices": [
      "Always use ${CLAUDE_PLUGIN_ROOT} for intra-plugin path references, never hardcoded absolute paths",
      "Start with minimal structure and refactor as plugin grows (flat â†’ categorized â†’ hierarchical)",
      "Include version, description, author, and license in plugin.json for production plugins",
      "Use kebab-case consistently for all directory and file names",
      "Keep SKILL.md focused (1500-2000 words), move detailed content to references/",
      "Test plugins on multiple platforms (macOS, Linux, Windows) to verify portability",
      "Rely on auto-discovery by using default directories (commands/, agents/, skills/)",
      "Only specify custom paths in plugin.json when necessary for organization",
      "Document plugin structure decisions in README at plugin root",
      "Follow semantic versioning (MAJOR.MINOR.PATCH) and update version on changes"
    ],
    "anti_patterns": [
      "Placing plugin.json anywhere except .claude-plugin/ directory",
      "Nesting component directories inside .claude-plugin/ instead of at plugin root",
      "Using hardcoded absolute paths instead of ${CLAUDE_PLUGIN_ROOT}",
      "Using relative paths from working directory in scripts",
      "Creating plugin.json with spaces or special characters in name field",
      "Naming skill files anything other than SKILL.md (README.md won't auto-discover)",
      "Overloading a single command/agent/skill instead of creating multiple focused components",
      "Duplicating code across components instead of using shared scripts in lib/",
      "Omitting version field in production plugins",
      "Using backslashes in paths (use forward slashes even on Windows)"
    ],
    "faq": [
      {
        "question": "Where exactly must plugin.json be located?",
        "answer": "Plugin.json MUST be at .claude-plugin/plugin.json relative to the plugin root. Component directories (commands/, agents/, skills/) MUST be at the plugin root level, NOT inside .claude-plugin/."
      },
      {
        "question": "What's the difference between commands, agents, and skills?",
        "answer": "Commands are user-invoked slash commands (/command), agents are specialized subagents for complex tasks (manually or auto-selected), and skills are auto-activating knowledge modules that Claude loads based on task context."
      },
      {
        "question": "How does auto-discovery work?",
        "answer": "Claude Code scans default directories (commands/, agents/, skills/) for .md files and SKILL.md respectively, loading them automatically when the plugin is enabled. Custom paths in plugin.json supplement these defaults."
      },
      {
        "question": "When should I use custom paths vs default directories?",
        "answer": "Use default directories (commands/, agents/, skills/) for simple plugins. Add custom paths in plugin.json only when you need multiple categorized directories or non-standard organization for complex plugins."
      },
      {
        "question": "Why use ${CLAUDE_PLUGIN_ROOT} instead of relative paths?",
        "answer": "Plugins install in different locations depending on OS, installation method, and user preferences. ${CLAUDE_PLUGIN_ROOT} resolves to the actual plugin location at runtime, ensuring portability across all environments."
      },
      {
        "question": "What's the minimum required content for plugin.json?",
        "answer": "Only the 'name' field is required: {\"name\": \"plugin-name\"}. However, production plugins should include version, description, author, license, and keywords for distribution."
      },
      {
        "question": "Can I have multiple skills in one plugin?",
        "answer": "Yes, create multiple subdirectories under skills/, each with its own SKILL.md. For example: skills/api-testing/SKILL.md and skills/database-ops/SKILL.md."
      },
      {
        "question": "How do I troubleshoot components not loading?",
        "answer": "Verify: 1) Files are in correct directories with correct extensions (.md for commands/agents, SKILL.md for skills), 2) YAML frontmatter syntax is valid, 3) Plugin is enabled in Claude Code settings, 4) Custom paths in plugin.json are correct and start with ./"
      },
      {
        "question": "What are the three plugin complexity patterns?",
        "answer": "Minimal (single command, bare manifest), Standard (multiple components with full metadata for production), and Advanced (enterprise-grade with MCP servers, shared libraries, multi-environment configs)."
      },
      {
        "question": "Should hooks be inline in plugin.json or in hooks/hooks.json?",
        "answer": "Use inline configuration for simple plugins with <50 lines of hooks. Use external hooks/hooks.json for complex plugins with many hooks. External files are easier to maintain and version control."
      }
    ],
    "technical_requirements": {
      "dependencies": [],
      "permissions": [],
      "complexity": "intermediate"
    }
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "advanced-plugin.md",
          "type": "file",
          "path": "examples/advanced-plugin.md"
        },
        {
          "name": "minimal-plugin.md",
          "type": "file",
          "path": "examples/minimal-plugin.md"
        },
        {
          "name": "standard-plugin.md",
          "type": "file",
          "path": "examples/standard-plugin.md"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "component-patterns.md",
          "type": "file",
          "path": "references/component-patterns.md"
        },
        {
          "name": "manifest-reference.md",
          "type": "file",
          "path": "references/manifest-reference.md"
        }
      ]
    },
    {
      "name": "README.md",
      "type": "file",
      "path": "README.md"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}