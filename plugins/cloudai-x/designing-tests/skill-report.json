{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T12:32:01.209Z",
    "slug": "cloudai-x-designing-tests",
    "source_url": "https://github.com/CloudAI-X/claude-workflow/tree/main/skills/designing-tests",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "1021ac813ff89bd5bebb055666d7432ec0393a7abc5cedc468662e1615aeed79",
    "tree_hash": "d7188280bd7b8e1e5319c48e0471fc57d5f20696b6372b9a776962679a53c71e"
  },
  "skill": {
    "name": "designing-tests",
    "description": "Designs and implements testing strategies for any codebase. Use when adding tests, improving coverage, setting up testing infrastructure, debugging test failures, or when asked about unit tests, integration tests, or E2E testing.",
    "summary": "Designs and implements testing strategies for any codebase. Use when adding tests, improving coverag...",
    "icon": "ðŸ§ª",
    "version": "1.0.0",
    "author": "CloudAI-X",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "testing",
      "unit-tests",
      "integration-tests",
      "e2e",
      "coverage"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a documentation-only skill that provides testing guidance and templates. It contains no executable code, network calls, or file system access. The skill is purely educational with code examples for test implementation.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 237,
    "audit_model": "claude",
    "audited_at": "2026-01-10T12:32:01.209Z"
  },
  "content": {
    "user_title": "Design comprehensive test suites with proven strategies",
    "value_statement": "Testing code effectively requires deep expertise in frameworks, patterns, and coverage strategies. This skill provides battle-tested templates and workflows for implementing unit, integration, and E2E tests that ensure code quality and reliability.",
    "seo_keywords": [
      "testing",
      "unit tests",
      "integration tests",
      "E2E testing",
      "test coverage",
      "Claude",
      "Codex",
      "Claude Code",
      "pytest",
      "Jest"
    ],
    "actual_capabilities": [
      "Provides testing framework recommendations for JavaScript, Python, and Go",
      "Includes ready-to-use test templates for unit, integration, and E2E tests",
      "Offers coverage strategies with specific thresholds and targets",
      "Contains test data management patterns using factories and fixtures",
      "Provides mocking strategies and when to apply them",
      "Includes complete testing workflow checklists"
    ],
    "limitations": [
      "Does not automatically write or generate tests",
      "Requires manual implementation of suggested patterns",
      "Framework recommendations may not cover all use cases",
      "Coverage thresholds are suggestions, not enforced"
    ],
    "use_cases": [
      {
        "target_user": "Full-stack developers",
        "title": "Set up testing infrastructure",
        "description": "Choose appropriate testing frameworks and configure coverage tools for new projects across JavaScript, Python, or Go codebases."
      },
      {
        "target_user": "QA engineers",
        "title": "Improve test coverage",
        "description": "Apply the testing pyramid strategy to achieve 80%+ coverage with balanced unit, integration, and E2E tests."
      },
      {
        "target_user": "Team leads",
        "title": "Standardize testing practices",
        "description": "Implement consistent testing patterns and quality gates across development teams using proven templates."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic test setup",
        "scenario": "New JavaScript project needs tests",
        "prompt": "Help me set up testing for my new JavaScript project. What framework should I use and how do I structure my first unit test?"
      },
      {
        "title": "Coverage improvement",
        "scenario": "Low test coverage in existing codebase",
        "prompt": "My Python project has only 30% test coverage. How can I systematically improve it to 80% using the testing pyramid approach?"
      },
      {
        "title": "E2E test design",
        "scenario": "Critical user journey needs testing",
        "prompt": "I need to write E2E tests for my user registration flow. Show me a complete Playwright test template with proper selectors and assertions."
      },
      {
        "title": "Mocking strategy",
        "scenario": "External API calls need mocking",
        "prompt": "My integration tests are hitting real APIs. How should I mock external services using MSW for reliable and fast tests?"
      }
    ],
    "output_examples": [
      {
        "input": "Help me write unit tests for my user service that has createUser, getUser, and deleteUser methods",
        "output": [
          "Testing Strategy: Focus on business logic with 3 test cases per method (happy path, edge cases, error handling)",
          "Recommended Framework: Use Vitest for fast execution with TypeScript support",
          "Test Structure: Arrange-Act-Assert pattern with clear test names",
          "Coverage Target: 95% for user service as it's core business logic",
          "Mocking: Mock database calls using dependency injection",
          "Example Template: Provides complete test file with describe blocks for each method"
        ]
      }
    ],
    "best_practices": [
      "Follow the testing pyramid with 70% unit, 20% integration, 10% E2E tests for optimal speed and coverage",
      "Use descriptive test names that explain the expected behavior and conditions being tested",
      "Mock external dependencies but test real integrations between your own modules"
    ],
    "anti_patterns": [
      "Writing tests that depend on execution order or share state between tests",
      "Testing implementation details instead of behavior - tests should break only when behavior changes",
      "Over-mocking by mocking the code you're actually testing instead of its dependencies"
    ],
    "faq": [
      {
        "question": "Which testing framework should I choose for React?",
        "answer": "Use Vitest with React Testing Library for modern React apps. It offers fast execution, TypeScript support, and excellent IDE integration."
      },
      {
        "question": "What's the minimum code coverage I should aim for?",
        "answer": "Aim for 80% overall coverage with 95% for critical business logic. Focus on testing behavior rather than achieving 100% coverage."
      },
      {
        "question": "How do I test code that uses external APIs?",
        "answer": "Use MSW (Mock Service Worker) to intercept HTTP requests and return mock responses. This ensures tests are fast and reliable."
      },
      {
        "question": "Should I test private functions?",
        "answer": "Generally no - test through public APIs. If private logic is complex, consider extracting it to a separate testable module."
      },
      {
        "question": "How do I handle flaky tests?",
        "answer": "Identify root causes: timing issues, test dependencies, or environmental factors. Use explicit waits, isolate tests, and run them multiple times."
      },
      {
        "question": "Can this skill help with test-driven development?",
        "answer": "Yes, it provides templates and patterns for writing tests first. Use the workflow checklists to ensure comprehensive test coverage from the start."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
