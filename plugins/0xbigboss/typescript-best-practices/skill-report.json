{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T08:55:50.740Z",
    "slug": "0xbigboss-typescript-best-practices",
    "source_url": "https://github.com/0xBigBoss/claude-code/tree/main/.claude/skills/typescript-best-practices",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "e57a1ffe09fa023d9563c076ad3b618778b6506ba6c9a9959bdb7dc1b8459878",
    "tree_hash": "4320b02266f46abc5d17deeb6c0dd1382b386feb0c2c3d69740324ea6f240af9"
  },
  "skill": {
    "name": "typescript-best-practices",
    "description": "Provides TypeScript patterns for type-first development, making illegal states unrepresentable, exhaustive handling, and runtime validation. Must use when reading or writing TypeScript/JavaScript files.",
    "summary": "Provides TypeScript patterns for type-first development, making illegal states unrepresentable, exha...",
    "icon": "ðŸ“˜",
    "version": "1.0.0",
    "author": "0xBigBoss",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "typescript",
      "type-safety",
      "patterns",
      "zod",
      "best-practices"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing only a SKILL.md markdown file with TypeScript best practices guidance. No executable code, no network access, no file system access beyond its own documentation, no external commands, no persistence mechanisms. All code examples are educational patterns for legitimate TypeScript development practices.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 271,
    "audit_model": "claude",
    "audited_at": "2026-01-10T08:55:50.740Z"
  },
  "content": {
    "user_title": "Write type-safe TypeScript with proven patterns",
    "value_statement": "TypeScript code often contains runtime errors that type checking misses. This skill provides battle-tested patterns for type-first development, discriminated unions for illegal states, exhaustive handling, and runtime validation with Zod to catch bugs before they ship.",
    "seo_keywords": [
      "TypeScript best practices",
      "type-first development",
      "Claude Code",
      "Claude",
      "Codex",
      "type safety",
      "discriminated unions",
      "exhaustive handling",
      "Zod validation",
      "branded types"
    ],
    "actual_capabilities": [
      "Guides type-first development workflow with types defined before implementation",
      "Provides discriminated union patterns to make illegal states unrepresentable",
      "Shows exhaustive switch handling with never type to catch unhandled cases",
      "Demonstrates runtime validation with Zod schemas as single source of truth",
      "Covers branded types and const assertions for domain primitive correctness",
      "Teaches configuration validation patterns with typed env variables"
    ],
    "limitations": [
      "Does not execute TypeScript code or run type checks",
      "Does not configure TypeScript compiler options in tsconfig.json",
      "Does not integrate with build tools or bundlers",
      "Does not provide project scaffolding or code generation"
    ],
    "use_cases": [
      {
        "target_user": "Frontend developers",
        "title": "Prevent invalid state bugs",
        "description": "Use discriminated unions and exhaustive handling to make invalid application states impossible at compile time."
      },
      {
        "target_user": "Backend developers",
        "title": "Validate API inputs safely",
        "description": "Apply Zod schemas for runtime validation of external data with type inference to avoid duplicating definitions."
      },
      {
        "target_user": "Full-stack developers",
        "title": "Maintain type consistency",
        "description": "Share validated schemas between frontend and backend to ensure API contracts stay in sync."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic type guidance",
        "scenario": "Need type patterns for a new feature",
        "prompt": "Use the typescript-best-practices skill. Design type-safe patterns for a [feature description]. Show how to make illegal states unrepresentable using discriminated unions or branded types."
      },
      {
        "title": "Error handling",
        "scenario": "Improve error handling in existing code",
        "prompt": "Use the typescript-best-practices skill. Review my [function/module] and apply exhaustive switch patterns with never checks. Show how to propagate errors with context."
      },
      {
        "title": "Runtime validation",
        "scenario": "Add input validation to API handlers",
        "prompt": "Use the typescript-best-practices skill. Create a Zod schema for [data type] and show how to use safeParse at trust boundaries. Include proper error handling for both success and failure cases."
      },
      {
        "title": "Configuration setup",
        "scenario": "Configure application settings",
        "prompt": "Use the typescript-best-practices skill. Define a typed configuration schema with Zod for environment variables. Include validation, sensible defaults, and proper type coercion."
      }
    ],
    "output_examples": [
      {
        "input": "Create a type-safe user profile update function with proper error handling",
        "output": [
          "Define UpdateUser schema using Zod's partial() for optional fields",
          "Use safeParse() to handle validation failures gracefully",
          "Return typed results so callers can handle success and error cases",
          "Throw with context at trust boundaries where invalid data is a bug"
        ]
      }
    ],
    "best_practices": [
      "Define types and schemas before implementation; let the compiler guide completeness",
      "Use discriminated unions to model mutually exclusive states rather than boolean flags",
      "Validate data at system boundaries with Zod; infer TypeScript types from schemas to avoid duplication"
    ],
    "anti_patterns": [
      "Using boolean flags for state (isLoading, isError) that allow invalid combinations",
      "Duplicating type definitions and runtime validation schemas separately",
      "Swallowing errors silently; always propagate failures to callers with context"
    ],
    "faq": [
      {
        "question": "Is this skill compatible with React projects?",
        "answer": "Yes. Load react-best-practices alongside this skill for React-specific patterns like hooks, effects, and component design."
      },
      {
        "question": "What TypeScript version is required?",
        "answer": "The patterns work with TypeScript 4.7+. Some features like const assertions require TS 3.4+."
      },
      {
        "question": "How does Zod compare to other validation libraries?",
        "answer": "Zod infers TypeScript types directly from schemas, eliminating duplication. It integrates well with type-first workflows."
      },
      {
        "question": "Does this skill access my files or environment?",
        "answer": "No. This is a prompt-based skill that provides guidance. It does not read files, access environment variables, or execute code."
      },
      {
        "question": "Can I use these patterns with JavaScript?",
        "answer": "Some patterns like discriminated unions and Zod validation require TypeScript's type system. Use JSDoc annotations for partial type safety in JS."
      },
      {
        "question": "What about strict mode?",
        "answer": "Enable strict mode in tsconfig.json. The patterns in this skill assume strictNullChecks and strictFunctionTypes are enabled."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
