{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-04T16:28:20.860Z",
    "slug": "hook-development",
    "source_url": "https://github.com/anthropics/claude-code/tree/main/plugins/plugin-dev/skills/hook-development",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "official",
    "content_hash": "271528377492e4c5d328c9851785c52bb6efefdbf17e89fe5be16c12fa4adea0",
    "tree_hash": "7e1f8611995119dec5ba2564b70df1bc91b2c3b2463b39411707713338b83bc6"
  },
  "skill": {
    "name": "Hook Development",
    "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
    "summary": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop ...",
    "icon": "ü™ù",
    "version": "0.1.0",
    "author": "anthropics",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "hooks",
      "Claude Code",
      "automation",
      "validation",
      "plugins"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Official Anthropic skill for hook development. Contains documentation and utility scripts for validating and testing hooks. No network calls or destructive operations. All scripts use safe bash practices with proper error handling.",
    "risk_factor_evidence": [
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "scripts/hook-linter.sh",
            "line_start": 1,
            "line_end": 154
          },
          {
            "file": "scripts/test-hook.sh",
            "line_start": 1,
            "line_end": 253
          },
          {
            "file": "scripts/validate-hook-schema.sh",
            "line_start": 1,
            "line_end": 160
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "examples/validate-write.sh",
            "line_start": 1,
            "line_end": 39
          },
          {
            "file": "examples/validate-bash.sh",
            "line_start": 1,
            "line_end": 44
          },
          {
            "file": "examples/load-context.sh",
            "line_start": 1,
            "line_end": 56
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "examples/validate-write.sh",
            "line_start": 8,
            "line_end": 8
          },
          {
            "file": "examples/load-context.sh",
            "line_start": 13,
            "line_end": 13
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 15,
    "total_lines": 2169,
    "audit_model": "claude",
    "audited_at": "2026-01-04T16:28:20.860Z"
  },
  "content": {
    "user_title": "Create Claude Code hooks for event-driven automation",
    "value_statement": "Hooks enable you to validate tool calls, enforce policies, and automate workflows triggered by Claude Code events. Build security guards, quality gates, and context loading mechanisms that run automatically before, during, or after AI operations.",
    "seo_keywords": [
      "Claude Code hooks",
      "PreToolUse",
      "PostToolUse",
      "Stop hook",
      "plugin automation",
      "event-driven hooks",
      "Claude Code plugins",
      "prompt-based hooks",
      "command hooks",
      "hook validation"
    ],
    "actual_capabilities": [
      "Configure PreToolUse hooks to validate and modify tool calls before execution",
      "Create PostToolUse hooks to analyze results, provide feedback, and log operations",
      "Build Stop hooks to verify task completion, test coverage, and build status",
      "Implement SessionStart hooks to load project context and set environment variables",
      "Use prompt-based hooks with LLM reasoning for context-aware validation",
      "Define matchers to target specific tools, MCP plugins, or operation types"
    ],
    "limitations": [
      "Hooks load at session start and require restart to apply configuration changes",
      "Parallel hook execution means hooks cannot rely on specific execution order",
      "Hook scripts must complete within configured timeout (default 60s command, 30s prompt)"
    ],
    "use_cases": [
      {
        "target_user": "Plugin developers",
        "title": "Build security validation",
        "description": "Create hooks that block writes to sensitive files, prevent destructive commands, and require user confirmation for risky operations."
      },
      {
        "target_user": "Team leads",
        "title": "Enforce quality gates",
        "description": "Configure hooks that require tests to run, builds to succeed, and code to pass linters before allowing agent to stop."
      },
      {
        "target_user": "DevOps engineers",
        "title": "Load project context",
        "description": "Automatically detect project type, set environment variables, and configure Claude behavior based on project structure at session start."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic validation hook",
        "scenario": "Validate file writes",
        "prompt": "File path: $TOOL_INPUT.file_path. Verify: 1) Not in /etc or system directories 2) Not .env or credentials file 3) No path traversal. Return 'approve' or 'deny'."
      },
      {
        "title": "Bash safety check",
        "scenario": "Check dangerous commands",
        "prompt": "Command: $TOOL_INPUT.command. Analyze for destructive operations (rm -rf, dd, mkfs), privilege escalation (sudo), and unauthorized network access. Return 'approve', 'deny', or 'ask'."
      },
      {
        "title": "Task completion check",
        "scenario": "Verify work is done",
        "prompt": "Review transcript at $TRANSCRIPT_PATH. Were tests run after code changes? Did builds succeed? Were all user questions answered? Return 'approve' or 'block' with reason."
      },
      {
        "title": "MCP protection",
        "scenario": "Guard MCP operations",
        "prompt": "MCP operation: $TOOL_NAME. If it contains delete, remove, or drop operations: verify backups exist, confirm intent, check if operation is reversible. Return 'approve' or 'ask'."
      }
    ],
    "output_examples": [
      {
        "input": "Create a hook that blocks dangerous bash commands",
        "output": [
          "Hook configuration created for PreToolUse event",
          "Matcher targets all Bash tool calls",
          "Prompt-based hook uses LLM to analyze commands",
          "Destructive operations blocked with user confirmation",
          "Exit code 2 blocks the operation with explanation"
        ]
      }
    ],
    "best_practices": [
      "Use ${CLAUDE_PLUGIN_ROOT} for all script paths to ensure portability across different systems",
      "Set appropriate timeouts: 5-10s for fast checks, 30s for complex prompt-based validation",
      "Return structured JSON output with decision, reason, and optional systemMessage fields"
    ],
    "anti_patterns": [
      "Hardcoding absolute paths like /home/user/project instead of using environment variables",
      "Relying on hook execution order since all matching hooks run in parallel",
      "Creating long-running hooks that timeout and block the agent workflow"
    ],
    "faq": [
      {
        "question": "Which events support prompt-based hooks?",
        "answer": "Prompt-based hooks work best on PreToolUse, Stop, SubagentStop, and UserPromptSubmit events. Command hooks work on all events."
      },
      {
        "question": "What is the maximum timeout for hooks?",
        "answer": "Default is 60 seconds for command hooks and 30 seconds for prompt hooks. Maximum allowed is 600 seconds but very high values may block workflows."
      },
      {
        "question": "Can hooks modify tool input before execution?",
        "answer": "Yes, PreToolUse hooks can return updatedInput to modify tool parameters. Use hookSpecificOutput.permissionDecision to control approval."
      },
      {
        "question": "Are hooks secure for production use?",
        "answer": "Yes when following security practices: validate all input, quote variables, use timeouts, and audit hook scripts before deployment."
      },
      {
        "question": "Why are my hook changes not taking effect?",
        "answer": "Hooks load only at session start. After editing hooks.json or scripts, exit Claude Code completely and restart with 'claude' or 'cc'."
      },
      {
        "question": "How do hooks compare to system prompts?",
        "answer": "Hooks run at specific events with structured input and output. System prompts influence AI behavior globally. Use hooks for enforcement, prompts for guidance."
      }
    ]
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "load-context.sh",
          "type": "file",
          "path": "examples/load-context.sh"
        },
        {
          "name": "validate-bash.sh",
          "type": "file",
          "path": "examples/validate-bash.sh"
        },
        {
          "name": "validate-write.sh",
          "type": "file",
          "path": "examples/validate-write.sh"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "advanced.md",
          "type": "file",
          "path": "references/advanced.md"
        },
        {
          "name": "migration.md",
          "type": "file",
          "path": "references/migration.md"
        },
        {
          "name": "patterns.md",
          "type": "file",
          "path": "references/patterns.md"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "hook-linter.sh",
          "type": "file",
          "path": "scripts/hook-linter.sh"
        },
        {
          "name": "README.md",
          "type": "file",
          "path": "scripts/README.md"
        },
        {
          "name": "test-hook.sh",
          "type": "file",
          "path": "scripts/test-hook.sh"
        },
        {
          "name": "validate-hook-schema.sh",
          "type": "file",
          "path": "scripts/validate-hook-schema.sh"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
