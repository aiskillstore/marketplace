{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2025-12-31T05:45:59.157Z",
    "slug": "hook-development",
    "source_url": "https://github.com/anthropics/claude-code/tree/main/plugins/plugin-dev/skills/hook-development",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "official"
  },
  "skill": {
    "name": "Hook Development",
    "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
    "summary": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop ...",
    "icon": "ü™ù",
    "version": "0.1.0",
    "author": "Anthropic",
    "license": "Not specified",
    "category": "development",
    "tags": [
      "hooks",
      "automation",
      "validation",
      "security",
      "plugin-development",
      "event-driven",
      "workflow",
      "claude-code"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Official Anthropic skill providing comprehensive hook development guidance and utilities. All example scripts demonstrate proper security practices including input validation, path safety, and injection prevention.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 11,
    "total_lines": 2781,
    "audit_model": "claude",
    "audited_at": "2025-12-31T05:45:59.157Z"
  },
  "content": {
    "user_title": "Hook Development for Claude Code Plugins",
    "value_statement": "Create sophisticated event-driven automation for Claude Code by building hooks that validate operations, enforce policies, load context, and integrate external tools into your development workflow.",
    "seo_keywords": [
      "claude code hooks",
      "plugin hooks",
      "pretooluse hooks",
      "stop hooks",
      "event-driven automation",
      "tool validation",
      "prompt-based hooks",
      "session hooks",
      "workflow automation",
      "claude plugin development"
    ],
    "actual_capabilities": [
      "Create PreToolUse hooks to validate and control tool execution before it happens",
      "Implement PostToolUse hooks to react to tool results and provide feedback",
      "Build Stop/SubagentStop hooks to enforce task completion standards",
      "Configure SessionStart hooks to automatically load project context and environment",
      "Use prompt-based hooks for LLM-driven context-aware decision making",
      "Write command hooks for deterministic validation and external tool integration",
      "Validate file writes, bash commands, and MCP tool usage with security checks",
      "Persist environment variables across sessions using SessionStart hooks",
      "Create matcher patterns to target specific tools or use wildcards",
      "Provide utility scripts to validate, test, and lint hook implementations"
    ],
    "limitations": [
      "Hooks load at session start only - changes require restarting Claude Code",
      "Cannot hot-swap hooks during active session",
      "Hooks run in parallel with no guaranteed execution order",
      "Command hook timeouts default to 60s, prompt hooks to 30s",
      "Hooks cannot directly modify other hooks' behavior or state",
      "Prompt-based hooks only fully supported on Stop, SubagentStop, UserPromptSubmit, and PreToolUse events"
    ],
    "use_cases": [
      {
        "title": "Security Validation",
        "description": "Prevent dangerous file writes to system directories, credential files, or paths with traversal attempts. Block destructive bash commands like rm -rf before execution.",
        "target_user": "Security-conscious developers, team leads enforcing safety standards"
      },
      {
        "title": "Test Enforcement",
        "description": "Automatically verify that tests were run after code modifications before allowing the session to end. Ensure builds succeed before committing changes.",
        "target_user": "Development teams requiring quality gates and continuous integration practices"
      },
      {
        "title": "Project Context Loading",
        "description": "Automatically detect project type (Node.js, Rust, Go, Python, Java) at session start and configure environment variables, load project-specific settings, and set up tooling.",
        "target_user": "Polyglot developers working across multiple project types and languages"
      },
      {
        "title": "MCP Tool Protection",
        "description": "Monitor and validate MCP tool usage, especially destructive operations like deletions. Ask for user confirmation or block unsafe operations based on context.",
        "target_user": "Plugin developers integrating external tools that require safety guardrails"
      },
      {
        "title": "Code Quality Automation",
        "description": "Automatically run linters, formatters, or security scanners on edited files. Provide immediate feedback on code quality issues.",
        "target_user": "Teams maintaining code quality standards and automated checks"
      },
      {
        "title": "Audit and Logging",
        "description": "Log all tool usage, notifications, and decisions for compliance, debugging, or analytics. Integrate with external logging systems or databases.",
        "target_user": "Enterprise teams requiring audit trails and compliance documentation"
      }
    ],
    "prompt_templates": [
      {
        "title": "Create a PreToolUse validation hook",
        "prompt": "Create a PreToolUse hook that validates Write and Edit operations. Block writes to /etc, /sys, system directories, .env files, and paths with .. traversal. Use a prompt-based hook.",
        "scenario": "When you need to prevent dangerous file writes before they happen"
      },
      {
        "title": "Add test enforcement Stop hook",
        "prompt": "Create a Stop hook that checks the transcript to verify tests were run if any code was modified (Write/Edit tools used). Block stopping if no tests were executed.",
        "scenario": "When you want to enforce that tests run before completing work"
      },
      {
        "title": "Implement project context loader",
        "prompt": "Create a SessionStart hook that detects the project type (package.json, Cargo.toml, go.mod, pyproject.toml, etc.) and sets PROJECT_TYPE environment variable. Save it to $CLAUDE_ENV_FILE.",
        "scenario": "When you want to automatically configure environment based on project type"
      },
      {
        "title": "Add bash command security validation",
        "prompt": "Create a PreToolUse hook for Bash commands that blocks rm -rf, dd, mkfs, and privilege escalation (sudo/su). Use prompt-based hook to catch variations and understand intent.",
        "scenario": "When you need to prevent destructive or dangerous shell commands"
      },
      {
        "title": "Create MCP tool deletion guard",
        "prompt": "Create a PreToolUse hook with matcher 'mcp__.*__delete.*' that uses a prompt to verify deletion is intentional, can be undone, and has backups. Return 'ask' to confirm with user.",
        "scenario": "When integrating MCP tools that have destructive delete operations"
      },
      {
        "title": "Add PostToolUse code quality check",
        "prompt": "Create a PostToolUse hook for Edit operations that runs eslint on .js and .ts files. Show linting results in the transcript.",
        "scenario": "When you want automatic code quality feedback after edits"
      }
    ],
    "output_examples": [
      {
        "input": "Create a PreToolUse hook to block writes to system directories",
        "output": "Created hooks/hooks.json with prompt-based PreToolUse hook that validates file paths. Hook checks for /etc, /sys, /usr directories, .env files, path traversal (..), and sensitive patterns. Returns 'deny' decision with explanation if unsafe, 'approve' otherwise. Uses ${CLAUDE_PLUGIN_ROOT} for portability."
      },
      {
        "input": "Add a SessionStart hook to detect Node.js projects",
        "output": "Created scripts/load-context.sh that checks for package.json and tsconfig.json. Exports PROJECT_TYPE=nodejs and USES_TYPESCRIPT=true to $CLAUDE_ENV_FILE. Added SessionStart hook in hooks/hooks.json that executes the script with 10s timeout. Script is executable and uses proper error handling."
      },
      {
        "input": "Create a Stop hook to enforce test execution",
        "output": "Added Stop hook with prompt-based validation that reviews the transcript at $TRANSCRIPT_PATH. Checks if Write/Edit tools were used (code modified) and verifies test commands were executed. Returns 'block' decision with reason 'Tests must be run after code changes' if tests missing, 'approve' otherwise."
      }
    ],
    "best_practices": [
      "Use prompt-based hooks for complex, context-aware validation - they handle edge cases better than hardcoded rules",
      "Always use ${CLAUDE_PLUGIN_ROOT} in hook commands for portability across installations",
      "Validate and quote all variables in bash hooks to prevent injection attacks",
      "Set appropriate timeouts: quick checks 5-10s, validation 15-30s, never exceed 60s",
      "Design hooks to be independent since they run in parallel with non-deterministic ordering",
      "Test hooks thoroughly with utility scripts (validate-hook-schema.sh, test-hook.sh, hook-linter.sh) before deployment",
      "Return structured JSON output with clear decision and systemMessage fields",
      "Use command hooks for deterministic checks, prompt hooks for intelligent reasoning",
      "Document hook behavior and activation requirements in plugin README",
      "Check for path traversal (..), system directories, and credential files in file validation hooks",
      "Use 'ask' permission decision when user confirmation is needed rather than auto-blocking",
      "Persist environment variables via $CLAUDE_ENV_FILE in SessionStart hooks only"
    ],
    "anti_patterns": [
      "Using hardcoded absolute paths instead of ${CLAUDE_PLUGIN_ROOT}",
      "Creating long-running hooks that exceed timeout limits",
      "Relying on hook execution order (they run in parallel)",
      "Not validating user input in command hooks (injection risk)",
      "Using unquoted bash variables ($var instead of \"$var\")",
      "Expecting hooks to hot-reload without restarting Claude Code session",
      "Logging sensitive information in hook output",
      "Creating hooks with exact string matching instead of pattern understanding",
      "Modifying global state in ways other hooks depend on",
      "Using command hooks for complex logic better suited to prompt-based reasoning",
      "Forgetting to make hook scripts executable (chmod +x)",
      "Not wrapping hook events in {\"hooks\": {...}} wrapper for plugin hooks.json format"
    ],
    "faq": [
      {
        "question": "When should I use prompt-based hooks vs command hooks?",
        "answer": "Use prompt-based hooks for context-aware validation that requires understanding intent, handling edge cases, and making intelligent decisions. Use command hooks for fast deterministic checks (<50ms), external tool integration, or mathematical validation. For most use cases, start with prompt-based hooks."
      },
      {
        "question": "How do I test hooks before deploying them?",
        "answer": "Use the provided utility scripts: validate-hook-schema.sh checks hooks.json syntax, test-hook.sh runs hooks with sample input, and hook-linter.sh checks scripts for common issues. Test in Claude Code with --debug flag to see detailed execution logs. Always restart Claude Code after changing hooks."
      },
      {
        "question": "Do hooks load dynamically or require restart?",
        "answer": "Hooks load at session start only. Any changes to hooks.json or hook scripts require restarting Claude Code to take effect. You cannot hot-swap hooks during an active session."
      },
      {
        "question": "How do hooks run - sequentially or parallel?",
        "answer": "All matching hooks run in parallel with no guaranteed execution order. Design hooks to be independent and not rely on other hooks' output or state. This maximizes performance but requires careful design."
      },
      {
        "question": "What's the difference between plugin hooks.json format and settings format?",
        "answer": "Plugin hooks.json uses wrapper format {\"hooks\": {\"PreToolUse\": [...]}}, while user settings use direct format {\"PreToolUse\": [...]}. Plugin format includes optional description field. The hook event structure is the same inside both formats."
      },
      {
        "question": "How do I make hooks temporarily active?",
        "answer": "Use flag files or configuration checks in your hook script. Check for existence of a file like .enable-strict-validation at the start of your hook script and exit 0 if not present. This allows users to enable/disable hooks without editing configuration."
      },
      {
        "question": "What environment variables are available in hooks?",
        "answer": "$CLAUDE_PROJECT_DIR (project root), $CLAUDE_PLUGIN_ROOT (plugin directory), $CLAUDE_ENV_FILE (SessionStart only for persisting env vars), and $CLAUDE_CODE_REMOTE (set if running remotely). Always use these for portable paths."
      },
      {
        "question": "How do I validate dangerous bash commands?",
        "answer": "Use a PreToolUse prompt-based hook with matcher 'Bash' that asks the LLM to check for destructive operations (rm -rf, dd, mkfs), privilege escalation (sudo, su), and network operations. Prompt-based hooks understand intent and catch variations better than regex."
      }
    ],
    "technical_requirements": {
      "dependencies": [
        "bash",
        "jq (for JSON parsing in command hooks)",
        "Claude Code v0.5.0+"
      ],
      "permissions": [
        "File system access for hook scripts",
        "Ability to execute shell commands"
      ],
      "complexity": "intermediate"
    }
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "load-context.sh",
          "type": "file",
          "path": "examples/load-context.sh"
        },
        {
          "name": "validate-bash.sh",
          "type": "file",
          "path": "examples/validate-bash.sh"
        },
        {
          "name": "validate-write.sh",
          "type": "file",
          "path": "examples/validate-write.sh"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "advanced.md",
          "type": "file",
          "path": "references/advanced.md"
        },
        {
          "name": "migration.md",
          "type": "file",
          "path": "references/migration.md"
        },
        {
          "name": "patterns.md",
          "type": "file",
          "path": "references/patterns.md"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "hook-linter.sh",
          "type": "file",
          "path": "scripts/hook-linter.sh"
        },
        {
          "name": "README.md",
          "type": "file",
          "path": "scripts/README.md"
        },
        {
          "name": "test-hook.sh",
          "type": "file",
          "path": "scripts/test-hook.sh"
        },
        {
          "name": "validate-hook-schema.sh",
          "type": "file",
          "path": "scripts/validate-hook-schema.sh"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}