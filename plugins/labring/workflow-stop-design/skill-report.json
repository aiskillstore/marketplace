{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-06T03:36:15.811Z",
    "slug": "labring-workflow-stop-design",
    "source_url": "https://github.com/labring/FastGPT/tree/main/.claude/skills/core/app/workflow/stop",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "9a79330c875e63a85e739ab7e1be3072faa8452d5d0acb90c454b4fe06f783b3",
    "tree_hash": "e0cec4378f1f8a3d77a13454c52b49cea0516b2322dfe54bc9b5687b14832e88"
  },
  "skill": {
    "name": "workflow-stop-design",
    "description": "Â∑•‰ΩúÊµÅÊöÇÂÅúÈÄªËæëËÆæËÆ°ÊñπÊ°à",
    "summary": "Â∑•‰ΩúÊµÅÊöÇÂÅúÈÄªËæëËÆæËÆ°ÊñπÊ°à",
    "icon": "üõë",
    "version": "1.0.0",
    "author": "labring",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "workflow",
      "redis",
      "design",
      "architecture"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a design document containing architecture specifications and TypeScript code examples for implementing workflow stop functionality. No executable code or malicious patterns detected.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 673,
    "audit_model": "claude",
    "audited_at": "2026-01-06T03:36:15.811Z"
  },
  "content": {
    "user_title": "Design workflow stop mechanism with Redis",
    "value_statement": "FastGPT workflows need reliable stop functionality for user control. This design provides a Redis-based state management system that enables graceful workflow termination with proper cleanup and timeout handling.",
    "seo_keywords": [
      "FastGPT workflow",
      "Redis state management",
      "workflow stop",
      "Claude Code",
      "TypeScript design",
      "AI agent control",
      "workflow termination",
      "graceful shutdown",
      "chatbot stop",
      "agent runtime"
    ],
    "actual_capabilities": [
      "Design Redis-based workflow state management with TTL",
      "Implement stop signal detection with 100ms polling",
      "Create graceful shutdown with 5-second timeout",
      "Handle edge cases including Redis failures and concurrent requests"
    ],
    "limitations": [
      "Design document only - requires implementation",
      "Depends on Redis availability for stop functionality",
      "HTTP request nodes cannot be forcefully terminated",
      "60-second TTL may be insufficient for very long workflows"
    ],
    "use_cases": [
      {
        "target_user": "Backend developers",
        "title": "Implement workflow stop feature",
        "description": "Add reliable stop functionality to AI workflow engines with Redis state management and proper error handling."
      },
      {
        "target_user": "System architects",
        "title": "Design distributed workflow control",
        "description": "Create scalable workflow termination systems that work across multiple service instances."
      },
      {
        "target_user": "DevOps engineers",
        "title": "Monitor and control AI agents",
        "description": "Implement operational controls for managing long-running AI workflows in production."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic implementation guide",
        "scenario": "Create Redis-based stop mechanism",
        "prompt": "Implement a workflow stop system using Redis with these requirements: 1) Use SETEX with 60s TTL for stop flags, 2) Poll every 100ms to check status, 3) Clean up flags after workflow completion, 4) Handle Redis connection failures gracefully."
      },
      {
        "title": "Error handling pattern",
        "scenario": "Handle Redis failures safely",
        "prompt": "Design error handling for workflow stop functionality where Redis operations might fail. Ensure workflows continue running if Redis is unavailable and implement proper logging for debugging."
      },
      {
        "title": "Concurrent request handling",
        "scenario": "Support multiple stop requests",
        "prompt": "Implement thread-safe workflow stop that handles concurrent stop requests from multiple users. Use Redis SETEX operations and ensure idempotent behavior."
      },
      {
        "title": "Timeout and cleanup strategy",
        "scenario": "Implement proper resource cleanup",
        "prompt": "Create a comprehensive cleanup strategy for workflow stop including: 1) 5-second timeout for graceful shutdown, 2) Automatic Redis key cleanup with TTL, 3) Timer cleanup in finally blocks, 4) Connection closing for external services."
      }
    ],
    "output_examples": [
      {
        "input": "Design a workflow stop system for an AI agent platform",
        "output": [
          "Redis Key Structure: agent_runtime_stopping:{appId}:{chatId}",
          "State Values: Key exists = should stop, Key missing = running",
          "TTL: 60 seconds automatic cleanup",
          "Polling: 100ms intervals for stop detection",
          "Timeout: 5-second graceful shutdown limit",
          "Error Handling: Continue execution if Redis fails",
          "Cleanup: Remove keys after workflow completion"
        ]
      }
    ],
    "best_practices": [
      "Always use TTL for Redis keys to prevent memory leaks from failed cleanups",
      "Implement proper error handling that allows workflows to continue if Redis is unavailable",
      "Use memory variables with periodic Redis polling rather than Redis queries for each check"
    ],
    "anti_patterns": [
      "Don't query Redis for every node execution - use in-memory caching with periodic updates",
      "Avoid blocking the main workflow thread while waiting for stop confirmation",
      "Never rely solely on client-side abort without server-side state management"
    ],
    "faq": [
      {
        "question": "What happens if Redis becomes unavailable?",
        "answer": "The system gracefully degrades - workflows continue running and checkIsStopping() returns false, ensuring no workflows are accidentally stopped due to Redis failures."
      },
      {
        "question": "How long does the stop signal persist?",
        "answer": "Stop signals have a 60-second TTL in Redis. They're also immediately deleted when workflows complete successfully."
      },
      {
        "question": "Can multiple users stop the same workflow?",
        "answer": "Yes, the Redis SETEX operation is idempotent. Multiple stop requests safely set the same key without conflicts."
      },
      {
        "question": "What types of nodes can be stopped?",
        "answer": "Most nodes stop at the next execution checkpoint. LLM streaming stops immediately, but HTTP requests complete their current operation."
      },
      {
        "question": "How does the polling mechanism work?",
        "answer": "A 100ms timer polls Redis and updates an in-memory variable. Node execution checks this variable synchronously for minimal performance impact."
      },
      {
        "question": "Is this design production-ready?",
        "answer": "The design includes comprehensive error handling, timeout management, and cleanup strategies suitable for production deployment with proper monitoring."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
