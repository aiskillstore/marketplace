{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-06T04:26:24.387Z",
    "slug": "labring-workflow-stop-design",
    "source_url": "https://github.com/labring/FastGPT/tree/main/.claude/skills/core/app/workflow/stop",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "9a79330c875e63a85e739ab7e1be3072faa8452d5d0acb90c454b4fe06f783b3",
    "tree_hash": "e0cec4378f1f8a3d77a13454c52b49cea0516b2322dfe54bc9b5687b14832e88"
  },
  "skill": {
    "name": "workflow-stop-design",
    "description": "å·¥ä½œæµæš‚åœé€»è¾‘è®¾è®¡æ–¹æ¡ˆ",
    "summary": "å·¥ä½œæµæš‚åœé€»è¾‘è®¾è®¡æ–¹æ¡ˆ",
    "icon": "ğŸ›‘",
    "version": "1.0.0",
    "author": "labring",
    "license": "Apache-2.0",
    "category": "documentation",
    "tags": [
      "workflow",
      "redis",
      "design",
      "architecture"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "çº¯æ–‡æ¡£æŠ€èƒ½ï¼Œä»…åŒ…å«è®¾è®¡æ–‡æ¡£å’Œä»£ç ç¤ºä¾‹ï¼Œæ— å¯æ‰§è¡Œä»£ç ï¼Œæ— ç½‘ç»œè°ƒç”¨ï¼Œæ— æ–‡ä»¶è®¿é—®ã€‚",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 673,
    "audit_model": "claude",
    "audited_at": "2026-01-06T04:26:24.387Z"
  },
  "content": {
    "user_title": "Design workflow stop mechanism",
    "value_statement": "Need to implement graceful workflow termination in your AI agent system. This design document provides a Redis-based state management solution with API endpoints and polling patterns for reliable workflow stopping.",
    "seo_keywords": [
      "workflow stop",
      "redis state management",
      "ai agent control",
      "fastgpt design",
      "claude code workflow",
      "graceful shutdown",
      "workflow cancellation",
      "agent runtime",
      "polling mechanism"
    ],
    "actual_capabilities": [
      "Design Redis-based workflow stop state management",
      "Implement stop flag with TTL and key patterns",
      "Create polling mechanism for stop detection",
      "Define stop API endpoint with authentication",
      "Handle edge cases including timeouts and concurrency",
      "Write unit tests for stop functionality"
    ],
    "limitations": [
      "Design document only, requires implementation",
      "Does not include frontend code for all scenarios",
      "HTTP request nodes may not be immediately terminated",
      "Focus on v2 API version, v1 uses different mechanism"
    ],
    "use_cases": [
      {
        "target_user": "AI System Architects",
        "title": "Design stop mechanism",
        "description": "Learn Redis-based state management for workflow control and implement graceful agent termination patterns"
      },
      {
        "target_user": "Backend Developers",
        "title": "Implement stop API",
        "description": "Build the /api/v2/chat/stop endpoint with authentication, polling, and timeout handling"
      },
      {
        "target_user": "QA Engineers",
        "title": "Test workflow control",
        "description": "Understand testing strategy for stop functionality including concurrency and timeout scenarios"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic design query",
        "scenario": "Understanding workflow stop",
        "prompt": "Explain the Redis-based workflow stop mechanism and the key functions for setting, checking, and deleting stop flags."
      },
      {
        "title": "API implementation",
        "scenario": "Building stop endpoint",
        "prompt": "How do I implement the /api/v2/chat/stop endpoint with authentication and the waitForWorkflowComplete function?"
      },
      {
        "title": "Testing strategy",
        "scenario": "Writing unit tests",
        "prompt": "What test cases should I write to verify the workflow stop functionality, including concurrency and timeout scenarios?"
      },
      {
        "title": "Edge cases",
        "scenario": "Handling failures",
        "prompt": "How should I handle Redis operation failures, TTL expiration, and concurrent stop requests in the workflow stop design?"
      }
    ],
    "output_examples": [
      {
        "input": "Explain the workflow stop mechanism and how it handles the stop signal from user click to actual workflow termination",
        "output": [
          "User clicks stop button â†’ Frontend aborts HTTP connection",
          "Backend sets Redis stop flag (agent_runtime_stopping:{appId}:{chatId})",
          "Timer polls Redis every 100ms and updates stopping variable",
          "Next node execution checks stopping flag and exits gracefully",
          "Workflow completion handler deletes Redis key",
          "60-second TTL provides fallback cleanup"
        ]
      }
    ],
    "best_practices": [
      "Use Redis key existence as the stop signal rather than storing complex state values",
      "Implement graceful degradation when Redis operations fail by continuing workflow execution",
      "Set appropriate TTL (60 seconds) on stop flags to prevent key leaks from crashes",
      "Poll frequently enough (100ms) to balance responsiveness and system load"
    ],
    "anti_patterns": [
      "Blocking the stop API indefinitely without timeout handling",
      "Storing stop state in memory only without persistence across server restarts",
      "Assuming all node types can be immediately terminated (LLM streaming vs HTTP requests)",
      "Not handling concurrent stop requests from multiple user actions"
    ],
    "faq": [
      {
        "question": "What Redis operations does this design use?",
        "answer": "SETEX for setting stop flag with TTL, GET for checking flag existence, and DEL for cleanup. All operations are idempotent."
      },
      {
        "question": "What is the polling frequency?",
        "answer": "The backend polls Redis every 100ms to check for stop flags, balancing responsiveness with system performance."
      },
      {
        "question": "How does it integrate with existing authentication?",
        "answer": "The stop API reuses authChatCrud which supports both token-based and API key authentication, plus external link auth data."
      },
      {
        "question": "Is my data safe when stopping workflows?",
        "answer": "Yes, the design only modifies in-memory state and Redis keys for the workflow being stopped. No external data access or exfiltration."
      },
      {
        "question": "What happens if Redis fails during stop operation?",
        "answer": "The design implements graceful degradation. Failed stop checks return false (continue running), and delete errors are logged without blocking."
      },
      {
        "question": "How does this compare to traditional thread interruption?",
        "answer": "This is a cooperative model using Redis as the coordination mechanism, suitable for async/await workflows. Unlike thread interruption, nodes must explicitly check the stopping flag."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
