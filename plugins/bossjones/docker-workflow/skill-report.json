{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-11T03:22:48.506Z",
    "slug": "bossjones-docker-workflow",
    "source_url": "https://github.com/bossjones/logging-lab/tree/main/.claude/skills/docker-workflow",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "164a4a80d21c87d92a420f3d2a33b2f6b9e3204f4a5133a46c883537b4195fec",
    "tree_hash": "8a8a8ebafa0315624fe9588332868e266d368dc132d52b3bcf32eb42d38addeb"
  },
  "skill": {
    "name": "docker-workflow",
    "description": "Comprehensive Docker containerization workflow covering multi-stage builds, docker-compose orchestration, image optimization, debugging, and production best practices. Use when containerizing applications, setting up development environments, or deploying with Docker.",
    "summary": "Comprehensive Docker containerization workflow covering multi-stage builds, docker-compose orchestra...",
    "icon": "üê≥",
    "version": "1.0.0",
    "author": "bossjones",
    "license": "MIT",
    "category": "devops",
    "tags": [
      "docker",
      "containerization",
      "devops",
      "deployment",
      "orchestration"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "external_commands",
      "network",
      "filesystem",
      "env_access"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a legitimate Docker containerization skill with comprehensive documentation and helper scripts. Static analysis flagged many false positives in documentation examples and legitimate Docker commands. No malicious intent detected.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "scripts/docker_helper.sh",
            "line_start": 94,
            "line_end": 94
          }
        ]
      },
      {
        "factor": "network",
        "evidence": [
          {
            "file": "examples/docker-compose.yml",
            "line_start": 23,
            "line_end": 24
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "examples/.dockerignore",
            "line_start": 124,
            "line_end": 125
          }
        ]
      },
      {
        "factor": "env_access",
        "evidence": [
          {
            "file": "examples/docker-compose.yml",
            "line_start": 53,
            "line_end": 54
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 6,
    "total_lines": 2499,
    "audit_model": "claude",
    "audited_at": "2026-01-11T03:22:48.506Z"
  },
  "content": {
    "user_title": "Containerize applications with Docker workflows",
    "value_statement": "Docker containerization simplifies development and deployment by packaging applications with dependencies. This skill provides professional workflows from development through production with optimization and debugging tools.",
    "seo_keywords": [
      "docker containerization",
      "docker compose",
      "multi-stage builds",
      "docker optimization",
      "container deployment",
      "Claude Code docker",
      "docker workflow",
      "container orchestration",
      "docker best practices",
      "production deployment"
    ],
    "actual_capabilities": [
      "Create multi-stage Dockerfiles for Node.js, Python, Go, Java, Rust",
      "Set up docker-compose orchestration with health checks and networking",
      "Optimize Docker images reducing size by 50-90%",
      "Debug containers with inspection tools and log analysis",
      "Implement production deployment strategies with security hardening"
    ],
    "limitations": [
      "Requires Docker and docker-compose installation",
      "Examples use placeholder configurations requiring customization",
      "Production deployment needs environment-specific adjustments",
      "Image optimization results vary by application type"
    ],
    "use_cases": [
      {
        "target_user": "Full-stack developers",
        "title": "Containerize full-stack applications",
        "description": "Package frontend, backend, and database into orchestrated containers with hot-reload for development and optimized builds for production."
      },
      {
        "target_user": "DevOps engineers",
        "title": "Set up production Docker workflows",
        "description": "Implement multi-stage builds, security hardening, health checks, and deployment strategies for scalable containerized applications."
      },
      {
        "target_user": "Development teams",
        "title": "Standardize development environments",
        "description": "Create consistent development environments across team members with docker-compose, volume mounting, and environment-specific configurations."
      }
    ],
    "prompt_templates": [
      {
        "title": "Create a Dockerfile",
        "scenario": "Node.js application with React frontend",
        "prompt": "Create a multi-stage Dockerfile for a Node.js application with a React frontend. Include build optimization, security best practices, and production-ready configuration."
      },
      {
        "title": "Docker Compose Setup",
        "scenario": "Multi-service application stack",
        "prompt": "Set up docker-compose.yml for a web application with Node.js backend, PostgreSQL database, and Redis cache. Include health checks, networking, and volume configuration."
      },
      {
        "title": "Optimize Docker Image",
        "scenario": "Reduce image size and improve build time",
        "prompt": "Optimize my existing Dockerfile to reduce image size by 50% or more. Use multi-stage builds, smaller base images, and layer caching strategies."
      },
      {
        "title": "Debug Container Issues",
        "scenario": "Container crashes or connectivity problems",
        "prompt": "Help debug why my container keeps crashing. Show me how to inspect logs, check health status, verify network connectivity, and identify common issues."
      }
    ],
    "output_examples": [
      {
        "input": "Create a multi-stage Dockerfile for my Python Flask application",
        "output": [
          "Stage 1 - Build dependencies in separate layer",
          "Stage 2 - Copy only production requirements",
          "Stage 3 - Final runtime image with non-root user",
          "Health check endpoint configured",
          "Image size reduced from 1.2GB to 180MB"
        ]
      }
    ],
    "best_practices": [
      "Use specific image versions instead of 'latest' tag for reproducible builds",
      "Implement health checks in docker-compose for reliable service dependencies",
      "Exclude sensitive files and build artifacts with comprehensive .dockerignore"
    ],
    "anti_patterns": [
      "Running containers as root user - always create and use non-root users",
      "Copying entire codebase before installing dependencies - breaks layer caching",
      "Using 'latest' tags in production - always pin specific versions"
    ],
    "faq": [
      {
        "question": "Why use multi-stage builds?",
        "answer": "Multi-stage builds reduce final image size by 50-90% by excluding build dependencies and keeping only runtime requirements."
      },
      {
        "question": "How do I debug a crashing container?",
        "answer": "Use 'docker logs container-name' to see error messages, then 'docker exec -it container-name sh' to inspect the running container."
      },
      {
        "question": "What's the difference between docker-compose.yml and override files?",
        "answer": "docker-compose.yml defines base configuration. Override files like docker-compose.override.yml modify settings for specific environments."
      },
      {
        "question": "How do I optimize Docker build speed?",
        "answer": "Enable BuildKit with DOCKER_BUILDKIT=1, use cache mounts, order Dockerfile commands from least to most changing, and minimize context with .dockerignore."
      },
      {
        "question": "Should I use Alpine or Debian base images?",
        "answer": "Alpine images are smaller but may have compatibility issues. Use Alpine for size-critical deployments, Debian for compatibility."
      },
      {
        "question": "How do I handle secrets in Docker?",
        "answer": "Use Docker secrets in Swarm mode, environment variables from secure sources, or external secret management tools. Never hardcode secrets in images."
      }
    ]
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "docker-compose.yml",
          "type": "file",
          "path": "examples/docker-compose.yml"
        },
        {
          "name": "Dockerfile.multi-stage",
          "type": "file",
          "path": "examples/Dockerfile.multi-stage"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "docker_helper.sh",
          "type": "file",
          "path": "scripts/docker_helper.sh"
        }
      ]
    },
    {
      "name": "README.md",
      "type": "file",
      "path": "README.md"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
