{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2025-12-31T06:28:24.885Z",
    "slug": "webapp-testing",
    "source_url": "https://github.com/anthropics/skills/tree/main/skills/webapp-testing",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "official"
  },
  "skill": {
    "name": "webapp-testing",
    "description": "Toolkit for interacting with and testing local web applications using Playwright. Supports verifying frontend functionality, debugging UI behavior, capturing browser screenshots, and viewing browser logs.",
    "summary": "Toolkit for interacting with and testing local web applications using Playwright. Supports verifying...",
    "icon": "ðŸ§ª",
    "version": "1.0.0",
    "author": "Anthropic",
    "license": "Complete terms in LICENSE.txt",
    "category": "automation",
    "tags": [
      "playwright",
      "testing",
      "web-automation",
      "browser",
      "frontend",
      "qa",
      "debugging",
      "screenshots"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Official Anthropic skill with no malicious code detected. Uses Playwright for legitimate browser automation with standard operations (navigation, screenshots, form interaction). All file operations write to safe temp/output directories.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 6,
    "total_lines": 512,
    "audit_model": "claude",
    "audited_at": "2025-12-31T06:28:24.885Z"
  },
  "content": {
    "user_title": "Web Application Testing with Playwright",
    "value_statement": "Automatically test, debug, and interact with local web applications using Python-based Playwright scripts for UI verification, screenshot capture, and browser console monitoring.",
    "seo_keywords": [
      "playwright testing",
      "web automation python",
      "frontend testing",
      "browser automation",
      "ui testing",
      "web app debugging",
      "screenshot testing",
      "console log capture"
    ],
    "actual_capabilities": [
      "Launch and control Chromium browser in headless mode",
      "Navigate to local web applications (localhost or file:// URLs)",
      "Discover and interact with page elements (buttons, links, forms)",
      "Capture full-page screenshots for visual verification",
      "Record browser console logs during automation",
      "Fill forms and submit data programmatically",
      "Wait for network activity and page state changes",
      "Manage server lifecycle with helper scripts",
      "Support for multiple concurrent servers (frontend + backend)"
    ],
    "limitations": [
      "Only supports Chromium browser (not Firefox or WebKit)",
      "Requires local server to be startable via command line",
      "Limited to localhost and file:// URLs (no remote testing)",
      "No built-in assertion framework (requires separate test framework)",
      "Synchronous API only (no async/await examples)",
      "Screenshots saved locally (no cloud storage integration)"
    ],
    "use_cases": [
      {
        "title": "Frontend Regression Testing",
        "description": "Verify that UI changes haven't broken existing functionality by automating user flows and capturing screenshots before/after changes",
        "target_user": "Frontend developers working on React, Vue, or vanilla JavaScript applications"
      },
      {
        "title": "Local Development Debugging",
        "description": "Capture console logs and screenshots during development to diagnose issues that only occur during automated interactions",
        "target_user": "Web developers debugging complex user interactions or race conditions"
      },
      {
        "title": "Static HTML Validation",
        "description": "Test form submissions, interactive elements, and client-side JavaScript in static HTML files without deploying to a server",
        "target_user": "Designers and junior developers working with static prototypes"
      },
      {
        "title": "Full-Stack Integration Testing",
        "description": "Test frontend-backend integration by starting both servers simultaneously and automating end-to-end user workflows",
        "target_user": "Full-stack developers validating API integration with UI"
      }
    ],
    "prompt_templates": [
      {
        "title": "Test Login Flow",
        "prompt": "Test the login flow on my React app running at localhost:3000. Fill in username 'testuser', password 'test123', click submit, and verify the dashboard loads. Capture screenshots at each step.",
        "scenario": "When you need to verify authentication functionality works correctly"
      },
      {
        "title": "Capture Console Errors",
        "prompt": "Navigate to my app at localhost:5173, click through all navigation links, and capture any console errors or warnings that appear. Save the logs to a file.",
        "scenario": "When debugging JavaScript errors that occur during user navigation"
      },
      {
        "title": "Discover Form Elements",
        "prompt": "Open my static HTML form at /path/to/form.html and list all input fields, their names, types, and any buttons available. Take a screenshot for reference.",
        "scenario": "When you need to understand the structure of a form before writing automation"
      },
      {
        "title": "Multi-Server E2E Test",
        "prompt": "Start my backend server (python server.py on port 8000) and frontend (npm run dev on port 5173), then test the user registration flow. Fill the form, submit, and verify success message appears.",
        "scenario": "When testing full-stack applications that require both servers running"
      }
    ],
    "output_examples": [
      {
        "input": "Test the contact form on localhost:5173",
        "output": "Creates a Python script that: (1) launches Chromium headless, (2) navigates to localhost:5173, (3) waits for networkidle, (4) fills name/email/message fields, (5) clicks submit button, (6) captures screenshot of success message, (7) saves to /tmp/contact_form_test.png"
      },
      {
        "input": "Capture console logs while clicking the Dashboard link",
        "output": "Returns a script that sets up console message handler, navigates to the page, clicks 'Dashboard', captures all console.log/warn/error messages, and saves them to /mnt/user-data/outputs/console.log with timestamps and log levels"
      }
    ],
    "best_practices": [
      "Always wait for 'networkidle' state before interacting with dynamic web apps",
      "Use descriptive selectors (text=, role=, or specific IDs) rather than generic CSS selectors",
      "Run scripts with --help first to understand available options before reading source code",
      "Launch browser in headless mode for faster execution and lower resource usage",
      "Close browser explicitly after automation completes to free resources",
      "Use with_server.py helper for managing server lifecycle instead of manual subprocess management",
      "Take screenshots at critical steps for visual debugging and verification",
      "Use reconnaissance-then-action pattern: inspect DOM first, then act on discovered elements"
    ],
    "anti_patterns": [
      "Inspecting DOM before waiting for networkidle on JavaScript-heavy apps",
      "Reading helper script source code instead of using --help and treating as black box",
      "Hardcoding timeouts instead of waiting for specific page states or selectors",
      "Using file:// URLs when the app actually needs a server (for API calls, routing, etc.)",
      "Forgetting to close browser, causing resource leaks in long-running processes",
      "Using non-headless mode unnecessarily, which requires display server"
    ],
    "faq": [
      {
        "question": "Can I use this skill to test remote websites in production?",
        "answer": "No, this skill is designed for local testing only (localhost and file:// URLs). For production testing, you'd need a different setup with proper authentication and network configuration."
      },
      {
        "question": "Do I need to install Playwright separately?",
        "answer": "The skill assumes Playwright is available in the Python environment. You may need to install it with 'pip install playwright' and run 'playwright install chromium' to download browser binaries."
      },
      {
        "question": "What's the difference between testing static HTML vs dynamic webapps?",
        "answer": "Static HTML can be tested directly via file:// URLs and the DOM is immediately available. Dynamic webapps need a server running and require waiting for 'networkidle' state since JavaScript modifies the DOM after initial load."
      },
      {
        "question": "Can I run tests on multiple browsers?",
        "answer": "The examples only show Chromium (headless). While Playwright supports Firefox and WebKit, you'd need to modify the scripts to use p.firefox or p.webkit instead of p.chromium."
      },
      {
        "question": "How do I handle authentication tokens or cookies?",
        "answer": "You can set cookies using page.context.add_cookies() or inject localStorage/sessionStorage with page.evaluate(). The skill doesn't provide pre-built auth helpers, so you'd write custom Playwright code."
      }
    ],
    "technical_requirements": {
      "dependencies": [
        "Python 3.x",
        "playwright (Python package)",
        "Chromium browser binaries (via 'playwright install chromium')",
        "Node.js/npm (if testing JavaScript applications that need build servers)"
      ],
      "permissions": [
        "Network access to localhost",
        "File system read access for static HTML files",
        "File system write access for screenshots and logs (/tmp, /mnt/user-data/outputs)",
        "Process spawning for starting servers and browser"
      ],
      "complexity": "intermediate"
    }
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "console_logging.py",
          "type": "file",
          "path": "examples/console_logging.py"
        },
        {
          "name": "element_discovery.py",
          "type": "file",
          "path": "examples/element_discovery.py"
        },
        {
          "name": "static_html_automation.py",
          "type": "file",
          "path": "examples/static_html_automation.py"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "with_server.py",
          "type": "file",
          "path": "scripts/with_server.py"
        }
      ]
    },
    {
      "name": "LICENSE.txt",
      "type": "file",
      "path": "LICENSE.txt"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}