{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T11:31:08.840Z",
    "slug": "briandai22-backend-dev-guidelines",
    "source_url": "https://github.com/BrianDai22/concetrateaiquiz/tree/main/.claude/skills/backend-dev-guidelines",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "7129685d12fab4fd1b8b881c467a455583374c314e4d0d20f4940f69f77ae23b",
    "tree_hash": "68b91abaa1f29304a739917188ad82a5c03c5e0ea02f68f6d420190811f19503"
  },
  "skill": {
    "name": "backend-dev-guidelines",
    "description": "Comprehensive backend development guide for Node.js/Express/TypeScript microservices. Use when creating routes, controllers, services, repositories, middleware, or working with Express APIs, Prisma database access, Sentry error tracking, Zod validation, unifiedConfig, dependency injection, or async patterns. Covers layered architecture (routes → controllers → services → repositories), BaseController pattern, error handling, performance monitoring, testing strategies, and migration from legacy patterns.",
    "summary": "Comprehensive backend development guide for Node.js/Express/TypeScript microservices. Use when creat...",
    "icon": "⚙️",
    "version": "1.0.0",
    "author": "BrianDai22",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "Node.js",
      "Express",
      "TypeScript",
      "microservices",
      "backend"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing only markdown files with code examples. No executable code, no network calls, no file system access beyond reading its own files, and no environment variable access. Content matches stated purpose of providing backend development guidelines.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 12,
    "total_lines": 5291,
    "audit_model": "claude",
    "audited_at": "2026-01-10T11:31:08.840Z"
  },
  "content": {
    "user_title": "Build Node.js backend services with best practices",
    "value_statement": "Inconsistent backend code causes bugs and slow development. This skill provides layered architecture patterns, BaseController templates, Prisma repository patterns, Zod validation guides, and Sentry integration for reliable Express microservices.",
    "seo_keywords": [
      "Claude backend development",
      "Node.js Express patterns",
      "TypeScript microservices",
      "Express routes controllers",
      "Prisma ORM best practices",
      "Sentry error tracking",
      "Zod validation",
      "dependency injection",
      "layered architecture",
      "Claude Code backend"
    ],
    "actual_capabilities": [
      "Creates route definitions that delegate to controllers",
      "Implements BaseController with error handling and Sentry integration",
      "Organizes business logic in services with dependency injection",
      "Builds repositories for database access with Prisma",
      "Adds input validation with Zod schemas and DTO pattern"
    ],
    "limitations": [
      "Does not generate complete project structure",
      "Does not create database migrations",
      "Does not configure deployment or CI/CD pipelines",
      "Does not provide OAuth or authentication implementation"
    ],
    "use_cases": [
      {
        "target_user": "Backend developers",
        "title": "New Express endpoint",
        "description": "Create a clean route that delegates to a controller following the layered architecture pattern"
      },
      {
        "target_user": "Full-stack engineers",
        "title": "Add input validation",
        "description": "Implement type-safe validation with Zod schemas and automatic TypeScript type inference"
      },
      {
        "target_user": "Team leads",
        "title": "Code review standards",
        "description": "Enforce consistent patterns across microservices with BaseController and repository patterns"
      }
    ],
    "prompt_templates": [
      {
        "title": "New endpoint",
        "scenario": "Creating a clean route",
        "prompt": "Create a route for /users that returns a list of active users. Use the layered architecture pattern with a controller that extends BaseController."
      },
      {
        "title": "Validation schema",
        "scenario": "Adding input validation",
        "prompt": "Create a Zod schema for a user registration form with email, name, and password fields. Include TypeScript type inference."
      },
      {
        "title": "Repository pattern",
        "scenario": "Database access layer",
        "prompt": "Create a UserRepository class that uses PrismaService to find users by email and create new users. Include error handling."
      },
      {
        "title": "Error handling",
        "scenario": "Sentry integration",
        "prompt": "Show how to properly capture errors in a service method with Sentry, including user context and operation tags."
      }
    ],
    "output_examples": [
      {
        "input": "Create a route for creating a new user",
        "output": [
          "Route definition (routes/userRoutes.ts):",
          "- Define POST /users route",
          "- Apply SSOMiddlewareClient.verifyLoginStatus",
          "- Delegate to UserController.createUser",
          "",
          "Controller method (controllers/UserController.ts):",
          "- Extend BaseController",
          "- Validate input with createUserSchema.parse(req.body)",
          "- Call userService.create(validated)",
          "- Use handleSuccess with 201 status on success",
          "- Use handleError with Sentry capture on failure"
        ]
      }
    ],
    "best_practices": [
      "Keep routes clean - delegate all logic to controllers",
      "Extend BaseController for consistent error handling and Sentry integration",
      "Use Zod for type-safe input validation with automatic TypeScript inference",
      "Separate concerns: routes handle routing, controllers handle HTTP, services handle business logic, repositories handle data access"
    ],
    "anti_patterns": [
      "Business logic in route handlers - violates separation of concerns",
      "Direct process.env usage instead of unifiedConfig",
      "Missing error handling or swallowing errors without Sentry capture",
      "Direct Prisma calls in controllers or services - use repositories instead"
    ],
    "faq": [
      {
        "question": "Does this skill work with Fastify instead of Express?",
        "answer": "The patterns translate to Fastify with minor adjustments. Routes and controllers remain similar. Use Fastify's plugin system instead of Express middleware."
      },
      {
        "question": "What database ORMs are supported?",
        "answer": "Primary pattern uses Prisma, but repository pattern applies to any ORM. Kysely and TypeORM can use similar service and repository layers."
      },
      {
        "question": "Can I use this with Next.js API routes?",
        "answer": "Yes. The controller pattern maps to API route handlers. Services and repositories work unchanged. BaseController methods can be adapted for Next.js Response."
      },
      {
        "question": "Is my data safe when using this skill?",
        "answer": "Yes. This is a documentation-only skill. It provides code examples but never accesses your files, environment variables, or makes network requests."
      },
      {
        "question": "Why am I getting type errors with the generated code?",
        "answer": "Ensure you have the required dependencies installed: @sentry/node, @prisma/client, zod, and their TypeScript types. Run prisma generate after defining your schema."
      },
      {
        "question": "How is this different from using documentation websites?",
        "answer": "This skill provides context-aware patterns specific to your codebase. It understands your existing patterns and generates consistent code that matches your architecture."
      }
    ]
  },
  "file_structure": [
    {
      "name": "resources",
      "type": "dir",
      "path": "resources",
      "children": [
        {
          "name": "architecture-overview.md",
          "type": "file",
          "path": "resources/architecture-overview.md"
        },
        {
          "name": "async-and-errors.md",
          "type": "file",
          "path": "resources/async-and-errors.md"
        },
        {
          "name": "complete-examples.md",
          "type": "file",
          "path": "resources/complete-examples.md"
        },
        {
          "name": "configuration.md",
          "type": "file",
          "path": "resources/configuration.md"
        },
        {
          "name": "database-patterns.md",
          "type": "file",
          "path": "resources/database-patterns.md"
        },
        {
          "name": "middleware-guide.md",
          "type": "file",
          "path": "resources/middleware-guide.md"
        },
        {
          "name": "routing-and-controllers.md",
          "type": "file",
          "path": "resources/routing-and-controllers.md"
        },
        {
          "name": "sentry-and-monitoring.md",
          "type": "file",
          "path": "resources/sentry-and-monitoring.md"
        },
        {
          "name": "services-and-repositories.md",
          "type": "file",
          "path": "resources/services-and-repositories.md"
        },
        {
          "name": "testing-guide.md",
          "type": "file",
          "path": "resources/testing-guide.md"
        },
        {
          "name": "validation-patterns.md",
          "type": "file",
          "path": "resources/validation-patterns.md"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
