{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2025-12-30T14:32:35.326Z",
    "slug": "writing-hookify-rules",
    "source_url": "https://github.com/anthropics/claude-code/tree/main/plugins/hookify/skills/writing-rules",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "trust_level": "official"
  },
  "skill": {
    "name": "Writing Hookify Rules",
    "description": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"configure hookify\", \"add a hookify rule\", or needs guidance on hookify rule syntax and patterns.",
    "summary": "This skill should be used when the user asks to \"create a hookify rule\", \"write a hook rule\", \"confi...",
    "icon": "⚙️",
    "version": "0.1.0",
    "author": "Anthropic",
    "license": "Not specified",
    "category": "automation",
    "tags": [
      "hookify",
      "rules",
      "patterns",
      "safety",
      "validation",
      "automation",
      "guards",
      "monitoring"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is an official Anthropic skill providing documentation and guidance for the Hookify plugin. It contains only instructional content with no executable code or external dependencies.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 375,
    "audit_model": "claude",
    "audited_at": "2025-12-30T14:32:35.326Z"
  },
  "content": {
    "user_title": "Hookify Rule Writing Assistant",
    "value_statement": "Helps you create custom safety rules and validation patterns to control what actions Claude Code can perform in your project, preventing dangerous commands and enforcing best practices.",
    "seo_keywords": [
      "hookify",
      "safety rules",
      "command validation",
      "claude code hooks",
      "pattern matching",
      "bash guards",
      "file operation controls",
      "regex patterns",
      "development safety",
      "code quality enforcement"
    ],
    "actual_capabilities": [
      "Creates hookify rule files with proper YAML frontmatter structure",
      "Generates regex patterns for matching bash commands, file operations, and prompts",
      "Configures warn and block actions for different event types",
      "Sets up multi-condition rules for complex validation scenarios",
      "Provides helpful warning messages and best practice guidance",
      "Creates rules for bash commands, file edits, stop events, and prompt submissions",
      "Generates patterns for common dangerous operations (rm -rf, chmod 777, etc.)",
      "Creates security-focused rules for sensitive files and credentials"
    ],
    "limitations": [
      "Only generates rule documentation - does not execute or test the rules",
      "Requires the Hookify plugin to be installed in Claude Code",
      "Cannot validate regex patterns in real-time",
      "Does not automatically detect what rules a project needs",
      "Rules must be manually placed in .claude/ directory",
      "Cannot modify or audit existing hookify rules"
    ],
    "use_cases": [
      {
        "title": "Prevent Dangerous Commands",
        "description": "Create rules that block or warn about destructive bash commands like rm -rf, sudo operations, or permission changes that could compromise system security.",
        "target_user": "DevOps engineers, system administrators, and developers working on production systems"
      },
      {
        "title": "Enforce Code Quality Standards",
        "description": "Set up rules to detect and prevent debug code (console.log, debugger statements) from being committed to production codebases.",
        "target_user": "Team leads, senior developers, and quality assurance engineers"
      },
      {
        "title": "Protect Sensitive Files",
        "description": "Monitor edits to configuration files, environment variables, and credential files to prevent accidental exposure of secrets.",
        "target_user": "Security engineers, DevOps teams, and compliance officers"
      },
      {
        "title": "Completion Checklists",
        "description": "Create stop event rules that remind Claude to run tests, update documentation, or verify builds before considering a task complete.",
        "target_user": "Project managers, QA engineers, and developers following strict workflows"
      },
      {
        "title": "Team-Specific Workflows",
        "description": "Enforce organization-specific patterns like required code review processes, deployment checklists, or architectural standards.",
        "target_user": "Engineering managers, tech leads, and platform teams"
      }
    ],
    "prompt_templates": [
      {
        "title": "Block Dangerous Delete Commands",
        "prompt": "Create a hookify rule that blocks any rm -rf commands from being executed",
        "scenario": "When you want to prevent accidental deletion of important files or directories"
      },
      {
        "title": "Warn About Console Logs",
        "prompt": "Write a hookify rule to warn me when I add console.log statements to TypeScript files",
        "scenario": "When enforcing code quality standards that prohibit debug logging in production"
      },
      {
        "title": "Protect Environment Files",
        "prompt": "Create a hookify rule that warns when editing .env files and reminds me to check .gitignore",
        "scenario": "When working with sensitive configuration to prevent credential leaks"
      },
      {
        "title": "Pre-Completion Checklist",
        "prompt": "Make a hookify rule that shows a checklist before Claude stops, reminding me to run tests and update docs",
        "scenario": "When you want to ensure all quality gates are checked before completing tasks"
      },
      {
        "title": "Multi-Condition Security Rule",
        "prompt": "Create a hookify rule that blocks editing Python files in the /config directory if they contain password or api_key strings",
        "scenario": "When implementing complex security policies with multiple validation criteria"
      }
    ],
    "output_examples": [
      {
        "input": "Create a hookify rule that blocks rm -rf commands",
        "output": "I'll create a hookify rule to block dangerous rm -rf commands.\n\n[Creates .claude/hookify.dangerous-rm.local.md with:\n- name: dangerous-rm\n- enabled: true\n- event: bash\n- action: block\n- pattern: rm\\s+-rf\n- Warning message about destructive operations]"
      },
      {
        "input": "Write a rule to warn about console.log in JavaScript files",
        "output": "[Creates .claude/hookify.console-log.local.md with:\n- Multi-condition rule checking file_path ends with .js/.jsx/.ts/.tsx\n- Checks new_text contains console.log(\n- Provides helpful message about using proper logging libraries\n- Suggests alternatives and best practices]"
      }
    ],
    "best_practices": [
      "Start with 'warn' action before using 'block' to test patterns safely",
      "Use descriptive, action-oriented names starting with verbs (warn-, block-, require-)",
      "Test regex patterns with Python or online tools before deploying",
      "Add rules to .gitignore with pattern .claude/*.local.md to keep them personal",
      "Write clear, actionable messages that explain why something is problematic and suggest alternatives",
      "Use multi-condition rules to avoid false positives with overly broad patterns",
      "Keep patterns specific enough to avoid matching unintended cases",
      "Document the purpose of each rule in the message body",
      "Group related rules by naming convention (e.g., security-*, quality-*)",
      "Review and update rules periodically as project requirements evolve"
    ],
    "anti_patterns": [
      "Using overly broad patterns that match unintended strings (e.g., 'log' matching 'login', 'dialog')",
      "Forgetting to escape special regex characters like dots and parentheses",
      "Creating rules without testing them first",
      "Using generic names like 'rule1' or 'my-rule' instead of descriptive identifiers",
      "Blocking operations without providing helpful alternatives in the message",
      "Using double backslashes in unquoted YAML strings (causes pattern matching failures)",
      "Omitting the .local suffix in filenames (may cause rules to be committed to version control)",
      "Setting action to 'block' without thoroughly testing pattern accuracy first",
      "Creating duplicate rules with overlapping patterns",
      "Writing messages without explaining why the detected pattern is problematic"
    ],
    "faq": [
      {
        "question": "Where should I create hookify rule files?",
        "answer": "Create them in the .claude/ directory at your project root with the naming pattern: hookify.{descriptive-name}.local.md. Add .claude/*.local.md to .gitignore to keep rules personal."
      },
      {
        "question": "When do rule changes take effect?",
        "answer": "Rules are read dynamically, so changes take effect immediately on the next tool use. No restart or reload is required."
      },
      {
        "question": "What's the difference between 'warn' and 'block' actions?",
        "answer": "'warn' shows the message but allows the operation to proceed. 'block' prevents the operation entirely (for bash/file events) or stops the session (for stop events)."
      },
      {
        "question": "How do I test regex patterns before using them in rules?",
        "answer": "Use Python: python3 -c \"import re; print(re.search(r'your_pattern', 'test text'))\" or online tools like regex101.com with Python flavor selected."
      },
      {
        "question": "Can I have multiple conditions in one rule?",
        "answer": "Yes, use the 'conditions' array in frontmatter. All conditions must match for the rule to trigger. Each condition specifies a field, operator, and pattern."
      },
      {
        "question": "What events can I hook into?",
        "answer": "You can hook into: 'bash' (Bash commands), 'file' (Edit/Write operations), 'stop' (when Claude wants to stop), 'prompt' (user input), or 'all' (every event)."
      },
      {
        "question": "How do I temporarily disable a rule?",
        "answer": "Set 'enabled: false' in the frontmatter. To permanently remove it, delete the .local.md file."
      },
      {
        "question": "What fields can I match on for file events?",
        "answer": "For file events, you can match on: file_path, new_text, old_text, or content. Use conditions to specify which field to check."
      },
      {
        "question": "Do I need to escape backslashes in YAML patterns?",
        "answer": "For unquoted YAML values, use single backslashes (pattern: \\s). For quoted strings, you'd need double backslashes, so it's recommended to leave patterns unquoted."
      },
      {
        "question": "Can rules access environment variables or project configuration?",
        "answer": "No, rules only have access to the specific fields provided by each event type (command text, file paths, file content, etc.). They cannot read environment variables or external configuration."
      }
    ],
    "technical_requirements": {
      "dependencies": [
        "Hookify plugin installed in Claude Code",
        "Python regex knowledge for pattern writing",
        "Access to create files in .claude/ directory"
      ],
      "permissions": [
        "File system write access to create .claude/ directory",
        "Ability to create .local.md files in project root"
      ],
      "complexity": "intermediate"
    }
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}