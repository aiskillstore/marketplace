{
  "meta": {
    "generated_at": "2025-12-29T14:56:28Z",
    "model": "gpt-5.2:high",
    "source_url": "https://github.com/anthropics/claude-code",
    "source_ref": "d213a74fc8e3b6efded52729196e0c2d4c3abb3e",
    "analysis_version": "2.0.0"
  },
  "security_audit": {
    "risk_level": "safe",
    "should_block": false,
    "safe_to_publish": true,
    "summary": "This skill is purely documentation for writing Hookify rules and contains no executable code, file access, or network behavior.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [
      "Documentation includes examples of potentially dangerous command patterns (e.g., rm -rf, sudo, chmod 777) for detection purposes, not execution."
    ],
    "files_analyzed": 1,
    "dangerous_patterns_found": [
      "Mentions of dangerous shell command patterns for matching (rm\\s+-rf, sudo\\s+, chmod\\s+777) in SKILL.md:130",
      "Mentions of disk/formatting command patterns for matching (dd\\s+if=, mkfs) in SKILL.md:138",
      "Mentions of risky code patterns for matching (eval\\(, innerHTML\\s*=, dangerouslySetInnerHTML) in SKILL.md:157",
      "Example command to run python3 -c for regex testing (user-executed) in SKILL.md:272"
    ],
    "files_scanned": 1,
    "total_lines": 374
  },
  "content": {
    "user_title": "Create Hookify rules to catch risky actions",
    "value_statement": "Manually writing Hookify rules is error-prone, especially around regex escaping, events, and conditions. This guide helps you author clear, effective rules that warn or block risky commands and unsafe code edits.",
    "seo_keywords": [
      "Hookify",
      "Claude Code",
      "claude",
      "regex rules",
      "YAML frontmatter",
      "bash command safety",
      "pre-commit style checks",
      "secure coding guardrails",
      "developer workflow",
      "markdown automation"
    ],
    "actual_capabilities": [
      "Explains Hookify rule file structure using Markdown + YAML frontmatter",
      "Documents supported events (bash, file, stop, prompt, all) and when to use each",
      "Provides guidance for simple regex patterns and multi-condition rules",
      "Lists common detection patterns for dangerous commands and risky code constructs",
      "Gives practical regex writing tips, escaping guidance, and testing approach"
    ],
    "limitations": [
      "Does not execute or validate rules automatically; it only provides syntax and examples",
      "Does not ship with built-in rule files; users must create `.claude/hookify.*.local.md` themselves",
      "Cannot guarantee coverage for all edge cases in user projects or commands",
      "Does not enforce gitignore changes; it only recommends them"
    ],
    "use_cases": [
      {
        "target_user": "Team leads and security-minded developers",
        "title": "Block dangerous shell commands",
        "description": "Write bash-event rules that warn or block patterns like `rm -rf`, `sudo`, or unsafe permission changes before they run."
      },
      {
        "target_user": "Frontend and full-stack engineers",
        "title": "Detect risky code edits",
        "description": "Add file-event rules to flag `eval(`, `innerHTML=`, or `dangerouslySetInnerHTML` additions during edits."
      },
      {
        "target_user": "DevEx / platform engineers",
        "title": "Standardize completion checks",
        "description": "Use stop-event rules to prompt for required steps like running tests, updating docs, or verifying builds."
      }
    ],
    "prompt_templates": [
      {
        "level": "beginner",
        "prompt": "Create a Hookify rule that warns when I run `rm -rf` in bash. Include the exact `.claude/hookify.*.local.md` content and a safe regex."
      },
      {
        "level": "intermediate",
        "prompt": "Write a Hookify `file` rule that triggers only for `.ts` or `.tsx` files and warns if `console.log(` is added in `new_text`. Use conditions."
      },
      {
        "level": "intermediate",
        "prompt": "Help me design a Hookify rule that warns when editing `.env` files and the text contains `API_KEY` or `SECRET`. Provide a tight regex and message."
      },
      {
        "level": "advanced",
        "prompt": "Create a `stop` Hookify rule that always triggers and shows a checklist for: tests, lint, build, and changelog. Make it concise and actionable."
      }
    ],
    "output_examples": [
      {
        "description": "Example rule output for blocking a dangerous bash command pattern",
        "example": "---\nname: block-dangerous-rm\nenabled: true\nevent: bash\naction: block\npattern: rm\\s+-rf\n---\n\nBlocked: detected `rm -rf`.\n\nSafer options:\n- Use `rm -i` for interactive deletes\n- Target specific files/directories\n- Confirm you are in the correct path before deleting\n"
      }
    ],
    "best_practices": [
      "Prefer condition-based rules for precision (e.g., match `file_path` and `new_text` together) to reduce false positives",
      "Keep regex patterns unquoted in YAML when possible to avoid double-escaping pitfalls",
      "Use clear messages that explain impact and provide safer alternatives, not just a warning"
    ],
    "anti_patterns": [
      "Using overly broad patterns like `log` that match unrelated words (e.g., login, catalog)",
      "Hard-coding exact command strings or paths when whitespace/flags vary; use `\\s+` and minimal anchors appropriately",
      "Forgetting to add `.claude/*.local.md` to `.gitignore`, causing local guardrails to leak into repos unintentionally"
    ],
    "faq": [
      {
        "question": "Is this compatible with Claude Code Hookify?",
        "answer": "Yes. It documents Hookify rules as Markdown files with YAML frontmatter using the events and fields described for Claude Code Hookify."
      },
      {
        "question": "Does it run commands, edit files, or access my credentials?",
        "answer": "No. The skill content is documentation only; it contains no executable code, no file reads, and no network calls."
      },
      {
        "question": "Can I use this to block actions instead of just warnings?",
        "answer": "Yes. It describes an optional `action` field, including `block`, and explains where blocking applies (e.g., PreToolUse for tool invocations)."
      },
      {
        "question": "How do I integrate the rules into my project?",
        "answer": "Create files under `.claude/` named like `.claude/hookify.{descriptive-name}.local.md` and ensure `.claude/*.local.md` is gitignored."
      },
      {
        "question": "My rule triggers too often. How do I reduce false positives?",
        "answer": "Switch from a single `pattern` to `conditions` and constrain by fields like `file_path` plus `new_text`, and tighten regex patterns to specific tokens."
      },
      {
        "question": "How is this different from pre-commit hooks or linters?",
        "answer": "Hookify rules trigger during the agent/tool workflow (bash/file/stop/prompt events) and can provide contextual guidance or blocking, complementing linters and pre-commit checks rather than replacing them."
      }
    ],
    "technical_requirements": {
      "dependencies": [
        "Claude Code with Hookify support"
      ],
      "permissions_needed": [
        "Write access to the project directory to create `.claude/hookify.*.local.md` files"
      ],
      "estimated_complexity": "low",
      "setup_time_minutes": 5
    }
  }
}
