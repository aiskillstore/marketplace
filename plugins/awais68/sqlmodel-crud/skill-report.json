{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T11:11:46.940Z",
    "slug": "awais68-sqlmodel-crud",
    "source_url": "https://github.com/Awais68/hackathon-2-phase-ii-full-stack-web-app/tree/main/.claude/skills/sqlmodel-crud",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "92aee1a31aa0be83ae389fad19c7a08fd2f5057ccdaa88bc6ef8e0531c625eea",
    "tree_hash": "569532bc281730c0a80d6b65e8289cd556d52940f17d13d53271f79c18d2aa29"
  },
  "skill": {
    "name": "sqlmodel-crud",
    "description": "Use when creating SQLModel database models, CRUD operations, queries with joins, or relationships.\nNOT when non-database operations, plain SQL, or unrelated data handling.\nTriggers: \"SQLModel\", \"database model\", \"CRUD\", \"create/read/update/delete\", \"query\", \"ForeignKey\", \"relationship\".\n",
    "summary": "Use when creating SQLModel database models, CRUD operations, queries with joins, or relationships.\nN...",
    "icon": "üóÑÔ∏è",
    "version": "1.0.0",
    "author": "Awais68",
    "license": "MIT",
    "category": "data",
    "tags": [
      "sqlmodel",
      "database",
      "crud",
      "pydantic",
      "sqlalchemy"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing only guidance examples for SQLModel database operations. No executable code, no network access, no filesystem access beyond the skill file itself.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 701,
    "audit_model": "claude",
    "audited_at": "2026-01-10T11:11:46.940Z"
  },
  "content": {
    "user_title": "Create SQLModel database models and CRUD operations",
    "value_statement": "Creating SQLModel database models requires understanding Pydantic integration, async sessions, and relationship configuration. This skill provides expert patterns for building type-safe database operations with proper validation.",
    "seo_keywords": [
      "sqlmodel",
      "sqlmodel crud",
      "database models",
      "pydantic validation",
      "sqlalchemy",
      "fastapi database",
      "python orm",
      "claude code sqlmodel",
      "claude sqlmodel",
      "codex sqlmodel"
    ],
    "actual_capabilities": [
      "Create SQLModel table=True models with Pydantic validators",
      "Implement async CRUD operations with AsyncSession",
      "Build queries with joins, filters, and pagination",
      "Configure one-to-many, many-to-many, and self-referential relationships",
      "Add field constraints with min_length, max_length, pattern, and foreign keys",
      "Use eager loading with selectinload for relationship access"
    ],
    "limitations": [
      "Does not execute database migrations automatically",
      "Does not provide database connection pooling configuration",
      "Does not handle authentication or authorization logic",
      "Requires separate setup for database engine and session management"
    ],
    "use_cases": [
      {
        "target_user": "Backend developers",
        "title": "Build type-safe FastAPI endpoints",
        "description": "Create SQLModel models and CRUD operations for FastAPI routes with proper Pydantic validation and async database sessions."
      },
      {
        "target_user": "Full-stack developers",
        "title": "Design database schema",
        "description": "Design entities with relationships including one-to-many, many-to-many, and one-to-one patterns with proper foreign keys."
      },
      {
        "target_user": "Data engineers",
        "title": "Write complex queries",
        "description": "Build advanced queries with joins, subqueries, aggregations, conditional logic, and pagination for reporting systems."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic model",
        "scenario": "Create a simple SQLModel table",
        "prompt": "Create a SQLModel table=True model called Product with id, name, price, and description fields including proper validation constraints."
      },
      {
        "title": "CRUD operations",
        "scenario": "Build CRUD for a model",
        "prompt": "Write async CRUD operations for a Product model including create, get_by_id, get_all with pagination, update, and delete methods using AsyncSession."
      },
      {
        "title": "Relationships",
        "scenario": "Link models with relationships",
        "prompt": "Create SQLModel models for Order and OrderItem with one-to-many relationship including back_populates and proper foreign key configuration."
      },
      {
        "title": "Complex queries",
        "scenario": "Build advanced query",
        "prompt": "Write a query to get orders with their items using eager loading with selectinload, filtering by date range, and ordering by created_at descending."
      }
    ],
    "output_examples": [
      {
        "input": "Create a Student model with name, email, and enrollment date fields",
        "output": [
          "Created Student model with id (UUID primary key), name (2-100 chars required), email (unique index), enrollment_date (datetime), and timestamps",
          "Added table=True for database table creation",
          "Configured optional is_active field with default True",
          "Ready to use with CRUD operations"
        ]
      }
    ],
    "best_practices": [
      "Use table=True for all database models and separate Pydantic models for request/response schemas",
      "Add index=True on frequently filtered fields and unique=True on email and other business keys",
      "Always use AsyncSession for async applications and handle transactions with commit/rollback"
    ],
    "anti_patterns": [
      "Do not use from_attributes = True without understanding the security implications of mass assignment",
      "Avoid mixing SQLModel and Pydantic models in the same class definition without proper separation",
      "Do not skip adding created_at and updated_at timestamps for audit trails"
    ],
    "faq": [
      {
        "question": "What Python versions are supported?",
        "answer": "SQLModel requires Python 3.8 or later for production use."
      },
      {
        "question": "What databases work with SQLModel?",
        "answer": "SQLModel supports PostgreSQL, MySQL, SQLite, and other databases compatible with SQLAlchemy async drivers."
      },
      {
        "question": "How do I integrate with FastAPI?",
        "answer": "Use FastAPI's Depends() to inject AsyncSession from a sessionmaker factory connected to your SQLModel engine."
      },
      {
        "question": "Is my data safe with this skill?",
        "answer": "Yes. This skill only provides guidance patterns. Data safety depends on your database configuration, connection security, and access controls."
      },
      {
        "question": "Why are my queries slow?",
        "answer": "Add index=True on filtered fields, use eager loading with selectinload for relationships, and avoid N+1 query patterns."
      },
      {
        "question": "How does this compare to SQLAlchemy?",
        "answer": "SQLModel is built on SQLAlchemy and Pydantic. It provides simpler syntax while maintaining full SQLAlchemy capability and type safety."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
