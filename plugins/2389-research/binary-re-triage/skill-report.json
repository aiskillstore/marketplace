{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T09:09:28.423Z",
    "slug": "2389-research-binary-re-triage",
    "source_url": "https://github.com/2389-research/claude-plugins/tree/main/binary-re/skills/triage",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "b022dcf307586d2ece3cf18b419c8f0e8355a4910aae5318e36e26d1fd54a793",
    "tree_hash": "779291e8df3fe7df37829b62ad3c23e0ad7b7b6ea24be7bc169eddb1e479f8f9"
  },
  "skill": {
    "name": "binary-re:triage",
    "description": "Use when first encountering an unknown binary, ELF file, executable, or firmware blob. Fast fingerprinting via rabin2 - architecture detection (ARM, x86, MIPS), ABI identification, dependency mapping, string extraction. Keywords - \"what is this binary\", \"identify architecture\", \"check file type\", \"rabin2\", \"file analysis\", \"quick scan\"",
    "summary": "Use when first encountering an unknown binary, ELF file, executable, or firmware blob. Fast fingerpr...",
    "icon": "üîç",
    "version": "1.0.0",
    "author": "2389-research",
    "license": "MIT",
    "category": "security",
    "tags": [
      "reverse-engineering",
      "binary-analysis",
      "firmware",
      "security"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a prompt-based skill containing only documentation and guidance for binary analysis. No executable code, no network access, no file system modifications beyond reading binary files for analysis. The skill describes running standard Unix analysis tools (file, rabin2, readelf) which is expected and appropriate for its stated purpose.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 268,
    "audit_model": "claude",
    "audited_at": "2026-01-10T09:09:28.423Z"
  },
  "content": {
    "user_title": "Identify binary architecture and dependencies",
    "value_statement": "Unknown binaries from embedded devices require quick identification before analysis. This skill runs rabin2 and file commands to extract architecture, libc type, and library dependencies in seconds.",
    "seo_keywords": [
      "binary triage",
      "rabin2",
      "ELF analysis",
      "architecture detection",
      "binary fingerprinting",
      "reverse engineering",
      "Claude Code skill",
      "embedded security",
      "firmware analysis",
      "radare2"
    ],
    "actual_capabilities": [
      "Detect CPU architecture (ARM, x86, MIPS, RISC-V) using file and rabin2",
      "Identify libc type (glibc, musl, uClibc) via interpreter path analysis",
      "Extract library dependencies and imported functions",
      "Map capability patterns from function imports (network, crypto, file I/O)",
      "Generate structured JSON output with binary metadata",
      "Record findings to episodic memory with hypothesis tracking"
    ],
    "limitations": [
      "Does not execute or decompile the binary",
      "Cannot analyze encrypted or packed binaries without unpacker",
      "Requires radare2 and readelf tools to be installed",
      "Limited on Windows hosts (native radare2 recommended via WSL)"
    ],
    "use_cases": [
      {
        "target_user": "Security researchers",
        "title": "Quick binary classification",
        "description": "Rapidly identify embedded device firmware binaries to determine analysis approach and tool selection."
      },
      {
        "target_user": "Reverse engineers",
        "title": "Pre-analysis assessment",
        "description": "Establish baseline facts about unknown executables before committing to expensive static or dynamic analysis."
      },
      {
        "target_user": "Embedded developers",
        "title": "Dependency inventory",
        "description": "Catalog shared library dependencies and identify which capabilities a binary likely contains."
      }
    ],
    "prompt_templates": [
      {
        "title": "What is this binary?",
        "scenario": "Quick identification",
        "prompt": "I have a binary at /path/to/file. What architecture is it? What libraries does it link against?"
      },
      {
        "title": "Identify dependencies",
        "scenario": "Library scan",
        "prompt": "Run triage on this binary and show me all imported functions and shared library dependencies."
      },
      {
        "title": "Assess capabilities",
        "scenario": "Quick capability check",
        "prompt": "What does this binary likely do based on its imports? Look for network, crypto, or file I/O patterns."
      },
      {
        "title": "Generate analysis report",
        "scenario": "Complete triage",
        "prompt": "Perform full triage on this binary including: file type, arch, bits, endian, libc, imports, exports, and interesting strings."
      }
    ],
    "output_examples": [
      {
        "input": "Run triage on /tmp/unknown_binary",
        "output": [
          "Architecture: ARM 32-bit, little endian",
          "Libc: musl (/lib/ld-musl-arm.so.1)",
          "Dependencies: libcurl, libssl, libpthread",
          "Capabilities inferred: HTTP client, TLS encryption, multi-threading",
          "Stripped: yes (symbols removed)",
          "Size: 153KB"
        ]
      }
    ],
    "best_practices": [
      "Always run triage before deeper analysis to select correct tools (QEMU, GDB architecture)",
      "Record findings in episodic memory so you can resume analysis in future sessions",
      "Use the JSON output format for structured data that Claude can parse reliably",
      "Match libc and sysroot to the target device before attempting dynamic analysis"
    ],
    "anti_patterns": [
      "Skipping triage and jumping straight to disassembly without knowing the architecture",
      "Using x86 tools on ARM binaries without QEMU emulation",
      "Assuming static binary means safe to execute without sandboxing",
      "Ignoring the libc type when setting up cross-compilation or emulation"
    ],
    "faq": [
      {
        "question": "What tools must be installed?",
        "answer": "radare2, readelf, file command. Install via apt (r2, binutils) on Linux or brew on macOS."
      },
      {
        "question": "Can it analyze Windows executables?",
        "answer": "No. This skill targets ELF binaries from embedded Linux devices. Use other tools for PE/EXE analysis."
      },
      {
        "question": "How long does triage take?",
        "answer": "Seconds. It runs quick metadata extraction commands. Full string scan may take a few seconds on large binaries."
      },
      {
        "question": "Does it modify the binary?",
        "answer": "No. All commands are read-only analysis (file, rabin2 -q, readelf). No modifications are made."
      },
      {
        "question": "What if rabin2 is not installed?",
        "answer": "Install radare2: apt install radare2 or brew install radare2. Triage requires rabin2 from the radare2 suite."
      },
      {
        "question": "How is this different from static analysis?",
        "answer": "Triage is fast fingerprinting (seconds) that identifies WHAT the binary is. Static analysis is deep function enumeration that shows HOW it works."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
