{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T14:12:16.834Z",
    "slug": "doubleslashse-functional-patterns",
    "source_url": "https://github.com/DoubleslashSE/claude-workflows/tree/main/Plugins/node-tdd/skills/functional-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "3cfafd7a892722ae23e8f17171b116ea3bff62abb0ef38064654bce2885285cd",
    "tree_hash": "bec123b2b6814ba7f71e50f8ec5abde9f6f643b305eee87c7cdc2651e4d72abc"
  },
  "skill": {
    "name": "Functional Patterns for Node.js/TypeScript",
    "description": "Functional programming patterns that promote testability, composability, and maintainability.",
    "summary": "Functional programming patterns that promote testability, composability, and maintainability.",
    "icon": "âš¡",
    "version": "1.0.0",
    "author": "DoubleslashSE",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "functional-programming",
      "typescript",
      "nodejs",
      "patterns",
      "best-practices"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill is a pure documentation file containing educational content about functional programming patterns. No executable code, scripts, network calls, filesystem access, or external command execution capabilities are present.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 367,
    "audit_model": "claude",
    "audited_at": "2026-01-10T14:12:16.834Z"
  },
  "content": {
    "user_title": "Apply Functional Patterns in Node.js",
    "value_statement": "Node.js code often suffers from side effects and implicit dependencies that make testing difficult and bugs hard to trace. This skill provides proven functional patterns including pure functions, immutable updates, and monadic error handling to write maintainable TypeScript code.",
    "seo_keywords": [
      "functional programming",
      "typescript patterns",
      "nodejs best practices",
      "pure functions",
      "function composition",
      "result pattern",
      "dependency injection",
      "immutability",
      "claude",
      "claude code"
    ],
    "actual_capabilities": [
      "Create pure functions that are deterministic and side-effect free",
      "Implement immutable state updates using spread operators and array methods",
      "Compose functions using pipe and compose patterns for readable data flows",
      "Handle errors gracefully with the Result pattern instead of exceptions",
      "Apply dependency injection via function parameters for testable code",
      "Use Option/Maybe pattern to safely handle nullable values"
    ],
    "limitations": [
      "Pattern examples are in TypeScript and may require adaptation for plain JavaScript",
      "Does not include runtime libraries or executable code",
      "Assumes basic familiarity with TypeScript types and functions"
    ],
    "use_cases": [
      {
        "target_user": "Backend Developers",
        "title": "Build Testable APIs",
        "description": "Create API handlers with pure business logic and injected dependencies for reliable unit tests"
      },
      {
        "target_user": "TypeScript Teams",
        "title": "Standardize Code Patterns",
        "description": "Establish consistent error handling and state management across a shared codebase"
      },
      {
        "target_user": "Code Reviewers",
        "title": "Validate Code Quality",
        "description": "Review pull requests against functional principles for maintainability and testability"
      }
    ],
    "prompt_templates": [
      {
        "title": "Pure Function Basics",
        "scenario": "Converting an impure function to pure",
        "prompt": "Show me how to convert this impure function to a pure function. The function calculates order totals and saves to database."
      },
      {
        "title": "Immutable Updates",
        "scenario": "Updating nested state safely",
        "prompt": "Write an immutable update function that changes a deeply nested property in a user object without mutating the original."
      },
      {
        "title": "Function Composition",
        "scenario": "Building a data processing pipeline",
        "prompt": "Create a pipe function that chains trim, validate, and transform operations on user input strings."
      },
      {
        "title": "Result Pattern",
        "scenario": "Replacing try-catch with Result",
        "prompt": "Convert this function that uses try-catch blocks to use the Result pattern with map and flatMap operations."
      }
    ],
    "output_examples": [
      {
        "input": "Show me how to structure a Node.js API handler with pure core and impure shell pattern",
        "output": [
          "Separate business logic into pure functions that take inputs and return results",
          "Wrap pure functions in handlers that inject dependencies for I/O operations",
          "Use the Result type to propagate errors without exceptions",
          "Example structure: validateOrder (pure) -> calculateDiscount (pure) -> applyDiscount (pure) -> processOrderHandler (impure shell with I/O)"
        ]
      }
    ],
    "best_practices": [
      "Keep business logic pure by separating it from I/O operations like database calls and network requests",
      "Use immutable updates with spread operators and array methods rather than mutating objects in place",
      "Return Result types from functions instead of throwing exceptions to make error handling explicit"
    ],
    "anti_patterns": [
      "Mixing I/O with business logic in the same function destroys testability",
      "Using mutable state and shared variables creates hidden dependencies",
      "Throwing exceptions for control flow hides error conditions from type signatures"
    ],
    "faq": [
      {
        "question": "Is this skill compatible with plain JavaScript projects?",
        "answer": "Yes. The patterns work in JavaScript but TypeScript provides better type safety for Result and Option patterns."
      },
      {
        "question": "What is the performance impact of immutable updates?",
        "answer": "Modern JavaScript engines optimize spread operations well. For most applications the overhead is negligible compared to correctness benefits."
      },
      {
        "question": "How does this integrate with existing codebases?",
        "answer": "Apply patterns incrementally. Start by isolating new code with pure functions, then gradually refactor existing code."
      },
      {
        "question": "Does this skill store or transmit any user data?",
        "answer": "No. This is a pure documentation skill with no code execution, network access, or file system operations."
      },
      {
        "question": "Why use Result instead of exceptions?",
        "answer": "Result types make errors explicit in the type signature, force handling at compile time, and compose cleanly with functional operations."
      },
      {
        "question": "How does this compare to object-oriented patterns?",
        "answer": "Functional patterns emphasize immutable data and pure functions. OOP emphasizes encapsulated state and behavior. Both can coexist in projects."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
