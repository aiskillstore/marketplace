{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T10:03:07.770Z",
    "slug": "activeinferenceinstitute-python-performance-optimization",
    "source_url": "https://github.com/ActiveInferenceInstitute/Journal-Utilities/tree/main/.claude/skills/python-performance-optimization",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "abc5e179bd8dd57f8098a88b3aaa88257367b74648fc4564354f4af56177ce62",
    "tree_hash": "12bb7a5850df4a6b281799e7d19b196c7f49ce6c8c1157a7330df8d8efb392e1"
  },
  "skill": {
    "name": "python-performance-optimization",
    "description": "Profile and optimize Python code using cProfile, memory profilers, and performance best practices. Use when debugging slow Python code, optimizing bottlenecks, or improving application performance.",
    "summary": "Profile and optimize Python code using cProfile, memory profilers, and performance best practices. U...",
    "icon": "⚡",
    "version": "1.0.0",
    "author": "ActiveInferenceInstitute",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "python",
      "performance",
      "profiling",
      "optimization"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill with no executable code. Contains only markdown guidance and educational code examples for Python performance optimization using standard profiling tools.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 870,
    "audit_model": "claude",
    "audited_at": "2026-01-10T10:03:07.770Z"
  },
  "content": {
    "user_title": "Optimize Python Performance",
    "value_statement": "Python applications can suffer from slow performance and memory issues. This skill provides profiling tools and optimization patterns to identify bottlenecks and improve speed and efficiency.",
    "seo_keywords": [
      "python performance optimization",
      "profiling python",
      "cProfile",
      "memory profiler",
      "python optimization",
      "Claude Code",
      "Claude",
      "Codex",
      "python performance tuning"
    ],
    "actual_capabilities": [
      "Profile CPU usage with cProfile and pstats",
      "Track memory allocation with memory_profiler",
      "Implement line-by-line profiling with line_profiler",
      "Apply optimization patterns for lists, dictionaries, and strings",
      "Use caching with functools.lru_cache",
      "Optimize database queries and batch operations"
    ],
    "limitations": [
      "Does not execute profiling on user code",
      "Requires external profiling tools to be installed separately",
      "Does not modify or auto-optimize user code",
      "Does not provide real-time performance monitoring"
    ],
    "use_cases": [
      {
        "target_user": "Python Developers",
        "title": "Debug Slow Applications",
        "description": "Identify and fix performance bottlenecks in Python applications using profiling tools."
      },
      {
        "target_user": "Data Engineers",
        "title": "Optimize Data Pipelines",
        "description": "Improve memory efficiency and processing speed for data processing workflows."
      },
      {
        "target_user": "Backend Engineers",
        "title": "Reduce Latency",
        "description": "Optimize API response times and database query performance for production services."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Profiling",
        "scenario": "Profile a Python function",
        "prompt": "Show me how to profile this Python function using cProfile to identify bottlenecks."
      },
      {
        "title": "Memory Analysis",
        "scenario": "Find memory issues",
        "prompt": "How can I track memory usage and detect memory leaks in my Python application?"
      },
      {
        "title": "Optimization Pattern",
        "scenario": "Improve code speed",
        "prompt": "Optimize this Python code snippet for better performance: [insert code]"
      },
      {
        "title": "Production Profiling",
        "scenario": "Profile live application",
        "prompt": "How do I profile a running Python process in production without restarting it?"
      }
    ],
    "output_examples": [
      {
        "input": "Profile my Python code to find performance bottlenecks",
        "output": [
          "CPU Profiling with cProfile:",
          "• Run: python -m cProfile -o output.prof script.py",
          "• Analyze: python -m pstats output.prof",
          "• Sort by cumulative time to find slow functions",
          "",
          "Memory Profiling:",
          "• Use memory_profiler package",
          "• Add @profile decorator to functions",
          "• Run: python -m memory_profiler script.py",
          "",
          "Key Bottleneck Indicators:",
          "• Functions with high cumulative time",
          "• Functions called many times",
          "• Large memory allocations"
        ]
      }
    ],
    "best_practices": [
      "Profile before optimizing to identify actual bottlenecks rather than guessed issues",
      "Use appropriate data structures like dictionaries for fast lookups instead of lists",
      "Apply caching with lru_cache for expensive repeated computations"
    ],
    "anti_patterns": [
      "Optimizing without profiling first leads to wasted effort on non-bottleneck code",
      "Using global variables instead of local variables causes slower performance",
      "Building large lists in memory when generators would use constant memory"
    ],
    "faq": [
      {
        "question": "What Python profiling tools are supported?",
        "answer": "cProfile for CPU profiling, memory_profiler for memory tracking, line_profiler for line-by-line analysis, and py-spy for production profiling."
      },
      {
        "question": "How long can profiling take?",
        "answer": "Profiling adds minimal overhead. cProfile typically slows code by 10-20%. For production, py-spy sampling profiler has minimal impact."
      },
      {
        "question": "Can I integrate with CI/CD pipelines?",
        "answer": "Yes, use pytest-benchmark for automated performance tests in CI. Set performance baselines and fail builds on regressions."
      },
      {
        "question": "Is my data safe during profiling?",
        "answer": "Profiling only measures execution time and memory. No data is read, written, or transmitted. Safe for production with appropriate sampling rates."
      },
      {
        "question": "What if profiling shows no obvious bottlenecks?",
        "answer": "Consider I/O-bound issues, network latency, database queries, or external API calls. Use async I/O or connection pooling."
      },
      {
        "question": "How is this different from other Python optimization tools?",
        "answer": "This skill provides patterns and guidance. Tools like Cython or PyPy provide runtime improvements. Use both approaches together."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
