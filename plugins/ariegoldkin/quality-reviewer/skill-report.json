{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T10:29:59.462Z",
    "slug": "ariegoldkin-quality-reviewer",
    "source_url": "https://github.com/ArieGoldkin/devPrepAi/tree/main/.claude/skills/quality-reviewer",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "8ec47b4b0ac28306c6fe66288585d7bb16c06be52f107b5ec70884f2e9b708aa",
    "tree_hash": "7a3d49af55fac328e001d8a441c857be85794e63485a80eda5984340212861c7"
  },
  "skill": {
    "name": "quality-reviewer",
    "description": "Automatically reviews DevPrep AI code for quality standards including ESLint compliance, TypeScript strict mode, 180-line file limits, complexity under 15, proper naming conventions, import patterns, and architectural compliance with the 6-folder structure",
    "summary": "Automatically reviews DevPrep AI code for quality standards including ESLint compliance, TypeScript ...",
    "icon": "üîç",
    "version": "1.0.0",
    "author": "ArieGoldkin",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "code quality",
      "typescript",
      "eslint",
      "automated review"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "external_commands",
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a legitimate code quality review skill. It contains bash scripts that run standard development tools (ESLint, TypeScript compiler, grep, find) to validate code against project standards. All file access is scoped to the frontend/src directory within the project. No network calls to external endpoints, no credential access, and no persistence mechanisms. The scripts only execute trusted development commands for quality assurance.",
    "risk_factor_evidence": [
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "scripts/full-review.sh",
            "line_start": 1,
            "line_end": 95
          },
          {
            "file": "scripts/check-imports.sh",
            "line_start": 1,
            "line_end": 45
          },
          {
            "file": "scripts/check-complexity.sh",
            "line_start": 1,
            "line_end": 35
          },
          {
            "file": "scripts/check-architecture.sh",
            "line_start": 1,
            "line_end": 65
          },
          {
            "file": "scripts/check-naming.sh",
            "line_start": 1,
            "line_end": 40
          },
          {
            "file": "scripts/check-file-size.sh",
            "line_start": 1,
            "line_end": 48
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "scripts/full-review.sh",
            "line_start": 49,
            "line_end": 50
          },
          {
            "file": "scripts/full-review.sh",
            "line_start": 61,
            "line_end": 61
          },
          {
            "file": "scripts/check-complexity.sh",
            "line_start": 15,
            "line_end": 15
          },
          {
            "file": "scripts/check-imports.sh",
            "line_start": 18,
            "line_end": 18
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "scripts/full-review.sh",
            "line_start": 59,
            "line_end": 59
          },
          {
            "file": "scripts/check-file-size.sh",
            "line_start": 18,
            "line_end": 34
          },
          {
            "file": "scripts/check-imports.sh",
            "line_start": 16,
            "line_end": 28
          },
          {
            "file": "scripts/check-architecture.sh",
            "line_start": 19,
            "line_end": 48
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 14,
    "total_lines": 1519,
    "audit_model": "claude",
    "audited_at": "2026-01-10T10:29:59.462Z"
  },
  "content": {
    "user_title": "Review code quality automatically",
    "value_statement": "Manual code reviews are time-consuming and inconsistent. This skill automatically enforces DevPrep AI standards across your codebase with 7 built-in checks covering file size, complexity, naming, imports, architecture, ESLint, and TypeScript.",
    "seo_keywords": [
      "code quality",
      "typescript linting",
      "eslint rules",
      "code review automation",
      "static analysis",
      "code standards",
      "claude code",
      "claude ai",
      "codex",
      "automated testing"
    ],
    "actual_capabilities": [
      "Check file size limits (180 lines maximum)",
      "Verify cyclomatic complexity under 15",
      "Validate TypeScript naming conventions (I prefix for interfaces)",
      "Detect incorrect import patterns (requires path aliases)",
      "Enforce 6-folder architecture structure",
      "Run ESLint and TypeScript compiler checks"
    ],
    "limitations": [
      "Designed specifically for DevPrep AI project structure",
      "Only scans TypeScript and TSX files in frontend/src",
      "Does not fix violations automatically",
      "Requires npm and npx to be available in PATH"
    ],
    "use_cases": [
      {
        "target_user": "Developers",
        "title": "Pre-commit quality gate",
        "description": "Integrate into pre-commit hooks to catch standards violations before code enters the repository."
      },
      {
        "target_user": "Code reviewers",
        "title": "Automated review feedback",
        "description": "Generate consistent quality reports for every pull request without manual checklist tracking."
      },
      {
        "target_user": "New contributors",
        "title": "Standards onboarding",
        "description": "Help new team members learn project conventions through immediate, actionable feedback."
      }
    ],
    "prompt_templates": [
      {
        "title": "Quick review",
        "scenario": "When you need a fast quality check",
        "prompt": "Review the code I just wrote for quality standards compliance"
      },
      {
        "title": "Full audit",
        "scenario": "When running comprehensive checks",
        "prompt": "Run a full quality review using all checks on the frontend/src directory"
      },
      {
        "title": "Specific check",
        "scenario": "When targeting a specific issue",
        "prompt": "Check file sizes and complexity in the modules directory"
      },
      {
        "title": "Fix guidance",
        "scenario": "When you need help resolving violations",
        "prompt": "Show me how to fix the naming convention violations and explain the patterns"
      }
    ],
    "output_examples": [
      {
        "input": "Run a full quality review",
        "output": [
          "Checking file sizes (max: 180 lines of code)... Found 3 files exceeding limit",
          "Checking code complexity (max: 15)... All functions within complexity limit",
          "Checking import patterns... Import patterns look good",
          "Checking architecture compliance (6-folder structure)... Architecture follows 6-folder structure",
          "Checking naming conventions... Naming conventions followed",
          "Running ESLint... 2 warnings found",
          "Running TypeScript check... TypeScript check passed",
          "REVIEW SUMMARY: File sizes need attention. Other checks passed."
        ]
      }
    ],
    "best_practices": [
      "Run full reviews before committing to catch all issues at once",
      "Address violations incrementally when learning the standards",
      "Use specific checks (check-file-size, check-naming) for focused feedback"
    ],
    "anti_patterns": [
      "Ignoring violations and pushing code anyway",
      "Running only one check when multiple standards are likely violated",
      "Skipping the review process entirely"
    ],
    "faq": [
      {
        "question": "Which AI platforms support this skill?",
        "answer": "This skill works with Claude, Codex, and Claude Code. It uses Bash, Read, Grep, and Glob tools available on all platforms."
      },
      {
        "question": "What are the line and complexity limits?",
        "answer": "Maximum 180 lines of code per file, maximum 15 cyclomatic complexity per function, maximum 50 lines per function."
      },
      {
        "question": "How do I integrate with pre-commit hooks?",
        "answer": "Add ./.claude/skills/quality-reviewer/scripts/full-review.sh to your .husky/pre-commit file to run checks before each commit."
      },
      {
        "question": "Does this skill modify my code?",
        "answer": "No, this skill only reads and analyzes code. It reports violations but does not make any changes to your files."
      },
      {
        "question": "Why are my imports being flagged?",
        "answer": "The skill requires path aliases (@shared/, @modules/, @lib/, @store/) instead of relative imports (../../../) for better maintainability."
      },
      {
        "question": "How is this different from ESLint?",
        "answer": "ESLint catches syntax and style issues. This skill enforces project-specific architectural standards like folder structure, file organization, and naming conventions."
      }
    ]
  },
  "file_structure": [
    {
      "name": "docs",
      "type": "dir",
      "path": "docs",
      "children": [
        {
          "name": "standards.md",
          "type": "file",
          "path": "docs/standards.md"
        }
      ]
    },
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "refactor-after",
          "type": "dir",
          "path": "examples/refactor-after",
          "children": [
            {
              "name": "Component.tsx",
              "type": "file",
              "path": "examples/refactor-after/Component.tsx"
            },
            {
              "name": "hooks.ts",
              "type": "file",
              "path": "examples/refactor-after/hooks.ts"
            },
            {
              "name": "types.ts",
              "type": "file",
              "path": "examples/refactor-after/types.ts"
            }
          ]
        },
        {
          "name": "bad-code.tsx",
          "type": "file",
          "path": "examples/bad-code.tsx"
        },
        {
          "name": "good-code.tsx",
          "type": "file",
          "path": "examples/good-code.tsx"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "check-architecture.sh",
          "type": "file",
          "path": "scripts/check-architecture.sh"
        },
        {
          "name": "check-complexity.sh",
          "type": "file",
          "path": "scripts/check-complexity.sh"
        },
        {
          "name": "check-file-size.sh",
          "type": "file",
          "path": "scripts/check-file-size.sh"
        },
        {
          "name": "check-imports.sh",
          "type": "file",
          "path": "scripts/check-imports.sh"
        },
        {
          "name": "check-naming.sh",
          "type": "file",
          "path": "scripts/check-naming.sh"
        },
        {
          "name": "full-review.sh",
          "type": "file",
          "path": "scripts/full-review.sh"
        }
      ]
    },
    {
      "name": "README.md",
      "type": "file",
      "path": "README.md"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
