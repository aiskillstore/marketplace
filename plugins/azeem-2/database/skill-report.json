{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T11:02:30.895Z",
    "slug": "azeem-2-database",
    "source_url": "https://github.com/Azeem-2/HackthonII/tree/master/.claude/skills/database",
    "source_ref": "master",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "b471ae12ac1cce8a295dd04b16bf4f5dff753c7833bc7536476e749daac452ba",
    "tree_hash": "8e1bcc61091abc10f9dca0053c1fa2f2288b92706c9b17245a14a251d679f12f"
  },
  "skill": {
    "name": "database",
    "description": "Universal database operations skill for modern applications. Expert in SQLModel/SQLAlchemy patterns, async database operations, connection pooling, migrations, performance optimization, and multi-database support (PostgreSQL, MySQL, SQLite). Provides production-ready patterns for any database-driven application.",
    "summary": "Universal database operations skill for modern applications. Expert in SQLModel/SQLAlchemy patterns,...",
    "icon": "üóÑÔ∏è",
    "version": "1.0.0",
    "author": "Azeem-2",
    "license": "MIT",
    "category": "data",
    "tags": [
      "database",
      "sql",
      "sqlalchemy",
      "async",
      "postgresql"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing only markdown content with code examples. No executable code, scripts, network calls, or file system access. This is informational content designed to guide database implementation patterns.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 745,
    "audit_model": "claude",
    "audited_at": "2026-01-10T11:02:30.895Z"
  },
  "content": {
    "user_title": "Build Production-Ready Database Operations",
    "value_statement": "Writing database code from scratch leads to connection leaks, slow queries, and migration headaches. This skill provides battle-tested patterns for async database operations, connection pooling, migrations, and performance optimization that work across PostgreSQL, MySQL, and SQLite.",
    "seo_keywords": [
      "Claude database skill",
      "SQLModel patterns",
      "SQLAlchemy async",
      "PostgreSQL Python",
      "connection pooling",
      "database migrations",
      "Python async database",
      "SQLAlchemy performance",
      "Claude Code database",
      "SQLModel best practices"
    ],
    "actual_capabilities": [
      "Design database schemas with SQLModel and SQLAlchemy",
      "Implement async database operations with connection pooling",
      "Create and manage database migrations with Alembic",
      "Optimize queries and improve database performance",
      "Build repository patterns for clean CRUD operations",
      "Handle complex relationships and advanced queries"
    ],
    "limitations": [
      "Does not execute database operations directly",
      "Does not generate full application boilerplate",
      "Requires user to implement patterns in their codebase",
      "Database-specific optimizations may require adjustment"
    ],
    "use_cases": [
      {
        "target_user": "Backend Developers",
        "title": "Set up production database layer",
        "description": "Configure async connections, connection pooling, and migrations for a new Python web application."
      },
      {
        "target_user": "Data Engineers",
        "title": "Optimize query performance",
        "description": "Analyze slow queries, add proper indexes, and implement caching strategies for large datasets."
      },
      {
        "target_user": "DevOps Engineers",
        "title": "Configure production databases",
        "description": "Set up connection limits, monitoring, backup strategies, and security configurations."
      }
    ],
    "prompt_templates": [
      {
        "title": "Create database models",
        "scenario": "New project model setup",
        "prompt": "Create SQLModel models for a [entity name] with fields for [field descriptions], including timestamps, soft delete, and proper indexes."
      },
      {
        "title": "Set up async connections",
        "scenario": "Database connection configuration",
        "prompt": "Set up async database connection with SQLAlchemy including connection pooling for [development/production] with pool size [number] and max overflow [number]."
      },
      {
        "title": "Build repository pattern",
        "scenario": "CRUD implementation",
        "prompt": "Create a repository class for [model name] with methods for create, get, get_multi, update, remove, and count with proper async support."
      },
      {
        "title": "Write migration script",
        "scenario": "Schema changes",
        "prompt": "Write an Alembic migration to [describe schema change] including upgrading and downgrading functions."
      }
    ],
    "output_examples": [
      {
        "input": "Create a User model with email, username, full name, and is_active fields with proper indexes",
        "output": [
          "Model includes email and username as unique indexed fields",
          "Uses Text for longer content like bio field",
          "Created_at and updated_at timestamps with server defaults",
          "Composite indexes for common query patterns",
          "Soft delete mixin available for logical deletion"
        ]
      }
    ],
    "best_practices": [
      "Always use async sessions with expire_on_commit=False for better performance",
      "Implement connection pooling with appropriate pool size based on expected concurrent users",
      "Add indexes on foreign keys and frequently filtered columns to optimize queries"
    ],
    "anti_patterns": [
      "Do not use synchronous database calls in async FastAPI or other async frameworks",
      "Do not commit transactions manually when using context managers for sessions",
      "Do not skip indexes on foreign key columns as this causes N+1 query problems"
    ],
    "faq": [
      {
        "question": "Which databases are supported?",
        "answer": "PostgreSQL, MySQL, and SQLite are fully supported. Any database with a SQLAlchemy async driver works."
      },
      {
        "question": "What is the maximum connection pool size?",
        "answer": "Pool size depends on your database limits. Start with pool_size=30 and max_overflow=40 for medium workloads."
      },
      {
        "question": "How does this integrate with FastAPI?",
        "answer": "Use the async sessionmaker with FastAPI dependencies. Inject sessions into route handlers for proper lifecycle management."
      },
      {
        "question": "Is my data safe when using these patterns?",
        "answer": "Yes. These patterns include connection disposal, proper transaction handling, and security recommendations for production."
      },
      {
        "question": "Why are my queries slow?",
        "answer": "Check for missing indexes, N+1 query patterns, or missing eager loading. Use the query analyzer to identify bottlenecks."
      },
      {
        "question": "How is this different from raw SQL?",
        "answer": "SQLModel provides type safety, relationship handling, and migrations. Raw SQL is faster for bulk operations but harder to maintain."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
