#!/usr/bin/env python3
"""
Track import/dependency chains in code.
Usage: python trace-imports.py --file ./src/index.ts --depth 3
"""

import re
import argparse
from pathlib import Path
from typing import Set, List, Dict
from collections import defaultdict

def extract_imports_typescript(content: str) -> List[str]:
    """Extract import statements from TypeScript/JavaScript."""
    imports = []

    # Match: import ... from '...'
    pattern1 = r"import\s+.*?\s+from\s+['\"]([^'\"]+)['\"]"
    imports.extend(re.findall(pattern1, content))

    # Match: require('...')
    pattern2 = r"require\(['\"]([^'\"]+)['\"]\)"
    imports.extend(re.findall(pattern2, content))

    return imports

def extract_imports_python(content: str) -> List[str]:
    """Extract import statements from Python."""
    imports = []

    # Match: import module
    pattern1 = r"^\s*import\s+(\S+)"
    imports.extend(re.findall(pattern1, content, re.MULTILINE))

    # Match: from module import ...
    pattern2 = r"^\s*from\s+(\S+)\s+import"
    imports.extend(re.findall(pattern2, content, re.MULTILINE))

    return imports

def resolve_relative_import(current_file: Path, import_path: str) -> Path:
    """Resolve relative import to absolute path."""
    if import_path.startswith('.'):
        # Relative import
        base_dir = current_file.parent
        resolved = (base_dir / import_path).resolve()

        # Try common extensions
        for ext in ['', '.ts', '.tsx', '.js', '.jsx', '.py']:
            if (resolved.parent / (resolved.name + ext)).exists():
                return resolved.parent / (resolved.name + ext)
            if (resolved / f'index{ext}').exists():
                return resolved / f'index{ext}'

        return resolved
    else:
        # External package
        return None

def trace_imports(file_path: Path, max_depth: int = 3, visited: Set[Path] = None) -> Dict:
    """Trace imports from a file recursively."""
    if visited is None:
        visited = set()

    if file_path in visited or max_depth <= 0:
        return {}

    visited.add(file_path)

    if not file_path.exists():
        return {}

    try:
        content = file_path.read_text()
    except Exception:
        return {}

    # Extract imports based on file type
    suffix = file_path.suffix
    if suffix in ['.ts', '.tsx', '.js', '.jsx']:
        imports = extract_imports_typescript(content)
    elif suffix == '.py':
        imports = extract_imports_python(content)
    else:
        return {}

    result = {
        'file': str(file_path),
        'imports': [],
        'external': []
    }

    for imp in imports:
        resolved = resolve_relative_import(file_path, imp)

        if resolved and resolved.exists():
            # Local file import
            result['imports'].append({
                'path': str(resolved),
                'children': trace_imports(resolved, max_depth - 1, visited)
            })
        else:
            # External package
            result['external'].append(imp)

    return result

def print_tree(data: Dict, indent: int = 0):
    """Print import tree."""
    prefix = "  " * indent

    if 'file' in data:
        print(f"{prefix}ðŸ“„ {Path(data['file']).name}")

    if 'imports' in data:
        for imp in data['imports']:
            print(f"{prefix}  â”œâ”€ {Path(imp['path']).name}")
            if imp.get('children', {}).get('imports'):
                print_tree(imp['children'], indent + 2)

    if 'external' in data and data['external']:
        print(f"{prefix}  â””â”€ External: {', '.join(data['external'][:5])}")
        if len(data['external']) > 5:
            print(f"{prefix}     ... and {len(data['external']) - 5} more")

def main():
    parser = argparse.ArgumentParser(description='Trace import dependencies')
    parser.add_argument('--file', required=True, help='File to analyze')
    parser.add_argument('--depth', type=int, default=3, help='Maximum depth to trace')
    args = parser.parse_args()

    file_path = Path(args.file).resolve()

    if not file_path.exists():
        print(f"Error: File '{file_path}' does not exist")
        return 1

    print(f"# Import Dependency Tree")
    print(f"Starting file: {file_path.name}")
    print(f"Max depth: {args.depth}")
    print()

    result = trace_imports(file_path, args.depth)
    print_tree(result)

    print()
    print("---")
    print("Generated by research-agent/investigating-codebases")

if __name__ == '__main__':
    main()
