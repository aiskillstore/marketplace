{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T11:33:49.669Z",
    "slug": "byronwilliamscpa-commit-prepare",
    "source_url": "https://github.com/ByronWilliamsCPA/template-sample/tree/main/.claude/skills/commit-prepare",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "a73003ac011206ccd3aab699414e2c3a9df373eb571f70fecd24b9f99fa8dbc7",
    "tree_hash": "3553fc63d955d8f67372cea96d51947825b1ed56a03f0c7e16035e253b33d068"
  },
  "skill": {
    "name": "commit-prepare",
    "description": "Prepare git commit messages following conventional commits. Activates on: commit, prepare commit, commit this, commit message, ready to commit, stage and commit",
    "summary": "Prepare git commit messages following conventional commits. Activates on: commit, prepare commit, co...",
    "icon": "üìù",
    "version": "1.0.0",
    "author": "ByronWilliamsCPA",
    "license": "MIT",
    "category": "documentation",
    "tags": [
      "git",
      "commits",
      "conventional-commits",
      "version-control"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a pure prompt-based skill containing only Markdown instructions. No executable code, scripts, or binaries present. The skill guides an AI assistant to help users prepare git commits using standard git commands for its stated purpose.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 199,
    "audit_model": "claude",
    "audited_at": "2026-01-10T11:33:49.669Z"
  },
  "content": {
    "user_title": "Prepare Conventional Git Commits",
    "value_statement": "Writing clear commit messages is hard. This skill helps you generate standardized commit messages following the conventional commits format, making your git history readable and enabling automated versioning.",
    "seo_keywords": [
      "conventional commits",
      "git commit message generator",
      "Claude Code git",
      "commit message format",
      "semantic versioning",
      "git workflow",
      "commitizen alternative",
      "AI commit helper",
      "Clauode Code commit",
      "Codex git"
    ],
    "actual_capabilities": [
      "Analyzes staged and unstaged git changes",
      "Generates conventional commit messages with type, scope, and subject",
      "Handles breaking changes with proper footer notation",
      "Splits multiple logical changes into separate commits",
      "Shows commit preview before execution",
      "Adds Claude attribution to AI-assisted commits"
    ],
    "limitations": [
      "Does not automatically stage or commit changes without user confirmation",
      "Does not modify commit history after push",
      "Does not skip git hooks unless explicitly requested",
      "Does not handle merge commits or revert commits"
    ],
    "use_cases": [
      {
        "target_user": "Individual developers",
        "title": "Standardize your commit history",
        "description": "Generate consistent, meaningful commit messages that improve project maintainability"
      },
      {
        "target_user": "Team leads",
        "title": "Enforce commit conventions",
        "description": "Help team members follow conventional commits for automated changelog generation"
      },
      {
        "target_user": "CI/CD engineers",
        "title": "Enable semantic versioning",
        "description": "Create commits that trigger semantic release workflows and auto-versioning"
      }
    ],
    "prompt_templates": [
      {
        "title": "Simple commit",
        "scenario": "Quick commit of staged changes",
        "prompt": "commit these changes"
      },
      {
        "title": "Stage and commit",
        "scenario": "Stage all and prepare commit",
        "prompt": "stage all my changes and prepare a commit message"
      },
      {
        "title": "Breaking change",
        "scenario": "Commit with breaking changes",
        "prompt": "ready to commit this breaking API change"
      },
      {
        "title": "Review first",
        "scenario": "Review changes before committing",
        "prompt": "what should I commit and show me the changes first"
      }
    ],
    "output_examples": [
      {
        "input": "commit these changes",
        "output": [
          "Looking at your staged changes:",
          "- Modified src/auth/oauth.py - added token refresh logic",
          "- Modified tests/test_auth.py - added refresh tests",
          "Suggested commit:",
          "feat(auth): add OAuth token refresh",
          "Implement automatic token refresh when access token expires.",
          "Includes retry logic with exponential backoff.",
          "Shall I commit with this message?"
        ]
      }
    ],
    "best_practices": [
      "Review the generated commit message before confirming execution",
      "Use scope to identify the affected component",
      "Split unrelated changes into separate commits"
    ],
    "anti_patterns": [
      "Using generic messages like 'fix bug' or 'update code'",
      "Skipping git hooks on commits unless necessary",
      "Committing directly to main without review"
    ],
    "faq": [
      {
        "question": "What are conventional commits?",
        "answer": "Conventional commits are a specification for writing commit messages with a structured format that describes the change type, scope, and description."
      },
      {
        "question": "Does this skill modify my files?",
        "answer": "No, the skill only analyzes your changes and suggests commit messages. You must confirm before any staging or commit occurs."
      },
      {
        "question": "Can I use this with any git host?",
        "answer": "Yes, conventional commits work with GitHub, GitLab, Bitbucket, and any git hosting service."
      },
      {
        "question": "What commit types are supported?",
        "answer": "feat, fix, docs, refactor, test, perf, chore, ci, and style. Each has specific use cases defined in the skill."
      },
      {
        "question": "Does this work with git GUIs?",
        "answer": "This skill is designed for CLI usage with Claude Code. GUIs have their own commit message tools."
      },
      {
        "question": "How is this different from commitizen?",
        "answer": "Commitizen is a CLI tool. This skill uses AI to understand your specific changes and generate contextual commit messages."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
