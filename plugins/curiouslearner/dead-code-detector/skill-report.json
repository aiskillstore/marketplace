{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T13:01:21.359Z",
    "slug": "curiouslearner-dead-code-detector",
    "source_url": "https://github.com/CuriousLearner/devkit/tree/main/skills/dead-code-detector",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "8a714be47060b9af0e164fed323e83d5ceac1a66f64eb6ef81b6dcd3cf3d7f55",
    "tree_hash": "44e063ff6a44871d1b25753b26c7946c970474bdf4b54c6cbd7be62260126df3"
  },
  "skill": {
    "name": "dead-code-detector",
    "description": "Identify unused code, imports, variables, and functions for safe removal.",
    "summary": "Identify unused code, imports, variables, and functions for safe removal.",
    "icon": "ðŸ§¹",
    "version": "1.0.0",
    "author": "CuriousLearner",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "code-cleanup",
      "refactoring",
      "static-analysis",
      "optimization",
      "maintenance"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a prompt-based skill with no executable code. It provides instructions for analyzing code to identify dead code patterns. No security risks detected.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 254,
    "audit_model": "claude",
    "audited_at": "2026-01-10T13:01:21.359Z"
  },
  "content": {
    "user_title": "Clean Dead Code from Your Codebase",
    "value_statement": "Dead code bloats your codebase and increases maintenance burden. This skill analyzes your code to identify unused imports, variables, and functions that can be safely removed.",
    "seo_keywords": [
      "dead code removal",
      "unused code detection",
      "code cleanup",
      "static analysis",
      "refactoring",
      "Claude Code",
      "AI coding assistant",
      "code optimization",
      "maintenance",
      "code quality"
    ],
    "actual_capabilities": [
      "Identifies unused imports and dependencies",
      "Finds unreferenced functions and variables",
      "Detects unreachable code blocks",
      "Analyzes npm package usage",
      "Categorizes findings by safety level"
    ],
    "limitations": [
      "Cannot detect dynamically referenced code",
      "May flag test-only code as unused",
      "Requires manual review for public API changes",
      "Limited to static analysis capabilities"
    ],
    "use_cases": [
      {
        "target_user": "Developers",
        "title": "Clean Up Legacy Codebases",
        "description": "Remove accumulated dead code in large, older projects to improve maintainability and reduce bundle size."
      },
      {
        "target_user": "Tech Leads",
        "title": "Pre-Refactoring Analysis",
        "description": "Before major refactoring, identify what code can be safely removed without affecting functionality."
      },
      {
        "target_user": "DevOps Engineers",
        "title": "Optimize Build Artifacts",
        "description": "Reduce bundle sizes and deployment artifacts by eliminating unused code and dependencies."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Dead Code Scan",
        "scenario": "Quick scan of entire codebase",
        "prompt": "Scan my entire codebase for dead code including unused imports, variables, functions, and unreachable code. Focus on obvious issues that are safe to remove."
      },
      {
        "title": "Aggressive Cleanup Mode",
        "scenario": "Deep clean including edge cases",
        "prompt": "Perform an aggressive dead code analysis including commented code blocks, deprecated functions, and potentially unused exports. Flag everything but categorize by safety."
      },
      {
        "title": "Dependency Analysis",
        "scenario": "Check npm package usage",
        "prompt": "Analyze my package.json and codebase to find unused npm dependencies, dev dependencies used in production, and production dependencies only used in tests."
      },
      {
        "title": "Targeted File Analysis",
        "scenario": "Focus on specific directories",
        "prompt": "Focus on the src/components directory and identify all unused code. Pay special attention to React-specific patterns like unused props, state variables, and lifecycle methods."
      }
    ],
    "output_examples": [
      {
        "input": "Scan my React project for dead code",
        "output": [
          "## Safe to Remove (23 items)",
          "### Unused Imports (8)",
          "- src/App.jsx:3 `import { oldLogo } from './assets'`",
          "### Unused Variables (7)",
          "- src/hooks/useData.js:15 `const cache = new Map()` (never referenced)",
          "### Unused Functions (8)",
          "- src/utils/helpers.js:34 `function formatLegacyData()` (never called)",
          "## Needs Review (12 items)",
          "### Exported but Unused (12)",
          "- src/api/client.js:89 `export function legacyRequest()` (public API?)"
        ]
      }
    ],
    "best_practices": [
      "Always run tests after removing code to ensure nothing broke",
      "Use version control to track removals for easy rollback",
      "Be conservative with public API changes in libraries",
      "Consider marking deprecated before removal"
    ],
    "anti_patterns": [
      "Removing code without understanding dynamic usage patterns",
      "Aggressively removing all flagged code without review",
      "Ignoring test-only code that appears unused",
      "Removing exported functions without checking consumers"
    ],
    "faq": [
      {
        "question": "How does this skill detect dead code?",
        "answer": "It uses static analysis to find declarations without references, unreachable code paths, and unused imports based on coding patterns."
      },
      {
        "question": "Can it detect dynamically referenced code?",
        "answer": "No, static analysis cannot detect code accessed via strings, reflection, or dynamic imports. These require manual review."
      },
      {
        "question": "Will it flag my test helper functions?",
        "answer": "It might. Test-only code that isn't properly excluded may appear unused. Use --include-tests flag to analyze test files separately."
      },
      {
        "question": "Is it safe to remove everything flagged?",
        "answer": "Only remove items marked 'Safe to Remove'. Review 'Needs Review' items manually as they might be public APIs or dynamically used."
      },
      {
        "question": "Which languages does it support?",
        "answer": "Currently optimized for JavaScript/TypeScript, but can identify patterns in most C-style languages including Python and Java."
      },
      {
        "question": "How is this different from ESLint?",
        "answer": "ESLint focuses on code quality rules while this provides comprehensive dead code analysis including dependencies and cross-file references."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
