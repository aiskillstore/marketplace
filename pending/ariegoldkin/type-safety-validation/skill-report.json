{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T10:54:19.801Z",
    "slug": "ariegoldkin-type-safety-validation",
    "source_url": "https://github.com/ArieGoldkin/ai-agent-hub/tree/main/skills/type-safety-validation",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "ba7292c2e193ccebf1029ada3557bc0bf7b55fcb173c3448727eb0b3bae3e7b2",
    "tree_hash": "029cf0859a562784691f1cbc52964ea921a7bf8559d27783db231c759fbb0756"
  },
  "skill": {
    "name": "type-safety-validation",
    "description": "Achieve end-to-end type safety with Zod runtime validation, tRPC type-safe APIs, Prisma ORM, and TypeScript 5.7+ features. Build fully type-safe applications from database to UI for 2025+ development.",
    "summary": "Achieve end-to-end type safety with Zod runtime validation, tRPC type-safe APIs, Prisma ORM, and Typ...",
    "icon": "üõ°Ô∏è",
    "version": "1.0.0",
    "author": "AI Agent Hub",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "typescript",
      "zod",
      "trpc",
      "prisma",
      "type-safety",
      "validation",
      "2025"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing only educational content about type safety patterns. No executable code, no network operations, no file access, no external command execution. Risk factor evidence array is empty due to zero detected risk factors.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 326,
    "audit_model": "claude",
    "audited_at": "2026-01-10T10:54:19.801Z"
  },
  "content": {
    "user_title": "Validate Types End-to-End with Zod, tRPC, and Prisma",
    "value_statement": "Type errors caught at runtime cause production bugs and costly hotfixes. This skill provides proven patterns for implementing Zod validation, tRPC type-safe APIs, and Prisma ORM integration to catch errors at compile time across your entire stack.",
    "seo_keywords": [
      "type safety",
      "Zod validation",
      "tRPC",
      "Prisma ORM",
      "TypeScript 5.7",
      "runtime validation",
      "type-safe APIs",
      "Claude Code",
      "Claude",
      "Codex"
    ],
    "actual_capabilities": [
      "Define Zod schemas for runtime validation with refinements and transformations",
      "Create type-safe API endpoints using tRPC with full-stack TypeScript",
      "Implement Prisma ORM patterns for type-safe database operations",
      "Apply TypeScript 5.7 features including const type parameters and satisfies operator",
      "Build end-to-end typed full-stack applications from database to React UI",
      "Validate user input at API boundaries with clear error handling"
    ],
    "limitations": [
      "Requires migration effort when adding types to existing JavaScript codebases",
      "Schema validation adds runtime overhead for complex nested structures",
      "tRPC requires both client and server to use TypeScript for full benefits",
      "Prisma schema changes require database migrations"
    ],
    "use_cases": [
      {
        "target_user": "Full-stack developers",
        "title": "Build type-safe full-stack apps",
        "description": "Create Next.js applications with tRPC APIs, Prisma database access, and React components all sharing the same type definitions"
      },
      {
        "target_user": "Backend engineers",
        "title": "Validate API inputs rigorously",
        "description": "Implement strict input validation for REST and RPC endpoints using Zod schemas that generate both runtime checks and TypeScript types"
      },
      {
        "target_user": "TypeScript teams",
        "title": "Modernize legacy codebases",
        "description": "Add type safety incrementally to JavaScript projects using Zod for validation boundaries and branded types for domain concepts"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic type safety setup",
        "scenario": "Getting started with Zod validation",
        "prompt": "Show me how to define a Zod schema for a user object with email validation, age range checks, and optional metadata. Include how to infer the TypeScript type from the schema."
      },
      {
        "title": "Create tRPC procedure",
        "scenario": "Building type-safe API endpoints",
        "prompt": "Write a tRPC procedure that accepts pagination parameters with defaults and limits, queries the database, and returns typed results with proper error handling."
      },
      {
        "title": "Prisma type patterns",
        "scenario": "Type-safe database operations",
        "prompt": "Demonstrate Prisma query patterns with proper TypeScript typing. Show how to use include for relations and how the return type automatically reflects the query shape."
      },
      {
        "title": "Full-stack integration",
        "scenario": "Connecting all layers",
        "prompt": "Show a complete example of how types flow from Zod input validation through tRPC procedures to Prisma queries and back to a React component, demonstrating end-to-end type safety."
      }
    ],
    "output_examples": [
      {
        "input": "Create a Zod schema for product validation with name, price, inventory count, and optional tags array",
        "output": [
          "‚úì ProductSchema defined with zod validation chain",
          "‚úì name: string with min 1 character required",
          "‚úì price: positive number with 2 decimal precision",
          "‚úì inventory: integer from 0 to 10000",
          "‚úì tags: optional array of strings",
          "‚úì TypeScript type inferred as Product = z.infer<typeof ProductSchema>"
        ]
      }
    ],
    "best_practices": [
      "Validate at system boundaries using safeParse() to handle errors without throwing",
      "Enable strict mode and noUncheckedIndexedAccess in tsconfig.json for comprehensive type checking",
      "Reuse schema definitions across validation, API inputs, and database queries to maintain single source of truth"
    ],
    "anti_patterns": [
      "Using any type to bypass TypeScript checking instead of properly typing unknown data",
      "Skipping validation on internal functions assuming caller behavior is correct",
      "Creating inline schemas inside functions instead of defining reusable schema modules"
    ],
    "faq": [
      {
        "question": "Which AI coding tools support this skill?",
        "answer": "Works with Claude, Claude Code, and Codex. Types are compatible across all TypeScript AI assistants."
      },
      {
        "question": "What are the performance implications of Zod validation?",
        "answer": "Zod adds minimal overhead for simple schemas. Complex nested schemas may slow validation measurably."
      },
      {
        "question": "Can I use Zod with existing JavaScript code?",
        "answer": "Yes, Zod works with plain JavaScript. You get runtime validation without TypeScript compilation."
      },
      {
        "question": "How does tRPC compare to REST APIs for type safety?",
        "answer": "tRPC shares types between client and server automatically, eliminating manual type synchronization required in REST."
      },
      {
        "question": "Is my data safe with this validation approach?",
        "answer": "Validation runs locally in your application. No data is sent to external services for processing."
      },
      {
        "question": "What if validation fails in production?",
        "answer": "Use safeParse() to catch validation errors gracefully. Return user-friendly error messages without exposing internal details."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
