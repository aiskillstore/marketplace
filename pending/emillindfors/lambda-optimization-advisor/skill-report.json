{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:11:20.100Z",
    "slug": "emillindfors-lambda-optimization-advisor",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-lambda/skills/lambda-optimization-advisor",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "71e0e2100ac1ad1eb3db35fd28cbd56b35245b58b78ebc2b1fe6ccfa2376fc70",
    "tree_hash": "5f4d46e42ce4570ad59dd0d5d11bbcdf7b160220dec2faff68c6e14a6466eb89"
  },
  "skill": {
    "name": "lambda-optimization-advisor",
    "description": "Reviews AWS Lambda functions for performance, memory configuration, and cost optimization. Activates when users write Lambda handlers or discuss Lambda performance.",
    "summary": "Reviews AWS Lambda functions for performance, memory configuration, and cost optimization. Activates...",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "category": "devops",
    "tags": [
      "aws",
      "lambda",
      "optimization",
      "rust",
      "serverless"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Static analysis flagged 25 potential issues in SKILL.md code examples, all of which are false positives. The flagged patterns (external_commands, network URLs, cryptographic references) are markdown documentation examples illustrating Lambda optimization patterns, not executable code. The skill only uses read-only tools (Read, Grep, Glob) for code analysis. No malicious intent or dangerous patterns present.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 169,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:11:20.100Z"
  },
  "content": {
    "user_title": "Optimize AWS Lambda Functions",
    "value_statement": "AWS Lambda functions often suffer from slow cold starts and high costs due to inefficient patterns. The Lambda Optimization Advisor analyzes Lambda code and suggests specific improvements for performance, memory configuration, and cost reduction.",
    "seo_keywords": [
      "AWS Lambda optimization",
      "Lambda performance tuning",
      "Lambda cold start improvement",
      "Rust Lambda functions",
      "serverless cost optimization",
      "Lambda memory configuration",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Detects sequential async operations that can be parallelized with tokio::try_join",
      "Identifies resource initialization patterns that create new clients on every invocation",
      "Reviews Cargo.toml configurations for release profile optimizations",
      "Recommends ARM64 architecture for 20% better price-performance",
      "Analyzes memory configuration to optimize CPU allocation and execution time",
      "Suggests batch processing patterns to reduce invocation overhead"
    ],
    "limitations": [
      "Only supports Rust-based Lambda functions using lambda_runtime",
      "Cannot modify code directly - only provides suggestions",
      "Does not analyze deployed Lambda configurations or permissions",
      "Cannot test optimizations in a live environment"
    ],
    "use_cases": [
      {
        "title": "New Lambda Project Setup",
        "description": "Review a new Rust Lambda handler during development to establish optimal patterns from the start, avoiding costly refactoring later.",
        "target_user": "Developers building new serverless applications"
      },
      {
        "title": "Performance Troubleshooting",
        "description": "Diagnose why an existing Lambda function has high latency or cold start issues and receive specific code changes to improve performance.",
        "target_user": "DevOps engineers troubleshooting production issues"
      },
      {
        "title": "Cost Optimization Review",
        "description": "Analyze Lambda functions to identify opportunities for reducing execution costs through better memory configuration and concurrent operations.",
        "target_user": "Cloud architects optimizing serverless costs"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Lambda Review",
        "prompt": "Review this AWS Lambda handler code for performance and cost optimizations. Identify any sequential async operations, resource initialization issues, or configuration problems.",
        "scenario": "General Lambda code review request"
      },
      {
        "title": "Cold Start Analysis",
        "prompt": "Analyze this Lambda function to find causes of slow cold starts. Look for patterns that create new clients or resources on each invocation and suggest fixes using OnceLock or static initialization.",
        "scenario": "Troubleshooting slow Lambda cold starts"
      },
      {
        "title": "Cargo.toml Optimization",
        "prompt": "Review this Lambda project's Cargo.toml file. Check if the release profile is optimized for Lambda deployment with settings like opt-level, lto, codegen-units, and strip for smaller binaries.",
        "scenario": "Optimizing build configuration for Lambda"
      },
      {
        "title": "ARM64 Migration",
        "prompt": "This Lambda function is running on x86_64. Evaluate whether migrating to ARM64 (Graviton2) would provide better price-performance and what code or build changes would be needed.",
        "scenario": "Evaluating architecture migration to ARM64"
      }
    ],
    "output_examples": [
      {
        "input": "Review this Lambda handler:\n\nasync fn handler(event: LambdaEvent<Request>) -> Result<Response, Error> {\n    let user = fetch_user(&event.payload.user_id).await?;\n    let posts = fetch_posts(&event.payload.user_id).await?;\n    let comments = fetch_comments(&event.payload.user_id).await?;\n    Ok(Response { user, posts, comments })\n}",
        "output": [
          "**Performance Issue Found: Sequential Async Operations**",
          "",
          "This handler makes three sequential API calls that take 3+ seconds total. Each `.await?` blocks until the previous call completes.",
          "",
          "**Optimization**: Use `tokio::try_join!` to run all requests concurrently:",
          "",
          "```rust",
          "async fn handler(event: LambdaEvent<Request>) -> Result<Response, Error> {",
          "    let (user, posts, comments) = tokio::try_join!(",
          "        fetch_user(&event.payload.user_id),",
          "        fetch_posts(&event.payload.user_id),",
          "        fetch_comments(&event.payload.user_id),",
          "    )?;",
          "    Ok(Response { user, posts, comments })",
          "}",
          "```",
          "",
          "**Expected Improvement**: Execution time reduced from 3s+ to ~500ms (6x faster)"
        ]
      },
      {
        "input": "Check this Lambda handler for optimization opportunities:\n\nasync fn handler(event: LambdaEvent<Request>) -> Result<Response, Error> {\n    let client = reqwest::Client::new();\n    let data = client.get(\"https://api.example.com\").await?;\n    Ok(Response { data })\n}",
        "output": [
          "**Cold Start Issue Found: Client Initialization in Handler**",
          "",
          "Creating a new HTTP client on every invocation adds latency and memory overhead. Each Lambda container start must initialize a new client.",
          "",
          "**Optimization**: Use `OnceLock` to initialize the client once per container:",
          "",
          "```rust",
          "use std::sync::OnceLock;",
          "static HTTP_CLIENT: OnceLock<reqwest::Client> = OnceLock::new();",
          "",
          "async fn handler(event: LambdaEvent<Request>) -> Result<Response, Error> {",
          "    let client = HTTP_CLIENT.get_or_init(|| {",
          "        reqwest::Client::builder()",
          "            .timeout(Duration::from_secs(10))",
          "            .build()",
          "            .unwrap()",
          "    });",
          "    let data = client.get(\"https://api.example.com\").await?;",
          "    Ok(Response { data })",
          "}",
          "```",
          "",
          "**Expected Improvement**: Faster cold starts and lower memory usage"
        ]
      }
    ],
    "best_practices": [
      "Use tokio::try_join! or tokio::join! for concurrent I/O operations instead of sequential await statements",
      "Initialize HTTP clients, database pools, and AWS SDK clients using OnceLock or lazy_static for container reuse",
      "Configure Cargo.toml release profile with opt-level = 'z', lto = true, codegen-units = 1, and strip = true"
    ],
    "anti_patterns": [
      "Creating new clients or resources inside the Lambda handler function (happens on every invocation)",
      "Making sequential async calls that could run concurrently (wastes execution time)",
      "Using default Cargo release profile without optimization flags (larger binaries, slower cold starts)"
    ],
    "faq": [
      {
        "question": "Does this skill modify my Lambda code?",
        "answer": "No, this skill only analyzes your code and provides optimization suggestions with example code changes. You must apply the changes yourself."
      },
      {
        "question": "Which Lambda runtimes are supported?",
        "answer": "This skill is designed for Rust Lambda functions using the lambda_runtime crate. Other runtimes like Python or Node.js are not within scope."
      },
      {
        "question": "How much performance improvement can I expect?",
        "answer": "Results vary based on your current patterns. Converting sequential I/O to concurrent operations typically provides 3-5x speedup. ARM64 migration offers 20% better price-performance on average."
      },
      {
        "question": "Can this skill help with Lambda permissions or IAM roles?",
        "answer": "No, this skill focuses on code-level performance optimizations. It does not analyze IAM policies, resource-based permissions, or VPC configurations."
      },
      {
        "question": "Should I always use ARM64 for Lambda?",
        "answer": "ARM64 provides better price-performance for most workloads, but some legacy x86-only libraries or dependencies may require x86_64 architecture. Test your specific workload before migrating."
      },
      {
        "question": "How do I test the suggested optimizations?",
        "answer": "Apply the suggested changes to your code, run your existing tests, and deploy to a test environment. Use Lambda Power Tuning to compare performance before and after changes."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 169
    }
  ]
}
