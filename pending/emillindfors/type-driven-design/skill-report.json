{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:41:03.497Z",
    "slug": "emillindfors-type-driven-design",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-modern-patterns/skills/type-driven-design",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "91795050d19408c9cc18527c3d8a46b7061dc81facb18c83064804274d91e9a6",
    "tree_hash": "b082e7a6935f6fb57ef5ae0ec2ad8c4f95ada90c009211c08968a9906cc9e41c"
  },
  "skill": {
    "name": "Type-Driven Design",
    "description": "Type-driven design patterns in Rust including typestate, newtype, builder pattern, and compile-time guarantees for safer APIs",
    "summary": "Type-driven design patterns in Rust for compile-time safety and zero-cost abstractions",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "tags": [
      "rust",
      "type-systems",
      "compile-time-safety",
      "design-patterns"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings are false positives. The scanner incorrectly flagged 'type-driven design' references as cryptographic algorithms, markdown backticks as shell command execution, and documentation URLs as network security risks. This is pure educational documentation about Rust patterns with no actual security concerns.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 798,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:41:03.497Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Design Safer Rust APIs with Types",
    "value_statement": "Manual validation and runtime checks are error-prone and costly. This skill teaches type-driven design patterns in Rust that move correctness guarantees from runtime to compile time, eliminating entire classes of bugs before code runs.",
    "seo_keywords": [
      "Rust type-driven design",
      "typestate pattern Rust",
      "newtype pattern Rust",
      "compile-time safety",
      "Claude Code",
      "Rust design patterns",
      "Rust type system",
      "phantom types Rust"
    ],
    "actual_capabilities": [
      "Implement the newtype pattern to prevent mixing similar values",
      "Apply typestate pattern to enforce state machine transitions at compile time",
      "Create builder patterns with compile-time validation",
      "Use phantom types for type-level programming",
      "Design APIs that make invalid states unrepresentable"
    ],
    "limitations": [
      "Does not generate code or refactor existing projects",
      "Does not evaluate performance or runtime characteristics",
      "Does not provide project setup or build configuration",
      "Cannot enforce types across FFI boundaries or unsafe code"
    ],
    "use_cases": [
      {
        "title": "Building Safe Financial Systems",
        "description": "Create type-safe financial APIs where AccountId and Amount types cannot be accidentally swapped, preventing costly errors in money transfer logic.",
        "target_user": "Backend developers building financial services"
      },
      {
        "title": "Modeling Protocol State Machines",
        "description": "Design network protocols or database sessions where connection states like Disconnected, Connected, and Authenticated are enforced by the type system.",
        "target_user": "Systems programmers and protocol engineers"
      },
      {
        "title": "Validating API Inputs at Compile Time",
        "description": "Construct builders that require all mandatory fields before building, eliminating runtime validation and providing better error messages.",
        "target_user": "Library authors and API designers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Newtype Pattern Introduction",
        "prompt": "Show me how to use the newtype pattern in Rust to prevent mixing up UserId and OrderId in my API. Include both the problem (plain types) and solution (newtypes).",
        "scenario": "Learning basic type safety with newtypes"
      },
      {
        "title": "Typestate Pattern for Connections",
        "prompt": "Help me implement a connection type that enforces calling connect() before authenticate() before send_data(). Use typestate to make invalid state transitions impossible at compile time.",
        "scenario": "Enforcing state machine transitions"
      },
      {
        "title": "Compile-Time Validated Builder",
        "prompt": "Create a ConfigBuilder in Rust where host and port are required fields that must be set before build() is called. The builder should return Config directly (not Result) since validity is guaranteed at compile time.",
        "scenario": "Building with compile-time guarantees"
      },
      {
        "title": "Phantom Types for Type-Level Constraints",
        "prompt": "Show me how to use phantom types to create a type-safe ID system where UserId and OrderId are incompatible types, and foreign keys like Order.user_id must match the correct ID type.",
        "scenario": "Advanced phantom type patterns"
      }
    ],
    "output_examples": [
      {
        "input": "How do I prevent accidentally swapping from_account and to_account in my money transfer function?",
        "output": "Use the newtype pattern:\n\n```rust\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct AccountId(String);\n\n#[derive(Debug, Clone, Copy)]\npub struct Amount(f64);\n\nfn transfer_money(from: AccountId, to: AccountId, amount: Amount) {\n    // Compiler prevents mixing up from and to!\n}\n\n// This won't compile:\n// transfer_money(to, from, amount); // Type error!\n```"
      },
      {
        "input": "How can I ensure my API users must call set_host() and set_port() before building?",
        "output": "Use a typestate builder with state markers:\n\n```rust\npub struct NoHost;\npub struct HasHost;\npub struct NoPort;\npub struct HasPort;\n\npub struct ConfigBuilder<HostState, PortState> { /* ... */ }\n\nimpl ConfigBuilder<HasHost, HasPort> {\n    pub fn build(self) -> Config {\n        // No Result needed - all required fields guaranteed!\n        Config { host: self.host.unwrap(), port: self.port.unwrap() }\n    }\n}\n\n// Won't compile:\n// ConfigBuilder::new().build(); // Missing host and port!\n```"
      }
    ],
    "best_practices": [
      "Encode domain invariants in types rather than runtime checks to catch bugs at compile time",
      "Use marker types for state to enforce valid transitions and make illegal states unrepresentable",
      "Leverage Rust's zero-cost abstractions - type-level constraints add no runtime overhead"
    ],
    "anti_patterns": [
      "Using boolean flags like is_connected instead of state types that prevent invalid operations",
      "Deferring validation to runtime when types could enforce correctness at compile time",
      "Exposing raw primitive types in public APIs where domain types would provide better safety"
    ],
    "faq": [
      {
        "question": "What is the typestate pattern in Rust?",
        "answer": "Typestate is a pattern where a type carries compile-time information about its current state. Methods are only available for specific states, preventing invalid operations like calling send_data() before authenticate()."
      },
      {
        "question": "How does the newtype pattern improve safety?",
        "answer": "The newtype pattern wraps a primitive type in a struct, creating a distinct type. This prevents accidentally passing AccountId where OrderId is expected since the compiler treats them as incompatible types."
      },
      {
        "question": "Do type-driven patterns add runtime overhead?",
        "answer": "No. All type-driven design patterns in Rust compile to zero-cost abstractions. Newtypes have the same size as their inner type, and phantom types are optimized away entirely."
      },
      {
        "question": "When should I avoid type-driven design?",
        "answer": "Consider alternatives when states are highly dynamic, transitions depend on runtime data, compile times become prohibitive, or the API complexity outweighs the safety benefits."
      },
      {
        "question": "What is the difference between runtime and compile-time validation?",
        "answer": "Runtime validation returns errors at execution time (Result or panic). Compile-time validation makes invalid states impossible to represent, so errors appear during compilation with better error messages."
      },
      {
        "question": "Can type-driven design work with async code?",
        "answer": "Yes. State types work seamlessly with async. The builder pattern shown in this skill includes async send() methods that are only available when the request is properly constructed."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 798
    }
  ]
}
