{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T01:57:50.400Z",
    "slug": "emillindfors-cold-start-optimizer",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-lambda/skills/cold-start-optimizer",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "5abcd134b549d53fe9d1513493d39e2b437f526831ff16d9d3a9cd89e26de16e",
    "tree_hash": "87586f1d13fb6ca02d826449f373976c818f3c10ed7f494eeeea49b5c70ee305"
  },
  "skill": {
    "name": "cold-start-optimizer",
    "description": "Provides guidance on reducing Lambda cold start times through binary optimization, lazy initialization, and deployment strategies. Activates when users discuss cold starts or deployment configuration.",
    "summary": "Optimize AWS Lambda cold starts for Rust functions through binary size reduction, lazy initialization, and ARM64 deployment.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "tags": [
      "aws-lambda",
      "rust",
      "cold-start",
      "performance-optimization",
      "serverless"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All 26 static findings are false positives. Shell command patterns are markdown code examples in documentation. 'SAM' refers to AWS Serverless Application Model, not Windows Security Account Manager. 'Weak cryptographic algorithm' trigger was a false positive on the word 'optimization' in the description field. Skill contains only documentation and safe code examples.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 214,
    "audit_model": "claude",
    "audited_at": "2026-01-23T01:57:50.400Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Optimize Lambda cold starts",
    "value_statement": "AWS Lambda cold starts cause latency spikes in serverless applications. This skill provides expert guidance on reducing cold start times for Rust Lambda functions through binary optimization, lazy initialization patterns, and deployment best practices.",
    "seo_keywords": [
      "AWS Lambda cold start optimization",
      "Rust Lambda performance",
      "serverless cold start reduction",
      "Lambda ARM64 Graviton2",
      "AWS Lambda provisioned concurrency",
      "Cargo optimization for Lambda",
      "cold start latency",
      "Lambda initialization time",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Analyzes Lambda deployment configurations and suggests binary size optimizations via Cargo.toml settings",
      "Identifies eager initialization patterns and recommends OnceLock-based lazy initialization alternatives",
      "Recommends ARM64 (Graviton2) deployment for improved price-performance and faster cold starts",
      "Provides CloudWatch Insights queries for measuring and monitoring cold start duration",
      "Suggests provisioned concurrency configuration for latency-critical functions"
    ],
    "limitations": [
      "Does not modify code files directly - only provides guidance and examples",
      "Does not execute or deploy Lambda functions - users must run commands themselves",
      "Focused specifically on Rust Lambda functions, not other runtimes",
      "Does not integrate with AWS API to fetch current Lambda configurations"
    ],
    "use_cases": [
      {
        "title": "New Rust Lambda Project Setup",
        "description": "When starting a new Rust Lambda project, get guidance on optimal Cargo.toml settings for minimal binary size and fastest cold start times.",
        "target_user": "Rust developers new to Lambda"
      },
      {
        "title": "Diagnosing Cold Start Issues",
        "description": "Existing Lambda functions experiencing slow cold starts receive recommendations for lazy initialization, dependency reduction, and ARM64 migration.",
        "target_user": "Serverless developers troubleshooting latency"
      },
      {
        "title": "Lambda Performance Review",
        "description": "Proactive optimization suggestions when reviewing Lambda deployment code, including measurement strategies and provisioned concurrency evaluation.",
        "target_user": "DevOps engineers conducting performance audits"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Cold Start Question",
        "prompt": "My Rust Lambda function is experiencing slow cold starts. What can I do to reduce initialization time?",
        "scenario": "User asks about cold start optimization without specific details"
      },
      {
        "title": "Cargo.toml Review",
        "prompt": "Review this Cargo.toml and suggest optimizations to reduce binary size for Lambda deployment:\n\n```toml\n[profile.release]\nopt-level = 3\n```",
        "scenario": "User provides Cargo.toml configuration for review"
      },
      {
        "title": "Initialization Pattern Analysis",
        "prompt": "Is this initialization pattern going to cause cold start issues? How can I make it lazy?\n\n```rust\nstatic DB_POOL: once_cell::sync::Lazy<PgPool> = once_cell::sync::Lazy::new(|| {\n    run_async_setup();\n    PgPool::connect(&std::env::var(\"DATABASE_URL\").unwrap())\n});\n```",
        "scenario": "User asks about specific initialization code"
      },
      {
        "title": "ARM64 Migration",
        "prompt": "I want to migrate my Lambda function to ARM64 (Graviton2) for better performance. What build commands and configuration changes do I need?",
        "scenario": "User wants to switch Lambda architecture"
      }
    ],
    "output_examples": [
      {
        "input": "My Lambda cold start takes over 1 second. How can I optimize this?",
        "output": [
          "Here are the key strategies to reduce Lambda cold start times:",
          "",
          "1. **Binary Size Reduction** - Add this to your Cargo.toml:",
          "```toml",
          "[profile.release]",
          "opt-level = 'z'     # Optimize for size",
          "lto = true          # Link-time optimization",
          "codegen-units = 1   # Single codegen unit",
          "strip = true        # Strip symbols",
          "panic = 'abort'     # Smaller panic handler",
          "```",
          "",
          "2. **Lazy Initialization** - Avoid static initializers that run on every cold start. Use OnceLock for expensive resources.",
          "",
          "3. **ARM64 Deployment** - Build for Graviton2:",
          "```bash",
          "cargo lambda build --release --arm64",
          "```",
          "",
          "4. **Measure First** - Use CloudWatch Insights to analyze current cold start duration:"
        ]
      },
      {
        "input": "Should I use provisioned concurrency to eliminate cold starts?",
        "output": [
          "Provisioned concurrency eliminates cold starts but has trade-offs:",
          "",
          "**Benefits**:",
          "- Consistent sub-100ms latency for every request",
          "- No initialization latency",
          "",
          "**Costs**:",
          "- Higher cost per invocation vs. on-demand",
          "- Must manage scaling of provisioned capacity",
          "",
          "**When to use**: Critical paths with strict latency SLAs, such as:",
          "- Real-time API endpoints",
          "- Interactive user-facing requests",
          "- Payment or transaction processing",
          "",
          "**Alternative**: Optimize your code first. A well-optimized Rust Lambda can achieve 100-200ms cold starts, eliminating the need for provisioned concurrency in many cases."
        ]
      }
    ],
    "best_practices": [
      "Configure Cargo.toml release profile with size optimization flags (opt-level = 'z', lto = true, strip = true) before deploying to production",
      "Use OnceLock for expensive resources like HTTP clients, database pools, and SDK clients to defer initialization until first use",
      "Measure cold start duration in CloudWatch before and after optimizations to validate improvements"
    ],
    "anti_patterns": [
      "Avoid eager initialization of heavy resources at module level - this increases every cold start even when the resource is not needed",
      "Do not include unused dependencies or enable all features - use cargo bloat to identify unnecessary dependencies",
      "Avoid synchronous blocking calls during initialization - this blocks the entire cold start process"
    ],
    "faq": [
      {
        "question": "What is the fastest cold start time achievable with Rust Lambda?",
        "answer": "Well-optimized Rust Lambda functions can achieve 50-200ms cold starts. Factors include binary size, initialization complexity, and runtime (ARM64 typically faster than x86_64)."
      },
      {
        "question": "Does ARM64 really improve cold starts?",
        "answer": "Yes, ARM64 (Graviton2) typically provides 20% faster cold starts and better price-performance. The smaller instruction set can reduce binary size and initialization time."
      },
      {
        "question": "How do I measure my current cold start duration?",
        "answer": "Use CloudWatch Insights to analyze @initDuration from Lambda logs: filter @type = 'REPORT' | stats avg(@initDuration), max(@initDuration) by bin(1h)"
      },
      {
        "question": "What is lazy initialization and why does it help?",
        "answer": "Lazy initialization defers creating expensive resources until they are first accessed. This reduces cold start time by only paying the initialization cost when that specific code path executes."
      },
      {
        "question": "Can I use OnceLock with async operations?",
        "answer": "OnceLock::get_or_init is synchronous. For async initialization, use OnceCell with std::sync::Mutex, or use tokio::sync::OnceCell for properly async lazy initialization."
      },
      {
        "question": "How much binary size reduction is realistic?",
        "answer": "With aggressive Cargo.toml optimizations (opt-level = 'z', lto, strip), expect 50-70% size reduction. The cargo bloat tool helps identify the largest dependencies to target."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 214
    }
  ]
}
