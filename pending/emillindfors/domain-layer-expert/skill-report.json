{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:03:28.666Z",
    "slug": "emillindfors-domain-layer-expert",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-hexagonal/skills/domain-layer-expert",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "c066125df35755e4d2a92f0f931ae873d67c58dbeb4664cbb91ffc985494513a",
    "tree_hash": "ccb15a4ed8cac36ffaa0e9ce0c4120b9bbb446599e69c04c8894c3cdc2847683"
  },
  "skill": {
    "name": "domain-layer-expert",
    "description": "Guides users in creating rich domain models with behavior, value objects, and domain logic. Activates when users define domain entities, business rules, or validation logic.",
    "summary": "Guides users in creating rich domain models with behavior, value objects, and domain logic. Activate...",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "tags": [
      "domain-driven-design",
      "rust",
      "ddd-patterns",
      "value-objects",
      "software-architecture"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings are false positives. Static analyzer misidentified Rust code examples as shell commands, YAML frontmatter as cryptographic algorithms, and legitimate patterns as reconnaissance. No executable code or security risks present.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 25,
            "line_end": 25
          },
          {
            "file": "SKILL.md",
            "line_start": 54,
            "line_end": 54
          },
          {
            "file": "SKILL.md",
            "line_start": 58,
            "line_end": 58
          },
          {
            "file": "SKILL.md",
            "line_start": 98,
            "line_end": 98
          },
          {
            "file": "SKILL.md",
            "line_start": 102,
            "line_end": 102
          },
          {
            "file": "SKILL.md",
            "line_start": 147,
            "line_end": 147
          },
          {
            "file": "SKILL.md",
            "line_start": 151,
            "line_end": 151
          },
          {
            "file": "SKILL.md",
            "line_start": 198,
            "line_end": 198
          },
          {
            "file": "SKILL.md",
            "line_start": 204,
            "line_end": 204
          },
          {
            "file": "SKILL.md",
            "line_start": 233,
            "line_end": 233
          },
          {
            "file": "SKILL.md",
            "line_start": 237,
            "line_end": 237
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [
      {
        "title": "Weak Cryptographic Algorithm False Positive",
        "description": "Static analyzer flagged YAML frontmatter text as cryptographic algorithm. Lines 3 and 10 contain only descriptive text about domain modeling, no cryptographic code exists.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 3,
            "line_end": 3
          },
          {
            "file": "SKILL.md",
            "line_start": 10,
            "line_end": 10
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "YAML frontmatter and plain English text describe domain modeling. No cryptographic functions or algorithms present."
      },
      {
        "title": "JSFuck Obfuscation False Positive",
        "description": "Static analyzer flagged YAML frontmatter delimiters as JSFuck obfuscation. Line 1 contains standard YAML `---` delimiters.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 1,
            "line_end": 1
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.98,
        "confidence_reasoning": "YAML frontmatter delimiters are standard markdown metadata syntax, not obfuscation code."
      }
    ],
    "medium_findings": [
      {
        "title": "Ruby/Shell Backtick Execution False Positive",
        "description": "Static analyzer misidentified Rust code examples in markdown code blocks as Ruby/shell backtick execution. All flagged locations contain legitimate Rust domain modeling patterns.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 25,
            "line_end": 25
          },
          {
            "file": "SKILL.md",
            "line_start": 54,
            "line_end": 54
          },
          {
            "file": "SKILL.md",
            "line_start": 58,
            "line_end": 58
          },
          {
            "file": "SKILL.md",
            "line_start": 98,
            "line_end": 98
          },
          {
            "file": "SKILL.md",
            "line_start": 102,
            "line_end": 102
          },
          {
            "file": "SKILL.md",
            "line_start": 147,
            "line_end": 147
          },
          {
            "file": "SKILL.md",
            "line_start": 151,
            "line_end": 151
          },
          {
            "file": "SKILL.md",
            "line_start": 198,
            "line_end": 198
          },
          {
            "file": "SKILL.md",
            "line_start": 204,
            "line_end": 204
          },
          {
            "file": "SKILL.md",
            "line_start": 233,
            "line_end": 233
          },
          {
            "file": "SKILL.md",
            "line_start": 237,
            "line_end": 237
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.92,
        "confidence_reasoning": "All flagged lines contain Rust code examples demonstrating value objects, entities, and domain events. No shell or Ruby execution present."
      }
    ],
    "low_findings": [
      {
        "title": "System Reconnaissance False Positive",
        "description": "Static analyzer flagged legitimate Rust code patterns as system reconnaissance. Lines 95, 118 contain simple getter methods and ID generation, line 200 is markdown header.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 95,
            "line_end": 95
          },
          {
            "file": "SKILL.md",
            "line_start": 118,
            "line_end": 118
          },
          {
            "file": "SKILL.md",
            "line_start": 200,
            "line_end": 200
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "Flagged patterns are standard Rust getter methods and markdown section headers, not reconnaissance code."
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 280,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:03:28.666Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Design Rich Domain Models in Rust",
    "value_statement": "Domain models often become simple data containers with no behavior. This skill guides developers in creating expressive, type-safe domain models using value objects, entities with identity, and domain events following DDD principles.",
    "seo_keywords": [
      "Claude",
      "Codex",
      "Claude Code",
      "domain-driven design",
      "DDD",
      "Rust domain modeling",
      "value objects",
      "entity pattern",
      "software architecture",
      "rich domain models"
    ],
    "actual_capabilities": [
      "Identifies and refactors anemic domain models into rich behavioral models",
      "Creates type-safe value objects with embedded validation logic",
      "Implements entities with identity and domain-specific behavior",
      "Adds domain events for capturing state changes",
      "Refactors primitive obsession by creating domain-specific types",
      "Applies business rules and invariants at the domain layer"
    ],
    "limitations": [
      "Does not generate persistence or infrastructure code",
      "Does not design database schemas or repository patterns",
      "Does not implement application services or use cases",
      "Focuses on Rust domain patterns, may not suit other languages"
    ],
    "use_cases": [
      {
        "title": "Refactor Anemic User Model",
        "description": "Transform a data-only User struct with getters and setters into a rich domain model with behavioral methods like deactivate() and change_email() that enforce business rules.",
        "target_user": "Backend developers adopting DDD patterns"
      },
      {
        "title": "Create Validated Value Types",
        "description": "Replace primitive types like String and i32 with domain-specific types like Email, Money, and Age that encapsulate validation logic.",
        "target_user": "Software architects establishing coding standards"
      },
      {
        "title": "Add Domain Events to Order Workflow",
        "description": "Implement an Order aggregate that emits UserCreated, EmailChanged, and other domain events when state changes occur.",
        "target_user": "Event-driven architecture practitioners"
      }
    ],
    "prompt_templates": [
      {
        "title": "Simple Domain Model",
        "prompt": "Create a domain model for a [concept] with proper validation. Include a value object for [field] and an entity with behavior methods.",
        "scenario": "When user wants a basic domain model with value objects and entities"
      },
      {
        "title": "Refactor Anemic Model",
        "prompt": "This struct is anemic. Refactor it into a rich domain model with behavior: [code]. Move validation into value objects and add domain methods.",
        "scenario": "When user shares an anemic domain model that needs refactoring"
      },
      {
        "title": "Add Business Rules",
        "prompt": "Add business rule validation to this domain model: [code]. The rules are: [rule1], [rule2]. Return errors with descriptive messages.",
        "scenario": "When user needs to add validation and business rules to existing domain logic"
      },
      {
        "title": "Implement Domain Events",
        "prompt": "Modify this aggregate to emit domain events on state changes: [code]. Include event struct definitions and a mechanism for event collection.",
        "scenario": "When user wants to add event sourcing or event-driven patterns"
      }
    ],
    "output_examples": [
      {
        "input": "Create a value object for an email address with validation for @ symbol and max length 255.",
        "output": [
          "A Rust struct Email(String) with a constructor that validates the email format.",
          "The constructor returns a ValidationError if the email is missing @ or exceeds 255 characters.",
          "Methods: as_str() to access the inner string, TryFrom<String> implementation for ergonomic conversion."
        ]
      },
      {
        "input": "Refactor this anemic User model into a rich domain model with behavior.",
        "output": [
          "User struct with private fields (id, email, name, status).",
          "Domain methods: deactivate(), change_email(), activate().",
          "Validation in domain methods preventing invalid state transitions.",
          "Status modeled as an enum UserStatus with Active, Inactive, Deleted variants."
        ]
      },
      {
        "input": "Create an Order entity with a minimum order value of $10.",
        "output": [
          "Order struct with OrderId, items, status, and total Money field.",
          "new() constructor rejects empty orders.",
          "confirm() method enforces $10 minimum and validates order status.",
          "add_item() only allowed on pending orders."
        ]
      }
    ],
    "best_practices": [
      "Create value objects that wrap primitives and contain validation logic",
      "Keep entities focused on identity and behavior, delegate data to value objects",
      "Model domain events when state changes need to trigger other behaviors",
      "Enforce invariants and business rules at creation time and state transitions"
    ],
    "anti_patterns": [
      "Using public fields on domain entities without encapsulation",
      "Putting validation in application services instead of domain types",
      "Mixing infrastructure concerns like database IDs with domain identity",
      "Creating anemic models that are just data containers with no behavior"
    ],
    "faq": [
      {
        "question": "What is the difference between a value object and an entity?",
        "answer": "Value objects are defined by their attributes and are immutable. Entities have a unique identity that persists through state changes. Use value objects for concepts like Email or Money, entities for things like User or Order."
      },
      {
        "question": "When should I use domain events?",
        "answer": "Use domain events when state changes in one aggregate need to trigger behavior in other parts of the system. Events decouple the aggregate from its consumers and enable event-driven architectures."
      },
      {
        "question": "How do I handle validation errors?",
        "answer": "Return Result types from constructors and methods. Create a ValidationError enum with specific variants for different failure modes. Keep error messages descriptive and actionable."
      },
      {
        "question": "Should I use Option or Result for optional values?",
        "answer": "Use Option when a value may legitimately be absent. Use Result when absence represents a failure condition. In domain models, prefer Result for validation failures and Option for optional attributes."
      },
      {
        "question": "How do I test domain models?",
        "answer": "Test domain behavior with unit tests covering valid state transitions, invalid operations, and error cases. Use property-based testing for value objects. Test invariants with multiple operations."
      },
      {
        "question": "Can this skill help with existing Rust projects?",
        "answer": "Yes. Share your existing domain models and the skill will suggest improvements for encapsulation, validation placement, and behavioral enrichment while maintaining compatibility."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 280
    }
  ]
}
