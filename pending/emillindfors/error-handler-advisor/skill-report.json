{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:08:26.038Z",
    "slug": "emillindfors-error-handler-advisor",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-error-handling/skills/error-handler-advisor",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "898f1b245234385fa03f0b752ab586ef1bf4e346186e054d3faa26f403b57b5c",
    "tree_hash": "a548064227ab2004070fda6922a4d217c92c53bc8b06ae44e806f0a8720d9602"
  },
  "skill": {
    "name": "error-handler-advisor",
    "description": "Proactively reviews error handling patterns and suggests improvements using Result types, proper error propagation, and idiomatic patterns. Activates when users write error handling code or use unwrap/expect.",
    "summary": "Proactively reviews error handling patterns and suggests improvements using Result types, proper error propagation, and idiomatic Rust patterns.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "rust",
      "error-handling",
      "result",
      "thiserror",
      "anyhow"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Static analyzer flagged 67 potential issues but ALL are false positives. The analyzer detected markdown syntax (backticks for inline code) as shell commands, error formatting strings as system reconnaissance, and YAML front matter as obfuscation. This is a legitimate Rust error handling documentation file with no executable code.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 15,
            "line_end": 15
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [
      {
        "title": "External Command Pattern - False Positive",
        "description": "Static analyzer detected backticks in markdown and flagged them as Ruby/shell backtick execution. These are markdown inline code markers (e.g., `unwrap()`, `?` operator) in Rust code examples, not actual shell commands.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 15,
            "line_end": 403
          }
        ],
        "confidence": 0.95,
        "confidence_reasoning": "This is a markdown documentation file containing Rust code examples. Backticks are markdown syntax for inline code, not executable shell commands."
      },
      {
        "title": "Weak Cryptographic Algorithm - False Positive",
        "description": "Static analyzer flagged error-related keywords as cryptographic algorithms. The file discusses error handling patterns, not cryptography.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 1,
            "line_end": 445
          }
        ],
        "confidence": 0.98,
        "confidence_reasoning": "The skill is about Rust error handling patterns. No cryptographic algorithms or related code exists in this documentation file."
      },
      {
        "title": "System Reconnaissance - False Positive",
        "description": "Static analyzer flagged error formatting strings as system reconnaissance. These are simply error message templates in code examples.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 89,
            "line_end": 118
          }
        ],
        "confidence": 0.97,
        "confidence_reasoning": "The flagged lines contain error message formatting like #[error(...)] attributes, which are standard Rust error definitions, not system commands."
      },
      {
        "title": "Obfuscation Pattern - False Positive",
        "description": "Static analyzer flagged YAML front matter delimiters as JSFuck obfuscation. Line 1 contains standard markdown YAML front matter (---).",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 1,
            "line_end": 1
          }
        ],
        "confidence": 0.99,
        "confidence_reasoning": "Line 1 is standard YAML front matter for markdown files. There is no obfuscated code present."
      }
    ],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 445,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:08:26.038Z"
  },
  "content": {
    "user_title": "Improve Rust Error Handling",
    "value_statement": "Rust developers often struggle with proper error handling patterns. This skill proactively reviews code and suggests idiomatic improvements using Result types, custom error types with thiserror, and proper error propagation with the ? operator.",
    "seo_keywords": [
      "Rust error handling",
      "Result type",
      "thiserror",
      "anyhow",
      "error propagation",
      "Rust panic handling",
      "Rust ? operator",
      "custom error types",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Detects unwrap() and expect() calls that could panic in production",
      "Suggests proper Result type usage with error propagation",
      "Recommends thiserror for library code and anyhow for applications",
      "Identifies missing error context and suggests improvements",
      "Provides complete code examples for error handling patterns",
      "Analyzes custom error types for proper From implementations"
    ],
    "limitations": [
      "Only activates when it detects error handling code or patterns",
      "Does not write new error handling code, only suggests improvements",
      "Cannot refactor existing codebases automatically",
      "Focuses on Rust error handling patterns only"
    ],
    "use_cases": [
      {
        "title": "New Rust Developer Learning",
        "description": "A developer new to Rust is unsure how to handle errors properly. The skill explains why unwrap() is dangerous and demonstrates the ? operator with concrete examples.",
        "target_user": "Rust beginners learning error handling"
      },
      {
        "title": "Code Review for Library Authors",
        "description": "A library maintainer wants to ensure their error types follow best practices. The skill reviews their thiserror definitions and suggests improvements for better ergonomics.",
        "target_user": "Rust library authors and maintainers"
      },
      {
        "title": "Production Code Audit",
        "description": "A team preparing to deploy wants to identify potential panic points. The skill scans the codebase for unwrap() and expect() in critical paths and suggests safer alternatives.",
        "target_user": "DevOps teams and engineering leads"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Error Review",
        "prompt": "Review this Rust function and suggest improvements for error handling. The function uses unwrap() and I want to make it more robust.",
        "scenario": "When a user shares code with unwrap() calls"
      },
      {
        "title": "Custom Error Type Design",
        "prompt": "Help me design custom error types for my library. I need error types that can represent validation errors, IO errors, and database errors.",
        "scenario": "When a user wants to create custom error types"
      },
      {
        "title": "Error Context Addition",
        "prompt": "Add context to my error propagation. Currently my errors don't explain which operation failed.",
        "scenario": "When a user wants to improve error messages"
      },
      {
        "title": "Library vs Application Patterns",
        "prompt": "What's the difference between thiserror and anyhow? When should I use each one for my project?",
        "scenario": "When a user asks about error handling libraries"
      }
    ],
    "output_examples": [
      {
        "input": "I wrote this function but I feel like the error handling could be better:\n\n```rust\nfn get_user(id: &str) -> User {\n    let user = db.find_user(id).unwrap();\n    user\n}\n```",
        "output": "This function will panic if the user is not found. Consider using Result to make errors recoverable:\n\n```rust\nfn get_user(id: &str) -> Result<User, DatabaseError> {\n    let user = db.find_user(id)?;\n    Ok(user)\n}\n```\n\nThe ? operator propagates the error to the caller, allowing them to decide how to handle it."
      },
      {
        "input": "How should I define errors for my library?",
        "output": "For library code, use thiserror with specific error types:\n\n```rust\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum MyLibError {\n    #[error(\"Invalid input: {0}\")]\n    InvalidInput(String),\n    \n    #[error(transparent)]\n    Io(#[from] std::io::Error),\n}\n```\n\nThis provides type-safe errors with automatic Display implementations and From trait implementations."
      }
    ],
    "best_practices": [
      "Use Result for fallible operations and propagate errors with the ? operator instead of unwrap()",
      "Choose thiserror for libraries (specific error types) and anyhow for applications (flexible error handling)",
      "Add context to errors using .context() or with #[error] messages to help with debugging"
    ],
    "anti_patterns": [
      "Using unwrap() or expect() in production code - these will panic on error",
      "Using String or &str as error types - lose type safety and pattern matching",
      "Ignoring errors with let _ = operation() - at minimum log the error"
    ],
    "faq": [
      {
        "question": "When should I use unwrap() instead of ?",
        "answer": "Use unwrap() only in tests or prototyping. In production code, always propagate errors with ? so callers can handle them gracefully."
      },
      {
        "question": "What is the difference between thiserror and anyhow?",
        "answer": "Use thiserror for libraries (specific, structured error types) and anyhow for applications (flexible, contextual errors). Libraries should not depend on anyhow."
      },
      {
        "question": "How do I add context to errors?",
        "answer": "Use anyhow's .context() method or thiserror's #[error] attributes with {0} placeholders for the wrapped error."
      },
      {
        "question": "Should my library return anyhow::Error?",
        "answer": "No. Libraries should define their own error types with thiserror. Applications can use anyhow at the top level."
      },
      {
        "question": "How do I convert between error types?",
        "answer": "Use #[from] attribute on error variants. This auto-implements From<T> for that variant, allowing ? to convert automatically."
      },
      {
        "question": "What about Option types?",
        "answer": "Use .ok_or() or .ok_or_else() to convert None into a Result error, or use .and_then() for chained Option operations."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 445
    }
  ]
}
