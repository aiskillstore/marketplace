{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:05:16.813Z",
    "slug": "emillindfors-error-conversion-guide",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-error-handling/skills/error-conversion-guide",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "c5316eb068fae0f7be35a5a960514a6fd5e705a752258170566ecf340214b439",
    "tree_hash": "43e91d3268cfa65535bb686aa21032b49696d01e7ff15bc9daf83d19211193c0"
  },
  "skill": {
    "name": "error-conversion-guide",
    "description": "Guides users on error conversion patterns, From trait implementations, and the ? operator. Activates when users need to convert between error types or handle multiple error types in a function.",
    "summary": "Rust error conversion guide with From trait patterns and ? operator best practices",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "tags": [
      "rust",
      "error-handling",
      "thiserror",
      "anyhow",
      "from-trait"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings are false positives. The 42 'external_commands' detections are markdown code fences (triple backticks for Rust examples). The 'network' detection is a Rust method call (repository.fetch), not a JavaScript Fetch API. The 'blocker' findings are unfounded. This is a benign documentation skill with Rust code examples only.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 559,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:05:16.813Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Convert error types with From trait patterns",
    "value_statement": "Developers struggle with Rust error type mismatches and repetitive map_err calls. This skill provides idiomatic patterns for converting errors using From trait implementations, the ? operator, and libraries like thiserror and anyhow.",
    "seo_keywords": [
      "Rust error conversion",
      "Claude Codex",
      "From trait Rust",
      "error handling Rust",
      "thiserror",
      "anyhow",
      "Claude Code",
      "Rust ? operator",
      "map_err",
      "Rust error types"
    ],
    "actual_capabilities": [
      "Detect error type mismatches in Rust code and suggest From trait implementations",
      "Recommend #[from] attribute for automatic conversion instead of manual map_err calls",
      "Show how to unify multiple error types into a single error enum",
      "Provide patterns for layered architectures with domain and infrastructure errors",
      "Guide on using thiserror for libraries and anyhow for applications",
      "Explain when to use map_err versus implementing From"
    ],
    "limitations": [
      "This skill provides guidance only; it does not modify code automatically",
      "The skill does not analyze external crates or their error types",
      "Pattern suggestions assume standard Rust error handling practices",
      "Does not cover async error handling specifics"
    ],
    "use_cases": [
      {
        "title": "Migrating from manual error conversion to #[from]",
        "description": "A developer has repetitive map_err calls like .map_err(|e| AppError::Io(e))? and wants cleaner code. The skill shows how to use #[from] for automatic From implementation.",
        "target_user": "Rust developers learning error handling"
      },
      {
        "title": "Creating unified error types for microservices",
        "description": "A team needs to combine database, API, and validation errors into one type. The skill demonstrates creating a unified error enum with From implementations for each source.",
        "target_user": "Backend engineers building Rust services"
      },
      {
        "title": "Choosing between thiserror and anyhow",
        "description": "A developer is unsure whether to use thiserror or anyhow for their project. The skill explains trade-offs: thiserror for libraries with specific error types, anyhow for applications needing flexibility.",
        "target_user": "Rust developers architecting error handling"
      }
    ],
    "prompt_templates": [
      {
        "title": "Convert map_err to From trait",
        "prompt": "I have this Rust code with manual error conversion. Help me convert it to use the #[from] attribute for automatic conversion:\n\n```rust\nfn process() -> Result<i32, AppError> {\n    let content = std::fs::read_to_string(\"data.txt\")\n        .map_err(|e| AppError::Io(e))?;\n    // ... more conversions\n}\n```",
        "scenario": "User wants to simplify error conversion code"
      },
      {
        "title": "Unify multiple error types",
        "prompt": "My Rust function calls three different functions that return different error types (RepositoryError, ValidationError, ApiError). How can I make them all compatible with the ? operator?",
        "scenario": "User needs to combine heterogeneous error types"
      },
      {
        "title": "Add context during error conversion",
        "scenario": "User wants to add custom context while converting errors",
        "prompt": "I need to convert an error but also add context about where the failure happened. What's the idiomatic way to do this in Rust? Should I use map_err, context, or implement From manually?"
      },
      {
        "title": "Library versus application error handling",
        "prompt": "I'm building a Rust library. Should I use thiserror or anyhow for my error types? What are the trade-offs for my library users?",
        "scenario": "Developer choosing error handling strategy for a library"
      }
    ],
    "output_examples": [
      {
        "input": "How do I convert std::io::Error to my custom AppError without map_err on every call?",
        "output": "Use the #[from] attribute on your error enum variant:\n\n```rust\n#[derive(Error, Debug)]\npub enum AppError {\n    #[error(\"IO error\")]\n    Io(#[from] std::io::Error),\n    // ... other variants\n}\n```\n\nThis automatically implements From<std::io::Error> for AppError, letting you use ? directly without manual conversion."
      },
      {
        "input": "What's the difference between thiserror and anyhow?",
        "output": "**thiserror** is for libraries:\n- Generates specific error types\n- Users can match on variants\n- No runtime overhead\n\n**anyhow** is for applications:\n- Single catch-all error type\n- Easy context with .context()\n- Simpler for applications\n\nChoose thiserror when library consumers need to handle specific errors. Choose anyhow when you just need readable error messages."
      }
    ],
    "best_practices": [
      "Use #[from] as the default pattern for automatic error conversion, reserving map_err for one-off conversions or when additional context is needed",
      "Create a unified error type for your application that can convert from all the error types you encounter",
      "Preserve the error chain by passing the error directly rather than converting to String, which loses source information"
    ],
    "anti_patterns": [
      "Converting errors to String with map_err(|e| MyError::Failed(e.to_string())) loses the error chain and source information",
      "Having multiple #[from] variants for the same source type causes compilation conflicts; use #[source] instead",
      "Using anyhow in library code forces a dependency on users; prefer thiserror for libraries"
    ],
    "faq": [
      {
        "question": "What is the difference between #[from] and #[source] in thiserror?",
        "answer": "#[from] generates a From implementation for automatic conversion. #[source] stores the error as the cause but does not generate From. Use #[from] when you want ? to work. Use #[source] when you need multiple variants for the same error type."
      },
      {
        "question": "How do I add context to an error during conversion?",
        "answer": "For one-off cases, use map_err with format!: .map_err(|e| MyError::Failed(format!(\"Operation failed: {}\", e))). For anyhow, use .context(\"Failed to load config\") instead."
      },
      {
        "question": "Can I implement From for types outside my crate?",
        "answer": "No, you can only implement From for types you own. For external types, use map_err or wrap the error in your own type with #[from] on that wrapper."
      },
      {
        "question": "How do I handle errors from multiple crates in one function?",
        "answer": "Create a unified error enum with #[from] on each variant that needs automatic conversion. Each source error type gets its own From implementation."
      },
      {
        "question": "Should I use Box<dyn Error> or a custom enum?",
        "answer": "Use a custom enum when you need to handle specific errors differently. Use Box<dyn Error> when you need flexibility or are writing a library that must accept any error type."
      },
      {
        "question": "What is the question mark operator (?) doing with errors?",
        "answer": "The ? operator calls Into::into on the error to convert it to the function's return type. This requires a From implementation. It also propagates the error early return."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 559
    }
  ]
}
