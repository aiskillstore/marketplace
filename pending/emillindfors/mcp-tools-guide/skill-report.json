{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:19:28.606Z",
    "slug": "emillindfors-mcp-tools-guide",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-mcp-server/skills/mcp-tools-guide",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "97a35864c9b94fb1c354bd181323e093d54638cc9d4194a45cd2ec647261fd1d",
    "tree_hash": "fdcfefcdab7a6eac229b9d5cf3337332d92b59a4050e3f90faf70ac2a8538013"
  },
  "skill": {
    "name": "MCP Tools Guide",
    "description": "Master creating MCP tools with type-safe parameters, automatic schema generation, and best practices using the rmcp crate",
    "summary": "Master creating MCP tools with type-safe parameters, automatic schema generation, and best practices",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "rust",
      "mcp",
      "tool-development",
      "codex",
      "claude-code"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Documentation-only skill. Static scanner flagged Rust code examples in markdown documentation as security patterns. All findings are false positives. The SKILL.md file contains educational code examples, not executable code with security implications. No actual external commands, network calls, or credential access patterns exist in this skill.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 698,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:19:28.606Z",
    "risk_factors": [],
    "risk_factor_evidence": []
  },
  "content": {
    "user_title": "Create type-safe MCP tools",
    "value_statement": "Creating MCP tools manually requires understanding complex macro systems and type constraints. This skill provides expert guidance on using the rmcp crate to build type-safe tools with automatic schema generation, validation, and async patterns.",
    "seo_keywords": [
      "Claude",
      "Codex",
      "Claude Code",
      "MCP tools",
      "Rust MCP",
      "rmcp crate",
      "tool development",
      "type-safe tools",
      "async Rust",
      "schema generation"
    ],
    "actual_capabilities": [
      "Design and implement MCP tools using the rmcp crate and #[tool] macro system",
      "Define type-safe parameters with support for simple types, options, arrays, enums, and complex objects",
      "Implement async tool methods with proper error handling using thiserror",
      "Create CRUD operations, validation services, API integrations, and stateful tool patterns",
      "Generate JSON schemas automatically and write comprehensive tests for tools"
    ],
    "limitations": [
      "This skill provides guidance only; it does not execute or generate actual Rust code",
      "Does not cover deploying or hosting MCP servers",
      "Does not provide pre-built MCP tools or libraries"
    ],
    "use_cases": [
      {
        "title": "Learn MCP tool fundamentals",
        "description": "New developers can understand the core concepts of MCP tools including the #[tool] macro system, parameter types, and tool invocation patterns through guided examples.",
        "target_user": "Rust developers new to MCP"
      },
      {
        "title": "Build production tools",
        "description": "Experienced developers can reference patterns for CRUD operations, validation, error handling, and performance optimization when building real MCP servers.",
        "target_user": "Experienced Rust developers"
      },
      {
        "title": "Design API integrations",
        "description": "Developers creating external API integrations can learn best practices for structuring services, handling credentials securely, and managing async operations.",
        "target_user": "API developers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic tool creation",
        "prompt": "Show me how to create a simple MCP tool that adds two numbers together using the rmcp crate. Include the tool_box declaration and async method.",
        "scenario": "Learning to create a basic MCP tool"
      },
      {
        "title": "Complex parameters",
        "prompt": "How do I define a tool that accepts a complex object with multiple fields? Show me how to use #[tool(aggr)] and derive the required traits.",
        "scenario": "Working with complex parameter types"
      },
      {
        "title": "Error handling",
        "prompt": "What is the best way to handle errors in MCP tools? Show me how to use thiserror to create custom error types that integrate with the tool result system.",
        "scenario": "Implementing proper error handling"
      },
      {
        "title": "Production patterns",
        "prompt": "Show me a complete CRUD implementation pattern for MCP tools. Include state management, validation, and proper async patterns.",
        "scenario": "Building production-ready tools"
      }
    ],
    "output_examples": [
      {
        "input": "How do I create an MCP tool with optional parameters?",
        "output": [
          "Use Option<T> for optional parameters in your tool methods:",
          "",
          "```rust",
          "#[tool(tool_box)]",
          "impl SearchService {",
          "    #[tool(description = \"Search with optional filters\")]",
          "    async fn search(",
          "        &self,",
          "        query: String,",
          "        limit: Option<u32>,",
          "        offset: Option<u32>,",
          "    ) -> Vec<String> {",
          "        let limit = limit.unwrap_or(10);",
          "        // Search logic",
          "        vec![]",
          "    }",
          "}",
          "```"
        ]
      },
      {
        "input": "What return types can MCP tools use?",
        "output": [
          "MCP tools support various return types:",
          "",
          "1. **Simple types**: i32, String, bool, etc.",
          "2. **Complex objects**: Structs deriving Serialize, Deserialize, JsonSchema",
          "3. **Collections**: Vec<T> for arrays",
          "4. **Result types**: Result<T, Error> for error handling",
          "",
          "Example Result return:",
          "```rust",
          "async fn fetch(&self, id: String) -> Result<String, ServiceError> {",
          "    // Return Ok or Err(ServiceError::NotFound)",
          "}",
          "```"
        ]
      }
    ],
    "best_practices": [
      "Use strong types for parameters rather than generic strings to enable compile-time validation and better AI understanding",
      "Provide clear, descriptive tool descriptions that explain when and how the AI should use the tool",
      "Implement proper error handling with actionable error messages that help the AI recover from failures"
    ],
    "anti_patterns": [
      "Avoid blocking operations in async tools; use tokio::fs and other async variants instead of std::fs",
      "Do not accept raw SQL or command strings as parameters without strict validation and sanitization",
      "Avoid tightly coupling tools to specific database implementations; abstract data access patterns"
    ],
    "faq": [
      {
        "question": "What is the rmcp crate?",
        "answer": "The rmcp crate is a Rust library for building MCP (Model Context Protocol) servers. It provides the #[tool] macro system for defining tools, automatic schema generation, and the infrastructure for communicating with MCP clients."
      },
      {
        "question": "Do I need to derive traits manually?",
        "answer": "Yes, for complex parameters you need to derive Deserialize, Serialize, and JsonSchema. The rmcp crate uses these for parameter parsing and automatic schema generation that AI assistants use to understand your tools."
      },
      {
        "question": "Can tools access environment variables?",
        "answer": "MCP tools can access environment variables through std::env, but this should be done carefully. Store sensitive values like API keys in the service struct during initialization rather than reading them on each call."
      },
      {
        "question": "How do I test MCP tools?",
        "answer": "Test MCP tools like any async Rust code using tokio::test. You can instantiate your service directly and call methods. For integration testing, consider testing the tool invocation flow through the list_tools and call_tool methods."
      },
      {
        "question": "What makes a good tool description?",
        "answer": "A good description explains what the tool does, what parameters it accepts, and when the AI should use it. Be specific about constraints and return values. Avoid vague language that could confuse the AI about when to invoke the tool."
      },
      {
        "question": "Can I use enums in tool parameters?",
        "answer": "Yes, enums work well for constrained choices. Define an enum with #[derive(Deserialize, Serialize, JsonSchema)] and use serde attributes like #[serde(rename_all = \"lowercase\")] for clean schema generation."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 698
    }
  ]
}
