{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:32:59.063Z",
    "slug": "emillindfors-rmcp-quickstart",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-mcp-server/skills/rmcp-quickstart",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "7db587ba32bc74d0ac59d31e0f654beb6e9e05a17bc551699a655bce826b2f97",
    "tree_hash": "eb566a6448a895c12a459686dc7811f5b1603c463da25109e213008e5f9d2394"
  },
  "skill": {
    "name": "RMCP Quickstart",
    "description": "Quick start guide for creating MCP servers with the rmcp crate - installation, concepts, and first server",
    "summary": "Quick start guide for building MCP servers in Rust using the rmcp SDK",
    "icon": "ðŸš€",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "tags": [
      "rust",
      "mcp",
      "model-context-protocol",
      "server",
      "sdk"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings are false positives. The scanner misidentified markdown code block backticks as Ruby/shell execution (52 locations). Documentation URLs and example code snippets are not actual network requests or command execution. No malicious patterns present. This is legitimate MCP documentation.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [
      {
        "title": "External Commands Pattern (False Positive)",
        "description": "Scanner detected backtick syntax in markdown code blocks as Ruby/shell backtick execution. All 52 locations are markdown documentation formatting (```toml, ```rust, `code`), not actual command execution.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 59,
            "line_end": 59
          },
          {
            "file": "SKILL.md",
            "line_start": 61,
            "line_end": 74
          },
          {
            "file": "SKILL.md",
            "line_start": 80,
            "line_end": 116
          },
          {
            "file": "SKILL.md",
            "line_start": 126,
            "line_end": 135
          },
          {
            "file": "SKILL.md",
            "line_start": 139,
            "line_end": 141
          },
          {
            "file": "SKILL.md",
            "line_start": 141,
            "line_end": 151
          },
          {
            "file": "SKILL.md",
            "line_start": 163,
            "line_end": 179
          },
          {
            "file": "SKILL.md",
            "line_start": 182,
            "line_end": 184
          },
          {
            "file": "SKILL.md",
            "line_start": 208,
            "line_end": 212
          },
          {
            "file": "SKILL.md",
            "line_start": 224,
            "line_end": 228
          },
          {
            "file": "SKILL.md",
            "line_start": 240,
            "line_end": 260
          },
          {
            "file": "SKILL.md",
            "line_start": 282,
            "line_end": 286
          },
          {
            "file": "SKILL.md",
            "line_start": 317,
            "line_end": 321
          },
          {
            "file": "SKILL.md",
            "line_start": 343,
            "line_end": 345
          },
          {
            "file": "SKILL.md",
            "line_start": 351,
            "line_end": 375
          },
          {
            "file": "SKILL.md",
            "line_start": 383,
            "line_end": 394
          },
          {
            "file": "SKILL.md",
            "line_start": 400,
            "line_end": 408
          },
          {
            "file": "SKILL.md",
            "line_start": 414,
            "line_end": 417
          },
          {
            "file": "SKILL.md",
            "line_start": 421,
            "line_end": 429
          },
          {
            "file": "SKILL.md",
            "line_start": 444,
            "line_end": 448
          },
          {
            "file": "SKILL.md",
            "line_start": 450,
            "line_end": 463
          },
          {
            "file": "SKILL.md",
            "line_start": 468,
            "line_end": 469
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "Markdown backticks for code formatting are not shell execution. No command injection vectors exist in documentation."
      },
      {
        "title": "Network Access Pattern (False Positive)",
        "description": "Scanner detected hardcoded URLs and fetch example as network access. URLs are documentation references. Fetch example is example code showing Result type, not actual network calls.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 52,
            "line_end": 52
          },
          {
            "file": "SKILL.md",
            "line_start": 53,
            "line_end": 53
          },
          {
            "file": "SKILL.md",
            "line_start": 366,
            "line_end": 366
          },
          {
            "file": "SKILL.md",
            "line_start": 491,
            "line_end": 491
          },
          {
            "file": "SKILL.md",
            "line_start": 492,
            "line_end": 492
          },
          {
            "file": "SKILL.md",
            "line_start": 493,
            "line_end": 493
          },
          {
            "file": "SKILL.md",
            "line_start": 494,
            "line_end": 494
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "Static documentation URLs and example code do not constitute network requests. No data exfiltration or network calls present."
      },
      {
        "title": "Weak Cryptographic Algorithm Pattern (False Positive)",
        "description": "Scanner misidentified Rust code patterns (serde derive macros, tool macros) as cryptographic algorithms. No cryptographic code exists in this documentation.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 2,
            "line_end": 2
          },
          {
            "file": "SKILL.md",
            "line_start": 82,
            "line_end": 82
          },
          {
            "file": "SKILL.md",
            "line_start": 92,
            "line_end": 92
          },
          {
            "file": "SKILL.md",
            "line_start": 97,
            "line_end": 97
          },
          {
            "file": "SKILL.md",
            "line_start": 144,
            "line_end": 145
          },
          {
            "file": "SKILL.md",
            "line_start": 155,
            "line_end": 155
          },
          {
            "file": "SKILL.md",
            "line_start": 202,
            "line_end": 202
          },
          {
            "file": "SKILL.md",
            "line_start": 272,
            "line_end": 272
          },
          {
            "file": "SKILL.md",
            "line_start": 277,
            "line_end": 277
          },
          {
            "file": "SKILL.md",
            "line_start": 305,
            "line_end": 305
          },
          {
            "file": "SKILL.md",
            "line_start": 312,
            "line_end": 312
          },
          {
            "file": "SKILL.md",
            "line_start": 323,
            "line_end": 325
          },
          {
            "file": "SKILL.md",
            "line_start": 337,
            "line_end": 337
          },
          {
            "file": "SKILL.md",
            "line_start": 365,
            "line_end": 365
          },
          {
            "file": "SKILL.md",
            "line_start": 468,
            "line_end": 468
          },
          {
            "file": "SKILL.md",
            "line_start": 472,
            "line_end": 472
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.98,
        "confidence_reasoning": "Rust derive macros (Serialize, Deserialize) and custom tool macros are not cryptographic algorithms. No crypto implementations detected."
      },
      {
        "title": "System Reconnaissance Pattern (False Positive)",
        "description": "Scanner flagged technical terms (SSE Transport, async operations) as reconnaissance. These are legitimate MCP protocol concepts with no scanning behavior.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 216,
            "line_end": 216
          },
          {
            "file": "SKILL.md",
            "line_start": 359,
            "line_end": 359
          },
          {
            "file": "SKILL.md",
            "line_start": 525,
            "line_end": 525
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "SSE (Server-Sent Events) and async patterns are standard transport mechanisms. No system or network scanning behavior present."
      }
    ],
    "files_scanned": 1,
    "total_lines": 526,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:32:59.063Z"
  },
  "content": {
    "user_title": "Build MCP Servers with rmcp",
    "value_statement": "Creating MCP servers requires understanding a complex protocol with multiple transport options and tool patterns. This skill provides a quick start guide with clear Rust code examples, transport configurations, and testing strategies for building production-ready MCP servers.",
    "seo_keywords": [
      "Claude",
      "Codex",
      "Claude Code",
      "MCP",
      "Model Context Protocol",
      "Rust",
      "rmcp",
      "server",
      "SDK",
      "tokio"
    ],
    "actual_capabilities": [
      "Explain MCP fundamentals including tools, resources, and prompts",
      "Guide rmcp crate installation and dependency configuration",
      "Provide working MCP server examples with stdio, SSE, and HTTP transports",
      "Show proper tool macro usage with descriptions and parameter handling",
      "Demonstrate testing strategies for unit and integration tests",
      "Help debug common MCP server issues and errors"
    ],
    "limitations": [
      "Does not provide pre-built MCP server binaries",
      "Does not handle deployment or production infrastructure",
      "Does not include authentication or authorization patterns",
      "Focuses on Rust implementation; other languages not covered"
    ],
    "use_cases": [
      {
        "title": "Build Your First MCP Server",
        "description": "New to MCP? Get step-by-step guidance from project setup to running your first server with working tools and proper error handling.",
        "target_user": "Rust developers new to MCP"
      },
      {
        "title": "Add Advanced Tool Patterns",
        "description": "Learn to create stateful services with async tools, complex parameter types, and proper error handling for production MCP servers.",
        "target_user": "Developers building production MCP servers"
      },
      {
        "title": "Choose and Configure Transports",
        "description": "Understand the differences between stdio, SSE, and HTTP transports. Get guidance on when to use each based on your deployment needs.",
        "target_user": "Engineers designing MCP server architecture"
      }
    ],
    "prompt_templates": [
      {
        "title": "Getting Started",
        "prompt": "I want to build an MCP server in Rust using the rmcp crate. Help me understand the basics: what is MCP, what are the key components, and walk me through creating a simple server with a greeting tool.",
        "scenario": "Learning MCP fundamentals and creating a first server"
      },
      {
        "title": "Adding Tools",
        "prompt": "I have a basic rmcp server working. Now I want to add more tools with complex parameters including optional fields and nested objects. Show me the proper pattern for using #[tool(aggr)] and implementing error handling.",
        "scenario": "Extending MCP servers with advanced tools"
      },
      {
        "title": "Transport Selection",
        "prompt": "I need to deploy my MCP server for cloud use. Explain the differences between SSE and HTTP transports, show code examples for each, and help me choose the right option for a multi-user production environment.",
        "scenario": "Selecting and implementing production transports"
      },
      {
        "title": "Testing and Debugging",
        "prompt": "My MCP server tools are not showing up in Claude. Walk me through debugging: check my #[tool] macro usage, verify tool_box placement, and help me write integration tests to validate my server is working correctly.",
        "scenario": "Debugging MCP server issues"
      }
    ],
    "output_examples": [
      {
        "input": "Help me create my first rmcp server",
        "output": [
          "I'll guide you through building your first MCP server with rmcp. Let's start:",
          "",
          "1. Create a new Rust project",
          "2. Add rmcp dependencies to Cargo.toml",
          "3. Define your service struct with the #[tool] macro",
          "4. Create a stdio transport",
          "5. Run and test your server",
          "",
          "Here's the basic pattern:",
          "```rust",
          "#[tool(tool_box)]",
          "struct MyService;",
          "",
          "#[tool(tool_box)]",
          "impl MyService {",
          "    #[tool(description = \"Say hello\")]",
          "    async fn greet(&self, name: String) -> String {",
          "        format!(\"Hello, {}!\", name)",
          "    }",
          "}",
          "",
          "#[tokio::main]",
          "async fn main() -> Result<(), Box<dyn std::error::Error>> {",
          "    let service = MyService;",
          "    let transport = stdio_transport();",
          "    service.serve(transport).await?;",
          "    Ok(())",
          "}",
          "```"
        ]
      },
      {
        "input": "How do I handle errors in rmcp?",
        "output": [
          "Use thiserror to define error types, then return Result from your tools:",
          "",
          "```rust",
          "use thiserror::Error;",
          "",
          "#[derive(Debug, Error)]",
          "enum MyError {",
          "    #[error(\"Not found: {0}\")]",
          "    NotFound(String),",
          "",
          "    #[error(\"Invalid input: {0}\")]",
          "    InvalidInput(String),",
          "}",
          "",
          "#[tool(tool_box)]",
          "impl MyService {",
          "    async fn fetch(&self, id: String) -> Result<String, MyError> {",
          "        if id.is_empty() {",
          "            return Err(MyError::InvalidInput(\"ID cannot be empty\".into()));",
          "        }",
          "        Ok(\"Item data\".to_string())",
          "    }",
          "}",
          "```"
        ]
      }
    ],
    "best_practices": [
      "Always include clear descriptions on #[tool] macros so AI assistants understand what each tool does",
      "Make tool functions async and use proper tokio runtime configuration in main",
      "Test servers locally with stdio transport before deploying to cloud transports"
    ],
    "anti_patterns": [
      "Missing #[tool(description = \"...\")] on tool functions causes tools to be invisible to AI assistants",
      "Non-async tool functions will fail at runtime; all tools must be async",
      "Using complex parameters without #[tool(aggr)] causes deserialization errors"
    ],
    "faq": [
      {
        "question": "What is the rmcp crate?",
        "answer": "rmcp is the official Rust SDK for the Model Context Protocol. It provides macros and types for building MCP servers that AI assistants like Claude can connect to and use tools from."
      },
      {
        "question": "What transport should I use?",
        "answer": "Use stdio for local development and testing. Use SSE for cloud deployments requiring server-sent events. Use HTTP transport for REST-like interfaces and load balancer compatibility."
      },
      {
        "question": "How do I debug tools not showing up?",
        "answer": "Check that #[tool(description = \"...\")] is present on each function, #[tool(tool_box)] is on the impl block, and functions are async. Use cargo test to verify your service works."
      },
      {
        "question": "What Rust version do I need?",
        "answer": "rmcp requires Rust 1.75 or higher. Use edition = \"2024\" in your Cargo.toml for the latest features."
      },
      {
        "question": "Can I use rmcp with other async runtimes?",
        "answer": "rmcp is built on tokio. Other runtimes like async-std are not supported. Use tokio with features = [\"full\"] for complete async support."
      },
      {
        "question": "How do I test my MCP server?",
        "answer": "Write unit tests with #[cfg(test)] modules. Create integration tests that import your service, call tool methods directly, and verify results. Use stdio_transport for local testing."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 526
    }
  ]
}
