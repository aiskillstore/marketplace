{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:24:17.699Z",
    "slug": "emillindfors-mock-strategy-guide",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-testing/skills/mock-strategy-guide",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "cb5ffb6f54c200d3314019c3e2d87807815bb9d4b70423d9b867b5381db60601",
    "tree_hash": "1fee624371f0c61ce80128ca0026b75b45f060b101f888471ad6325051c4e314"
  },
  "skill": {
    "name": "mock-strategy-guide",
    "description": "Guides users on creating mock implementations for testing with traits, providing test doubles, and avoiding tight coupling to test infrastructure. Activates when users need to test code with external dependencies.",
    "summary": "Teaches Rust testing patterns for mock implementations using traits, test doubles, and hexagonal architecture principles.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "tags": [
      "rust",
      "testing",
      "mocking",
      "tdd",
      "test-doubles"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All 14 static findings are false positives. Scanner misidentified YAML frontmatter delimiters as obfuscation patterns, Rust code blocks as shell commands, and skill description text as cryptographic code. This is a legitimate testing guide containing only educational Rust code examples with no execution capabilities.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 331,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:24:17.699Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Create Mock Implementations for Rust Tests",
    "value_statement": "Testing code with external dependencies is challenging. This skill provides patterns for creating mock implementations using traits, enabling reliable unit tests without real infrastructure.",
    "seo_keywords": [
      "Rust mock testing",
      "Rust test doubles",
      "Rust trait mocking",
      "Rust unit testing patterns",
      "Rust TDD guide",
      "Rust hexagonal architecture testing",
      "Rust integration testing",
      "Claude Code testing skill",
      "Claude Code mock strategy",
      "Claude Codex testing patterns"
    ],
    "actual_capabilities": [
      "Identifies code with external dependencies that needs mocking",
      "Creates mock implementations following Rust trait patterns",
      "Shows verification patterns to confirm mock behavior",
      "Demonstrates controlled failure testing with error scenarios",
      "Provides builder patterns for flexible mock configuration",
      "Creates in-memory test implementations for integration testing"
    ],
    "limitations": [
      "Focuses on Rust testing patterns only, not other languages",
      "Does not generate complete test suites automatically",
      "Does not integrate with specific mocking crates like mockall",
      "Does not provide runtime test execution or reporting"
    ],
    "use_cases": [
      {
        "title": "Test Services with Database Dependencies",
        "description": "Create mock repository implementations to test business logic without setting up a real database. Verify that your service layer handles data retrieval, persistence, and error cases correctly.",
        "target_user": "Rust backend developers building database-driven applications"
      },
      {
        "title": "Verify External API Interactions",
        "description": "Build mock HTTP clients or email services to test code that makes external calls. Verify that your application sends correct requests and handles responses or failures appropriately.",
        "target_user": "API developers integrating with third-party services"
      },
      {
        "title": "Test Error Handling Paths",
        "description": "Create mocks that return specific errors like not found or connection failures. Test that your application handles these edge cases gracefully and provides proper error messages.",
        "target_user": "QA engineers and developers focused on error resilience"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Mock Request",
        "prompt": "I need to test my Rust service that uses a database. Show me how to create a mock repository implementation for the UserRepository trait.",
        "scenario": "User needs a simple mock for a repository trait"
      },
      {
        "title": "Mock with Behavior Control",
        "prompt": "My service needs to handle different error scenarios. Create a mock that I can configure to return success, not found, or database errors.",
        "scenario": "User needs to test multiple error paths"
      },
      {
        "title": "Builder Pattern for Mocks",
        "prompt": "I want to build mocks with different configurations in my tests. Show me a builder pattern that lets me set up users, errors, and other state before running tests.",
        "scenario": "User needs flexible mock setup for complex tests"
      },
      {
        "title": "Verification Pattern",
        "prompt": "I need to verify that my service called external dependencies correctly. Create a mock that tracks method calls and lets me assert on them after the test.",
        "scenario": "User needs to verify interaction with mocked dependencies"
      }
    ],
    "output_examples": [
      {
        "input": "How do I mock a UserRepository trait for testing?",
        "output": [
          "Here is a pattern for creating a mock repository:",
          "",
          "1. Create a struct to hold test data",
          "2. Implement the trait for your mock struct",
          "3. Use the builder pattern for flexibility",
          "",
          "Key elements:",
          "- Use HashMap to store test data in memory",
          "- Return errors for missing keys",
          "- Chain methods to configure mock state"
        ]
      },
      {
        "input": "How can I test error handling with my service?",
        "output": [
          "Create an enum to control mock behavior:",
          "",
          "```rust",
          "enum MockBehavior {",
          "    Success,",
          "    NotFound,",
          "    DatabaseError,",
          "}",
          "```",
          "",
          "Then configure your mock with the desired behavior and verify your service handles each case correctly."
        ]
      }
    ],
    "best_practices": [
      "Use traits to define dependencies, enabling mock implementations without coupling to concrete types",
      "Keep mocks simple and focused on the behavior you need to test, not full feature parity",
      "Create verification methods to assert that your code interacted with mocks as expected"
    ],
    "anti_patterns": [
      "Avoid tight coupling to specific mock implementations in your production code",
      "Do not make tests depend on real infrastructure, as this makes tests slow and flaky",
      "Avoid over-mocking; focus on boundaries where external dependencies enter your system"
    ],
    "faq": [
      {
        "question": "Should I use a mocking crate instead of manual mocks?",
        "answer": "Crates like mockall provide convenient auto-mocking capabilities. Manual mocks give you more control and are useful for learning patterns. Use whichever fits your project needs."
      },
      {
        "question": "How is this different from integration tests?",
        "answer": "Unit tests with mocks isolate your code from dependencies. Integration tests use real components. Both have valueâ€”mocks for fast feedback, integration tests for confidence."
      },
      {
        "question": "Can I use these patterns with async Rust?",
        "answer": "Yes. The patterns shown work with async traits using the async-trait crate. Simply make your mock methods async like the real implementation."
      },
      {
        "question": "How do I handle trait methods that borrow data?",
        "answer": "Adjust your mock to clone data when needed. For tests, taking ownership is often simpler than managing lifetimes across async boundaries."
      },
      {
        "question": "What is the difference between mocks and stubs?",
        "answer": "Mocks verify behavior by tracking interactions. Stubs just provide predefined responses. The patterns here support bothâ€”you can add verification or keep it simple."
      },
      {
        "question": "How do I share mocks across multiple tests?",
        "answer": "Create a fixtures module with helper functions. These can return pre-configured mocks or build them on demand for each test."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 331
    }
  ]
}
