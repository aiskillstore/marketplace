{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:15:33.598Z",
    "slug": "emillindfors-mcp-best-practices",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-mcp-server/skills/mcp-best-practices",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "3af06c2424ac6389f145d0394d663894457e720cdece0aeead594f1f5329ac78",
    "tree_hash": "afbdfe6185251bbeba8d8813e9f4f22fadbe0a9403c5f84b1b2fc18f2778070a"
  },
  "skill": {
    "name": "MCP Best Practices",
    "description": "Production-ready patterns and best practices for MCP servers - architecture, security, performance, and maintenance",
    "summary": "Expert guidance for building secure, performant, and maintainable MCP servers in Rust",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "tags": [
      "mcp",
      "rust",
      "protocol",
      "best-practices",
      "server-development"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "external_commands",
      "network",
      "env_access"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Documentation-only skill containing Rust code examples for MCP server best practices. Static scanner flagged pattern-based false positives triggered by code block syntax and legitimate security-related keywords. All findings evaluated as false positives - this is educational content, not executable code with security implications.",
    "risk_factor_evidence": [
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 511,
            "line_end": 511
          },
          {
            "file": "SKILL.md",
            "line_start": 532,
            "line_end": 532
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 23,
            "line_end": 58
          },
          {
            "file": "SKILL.md",
            "line_start": 58,
            "line_end": 62
          },
          {
            "file": "SKILL.md",
            "line_start": 62,
            "line_end": 112
          },
          {
            "file": "SKILL.md",
            "line_start": 112,
            "line_end": 116
          },
          {
            "file": "SKILL.md",
            "line_start": 116,
            "line_end": 157
          },
          {
            "file": "SKILL.md",
            "line_start": 157,
            "line_end": 163
          },
          {
            "file": "SKILL.md",
            "line_start": 163,
            "line_end": 214
          },
          {
            "file": "SKILL.md",
            "line_start": 214,
            "line_end": 218
          },
          {
            "file": "SKILL.md",
            "line_start": 218,
            "line_end": 250
          },
          {
            "file": "SKILL.md",
            "line_start": 250,
            "line_end": 256
          },
          {
            "file": "SKILL.md",
            "line_start": 256,
            "line_end": 312
          },
          {
            "file": "SKILL.md",
            "line_start": 312,
            "line_end": 316
          },
          {
            "file": "SKILL.md",
            "line_start": 316,
            "line_end": 373
          },
          {
            "file": "SKILL.md",
            "line_start": 373,
            "line_end": 377
          },
          {
            "file": "SKILL.md",
            "line_start": 377,
            "line_end": 394
          },
          {
            "file": "SKILL.md",
            "line_start": 394,
            "line_end": 400
          },
          {
            "file": "SKILL.md",
            "line_start": 400,
            "line_end": 413
          },
          {
            "file": "SKILL.md",
            "line_start": 413,
            "line_end": 417
          },
          {
            "file": "SKILL.md",
            "line_start": 417,
            "line_end": 451
          },
          {
            "file": "SKILL.md",
            "line_start": 451,
            "line_end": 455
          },
          {
            "file": "SKILL.md",
            "line_start": 455,
            "line_end": 482
          },
          {
            "file": "SKILL.md",
            "line_start": 482,
            "line_end": 488
          },
          {
            "file": "SKILL.md",
            "line_start": 488,
            "line_end": 543
          },
          {
            "file": "SKILL.md",
            "line_start": 543,
            "line_end": 547
          },
          {
            "file": "SKILL.md",
            "line_start": 547,
            "line_end": 581
          },
          {
            "file": "SKILL.md",
            "line_start": 581,
            "line_end": 587
          },
          {
            "file": "SKILL.md",
            "line_start": 587,
            "line_end": 609
          },
          {
            "file": "SKILL.md",
            "line_start": 609,
            "line_end": 613
          },
          {
            "file": "SKILL.md",
            "line_start": 613,
            "line_end": 639
          },
          {
            "file": "SKILL.md",
            "line_start": 639,
            "line_end": 643
          },
          {
            "file": "SKILL.md",
            "line_start": 643,
            "line_end": 672
          }
        ]
      },
      {
        "factor": "network",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 71,
            "line_end": 71
          },
          {
            "file": "SKILL.md",
            "line_start": 89,
            "line_end": 89
          },
          {
            "file": "SKILL.md",
            "line_start": 476,
            "line_end": 476
          },
          {
            "file": "SKILL.md",
            "line_start": 631,
            "line_end": 631
          }
        ]
      },
      {
        "factor": "env_access",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 409,
            "line_end": 409
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 722,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:15:33.598Z"
  },
  "content": {
    "user_title": "Build production-ready MCP servers",
    "value_statement": "Building MCP servers for production requires careful attention to architecture, security, and performance. This skill provides expert guidance on proven patterns for creating maintainable and secure MCP server implementations.",
    "seo_keywords": [
      "MCP server",
      "Model Context Protocol",
      "Rust MCP",
      "Claude",
      "Codex",
      "Claude Code",
      "server architecture",
      "best practices",
      "protocol server",
      "MCP development"
    ],
    "actual_capabilities": [
      "Provide architecture patterns for MCP server implementation including layered and hexagonal architectures",
      "Guide on security best practices such as input validation, authentication, and SQL injection prevention",
      "Recommend performance optimization techniques including connection pooling and caching strategies",
      "Explain error handling patterns and comprehensive error type design for production systems",
      "Detail testing strategies including unit testing with mocks and integration testing with containers",
      "Cover observability practices including structured logging, metrics, and monitoring setup"
    ],
    "limitations": [
      "Does not provide executable code or implementation templates",
      "Focuses on Rust implementations - patterns may need adaptation for other languages",
      "Does not cover specific transport layer implementations beyond architectural guidance",
      "Does not include deployment or infrastructure configuration examples"
    ],
    "use_cases": [
      {
        "title": "Design new MCP server architecture",
        "description": "Architects designing a new MCP server can use this skill to select appropriate patterns, understand trade-offs between layered and hexagonal approaches, and establish a maintainable code organization structure.",
        "target_user": "Software architects designing MCP server implementations"
      },
      {
        "title": "Review MCP server security posture",
        "description": "Security engineers can use this skill to evaluate existing MCP server implementations against established security patterns, identify gaps in authentication, authorization, and input validation implementations.",
        "target_user": "Security engineers conducting code reviews"
      },
      {
        "title": "Optimize MCP server performance",
        "description": "Backend developers can use this skill to identify performance bottlenecks in their MCP server implementations, apply connection pooling, caching strategies, and async best practices for improved throughput.",
        "target_user": "Backend developers optimizing production systems"
      }
    ],
    "prompt_templates": [
      {
        "title": "Getting started with architecture",
        "prompt": "I am building an MCP server in Rust. What are the recommended architecture patterns for organizing the codebase? Should I use a layered architecture or hexagonal architecture? What are the trade-offs between these approaches?",
        "scenario": "When a developer needs initial guidance on structuring their MCP server project"
      },
      {
        "title": "Implementing authentication",
        "prompt": "How should I implement authentication and authorization in my MCP server? What are the best practices for handling auth tokens, validating permissions, and protecting sensitive endpoints? Show me example code patterns.",
        "scenario": "When a developer needs guidance on implementing security features"
      },
      {
        "title": "Error handling design",
        "prompt": "What error handling patterns do you recommend for production MCP servers? How should I structure error types, handle different error categories, and provide meaningful error messages to clients?",
        "scenario": "When designing error handling strategies for reliability"
      },
      {
        "title": "Performance optimization",
        "prompt": "What performance optimizations should I implement in my MCP server? Include guidance on database connection pooling, caching strategies, async operation patterns, and handling external service calls efficiently.",
        "scenario": "When optimizing for production performance and scalability"
      }
    ],
    "output_examples": [
      {
        "input": "What error types should I define for my MCP server?",
        "output": [
          "A production-ready MCP server should define a comprehensive error enum that covers all failure scenarios.",
          "Key error categories include:",
          "  - NotFound: Resource does not exist",
          "  - InvalidInput: User provided invalid data",
          "  - PermissionDenied: User lacks required permissions",
          "  - RateLimitExceeded: Client exceeded rate limits",
          "  - ExternalServiceError: Dependency service failed",
          "  - DatabaseError: Database operation failed",
          "  - Internal: Unexpected internal error",
          "Each error should implement the standard Error trait, provide user-friendly messages, and include retryability information."
        ]
      },
      {
        "input": "How do I prevent SQL injection in my MCP server?",
        "output": [
          "Always use parameterized queries instead of string concatenation.",
          "Good pattern (Rust with sqlx):",
          "```rust",
          "sqlx::query_as!(User, \"SELECT * FROM users WHERE id = $1\", id)",
          "    .fetch_optional(&self.pool)",
          "    .await",
          "```",
          "Bad pattern (vulnerable):",
          "```rust",
          "let query = format!(\"SELECT * FROM users WHERE id = '{}'\", id);",
          "```",
          "The parameterized approach ensures user input is never interpreted as SQL code."
        ]
      }
    ],
    "best_practices": [
      "Use parameterized queries for all database operations to prevent SQL injection attacks",
      "Implement comprehensive input validation at service boundaries using validation libraries",
      "Design error types that provide actionable information while avoiding information leakage in production",
      "Apply connection pooling for database connections and implement caching for frequently accessed data"
    ],
    "anti_patterns": [
      "Avoid string concatenation for building SQL queries - always use parameterized queries",
      "Do not expose internal error details to clients in production - log internally but return generic errors",
      "Avoid blocking async operations with synchronous calls - use proper async patterns throughout",
      "Do not skip authentication or authorization checks on any endpoint - apply consistent security across all operations"
    ],
    "faq": [
      {
        "question": "What architecture pattern should I use for my MCP server?",
        "answer": "For most MCP servers, hexagonal architecture (ports and adapters) provides the best flexibility. It separates core business logic from external dependencies, making it easy to test and swap implementations. Layered architecture works for simpler applications with fewer external integrations."
      },
      {
        "question": "How should I handle authentication in my MCP server?",
        "answer": "Use JWT tokens with appropriate validation. Decode tokens using a secret key, validate expiration, and check user roles for authorization. Implement a context object that wraps token claims and provides helper methods for permission checks."
      },
      {
        "question": "What testing strategies work best for MCP servers?",
        "answer": "Use unit tests with mock dependencies (like mockall in Rust) for testing business logic in isolation. Use integration tests with test containers for testing database interactions. Aim for fast unit tests for development and slower integration tests for critical paths."
      },
      {
        "question": "How do I implement proper error handling?",
        "answer": "Define an enum that covers all error cases, implement the Error trait with Display for user messages, add error codes for categorization, and include a method to determine if an error is retryable for resilience patterns."
      },
      {
        "question": "What performance optimizations should I prioritize?",
        "answer": "Start with connection pooling for databases, implement caching for frequently accessed data, use concurrent operations with try_join_all for batch fetches, and add timeouts for all external service calls to prevent resource exhaustion."
      },
      {
        "question": "How do I make my MCP server observable?",
        "answer": "Use structured logging with contextual information (like user IDs in log fields), implement metrics with counters and histograms for request tracking, and add tracing spans for performance profiling in production environments."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 722
    }
  ]
}
