{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:21:47.221Z",
    "slug": "emillindfors-mcp-transport-guide",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-mcp-server/skills/mcp-transport-guide",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "c756f310889843fe79d166d3392e8e35d3d78c9b7d6caeab5f19a90a8f95b4b1",
    "tree_hash": "57647ef2fe9885e083c1e5c600dd270454ee5be2ae8bb7dbe117944accd0be2f"
  },
  "skill": {
    "name": "Package as binary",
    "description": "Understand MCP transport mechanisms - stdio, SSE, HTTP streaming, and custom transports",
    "summary": "Understand MCP transport mechanisms - stdio, SSE, HTTP streaming, and custom transports",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "tags": [
      "MCP",
      "transport",
      "Rust",
      "stdio",
      "SSE",
      "HTTP"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [],
    "category": "coding"
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a documentation-only skill providing educational guidance on MCP transport mechanisms. Static scanner detected code examples and documentation patterns, but these are all false positives. No executable code, no user input processing, no command execution, and no credential access at runtime. The skill consists entirely of informational content about stdio, SSE, and HTTP transports for developers implementing MCP servers.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 616,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:21:47.221Z"
  },
  "content": {
    "user_title": "MCP Transport Guide",
    "value_statement": "Developers building MCP servers need clear guidance on transport layer options. This skill explains stdio, SSE, and HTTP transports with implementation examples, security best practices, and deployment scenarios for different use cases.",
    "seo_keywords": [
      "MCP transport",
      "MCP stdio transport",
      "MCP SSE transport",
      "MCP HTTP transport",
      "Model Context Protocol",
      "Claude MCP server",
      "Rust MCP transport",
      "MCP implementation",
      "MCP deployment",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Explain MCP transport types and their characteristics",
      "Provide implementation examples for stdio, SSE, and HTTP transports",
      "Guide transport selection based on deployment scenario",
      "Show security configurations including TLS and authentication",
      "Demonstrate testing approaches for transport layers",
      "Outline production deployment patterns for containers and Kubernetes"
    ],
    "limitations": [
      "Does not execute code or modify any files",
      "Does not connect to external services or APIs",
      "Does not provide pre-built binaries or containers",
      "Does not handle credentials or authentication tokens"
    ],
    "use_cases": [
      {
        "title": "Building a Local MCP Server",
        "description": "A developer creating an MCP server for Claude Desktop needs guidance on stdio transport implementation and subprocess communication patterns.",
        "target_user": "MCP server developers"
      },
      {
        "title": "Deploying MCP to the Cloud",
        "description": "An engineer moving an MCP server from local development to production needs to understand SSE or HTTP transport options with proper security configuration.",
        "target_user": "DevOps engineers"
      },
      {
        "title": "Choosing the Right Transport",
        "description": "A technical architect evaluating transport options for a new MCP integration needs to understand trade-offs between stdio, SSE, and HTTP for different deployment scenarios.",
        "target_user": "Technical architects"
      }
    ],
    "prompt_templates": [
      {
        "title": "Getting Started with MCP Transport",
        "prompt": "I want to build an MCP server. What transport type should I use for [deployment scenario] and how do I implement it in Rust?",
        "scenario": "Beginner asking about transport selection"
      },
      {
        "title": "Implementing SSE Transport",
        "prompt": "Show me how to implement an SSE transport for my MCP server that will run in a cloud environment. Include TLS configuration and authentication.",
        "scenario": "Developer implementing SSE transport"
      },
      {
        "title": "Adding Security to HTTP Transport",
        "prompt": "My MCP server currently uses HTTP transport. Help me add proper security including TLS certificates, Bearer token authentication, and rate limiting.",
        "scenario": "Developer adding security to existing transport"
      },
      {
        "title": "Testing Transport Layer",
        "prompt": "Write unit tests for my [stdio/HTTP/SSE] MCP transport. Include test cases for message serialization, error handling, and connection lifecycle.",
        "scenario": "Developer writing tests for transport"
      }
    ],
    "output_examples": [
      {
        "input": "What transport should I use for Claude Desktop integration?",
        "output": [
          "For Claude Desktop integration, use stdio transport.",
          "",
          "stdio transport is ideal because:",
          "- Native integration with Claude Desktop subprocess model",
          "- Simple setup with stdin/stdout communication",
          "- No network exposure needed",
          "- Low latency for local communication",
          "",
          "Implementation uses `stdio_transport()` from the rmcp crate. Logs should go to stderr to avoid interfering with JSON-RPC messages on stdout."
        ]
      },
      {
        "input": "How do I secure my HTTP MCP server for production deployment?",
        "output": [
          "For production HTTP MCP servers, implement these security measures:",
          "",
          "1. TLS with Rustls:",
          "- Use axum_server with RustlsConfig from PEM files",
          "- Configure certificates and private key paths",
          "",
          "2. Authentication:",
          "- Implement Bearer token validation",
          "- Reject requests without valid authorization header",
          "",
          "3. Rate Limiting:",
          "- Use tower_governor for request throttling",
          "- Configure requests per second and burst size",
          "",
          "4. CORS:",
          "- Configure allowed origins, methods, and headers",
          "- Use tower_http CORS layer"
        ]
      }
    ],
    "best_practices": [
      "Match transport type to deployment scenario: stdio for local subprocess, SSE/HTTP for cloud and remote access",
      "Always use TLS for network transports in production - stdio is inherently secure without additional measures",
      "Log to the correct stream: stderr for stdio transport (stdout carries JSON-RPC messages)"
    ],
    "anti_patterns": [
      "Using stdout for logging in stdio transport - this corrupts JSON-RPC message stream",
      "Deploying HTTP transport without TLS in production - exposes credentials and data in clear text",
      "Skipping authentication on network transports - allows unauthorized access to MCP server capabilities"
    ],
    "faq": [
      {
        "question": "What is the difference between SSE and HTTP transport?",
        "answer": "SSE (Server-Sent Events) is designed for server-to-client streaming where the server pushes updates. HTTP transport uses standard request-response patterns. SSE is better for real-time updates while HTTP is more compatible with standard web infrastructure like load balancers and API gateways."
      },
      {
        "question": "Can I use stdio transport in a containerized environment?",
        "answer": "stdio transport works in containers but requires wrapping the MCP server in an entrypoint script that handles process management. For container deployments, HTTP or SSE transport is typically preferred since they work naturally with container networking."
      },
      {
        "question": "How do I handle authentication in MCP transport?",
        "answer": "For HTTP/SSE transports, implement authentication as middleware. Common approaches include Bearer token validation, JWT verification, or API key checking. The skill shows examples using axum middleware to check the Authorization header before processing MCP requests."
      },
      {
        "question": "What rate limiting should I configure for my MCP server?",
        "answer": "For production deployments, start with 10 requests per second per client with a burst size of 50. Adjust based on your server capacity and expected usage patterns. Use tower_governor for easy rate limiting configuration in Rust axum servers."
      },
      {
        "question": "How do I test MCP transport implementations?",
        "answer": "For stdio transport, create mock stdin/stdout using tokio::io::duplex and send test JSON-RPC messages. For HTTP transport, use reqwest to send test requests to localhost. Test message serialization, error handling, and connection lifecycle separately from business logic."
      },
      {
        "question": "What monitoring should I add to MCP transport?",
        "answer": "Add metrics for request count, duration histograms, and error rates. Use tracing for structured logging with request context. The skill includes examples using prometheus metrics and tracing instrumentation for observability."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 616
    }
  ]
}
