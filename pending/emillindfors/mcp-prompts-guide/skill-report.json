{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:16:53.590Z",
    "slug": "emillindfors-mcp-prompts-guide",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-mcp-server/skills/mcp-prompts-guide",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "29caba8f0052d0c2309fe79912fd72634974bb7b2dc62dea6f816e36c778fef5",
    "tree_hash": "f2306d05b8c0f39a23a193844aebeef3839e03fd4251d82825971b16d44cc2c5"
  },
  "skill": {
    "name": "MCP Prompts Guide",
    "description": "Create powerful MCP prompts that guide AI interactions with templates, arguments, and context injection",
    "summary": "Create MCP prompts for AI interaction guidance using the rmcp crate",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "tags": [
      "mcp",
      "prompt-engineering",
      "rust",
      "templates",
      "context-injection"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Static analysis flagged 23 external_commands patterns and 28 weak_crypto patterns. Evaluation reveals all are FALSE POSITIVES. The scanner misidentified Rust string formatting (format!) as shell backticks and string operations (to_string, unwrap) as cryptographic functions. This is documentation containing example Rust code for creating MCP prompts. No actual command execution, network access, file system operations, or cryptographic code exists.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": []
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [
      {
        "title": "False Positive: Rust format! Macro Misidentified as Shell Backticks",
        "description": "Scanner detected 'Ruby/shell backtick execution' at 23 locations in SKILL.md (lines 33-501). These are Rust format! macro calls creating strings, not shell commands. Example: format!(\"Generate a {} {}\", language, component). No backticks or shell execution exists.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 33,
            "line_end": 97
          },
          {
            "file": "SKILL.md",
            "line_start": 97,
            "line_end": 103
          },
          {
            "file": "SKILL.md",
            "line_start": 103,
            "line_end": 139
          },
          {
            "file": "SKILL.md",
            "line_start": 139,
            "line_end": 143
          },
          {
            "file": "SKILL.md",
            "line_start": 143,
            "line_end": 177
          },
          {
            "file": "SKILL.md",
            "line_start": 177,
            "line_end": 181
          },
          {
            "file": "SKILL.md",
            "line_start": 181,
            "line_end": 216
          },
          {
            "file": "SKILL.md",
            "line_start": 216,
            "line_end": 220
          },
          {
            "file": "SKILL.md",
            "line_start": 220,
            "line_end": 260
          },
          {
            "file": "SKILL.md",
            "line_start": 260,
            "line_end": 266
          },
          {
            "file": "SKILL.md",
            "line_start": 266,
            "line_end": 293
          },
          {
            "file": "SKILL.md",
            "line_start": 293,
            "line_end": 297
          },
          {
            "file": "SKILL.md",
            "line_start": 297,
            "line_end": 333
          },
          {
            "file": "SKILL.md",
            "line_start": 333,
            "line_end": 337
          },
          {
            "file": "SKILL.md",
            "line_start": 337,
            "line_end": 371
          },
          {
            "file": "SKILL.md",
            "line_start": 371,
            "line_end": 377
          },
          {
            "file": "SKILL.md",
            "line_start": 377,
            "line_end": 408
          },
          {
            "file": "SKILL.md",
            "line_start": 408,
            "line_end": 412
          },
          {
            "file": "SKILL.md",
            "line_start": 412,
            "line_end": 436
          },
          {
            "file": "SKILL.md",
            "line_start": 436,
            "line_end": 453
          },
          {
            "file": "SKILL.md",
            "line_start": 453,
            "line_end": 475
          },
          {
            "file": "SKILL.md",
            "line_start": 475,
            "line_end": 479
          },
          {
            "file": "SKILL.md",
            "line_start": 479,
            "line_end": 501
          }
        ],
        "confidence": 0.95,
        "confidence_reasoning": "Pattern match is on Rust format! macro syntax used for string interpolation, not shell backtick execution. Verified by reading SKILL.md content."
      },
      {
        "title": "False Positive: String Operations Misidentified as Weak Cryptography",
        "description": "Scanner detected 'Weak cryptographic algorithm' at 28 locations in SKILL.md. These are standard Rust string operations: .to_string(), .unwrap(), .as_str(), and .map() calls. No cryptographic functions or algorithms exist in this documentation file.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 2,
            "line_end": 2
          },
          {
            "file": "SKILL.md",
            "line_start": 5,
            "line_end": 5
          },
          {
            "file": "SKILL.md",
            "line_start": 10,
            "line_end": 10
          },
          {
            "file": "SKILL.md",
            "line_start": 35,
            "line_end": 35
          },
          {
            "file": "SKILL.md",
            "line_start": 46,
            "line_end": 46
          },
          {
            "file": "SKILL.md",
            "line_start": 50,
            "line_end": 50
          },
          {
            "file": "SKILL.md",
            "line_start": 55,
            "line_end": 55
          },
          {
            "file": "SKILL.md",
            "line_start": 89,
            "line_end": 89
          },
          {
            "file": "SKILL.md",
            "line_start": 99,
            "line_end": 99
          },
          {
            "file": "SKILL.md",
            "line_start": 129,
            "line_end": 129
          },
          {
            "file": "SKILL.md",
            "line_start": 145,
            "line_end": 145
          },
          {
            "file": "SKILL.md",
            "line_start": 150,
            "line_end": 150
          },
          {
            "file": "SKILL.md",
            "line_start": 150,
            "line_end": 150
          },
          {
            "file": "SKILL.md",
            "line_start": 162,
            "line_end": 162
          },
          {
            "file": "SKILL.md",
            "line_start": 165,
            "line_end": 165
          },
          {
            "file": "SKILL.md",
            "line_start": 188,
            "line_end": 188
          },
          {
            "file": "SKILL.md",
            "line_start": 250,
            "line_end": 250
          },
          {
            "file": "SKILL.md",
            "line_start": 270,
            "line_end": 270
          },
          {
            "file": "SKILL.md",
            "line_start": 280,
            "line_end": 280
          },
          {
            "file": "SKILL.md",
            "line_start": 281,
            "line_end": 281
          },
          {
            "file": "SKILL.md",
            "line_start": 287,
            "line_end": 287
          },
          {
            "file": "SKILL.md",
            "line_start": 303,
            "line_end": 303
          },
          {
            "file": "SKILL.md",
            "line_start": 361,
            "line_end": 361
          },
          {
            "file": "SKILL.md",
            "line_start": 434,
            "line_end": 434
          },
          {
            "file": "SKILL.md",
            "line_start": 440,
            "line_end": 440
          },
          {
            "file": "SKILL.md",
            "line_start": 459,
            "line_end": 459
          },
          {
            "file": "SKILL.md",
            "line_start": 484,
            "line_end": 484
          },
          {
            "file": "SKILL.md",
            "line_start": 512,
            "line_end": 512
          }
        ],
        "confidence": 0.98,
        "confidence_reasoning": "Scanner misidentified common Rust string operations as cryptographic functions. Verified file contains only prompt template code with no crypto algorithms."
      }
    ],
    "files_scanned": 1,
    "total_lines": 533,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:16:53.590Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Create MCP prompts for AI guidance",
    "value_statement": "Building MCP servers requires well-designed prompts to guide AI interactions. This skill provides patterns and examples for creating reusable, parameterized prompts using the rmcp Rust crate.",
    "seo_keywords": [
      "MCP prompts",
      "Claude",
      "Codex",
      "Claude Code",
      "prompt engineering",
      "rmcp",
      "Rust MCP",
      "context injection",
      "prompt templates",
      "AI interaction design"
    ],
    "actual_capabilities": [
      "Design prompt structures with arguments and descriptions",
      "Create parameterized prompts for dynamic AI interactions",
      "Implement multi-turn conversation patterns",
      "Build context-rich prompts with project information",
      "Add examples and few-shot learning to prompts",
      "Test and validate MCP prompt implementations"
    ],
    "limitations": [
      "Skill focuses on prompt creation patterns, not prompt optimization techniques",
      "Does not cover prompt injection defenses or security hardening",
      "Examples use Rust rmcp crate; other languages not addressed",
      "Does not include runtime prompt management or versioning"
    ],
    "use_cases": [
      {
        "title": "MCP Server Developer",
        "description": "Learn to implement prompt services for MCP servers with structured arguments, validation, and error handling following Rust patterns.",
        "target_user": "Rust developers building MCP servers"
      },
      {
        "title": "AI Interaction Designer",
        "description": "Design reusable prompt templates that accept dynamic arguments for different AI tasks like code review, API design, and learning."
      },
      {
        "title": "Documentation Writer",
        "description": "Document prompt patterns and provide examples for teams adopting MCP protocol in their AI-powered applications."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Code Analysis Prompt",
        "prompt": "Create an MCP prompt that analyzes code in a specific programming language. The prompt should accept 'language' (required) and 'focus' (optional: performance, security, style) arguments. Return structured review guidance.",
        "scenario": "Setting up a code analysis tool for your MCP server"
      },
      {
        "title": "API Design Assistant",
        "prompt": "Design an MCP prompt for creating REST APIs. Include arguments for api_type (REST, GraphQL, gRPC) and domain (e.g., e-commerce, messaging). The prompt should guide AI to produce complete API specifications."
      },
      {
        "title": "Contextual Learning Prompt",
        "prompt": "Create a learning-focused MCP prompt that accepts topic and difficulty level (beginner, intermediate, advanced). The prompt should adapt explanations based on the level provided."
      },
      {
        "title": "Project Task Prompt",
        "prompt": "Build a context-rich prompt that injects project information (name, language, framework, dependencies) and accepts a task description. The AI should consider project context when generating responses."
      }
    ],
    "output_examples": [
      {
        "input": "Request a code review prompt for Rust with focus on performance",
        "output": "A PromptInfo with name 'analyze_code', description 'Analyze code for issues and improvements', arguments for language (required) and focus (optional), returning a PromptResponse with formatted user message about reviewing Rust code with performance focus."
      },
      {
        "input": "Request an API design prompt for GraphQL in healthcare domain",
        "output": "A PromptResponse containing system message setting AI as API architect, user message with GraphQL healthcare API design requirements including resource models, endpoints, and compliance considerations."
      }
    ],
    "best_practices": [
      "Define clear argument schemas with required and optional parameters",
      "Provide meaningful descriptions for prompts and arguments",
      "Include context and examples to improve AI response quality",
      "Test prompts with various argument combinations"
    ],
    "anti_patterns": [
      "Creating prompts without argument validation, leading to runtime errors",
      "Omitting descriptions that help users understand prompt purpose",
      "Failing to handle missing optional arguments with sensible defaults",
      "Using prompts without testing edge cases and error conditions"
    ],
    "faq": [
      {
        "question": "What is MCP (Model Context Protocol)?",
        "answer": "MCP is a protocol that allows servers to provide prompts, resources, and tools to AI assistants. Prompts are predefined templates that guide AI interactions with specific context and structure."
      },
      {
        "question": "What is the rmcp crate?",
        "answer": "Rmcp is a Rust implementation of the Model Context Protocol. It provides types and traits for building MCP servers including PromptService, PromptInfo, and PromptResponse."
      },
      {
        "question": "How do arguments work in MCP prompts?",
        "answer": "Prompts define arguments using PromptArgument with name, description, and required flag. Users provide arguments as key-value pairs when selecting prompts. The server validates and uses these values to customize prompt content."
      },
      {
        "question": "What are the different message roles?",
        "answer": "MCP prompts support three roles: System sets AI behavior and expertise, User provides the main request, Assistant shows example responses for few-shot learning."
      },
      {
        "question": "How do I test MCP prompts?",
        "answer": "Test prompts by calling list_prompts to verify structure, get_prompt with various argument combinations to check validation, and integration tests that verify the complete prompt flow."
      },
      {
        "question": "Can prompts include dynamic context?",
        "answer": "Yes. Prompts can receive additional context objects like ProjectContext and inject that information into prompt messages using format strings or template composition."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 533
    }
  ]
}
