{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:39:48.496Z",
    "slug": "emillindfors-thiserror-expert",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-error-handling/skills/thiserror-expert",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "cc341fcad21afb8583d419159dfadb353e16789275470e2bbff0672370c3d40c",
    "tree_hash": "02b0967b9bb7a82bd6ec35fb9f20c1153b11acb90a34deb52025576c68fae1f0"
  },
  "skill": {
    "name": "thiserror-expert",
    "description": "Provides guidance on creating custom error types with thiserror, including proper derive macros, error messages, and source error chaining. Activates when users define error enums or work with thiserror.",
    "summary": "Expert guidance on creating custom Rust error types using the thiserror derive crate with proper error messages and source chaining.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "tags": [
      "rust",
      "error-handling",
      "thiserror",
      "derive-macros",
      "error-types"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Static analysis flagged pattern matches that are false positives. The 'backticks' detected are Rust attribute syntax (e.g., #[error(\"...\")]) in documentation code examples, not shell commands. The skill contains only educational content and Rust code patterns for the thiserror crate.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [
      {
        "title": "External Command Pattern - False Positive",
        "description": "Pattern detected: 'backticks' at SKILL.md locations. These are Rust attribute syntax (e.g., #[error(\"...\")]) in code examples, not shell command execution. Static analyzer does not understand Rust attribute macros.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 17,
            "line_end": 17
          },
          {
            "file": "SKILL.md",
            "line_start": 30,
            "line_end": 515
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "The backticks detected are Rust attribute syntax in code blocks. The entire skill is documentation for the thiserror crate with no shell or Ruby command execution."
      },
      {
        "title": "Weak Cryptographic Algorithm - False Positive",
        "description": "Pattern flagged as 'weak cryptographic algorithm'. This is a false positive from the static analyzer misidentifying Rust error-related terms.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 3,
            "line_end": 3
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "Line 3 contains skill metadata. The 'Error' term in thiserror documentation was misidentified as a crypto reference by the pattern matcher."
      },
      {
        "title": "System Reconnaissance - False Positive",
        "description": "Pattern flagged as 'system reconnaissance'. This is a false positive from the static analyzer misidentifying error-related documentation.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 41,
            "line_end": 41
          },
          {
            "file": "SKILL.md",
            "line_start": 74,
            "line_end": 74
          },
          {
            "file": "SKILL.md",
            "line_start": 94,
            "line_end": 94
          },
          {
            "file": "SKILL.md",
            "line_start": 102,
            "line_end": 102
          },
          {
            "file": "SKILL.md",
            "line_start": 120,
            "line_end": 120
          },
          {
            "file": "SKILL.md",
            "line_start": 194,
            "line_end": 194
          },
          {
            "file": "SKILL.md",
            "line_start": 292,
            "line_end": 292
          },
          {
            "file": "SKILL.md",
            "line_start": 330,
            "line_end": 330
          },
          {
            "file": "SKILL.md",
            "line_start": 404,
            "line_end": 404
          },
          {
            "file": "SKILL.md",
            "line_start": 429,
            "line_end": 429
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "These lines contain error field names and message text like 'source', 'path', 'port' in Rust error examples. No actual system reconnaissance code exists."
      }
    ],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 533,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:39:48.496Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Create Rust Error Types with Thiserror",
    "value_statement": "Thiserror is a Rust crate that simplifies custom error type creation through derive macros. This skill provides expert guidance on defining error enums with clear messages, chaining source errors, and implementing proper From conversions for ergonomic error handling.",
    "seo_keywords": [
      "Rust error handling",
      "thiserror crate",
      "custom error types",
      "Rust derive macros",
      "error chaining",
      "Claude",
      "Codex",
      "Claude Code",
      "Rust error messages",
      "From trait errors"
    ],
    "actual_capabilities": [
      "Detects custom error enum definitions and suggests thiserror patterns",
      "Recommends proper #[error(\"...\")] attribute usage for clear error messages",
      "Guides on using #[from] for automatic From trait implementations",
      "Shows how to use #[source] for error chain preservation",
      "Explains #[transparent] for wrapper error forwarding",
      "Provides best practices for layered error architectures"
    ],
    "limitations": [
      "Does not generate full error implementations outside thiserror patterns",
      "Does not handle error logging or reporting libraries",
      "Does not provide runtime error recovery strategies",
      "Does not integrate with specific framework error types"
    ],
    "use_cases": [
      {
        "title": "Migrate Manual Error Implementations",
        "description": "Convert verbose manual Display and Error trait implementations to concise thiserror derive macros with automatic trait implementations.",
        "target_user": "Rust developers refactoring error handling code"
      },
      {
        "title": "Design Application Error Types",
        "description": "Create well-structured error enums for applications with clear error variants, field-based messages, and proper source error chaining.",
        "target_user": "Application developers designing error strategies"
      },
      {
        "title": "Integrate External Error Types",
        "description": "Wrap errors from libraries like std::io, sqlx, reqwest using #[from] to enable the ? operator for automatic conversion.",
        "target_user": "Library and application developers integrating external crates"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Error Conversion",
        "prompt": "I have this error enum with manual Display implementation. Can you convert it to use thiserror?",
        "scenario": "User has custom error code with manual Display trait"
      },
      {
        "title": "Error with Source Chaining",
        "prompt": "How do I wrap a std::io::Error in my custom error while preserving the source error chain?",
        "scenario": "User needs to chain errors from standard library"
      },
      {
        "title": "Error Conversion with Context",
        "scenario": "User needs to add custom context while still using #[from] conversion",
        "prompt": "I want to convert an io::Error to my error type but add custom message and file path context"
      },
      {
        "title": "Layered Error Architecture",
        "prompt": "What's the best way to structure errors across domain, infrastructure, and application layers with proper conversion between them?",
        "scenario": "Designing multi-layer error handling"
      }
    ],
    "output_examples": [
      {
        "input": "Convert this error to use thiserror",
        "output": [
          "Here is your error converted to thiserror:",
          "",
          "```rust",
          "use thiserror::Error;",
          "",
          "#[derive(Error, Debug)]",
          "pub enum MyError {",
          "    #[error(\"Not found\")]",
          "    NotFound,",
          "",
          "    #[error(\"Invalid input: {0}\")]",
          "    Invalid(String),",
          "}",
          "```",
          "",
          "This automatically implements Display, std::fmt::Debug, and std::error::Error."
        ]
      },
      {
        "input": "How do I chain errors with #[source]?",
        "output": [
          "Use #[source] to preserve the error chain while providing a custom message:",
          "",
          "```rust",
          "#[derive(Error, Debug)]",
          "pub enum ConfigError {",
          "    #[error(\"Failed to load config file '{path}'\")]",
          "    LoadFailed {",
          "        path: String,",
          "        #[source]",
          "        source: std::io::Error,",
          "    },",
          "}",
          "```",
          "",
          "The #[source] attribute ensures the original error is available through the source() method."
        ]
      }
    ],
    "best_practices": [
      "Use descriptive field placeholders like {0}, {field_name} in error messages to include runtime values",
      "Apply #[from] for errors that should support automatic ? operator conversion",
      "Choose #[source] over #[from] when you need custom construction with added context"
    ],
    "anti_patterns": [
      "Using vague error messages like 'Error occurred' without actionable information",
      "Forgetting #[source] or #[from] when wrapping other error types",
      "Using #[from] when custom error construction with additional fields is needed"
    ],
    "faq": [
      {
        "question": "What is thiserror and why should I use it?",
        "answer": "Thiserror is a Rust derive crate that automatically implements std::error::Error and Display traits for error enums. It reduces boilerplate code and ensures consistent error handling across your codebase."
      },
      {
        "question": "When should I use #[from] vs #[source]?",
        "answer": "Use #[from] when you want automatic From trait implementation and the ? operator to work. Use #[source] when you need custom error construction with additional fields while still preserving the error chain."
      },
      {
        "question": "What is #[error(transparent)] used for?",
        "answer": "#[error(transparent)] forwards all Display and source behavior to the inner error type. It is useful for wrapper errors that should not change how the inner error is displayed."
      },
      {
        "question": "How do I include field values in error messages?",
        "answer": "Use {0}, {1} for positional fields in tuple variants. Use {field_name} for named fields in struct variants. The placeholders are replaced at runtime with actual values."
      },
      {
        "question": "Can thiserror work with generic error types?",
        "answer": "Yes, thiserror supports generic error types. You can create error enums with type parameters as long as the type bounds include std::error::Error."
      },
      {
        "question": "Does thiserror support conditional compilation?",
        "answer": "Yes, you can use #[cfg(feature = \"...\")] attributes on error variants to include or exclude them based on enabled features."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 533
    }
  ]
}
