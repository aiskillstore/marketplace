{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-31T08:39:06.922Z",
    "slug": "avdlee-swiftui-expert-skill",
    "source_url": "https://github.com/avdlee/swiftui-agent-skill/tree/main/swiftui-expert-skill/",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "958a3f52ba010e2296f42e07679b0ddcde751111cefd965abc046e8badcf9875",
    "tree_hash": "0484de111cd3e740723d7ba139d2f8b436bd56ce2b27f544689a5fbfa68d417d"
  },
  "skill": {
    "name": "swiftui-expert-skill",
    "description": "Write, review, or improve SwiftUI code following best practices for state management, view composition, performance, modern APIs, Swift concurrency, and iOS 26+ Liquid Glass adoption. Use when building new SwiftUI features, refactoring existing views, reviewing code quality, or adopting modern SwiftUI patterns.",
    "summary": "Expert guidance for building, reviewing, and improving SwiftUI applications with modern patterns and best practices",
    "icon": "ðŸ“±",
    "version": "1.0.0",
    "author": "avdlee",
    "license": "MIT",
    "tags": [
      "SwiftUI",
      "iOS",
      "Apple",
      "mobile-development",
      "Swift"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings are false positives. The 'Ruby/shell backtick execution' detections are markdown code block delimiters in documentation files. The 'weak cryptographic algorithm' and 'system reconnaissance' patterns are false positives from documentation text and file paths. No actual code execution, network calls, or prompt injection attempts exist. This is a pure documentation skill containing SwiftUI best practices and reference guides.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 14,
            "line_end": 261
          }
        ]
      },
      {
        "factor": "network",
        "evidence": [
          {
            "file": "references/text-formatting.md",
            "line_start": 223,
            "line_end": 223
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [
      {
        "title": "Ruby/Shell Backtick Execution - False Positive",
        "description": "Scanner detected backtick patterns in markdown files. These are code block delimiters in SwiftUI documentation, not actual shell commands. All locations are in markdown files containing Swift code examples.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 14,
            "line_end": 261
          },
          {
            "file": "references/image-optimization.md",
            "line_start": 1,
            "line_end": 287
          },
          {
            "file": "references/layout-best-practices.md",
            "line_start": 1,
            "line_end": 313
          },
          {
            "file": "references/liquid-glass.md",
            "line_start": 1,
            "line_end": 378
          },
          {
            "file": "references/list-patterns.md",
            "line_start": 1,
            "line_end": 154
          },
          {
            "file": "references/modern-apis.md",
            "line_start": 1,
            "line_end": 401
          },
          {
            "file": "references/performance-patterns.md",
            "line_start": 1,
            "line_end": 378
          },
          {
            "file": "references/scroll-patterns.md",
            "line_start": 1,
            "line_end": 306
          },
          {
            "file": "references/sheet-navigation-patterns.md",
            "line_start": 1,
            "line_end": 293
          },
          {
            "file": "references/state-management.md",
            "line_start": 1,
            "line_end": 448
          },
          {
            "file": "references/text-formatting.md",
            "line_start": 1,
            "line_end": 286
          },
          {
            "file": "references/view-structure.md",
            "line_start": 1,
            "line_end": 277
          }
        ],
        "confidence": 0.98,
        "confidence_reasoning": "All 669 detections are in markdown documentation files. Backticks are markdown syntax for code blocks. No actual shell or Ruby code exists in this repository."
      }
    ],
    "medium_findings": [],
    "low_findings": [
      {
        "title": "Hardcoded URL in Documentation",
        "description": "Scanner detected a URL reference in text-formatting.md. This is a legitimate documentation link, not a security risk.",
        "locations": [
          {
            "file": "references/text-formatting.md",
            "line_start": 223,
            "line_end": 223
          }
        ],
        "confidence": 0.95,
        "confidence_reasoning": "URL references in documentation are expected and pose no security risk. No network calls are made by this skill."
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 12,
    "total_lines": 3785,
    "audit_model": "claude",
    "audited_at": "2026-01-31T08:39:06.922Z"
  },
  "content": {
    "user_title": "Build better SwiftUI apps",
    "value_statement": "Writing SwiftUI apps requires understanding modern patterns, performance optimization, and Apple design guidelines. This skill provides expert guidance on state management, view composition, and iOS 26+ Liquid Glass adoption to help you build high-quality iOS applications.",
    "seo_keywords": [
      "SwiftUI",
      "iOS development",
      "mobile app development",
      "Apple development",
      "SwiftUI best practices",
      "SwiftUI patterns",
      "iOS 26",
      "Liquid Glass",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Review SwiftUI code for correct property wrapper usage (@State, @Binding, @Bindable, @Observable)",
      "Replace deprecated SwiftUI APIs with modern equivalents",
      "Optimize view performance and identify common anti-patterns",
      "Implement iOS 26+ Liquid Glass effects with proper fallbacks",
      "Design proper data flow and state management architecture",
      "Structure views for maintainability and optimal diffing"
    ],
    "limitations": [
      "This skill provides guidance only - it does not execute Swift code",
      "Does not generate complete Xcode project files from scratch",
      "Does not integrate with external APIs or build tools",
      "Limited to SwiftUI patterns - does not cover UIKit or AppKit"
    ],
    "use_cases": [
      {
        "title": "Code review for iOS teams",
        "description": "Review pull requests containing SwiftUI changes. Get feedback on state management patterns, API usage, and performance issues before merging.",
        "target_user": "iOS developers and tech leads"
      },
      {
        "title": "Modernizing legacy SwiftUI code",
        "description": "Refactor older SwiftUI codebases to use modern patterns like @Observable, NavigationStack, and contemporary modifiers.",
        "target_user": "iOS maintenance developers"
      },
      {
        "title": "Learning modern SwiftUI",
        "description": "Understand best practices and modern patterns when building new SwiftUI features. Get guidance on property wrapper selection and view composition.",
        "target_user": "Swift developers learning SwiftUI"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic code review",
        "prompt": "Review this SwiftUI code and check if it follows modern best practices. Look at state management, API usage, and performance: {{code}}",
        "scenario": "When you have SwiftUI code that needs review"
      },
      {
        "title": "Modern API migration",
        "prompt": "Help me replace deprecated SwiftUI patterns in this code with modern alternatives. Specifically update: {{code}}",
        "scenario": "When modernizing legacy SwiftUI code"
      },
      {
        "title": "Performance optimization",
        "prompt": "Analyze this SwiftUI view for performance issues. Identify unnecessary redraws, inefficient state updates, or layout problems: {{code}}",
        "scenario": "When optimizing SwiftUI performance"
      },
      {
        "title": "New feature implementation",
        "prompt": "Help me design and implement a new SwiftUI feature. I need a view that shows a list of items with details on tap, using modern patterns. Requirements: {{requirements}}",
        "scenario": "When building new SwiftUI features"
      }
    ],
    "output_examples": [
      {
        "input": "Review this SwiftUI code:\n```swift\nstruct ContentView: View {\n    @StateObject var viewModel = MyViewModel()\n    @State private var selectedItem: Item?\n    \n    var body: some View {\n        List(items) { item in\n            Text(item.name)\n                .onTapGesture {\n                    selectedItem = item\n                }\n        }\n        .sheet(isPresented: $selectedItem != nil) {\n            DetailView(item: selectedItem!)\n        }\n    }\n}\n```",
        "output": "## Code Review Results\n\n### Issues Found:\n\n1. **Prefer @Observable over @StateObject** (High priority)\n   - @StateObject is legacy. Use @Observable with @State for new code.\n\n2. **Use .sheet(item:) instead of .sheet(isPresented:)**\n   - Current code uses optional binding which is error-prone.\n\n3. **Replace onTapGesture with Button**\n   - Button is more semantic and accessible.\n\n### Recommended Changes:\n```swift\n@Observable\nclass MyViewModel {\n    // model properties\n}\n\nstruct ContentView: View {\n    @State private var viewModel = MyViewModel()\n    @State private var selectedItem: Item?\n    \n    var body: some View {\n        List(items) { item in\n            Button {\n                selectedItem = item\n            } label: {\n                Text(item.name)\n            }\n        }\n        .sheet(item: $selectedItem) { item in\n            DetailView(item: item)\n        }\n    }\n}\n```"
      },
      {
        "input": "How do I add Liquid Glass to my iOS 26 app?",
        "output": "## iOS 26 Liquid Glass Implementation\n\n### Basic Glass Effect:\n```swift\nif #available(iOS 26, *) {\n    content\n        .padding()\n        .glassEffect(.regular.interactive(), in: .rect(cornerRadius: 16))\n} else {\n    content\n        .padding()\n        .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 16))\n}\n```\n\n### Key Guidelines:\n1. Apply `.glassEffect()` after layout and appearance modifiers\n2. Wrap multiple glass elements in `GlassEffectContainer`\n3. Use `.interactive()` only on tappable elements\n4. Always provide fallbacks for older iOS versions"
      }
    ],
    "best_practices": [
      "Prefer @Observable over ObservableObject for new state management. Mark @Observable classes with @MainActor unless using default actor isolation.",
      "Apply glass effects after layout modifiers. Wrap multiple glass elements in GlassEffectContainer and provide iOS 26+ availability checks with fallbacks.",
      "Extract complex views into smaller subviews for better performance and maintainability. Use modifiers over conditional views to preserve view identity."
    ],
    "anti_patterns": [
      "Using @State or @StateObject for values passed from parent views - these only accept initial values and will not update reactively.",
      "Using .indices in ForEach for dynamic content - this breaks identity and causes rendering issues. Use stable unique identifiers instead.",
      "Creating objects or performing heavy computations in view body - body should be pure and fast, with all logic moved to models or computed properties."
    ],
    "faq": [
      {
        "question": "When should I use @State vs @Binding?",
        "answer": "Use @State for internal view state that the view owns and modifies. Use @Binding when a child view needs to modify state that belongs to a parent view. @Binding creates a two-way connection to the parent's @State."
      },
      {
        "question": "How do I migrate from ObservableObject to @Observable?",
        "answer": "Replace @Published properties with regular properties in a class marked with @Observable. Change @StateObject to @State and @ObservedObject to let/binding patterns. @Observable handles nested objects automatically."
      },
      {
        "question": "What is the performance impact of deep view hierarchies?",
        "answer": "Deep hierarchies increase diffing time during view updates. Extract subviews early, keep views small, and avoid GeometryReader when alternatives exist. Use LazyVStack for large lists and stable identity in ForEach."
      },
      {
        "question": "How do I implement type-safe navigation?",
        "answer": "Use NavigationStack with navigationDestination(for:destination:). This provides compile-time checking for navigation paths. Avoid NavigationView and use programmatic dismissal with @Environment(\\.dismiss) instead of presenting sheets with boolean bindings."
      },
      {
        "question": "What are the Liquid Glass requirements for iOS 26?",
        "answer": "iOS 26+ required. Use native glassEffect, GlassEffectContainer, and glass button styles. Apply glass effects after layout modifiers. Always provide #available checks with fallback materials for older iOS versions."
      },
      {
        "question": "How do I debug unexpected view updates?",
        "answer": "Use Self._printChanges() in your view body to log which properties caused redraws. Check for unnecessary @State updates in onReceive and onChange handlers. Ensure value types are actually changing before assigning to state."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "image-optimization.md",
          "type": "file",
          "path": "references/image-optimization.md",
          "lines": 287
        },
        {
          "name": "layout-best-practices.md",
          "type": "file",
          "path": "references/layout-best-practices.md",
          "lines": 313
        },
        {
          "name": "liquid-glass.md",
          "type": "file",
          "path": "references/liquid-glass.md",
          "lines": 378
        },
        {
          "name": "list-patterns.md",
          "type": "file",
          "path": "references/list-patterns.md",
          "lines": 154
        },
        {
          "name": "modern-apis.md",
          "type": "file",
          "path": "references/modern-apis.md",
          "lines": 401
        },
        {
          "name": "performance-patterns.md",
          "type": "file",
          "path": "references/performance-patterns.md",
          "lines": 378
        },
        {
          "name": "scroll-patterns.md",
          "type": "file",
          "path": "references/scroll-patterns.md",
          "lines": 306
        },
        {
          "name": "sheet-navigation-patterns.md",
          "type": "file",
          "path": "references/sheet-navigation-patterns.md",
          "lines": 293
        },
        {
          "name": "state-management.md",
          "type": "file",
          "path": "references/state-management.md",
          "lines": 448
        },
        {
          "name": "text-formatting.md",
          "type": "file",
          "path": "references/text-formatting.md",
          "lines": 286
        },
        {
          "name": "view-structure.md",
          "type": "file",
          "path": "references/view-structure.md",
          "lines": 277
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 264
    }
  ]
}
