{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-02-06T08:54:36.463Z",
    "slug": "vuejs-ai-vue-development-guides",
    "source_url": "https://github.com/vuejs-ai/skills/tree/main/skills/vue-development-guides/",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "908cdd8a63deed7a16f522906853dd31ad67b2ffb2fea2daeaee5aa4d7c096ad",
    "tree_hash": "d7355a195764e073b771c215125c994bd47132caad923056e72df6c0ddcabb82"
  },
  "skill": {
    "name": "vue-development-guides",
    "description": "A collection of best practices and tips for developing applications using Vue.js. This skill MUST be apply when developing, refactoring or reviewing Vue.js or Nuxt projects.",
    "summary": "Best practices guide for Vue 3 and Nuxt 3 development including reactivity, components, data flow, and state management.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "vuejs-ai",
    "license": "MIT",
    "tags": [
      "vue",
      "vue3",
      "frontend",
      "nuxt",
      "javascript"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill is a pure documentation/guide resource containing only markdown files with Vue.js best practices. All static analysis findings are false positives: (1) 'external_commands' alerts are triggered by Markdown backtick syntax for code formatting, not actual command execution; (2) 'network' alerts are documentation URL references to vuejs.org, vueuse.org, and pinia.vuejs.org; (3) No actual cryptographic operations, system reconnaissance, or executable code exists. This skill provides guidance only and does not make network calls, execute commands, or access the file system.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 5,
    "total_lines": 625,
    "audit_model": "claude",
    "audited_at": "2026-02-06T08:54:36.463Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Apply Vue.js Development Best Practices",
    "value_statement": "Vue.js projects often suffer from unclear data flow and reactivity mistakes. This skill provides comprehensive best practices for Vue 3 and Nuxt 3 development including proper state management, component patterns, and data flow architecture.",
    "seo_keywords": [
      "Vue.js",
      "Vue 3",
      "Nuxt 3",
      "frontend development",
      "JavaScript framework",
      "Vue components",
      "Vue reactivity",
      "Pinia state management",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Enforce Vue 3 Composition API patterns with script setup",
      "Guide proper props and emits for component communication",
      "Recommend correct reactivity primitives (ref vs reactive vs shallowRef)",
      "Provide state management guidance for Pinia and composable stores",
      "Identify Vue SFC best practices for template, script, and style sections"
    ],
    "limitations": [
      "Does not execute code or modify project files directly",
      "Does not install dependencies or configure build tools",
      "Does not provide runtime validation or linting",
      "Focuses on Vue 3 and Nuxt 3 patterns only"
    ],
    "use_cases": [
      {
        "title": "Review Vue Component Architecture",
        "description": "When reviewing or auditing Vue.js codebases, this skill helps identify violations of the Props Down / Events Up principle and recommends proper component composition patterns.",
        "target_user": "Code reviewers and tech leads"
      },
      {
        "title": "Fix Reactivity Issues",
        "description": "When Vue components behave unexpectedly due to reactivity bugs, this skill provides guidance on correct usage of ref, reactive, computed, and watchers.",
        "target_user": "Frontend developers debugging Vue applications"
      },
      {
        "title": "Establish Team Coding Standards",
        "description": "When starting a new Vue 3 or Nuxt 3 project, this skill establishes consistent patterns for data flow, state management, and component structure.",
        "target_user": "Engineering teams and architects"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Vue Pattern Check",
        "prompt": "Check my Vue component for best practices. Review the component code and verify it follows the Composition API patterns, proper reactivity usage, and data flow principles from the vue-development-guides skill.",
        "scenario": "Quick pattern validation for a single component"
      },
      {
        "title": "Refactor to Composition API",
        "prompt": "Refactor this Vue component from Options API to Composition API with <script setup>. Follow the vue-development-guides best practices for component structure, reactivity primitives, and TypeScript typing.",
        "scenario": "Migrating legacy Vue components to modern patterns"
      },
      {
        "title": "Data Flow Architecture Review",
        "prompt": "Analyze the component hierarchy in my Vue/Nuxt project. Check if the data flow follows Props Down / Events Up principles and identify any props drilling anti-patterns that could be solved with provide/inject or a store.",
        "scenario": "Architectural review of component relationships"
      },
      {
        "title": "State Management Implementation",
        "prompt": "Design a state management solution for my Vue/Nuxt application following the vue-development-guides. Recommend whether to use composable stores, VueUse createGlobalState, or Pinia based on the project scale and SSR requirements.",
        "scenario": "Choosing and implementing state management"
      }
    ],
    "output_examples": [
      {
        "input": "Component code using reactive() and replacing the entire state object",
        "output": [
          "Issue: reactive() proxy breaks when you replace the entire object",
          "Fix: Use ref() instead for replaceable state",
          "Code:",
          "const user = ref({ id: 1, name: 'Tom' })",
          "async function reload() {",
          "  user.value = await fetchUser()  // Correct: reassigns .value",
          "}"
        ]
      },
      {
        "input": "Child component mutating a prop received from parent",
        "output": [
          "Issue: Props are readonly - mutating them violates one-way data flow",
          "Fix: Emit an event to let the parent update the source of truth",
          "Pattern:",
          "Child: defineProps<{ count: number }>() + defineEmits<{ (e: 'update', value: number): void }>()",
          "Parent: <Counter :count=\"count\" @update=\"count = $event\" />"
        ]
      }
    ],
    "best_practices": [
      "Use the Composition API with <script setup lang=\"ts\"> as the default pattern for Vue 3 and Nuxt 3 components.",
      "Follow Props Down / Events Up for component communication and avoid direct parent state mutation from child components.",
      "Choose reactivity primitives carefully: ref() for replaceable values, reactive() for mutable objects, shallowRef() for opaque data."
    ],
    "anti_patterns": [
      "Avoid mixing Options API and Composition API patterns inconsistently within the same codebase.",
      "Do not destructure primitives from reactive() objects as this disconnects them from reactivity.",
      "Avoid storing derived state in refs manually when computed() can derive it automatically from sources."
    ],
    "faq": [
      {
        "question": "When should I use ref() vs reactive() in Vue 3?",
        "answer": "Use ref() when you need to replace the entire value or for primitive types. Use reactive() when you primarily mutate properties of an existing object without full replacement."
      },
      {
        "question": "How do I avoid props drilling in Vue?",
        "answer": "Use provide/inject for context shared across more than 3 component layers. For global application state, consider Pinia or composable stores."
      },
      {
        "question": "What is the recommended state management for Nuxt 3?",
        "answer": "Pinia is strongly recommended for Nuxt 3 and SSR applications due to its TypeScript support, DevTools integration, and persistence plugins."
      },
      {
        "question": "How do I properly use computed() in Vue 3?",
        "answer": "Keep computed getters pure without side effects. They should only derive values from reactive state and return derived results without mutating anything."
      },
      {
        "question": "What is the correct order for Vue SFC sections?",
        "answer": "Keep sections in this order: <script> â†’ <template> â†’ <style>. Use <script setup lang=\"ts\"> for cleaner component definitions."
      },
      {
        "question": "How do I handle async operations in watchers properly?",
        "answer": "Use AbortController with onCleanup to cancel pending requests when the watched value changes rapidly. This prevents race conditions in search and filter scenarios."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "data-flow-guide.md",
          "type": "file",
          "path": "references/data-flow-guide.md",
          "lines": 143
        },
        {
          "name": "reactivity-guide.md",
          "type": "file",
          "path": "references/reactivity-guide.md",
          "lines": 192
        },
        {
          "name": "sfc-guide.md",
          "type": "file",
          "path": "references/sfc-guide.md",
          "lines": 165
        },
        {
          "name": "state-management-guide.md",
          "type": "file",
          "path": "references/state-management-guide.md",
          "lines": 57
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 68
    }
  ]
}
