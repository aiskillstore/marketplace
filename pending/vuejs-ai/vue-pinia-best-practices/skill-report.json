{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-02-08T08:41:25.392Z",
    "slug": "vuejs-ai-vue-pinia-best-practices",
    "source_url": "https://github.com/vuejs-ai/skills/tree/main/skills/vue-pinia-best-practices/",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "43108a9feeb8928d0162ccb8fbb77f50cba2e0253efb0e624f2631c4f669ac89",
    "tree_hash": "54bc01068e0b65cf9f2afc2e6c0d225f4712cd53a4626b779d9183d651c6022f"
  },
  "skill": {
    "name": "vue-pinia-best-practices",
    "description": "Pinia stores, state management patterns, store setup, and reactivity with stores.",
    "summary": "Pinia stores, state management patterns, store setup, and reactivity with stores.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "github.com/vuejs-ai",
    "license": "MIT",
    "tags": [
      "vue3",
      "pinia",
      "state-management",
      "vuex-alternative",
      "vue-composition-api"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Static analysis detected 215 patterns in markdown documentation files. All findings are FALSE POSITIVES. The 'Ruby/shell backtick execution' patterns are markdown code blocks using backticks for syntax highlighting. The 'Weak cryptographic algorithm' and 'System reconnaissance' findings are false positives from documentation text. No executable code, network calls, or file system operations exist in this skill. Risk level: safe.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 7,
    "total_lines": 1387,
    "audit_model": "claude",
    "audited_at": "2026-02-08T08:41:25.392Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Implement Pinia State Management Best Practices",
    "value_statement": "Vue applications often face state management issues like reactivity loss, initialization errors, and debugging challenges. This skill provides proven patterns and solutions for implementing Pinia stores correctly in Vue 3 applications.",
    "seo_keywords": [
      "Pinia",
      "Vue 3 state management",
      "Vue Pinia tutorial",
      "Pinia store patterns",
      "Pinia setup stores",
      "Vue state management best practices",
      "Pinia reactivity",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Fix 'No Active Pinia' initialization errors by ensuring correct plugin order",
      "Implement setup stores that properly expose state to DevTools and SSR",
      "Preserve reactivity when destructuring store properties",
      "Bind store methods correctly to maintain 'this' context in templates",
      "Manage ephemeral filter state using URL parameters",
      "Scale Pinia for large applications with proper conventions"
    ],
    "limitations": [
      "Does not generate new Pinia store code from scratch",
      "Does not migrate Vuex stores to Pinia automatically",
      "Does not provide runtime performance profiling",
      "Does not include server-side rendering configuration"
    ],
    "use_cases": [
      {
        "title": "Debug Pinia Initialization Errors",
        "description": "Resolve 'getActivePinia was called but there was no active Pinia' errors by fixing plugin initialization order and store usage timing.",
        "target_user": "Vue developers encountering runtime errors with Pinia"
      },
      {
        "title": "Fix Store Reactivity Issues",
        "description": "Restore reactivity when destructuring store properties or calling store methods from Vue templates.",
        "target_user": "Vue developers working with reactive store data"
      },
      {
        "title": "Scale State Management",
        "description": "Apply Pinia conventions and patterns suitable for large Vue applications with multiple stores and complex state requirements.",
        "target_user": "Senior Vue developers and architects"
      }
    ],
    "prompt_templates": [
      {
        "title": "Fix Pinia Initialization Error",
        "prompt": "I'm getting the error 'getActivePinia() was called but there was no active Pinia' in my Vue 3 app. How do I fix this?",
        "scenario": "Initial setup and configuration"
      },
      {
        "title": "Setup Store Best Practices",
        "prompt": "What are the best practices for setting up a Pinia store in Vue 3? Include the difference between options stores and setup stores.",
        "scenario": "Learning store patterns"
      },
      {
        "title": "Store Reactivity Solutions",
        "prompt": "My Pinia store properties stop updating the UI when I destructure them. How do I preserve reactivity?",
        "scenario": "Fixing reactivity issues"
      },
      {
        "title": "Large App Architecture",
        "prompt": "What patterns and conventions should I use when building a large Vue application with Pinia for multiple teams and many stores?",
        "scenario": "Scalable architecture design"
      }
    ],
    "output_examples": [
      {
        "input": "How do I fix the 'No Active Pinia' error?",
        "output": [
          "The error occurs when using a Pinia store before calling app.use(pinia).",
          "",
          "Check your main.js order:",
          "1. app.use(pinia) must come BEFORE app.use(router) if router guards use stores",
          "2. Never call useXxxStore() in top-level module code",
          "3. Only call useXxxStore() inside setup functions or after app initialization",
          "",
          "For router guards that need stores, dynamically import inside the guard callback:"
        ]
      },
      {
        "input": "Why did my store reactivity break?",
        "output": [
          "Destructuring from a Pinia store breaks reactivity because you lose the proxy wrapper.",
          "",
          "AVOID this pattern:",
          "const { count } = store",
          "",
          "USE one of these solutions:",
          "- Keep the reactive reference: const store = useStore(); const { count } = store",
          "- Use storeToRefs for state: const { count } = storeToRefs(store)",
          "- Access properties directly: store.count"
        ]
      },
      {
        "input": "How do I bind store methods in templates?",
        "output": [
          "Store methods lose 'this' context when called without proper binding.",
          "",
          "WRONG in template:",
          "@click='store.increment()' // 'this' is undefined",
          "",
          "CORRECT solutions:",
          "- Define wrapped methods in setup: const increment = () => store.increment()",
          "- Bind in methods: increment: store.increment.bind(store)",
          "- Use arrow functions in options stores"
        ]
      }
    ],
    "best_practices": [
      "Always call app.use(pinia) before mounting the Vue app and before installing other plugins that might use stores",
      "Use storeToRefs() when destructuring state to maintain reactivity, but destructure actions normally",
      "Avoid calling store constructors at module level; instead, use lazy initialization or composables"
    ],
    "anti_patterns": [
      "Calling useXxxStore() outside of setup functions, composables, or after Pinia initialization",
      "Destructuring store state directly without storeToRefs(), which breaks Vue reactivity",
      "Using methods: {} in setup stores without binding 'this' context for template usage"
    ],
    "faq": [
      {
        "question": "What is the difference between options stores and setup stores in Pinia?",
        "answer": "Options stores use the traditional Vuex-like syntax with state, getters, and actions properties. Setup stores use the Vue Composition API style with ref() for state, computed() for getters, and regular functions for actions. Setup stores offer more flexibility and better TypeScript support."
      },
      {
        "question": "How do I persist Pinia state across page refreshes?",
        "answer": "Use the pinia-plugin-persistedstate plugin or manually save state to localStorage in store subscriptions. For URL-persistent state like filters, use reactive URL query parameters with vue-router."
      },
      {
        "question": "Can I use Pinia with Vue 2?",
        "answer": "Yes, Pinia has a Vue 2 compatible version (pinia@^2.0.0). However, Vue 3 is recommended for new projects as Pinia was designed primarily for Vue 3's Composition API."
      },
      {
        "question": "How do I access a store from another store?",
        "answer": "Import and instantiate the other store directly within your store's setup function. In setup stores, you can call useOtherStore() and use its methods. Avoid circular dependencies between stores."
      },
      {
        "question": "Why is my setup store not showing in Vue DevTools?",
        "answer": "Ensure your setup store returns the state object. Pinia DevTools require a returned state reference. If using computed properties for state, switch to ref() for the state fields you want to see in DevTools."
      },
      {
        "question": "How do I reset all stores to their initial state?",
        "answer": "For options stores, define a $reset() method using this.$patch. For setup stores, create a reset function that reinitializes your ref values. Consider using initial state constants to ensure consistent resets."
      }
    ]
  },
  "file_structure": [
    {
      "name": "reference",
      "type": "dir",
      "path": "reference",
      "children": [
        {
          "name": "pinia-no-active-pinia-error.md",
          "type": "file",
          "path": "reference/pinia-no-active-pinia-error.md",
          "lines": 249
        },
        {
          "name": "pinia-setup-store-return-all-state.md",
          "type": "file",
          "path": "reference/pinia-setup-store-return-all-state.md",
          "lines": 228
        },
        {
          "name": "pinia-store-destructuring-breaks-reactivity.md",
          "type": "file",
          "path": "reference/pinia-store-destructuring-breaks-reactivity.md",
          "lines": 194
        },
        {
          "name": "state-url-for-ephemeral-filters.md",
          "type": "file",
          "path": "reference/state-url-for-ephemeral-filters.md",
          "lines": 239
        },
        {
          "name": "state-use-pinia-for-large-apps.md",
          "type": "file",
          "path": "reference/state-use-pinia-for-large-apps.md",
          "lines": 263
        },
        {
          "name": "store-method-binding-parentheses.md",
          "type": "file",
          "path": "reference/store-method-binding-parentheses.md",
          "lines": 192
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 22
    }
  ]
}
