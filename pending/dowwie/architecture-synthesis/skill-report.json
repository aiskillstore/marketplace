{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T14:25:32.629Z",
    "slug": "dowwie-architecture-synthesis",
    "source_url": "https://github.com/Dowwie/agent_framework_study/tree/main/.claude/skills/architecture-synthesis",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "4df9a834c0c3b9bf6d8bafe20d2bd4766828210b16da2cf8de36ff8e211538e0",
    "tree_hash": "ae5f5637b2eb2a6f968a912904054f9ea49ebbca2ef9cba0e8ef72ee18fa703b"
  },
  "skill": {
    "name": "architecture-synthesis",
    "description": "Generate a reference architecture specification from analyzed frameworks. Use when (1) designing a new agent framework based on prior art, (2) defining core primitives (Message, State, Tool types), (3) specifying interface protocols, (4) creating execution loop pseudocode, or (5) producing architecture diagrams and implementation roadmaps.",
    "summary": "Generate a reference architecture specification from analyzed frameworks. Use when (1) designing a n...",
    "icon": "ðŸ—ï¸",
    "version": "1.0.0",
    "author": "Dowwie",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "agent-frameworks",
      "architecture-design",
      "software-design",
      "protocols"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing only architectural guidance and code examples. No executable code, scripts, network calls, filesystem access, or environment variable access detected.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 371,
    "audit_model": "claude",
    "audited_at": "2026-01-10T14:25:32.629Z"
  },
  "content": {
    "user_title": "Generate Agent Framework Architecture",
    "value_statement": "Designing an AI agent framework from scratch requires careful architecture decisions. This skill synthesizes reference architectures with core primitives, interface protocols, and implementation roadmaps based on established patterns.",
    "seo_keywords": [
      "architecture synthesis",
      "agent framework design",
      "Claude Code architecture",
      "AI agent primitives",
      "LLM protocols",
      "software architecture",
      "agent execution loop",
      "Codex agent design"
    ],
    "actual_capabilities": [
      "Define core data primitives (Message, State, Result, Tool types) using Python patterns",
      "Specify interface protocols for LLM, Tool, and Memory components",
      "Create execution loop pseudocode with termination conditions",
      "Generate architecture diagrams using Mermaid syntax",
      "Produce implementation roadmaps with phased deliverables",
      "Generate project structure templates with documentation and examples"
    ],
    "limitations": [
      "Does not write code files to disk - provides guidance only",
      "Does not execute any code or run commands",
      "Does not integrate with external APIs or services",
      "Requires prerequisite analysis outputs from other skills"
    ],
    "use_cases": [
      {
        "target_user": "Framework Developers",
        "title": "Build Custom Agent Frameworks",
        "description": "Design and architect new agent frameworks with proper type safety and protocol definitions."
      },
      {
        "target_user": "AI Engineers",
        "title": "Document Architecture Decisions",
        "description": "Create reference architecture specifications for team review and implementation planning."
      },
      {
        "target_user": "Technical Architects",
        "title": "Evaluate Integration Patterns",
        "description": "Assess different protocol approaches for LLM, tool, and memory integration in agent systems."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Architecture",
        "scenario": "Generate architecture for new agent",
        "prompt": "Generate a reference architecture for a new AI agent framework. Include Message, State, and Tool types with Python examples, LLM and Tool protocols, and the execution loop pseudocode."
      },
      {
        "title": "With Prerequisites",
        "scenario": "Synthesize from prior analysis",
        "prompt": "Using the comparative matrix and anti-pattern catalog results, synthesize a reference architecture specification for our new agent framework. Include all core primitives, interface protocols, and a phased implementation roadmap."
      },
      {
        "title": "Complete Specification",
        "scenario": "Full architecture deliverable",
        "prompt": "Produce a complete reference architecture specification including: (1) core primitives with frozen dataclasses, (2) LLM/Tool/Memory protocols, (3) execution loop with step limits, (4) Mermaid architecture diagram, (5) 8-week implementation roadmap with phases."
      },
      {
        "title": "Integration Focus",
        "scenario": "Protocol specification",
        "prompt": "Create detailed interface protocols for integrating multiple LLM providers (OpenAI, Anthropic) with a consistent Tool protocol. Include protocol definitions, error handling patterns, and a Memory protocol for context management."
      }
    ],
    "output_examples": [
      {
        "input": "Generate a reference architecture for a new AI agent framework",
        "output": [
          "Core Primitives: Message (frozen, immutable), AgentState (copy-on-write), ToolResult, AgentFinish, AgentContinue",
          "LLM Protocol: generate() and stream() methods with LLMResponse containing content, tool_calls, usage, and raw response",
          "Tool Protocol: name, description, schema properties and execute() method",
          "Memory Protocol: add(), get_context(), clear() for context management",
          "Execution Loop: build messages -> call LLM -> parse response -> handle finish/continue -> emit events",
          "Architecture Diagram: Core Layer -> Protocol Layer -> Execution Layer -> Integration Layer",
          "Phase 1 (Weeks 1-2): Core types, LLM Protocol, basic Tool Protocol, minimal Agent loop",
          "Phase 2 (Weeks 3-4): Error handling, retry mechanisms, logging, callbacks, token counting",
          "Phase 3 (Weeks 5-6): Memory Protocol, vector store, tool registry, configuration system",
          "Phase 4 (Weeks 7-8): Tracing, streaming, rate limiting, async version, optimization"
        ]
      }
    ],
    "best_practices": [
      "Use immutable data structures (frozen=True, frozen=True dataclasses) to prevent state corruption",
      "Define clear protocol interfaces for LLM, Tool, and Memory to enable pluggable components",
      "Implement step limits and termination conditions to prevent infinite loops in agent execution"
    ],
    "anti_patterns": [
      "Mutating agent state directly instead of using copy-on-write pattern",
      "Hardcoding LLM provider instead of using protocol-based abstraction",
      "Skipping error handling and feedback loops in the execution loop"
    ],
    "faq": [
      {
        "question": "What platforms support this skill?",
        "answer": "This skill works with Claude, Codex, and Claude Code for architecture design tasks."
      },
      {
        "question": "What are the input requirements?",
        "answer": "Provide comparative matrix and anti-pattern catalog outputs for best results."
      },
      {
        "question": "Does this skill write files?",
        "answer": "No. This skill generates architectural guidance and code examples as text output."
      },
      {
        "question": "Is my data safe with this skill?",
        "answer": "Yes. No data is written, transmitted, or stored. Purely a prompt-based guidance skill."
      },
      {
        "question": "Why is my output truncated?",
        "answer": "Request specific sections (primitives, protocols, loop, diagram, roadmap) individually for detailed output."
      },
      {
        "question": "How does this compare to coding skills?",
        "answer": "This skill provides architectural guidance rather than writing executable code. Use with code generation skills for full implementation."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
