{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T09:42:20.227Z",
    "slug": "afi-protocol-extend-signal-schema",
    "source_url": "https://github.com/AFI-Protocol/afi-core/tree/main/.factory/skills/extend-signal-schema",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "49442be6c899aed59139dfdb103ebce5e574ebce9aca3c032cd19ad8ccd7400c",
    "tree_hash": "cce7a43c0ac618d30e7058bda51644ab22a2076ad02646f31821d7bede869df9"
  },
  "skill": {
    "name": "extend-signal-schema",
    "description": "Safely extend or refine AFI signal schemas and closely-related validators in afi-core, while preserving determinism, respecting PoI/PoInsight design, and obeying the AFI Droid Charter and AFI Core AGENTS.md boundaries.\n",
    "summary": "Safely extend or refine AFI signal schemas and closely-related validators in afi-core, while preserv...",
    "icon": "üìê",
    "version": "1.0.0",
    "author": "AFI-Protocol",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "schema",
      "validation",
      "typescript",
      "zod",
      "afi-core"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure prompt-based skill consisting only of documentation. No executable code, scripts, network calls, filesystem access, or command execution. The skill provides guidelines for schema extension with explicit safety boundaries and hard prohibitions against dangerous operations.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 376,
    "audit_model": "claude",
    "audited_at": "2026-01-10T09:42:20.227Z"
  },
  "content": {
    "user_title": "Extend AFI Signal Schemas",
    "value_statement": "Need to add new fields to signal schemas while maintaining backwards compatibility. This skill provides step-by-step guidance for safely extending Zod schemas, updating type exports, and adding validation logic with clear migration paths.",
    "seo_keywords": [
      "signal schema",
      "Zod validation",
      "TypeScript types",
      "schema extension",
      "Claude Code",
      "Claude",
      "Codex",
      "afi-core",
      "signal validation",
      "schema migration"
    ],
    "actual_capabilities": [
      "Add new fields to Raw, Enriched, Analyzed, or Scored signal schemas using Zod",
      "Update TypeScript type exports to match schema changes",
      "Add validation logic to existing validators when needed",
      "Include backwards compatibility considerations with migration strategies",
      "Add or update unit tests for new schema fields",
      "Validate changes with build and test commands"
    ],
    "limitations": [
      "Cannot modify orchestration logic in afi-reactor or DAG pipeline wiring",
      "Cannot introduce PoI/PoInsight as signal fields by design",
      "Cannot touch smart contracts, token economics, or Eliza agent configs",
      "Cannot perform large sweeping refactors without explicit approval"
    ],
    "use_cases": [
      {
        "target_user": "Schema Developer",
        "title": "Add new signal field",
        "description": "Add optional or required fields to signal schemas with proper type safety and validation rules."
      },
      {
        "target_user": "Core Maintainer",
        "title": "Refine existing schema",
        "description": "Refine field types, add enum values, or add validation constraints while preserving backwards compatibility."
      },
      {
        "target_user": "Test Engineer",
        "title": "Add schema tests",
        "description": "Add unit tests for new fields including valid and invalid value testing with clear coverage."
      }
    ],
    "prompt_templates": [
      {
        "title": "Add optional field",
        "scenario": "Enrich signal data",
        "prompt": "Add an optional macro_regime field to Enriched signals with enum values risk_on, risk_off, and neutral. Make it optional with a clear description."
      },
      {
        "title": "Add scored breakdown",
        "scenario": "Risk scoring",
        "prompt": "Extend the Scored schema to include a risk_breakdown object with sub-scores for market_risk, liquidity_risk, and execution_risk. Each should be a number between 0 and 1."
      },
      {
        "title": "Refine enum values",
        "scenario": "Action types",
        "prompt": "Refine the action field enum to include new values: buy, sell, hold, close, reduce. Update all related type exports."
      },
      {
        "title": "Required with default",
        "scenario": "Migration scenario",
        "prompt": "Make the content field required for all signals. Add a default empty string value for backwards compatibility and provide migration guidance."
      }
    ],
    "output_examples": [
      {
        "input": "Add an optional macro_regime field to Enriched signals with enum values risk_on, risk_off, and neutral.",
        "output": [
          "Stage modified: Enriched (via universal_signal_schema.ts)",
          "Field added: macro_regime - enum([\"risk_on\", \"risk_off\", \"neutral\"]), Optional",
          "Description: Macro regime classification for market sentiment",
          "Files modified: schemas/universal_signal_schema.ts, schemas/index.ts",
          "Build/test results: Pass",
          "Backwards compatibility: Safe (optional field)",
          "TODOs: None"
        ]
      }
    ],
    "best_practices": [
      "Always add fields as optional first when possible to maintain backwards compatibility",
      "Use clear comments explaining field purpose, when populated, and validation constraints",
      "Run build and tests after schema changes before marking the task complete",
      "Document migration strategy for any breaking changes with clear guidance"
    ],
    "anti_patterns": [
      "Silently renaming or removing existing fields without deprecation path",
      "Introducing PoI/PoInsight as signal fields against design principles",
      "Modifying orchestration or DAG wiring when only schema changes were requested",
      "Making breaking changes without explicit human approval and migration strategy"
    ],
    "faq": [
      {
        "question": "Which signal stages can I modify?",
        "answer": "You can extend schemas for Raw, Enriched, Analyzed, or Scored stages depending on when the field is populated."
      },
      {
        "question": "What validation rules can I add?",
        "answer": "Use Zod methods like .min(), .max(), .regex(), or .enum() to add validation rules to schema fields."
      },
      {
        "question": "How do I ensure backwards compatibility?",
        "answer": "Add new fields as optional or with .default(value). Document any breaking changes with migration guidance."
      },
      {
        "question": "Is my data safe when using this skill?",
        "answer": "This skill only modifies schema definitions. It does not access, transmit, or store any user data externally."
      },
      {
        "question": "Why did my build fail after schema changes?",
        "answer:": "Check that type exports are updated and any referencing files have correct imports. Run npm run build for full validation."
      },
      {
        "question": "How is this different from add-dag-node?",
        "answer": "extend-signal-schema modifies data structures. add-dag-node wires schemas into the pipeline execution flow in afi-reactor."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
