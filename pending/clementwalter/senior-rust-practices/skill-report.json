{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T12:23:54.987Z",
    "slug": "clementwalter-senior-rust-practices",
    "source_url": "https://github.com/ClementWalter/rookie-marketplace/tree/main/rust-dev/skills/senior-rust-practices",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "dccff8e34c4ba38c0d8a4aafebdbf254f666fe080965c247249f3266a2d5e7a5",
    "tree_hash": "7d32e680b22bd26f985a0bb8ddc8e685fb04c10bf90f533ed7f00d8f2821bf0d"
  },
  "skill": {
    "name": "Senior Rust Practices",
    "description": "This skill should be used when the user asks about \"rust workspace\", \"rust best practices\", \"cargo workspace setup\", \"rust code organization\", \"rust dependency management\", \"rust testing strategy\", \"rust project\", \"scalable rust\", \"rust CI setup\", or needs guidance on senior-level Rust development patterns, workspace design, code organization strategies, or production-ready Rust architectures.",
    "summary": "This skill should be used when the user asks about \"rust workspace\", \"rust best practices\", \"cargo w...",
    "icon": "ðŸ¦€",
    "version": "1.0.0",
    "author": "ClementWalter",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "rust",
      "architecture",
      "best-practices",
      "workspaces",
      "scaling"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a documentation-only skill containing Rust best practices and architectural guidance. No executable code, scripts, or network operations detected. The skill provides guidance on workspace organization, testing strategies, and development patterns.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 372,
    "audit_model": "claude",
    "audited_at": "2026-01-10T12:23:54.987Z"
  },
  "content": {
    "user_title": "Master Rust workspace architecture and best practices",
    "value_statement": "Struggling with Rust project organization? This skill provides battle-tested patterns for scalable workspace design, from prototype to production. Learn how senior developers structure large Rust codebases with clear boundaries and maintainable architecture.",
    "seo_keywords": [
      "rust workspace",
      "rust best practices",
      "cargo workspace",
      "rust architecture",
      "rust testing",
      "rust dependencies",
      "rust code organization",
      "claude rust",
      "codex rust",
      "claude code rust"
    ],
    "actual_capabilities": [
      "Provides workspace structure patterns for multi-crate projects",
      "Explains layered architecture with core, adapters, and app separation",
      "Details dependency management and feature flag strategies",
      "Outlines testing pyramids from unit to integration tests",
      "Includes CI/CD quality gates and tooling recommendations"
    ],
    "limitations": [
      "Focuses on workspace-level patterns, not basic Rust syntax",
      "Assumes familiarity with Cargo and Rust fundamentals",
      "Patterns may be overkill for simple single-crate projects"
    ],
    "use_cases": [
      {
        "target_user": "Senior developers",
        "title": "Design scalable Rust architecture",
        "description": "Structure large Rust projects with clear crate boundaries and maintainable dependencies for teams."
      },
      {
        "target_user": "Tech leads",
        "title": "Establish Rust coding standards",
        "description": "Define workspace conventions, testing strategies, and quality gates for Rust projects."
      },
      {
        "target_user": "DevOps engineers",
        "title": "Set up Rust CI/CD pipelines",
        "description": "Implement automated testing, linting, and security checks for Rust workspaces."
      }
    ],
    "prompt_templates": [
      {
        "title": "Workspace structure",
        "scenario": "Setting up a new Rust project",
        "prompt": "I need to create a Rust workspace for a web service with core business logic, database layer, and API handlers. What's the recommended structure?"
      },
      {
        "title": "Dependency management",
        "scenario": "Managing crate versions",
        "prompt": "How should I organize dependencies in a workspace to avoid version conflicts and keep builds fast?"
      },
      {
        "title": "Testing strategy",
        "scenario": "Implementing comprehensive tests",
        "prompt": "What's the best testing approach for a Rust workspace with multiple crates? How do I balance unit, integration, and e2e tests?"
      },
      {
        "title": "Production readiness",
        "scenario": "Preparing for deployment",
        "prompt": "What CI checks and quality gates should I implement for a production Rust service? Include tooling recommendations."
      }
    ],
    "output_examples": [
      {
        "input": "How should I structure a Rust workspace for a microservice with shared domain logic?",
        "output": [
          "Use a layered architecture with 4 crates:",
          "- core/: Pure domain logic, no IO dependencies",
          "- storage/: Database implementations with traits",
          "- api/: HTTP handlers and DTOs",
          "- cli/: Binary that wires everything together",
          "Keep core synchronous and free of tokio/sqlx dependencies"
        ]
      }
    ],
    "best_practices": [
      "Start with 2-5 crates maximum and split only when compile times become painful",
      "Use workspace dependencies to centralize version management",
      "Keep async code at the edges - make core logic synchronous when possible",
      "Always use tracing instead of println for proper observability"
    ],
    "anti_patterns": [
      "Creating too many small crates creates unnecessary complexity",
      "Leaking implementation details from core to other layers",
      "Using unwrap() in library code instead of proper error handling",
      "Putting IO operations in the core domain layer"
    ],
    "faq": [
      {
        "question": "When should I use a Rust workspace instead of a single crate?",
        "answer": "Use workspaces when you have multiple crates that ship together, need shared CI/tooling, or have different dependency profiles (no-std, WASM)."
      },
      {
        "question": "How many crates should I have in my workspace?",
        "answer": "Start with 2-5 crates maximum. Split only when you need separate release cycles, compile times are painful, or boundaries are well-defined."
      },
      {
        "question": "Can I use async/await in my core domain logic?",
        "answer": "Avoid async in core. Keep it synchronous and pure. Async should be at the edges (API, CLI) where IO operations happen."
      },
      {
        "question": "How do I manage dependencies across workspace crates?",
        "answer": "Use workspace.dependencies in the root Cargo.toml to centralize versions, then reference with workspace = true in each crate."
      },
      {
        "question": "What testing approach works best for workspaces?",
        "answer": "Use unit tests in each crate, integration tests at crate boundaries, and sparing e2e tests. Aim for a testing pyramid with most tests being fast unit tests."
      },
      {
        "question": "How does this compare to other Rust architecture guides?",
        "answer": "This focuses on practical, production-tested patterns rather than theoretical designs. It emphasizes keeping boundaries hard and starting simple."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
