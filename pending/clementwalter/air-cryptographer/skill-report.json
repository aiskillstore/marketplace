{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T12:16:57.440Z",
    "slug": "clementwalter-air-cryptographer",
    "source_url": "https://github.com/ClementWalter/rookie-marketplace/tree/main/air-cryptographer/skills/air-expertise",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "db6fa32ee39c4c7a8a44a2a6a9560ca8e4828612d1dc9973d3046cacb18ce7ad",
    "tree_hash": "92269537d598b040e1fa9c357dace0eb5b4b92679a23d9c41a034509a73112b0"
  },
  "skill": {
    "name": "AIR Cryptographer",
    "description": "This skill should be used when the user asks about \"AIR\", \"algebraic intermediate representation\", \"ZK constraints\", \"trace design\", \"constraint soundness\", \"polynomial commitments\", \"FRI\", \"STARK\", \"lookup arguments\", \"permutation arguments\", \"memory consistency\", \"transition constraints\", \"boundary constraints\", \"vanishing polynomial\", \"quotient polynomial\", \"Fiat-Shamir\", or needs expert-level cryptographic review of constraint systems.",
    "summary": "This skill should be used when the user asks about \"AIR\", \"algebraic intermediate representation\", \"...",
    "icon": "üîê",
    "version": "1.0.0",
    "author": "ClementWalter",
    "license": "MIT",
    "category": "security",
    "tags": [
      "cryptography",
      "zero-knowledge",
      "zk-proofs",
      "stark",
      "constraint-systems"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure knowledge-based skill containing only educational documentation about AIR cryptography. No executable code, no file access, no network calls, no external commands. Contains only markdown files with cryptographic expertise content.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 612,
    "audit_model": "claude",
    "audited_at": "2026-01-10T12:16:57.440Z"
  },
  "content": {
    "user_title": "Design and audit AIR constraint systems",
    "value_statement": "Zero-knowledge proof systems require mathematically sound AIR constraints. This skill provides expert guidance on trace design, boundary constraints, permutation arguments, and security review methodologies for ZK systems.",
    "seo_keywords": [
      "AIR cryptographer",
      "algebraic intermediate representation",
      "zero knowledge proof",
      "STARK protocol",
      "constraint system audit",
      "trace design",
      "polynomial commitment",
      "FRI",
      "Claude Code",
      "Claude"
    ],
    "actual_capabilities": [
      "Design trace columns with proper source, derived, and auxiliary classifications",
      "Define transition and boundary constraints with correct vanishing polynomials",
      "Implement permutation and lookup arguments using grand products",
      "Audit AIR soundness using systematic adversarial testing",
      "Analyze degree accounting for composition polynomial correctness",
      "Review Fiat-Shamir transcript binding and challenge separation"
    ],
    "limitations": [
      "Does not generate constraint code or proof implementations",
      "Does not execute or verify actual cryptographic implementations",
      "Does not provide legal or regulatory compliance advice",
      "Does not include performance benchmarking or optimization"
    ],
    "use_cases": [
      {
        "target_user": "ZK Protocol Developers",
        "title": "Design sound AIR constraints",
        "description": "Build constraint systems with proper boundary conditions, transition rules, and global consistency arguments."
      },
      {
        "target_user": "Security Auditors",
        "title": "Audit ZK constraint systems",
        "description": "Review AIR implementations for unconstrained columns, selector vulnerabilities, and soundness gaps."
      },
      {
        "target_user": "Cryptography Engineers",
        "title": "Apply advanced cryptographic arguments",
        "description": "Implement permutation arguments, lookup tables, and memory consistency checks with correctness proofs."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic AIR Question",
        "scenario": "Learning about AIR basics",
        "prompt": "Explain the difference between source, derived, and auxiliary columns in AIR trace design."
      },
      {
        "title": "Constraint Design",
        "scenario": "Building transition constraints",
        "prompt": "How do I write a transition constraint that ensures the program counter increments correctly only when not branching?"
      },
      {
        "title": "Security Review",
        "scenario": "Auditing an AIR implementation",
        "prompt": "What are the key red flags to look for when auditing AIR selectors and booleanity constraints?"
      },
      {
        "title": "Advanced Analysis",
        "scenario": "Deep security assessment",
        "prompt": "Walk me through the adversarial witness exercises: how would I test if all selectors equals zero creates a vulnerability?"
      }
    ],
    "output_examples": [
      {
        "input": "How do I check if my AIR has unconstrained columns?",
        "output": [
          "Trace column inventory: List every column with its meaning, source type (source/derived/auxiliary), and where it is constrained",
          "Red flag: Columns that are only documented but never actually referenced in any constraint",
          "Critical rule: Every column must appear in at least one constraint equation",
          "Check derived columns: Their derivation constraint must be complete, not gated by unconstrained selectors",
          "Adversarial test: Attempt to construct a trace where one column varies freely while all constraints pass"
        ]
      }
    ],
    "best_practices": [
      "Start with a one-page summary: claimed statement, trace length handling, public inputs placement, and prover freedom degrees",
      "Enforce selector exclusivity using s(s-1)=0 for booleanity and sum(s_i)=1 for mutual exclusivity",
      "Always bound challenges in the transcript before they are used, with separate challenges for different arguments"
    ],
    "anti_patterns": [
      "Leaving selectors unconstrained (allows vacuous constraints when all selectors are zero)",
      "Using the same Fiat-Shamir challenge for multiple arguments (enables algebraic cancellation)",
      "Defining \"final row\" without unique identification (allows prover to dump inconsistencies)"
    ],
    "faq": [
      {
        "question": "What AIR frameworks are supported?",
        "answer": "This skill covers general AIR principles applicable to any ZK framework including Cairo, Stwo, Plonky3, and custom implementations."
      },
      {
        "question": "What trace lengths are supported?",
        "answer": "Fixed and variable length traces. Variable length requires explicit halt handling and trace length binding into the Fiat-Shamir transcript."
      },
      {
        "question": "How does this integrate with existing ZK tools?",
        "answer": "Provides architectural guidance compatible with constraint compilers, provers, and verifiers. Does not replace implementation code."
      },
      {
        "question": "Is data stored or transmitted?",
        "answer": "No. This is a knowledge-only skill with no file access, network calls, or data persistence capabilities."
      },
      {
        "question": "Why is my AIR failing FRI?",
        "answer": "Common causes: constraint polynomial does not vanish on domain (quotient has poles), degree exceeds domain size, or missing boundary constraints on composition."
      },
      {
        "question": "How does this compare to formal verification?",
        "answer": "Provides security review methodology for human analysis. Complements but does not replace automated formal verification tools."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "review-checklist.md",
          "type": "file",
          "path": "references/review-checklist.md"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
