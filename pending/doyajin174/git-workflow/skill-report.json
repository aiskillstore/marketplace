{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T14:19:28.881Z",
    "slug": "doyajin174-git-workflow",
    "source_url": "https://github.com/Doyajin174/myskills/tree/main/.public/skills/git-workflow",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "e12cab7bcec4ec42edc02e921334152cb0bfa16f0af39c34959495082743faf3",
    "tree_hash": "807a5f3c4ecd3b886f022b76c440aeae88c718f1088c0725a003ffea0ffd007d"
  },
  "skill": {
    "name": "git-workflow",
    "description": "Complete Git workflow from conventional commits to pre-completion verification. Use for all Git operations including commits, branches, and releases.",
    "summary": "Complete Git workflow from conventional commits to pre-completion verification. Use for all Git oper...",
    "icon": "ðŸ”€",
    "version": "1.0.0",
    "author": "Doyajin174",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "git",
      "version-control",
      "workflow",
      "commits",
      "devops"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill with no executable code. Contains only markdown guidance on Git workflow best practices. No scripts, network calls, filesystem access beyond its own files, or code execution capabilities.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 119,
    "audit_model": "claude",
    "audited_at": "2026-01-10T14:19:28.881Z"
  },
  "content": {
    "user_title": "Master Git workflow with conventional commits",
    "value_statement": "Developers struggle with inconsistent commit messages and branch naming. This skill provides standardized Git workflows including conventional commits, branch strategies, and pre-completion verification checklists to ensure clean, traceable code changes.",
    "seo_keywords": [
      "git workflow",
      "conventional commits",
      "git branch strategy",
      "git best practices",
      "commit message format",
      "git commit",
      "claude git",
      "codex git",
      "claude-code workflow"
    ],
    "actual_capabilities": [
      "Guide conventional commit format with type, scope, and description",
      "Provide branch naming conventions for features, fixes, and refactors",
      "Offer pre-completion verification checklist for code quality",
      "Document breaking change notation and footer conventions",
      "Suggest git add, commit, and push workflow sequence",
      "Explain test, lint, and build verification before push"
    ],
    "limitations": [
      "Does not execute git commands directly",
      "Does not interact with remote repositories automatically",
      "Does not provide merge conflict resolution",
      "Does not create branches or commits on behalf of user"
    ],
    "use_cases": [
      {
        "target_user": "Individual developers",
        "title": "Write clean commits",
        "description": "Learn conventional commit format to create traceable, auto-changelog-friendly commit history"
      },
      {
        "target_user": "Team leads",
        "title": "Enforce team standards",
        "description": "Establish consistent branch naming and commit message conventions across development teams"
      },
      {
        "target_user": "CI/CD engineers",
        "title": "Verify before push",
        "description": "Follow pre-completion checklists ensuring tests, linting, and builds pass before code reaches remote"
      }
    ],
    "prompt_templates": [
      {
        "title": "Create a feature commit",
        "scenario": "Making a new feature change",
        "prompt": "Help me write a conventional commit for adding user authentication. Include type, scope, and description."
      },
      {
        "title": "Document breaking change",
        "scenario": "Releasing API changes",
        "prompt": "I need to create a breaking change commit for my API. Show me the correct format with footer."
      },
      {
        "title": "Verify before push",
        "scenario": "Preparing to push code",
        "prompt": "What are the pre-completion verification steps I should run before pushing my git changes?"
      },
      {
        "title": "Branch naming",
        "scenario": "Starting new work",
        "prompt": "What is the proper naming convention for a branch that fixes bug issue-123?"
      }
    ],
    "output_examples": [
      {
        "input": "Help me create a conventional commit for adding user login",
        "output": [
          "feat(auth): add user login functionality",
          "",
          "Implement JWT-based authentication with email/password",
          "",
          "Closes #45"
        ]
      }
    ],
    "best_practices": [
      "Use semantic commit types: feat for features, fix for bug fixes, refactor for restructuring",
      "Always run tests and linting before committing to catch issues early",
      "Include issue numbers in commit messages for traceability"
    ],
    "anti_patterns": [
      "Using generic commit messages like 'fixed stuff' or 'update'",
      "Committing directly to main branch without code review",
      "Skipping pre-completion checks and pushing broken code"
    ],
    "faq": [
      {
        "question": "What are the supported commit types?",
        "answer": "Six types: feat, fix, refactor, docs, test, and chore. Each serves a specific purpose in tracking changes."
      },
      {
        "question": "What is the maximum line length for commit messages?",
        "answer": "Keep subject lines under 72 characters. Wrap body text at 80 characters for readability."
      },
      {
        "question": "How do I integrate with changelog tools?",
        "answer": "Conventional commits auto-generate changelogs when using semantic-release or similar tools."
      },
      {
        "question": "Is my data safe with this skill?",
        "answer": "This is a read-only documentation skill. It only reads its own files and provides guidance. No code execution."
      },
      {
        "question": "Why are my commits not being recognized?",
        "answer": "Ensure format follows: type(scope): description. Check for typos in type names like feat or fix."
      },
      {
        "question": "How does this compare to gitmoji?",
        "answer": "Conventional commits use text labels while gitmoji uses emojis. Both are valid; conventional is more explicit."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
