{
  "user_title": "Design Type-Safe APIs with OpenAPI Schema-First Approach",
  "value_statement": "Building APIs without proper contracts leads to frontend-backend integration issues and costly rework. This skill enables teams to design APIs collaboratively using OpenAPI/Swagger specifications, generating TypeScript types and clients automatically while ensuring type safety throughout the development lifecycle.",
  "seo_keywords": [
    "OpenAPI",
    "Swagger",
    "API design",
    "TypeScript",
    "schema-first",
    "API documentation",
    "code generation",
    "React Query",
    "Zod validation",
    "mock server"
  ],
  "actual_capabilities": [
    "Create comprehensive OpenAPI 3.1 specifications with paths, schemas, and security definitions",
    "Generate TypeScript types from OpenAPI specs using openapi-typescript",
    "Build type-safe API clients with openapi-fetch or Orval code generation",
    "Implement request/response validation using Zod schemas derived from OpenAPI",
    "Set up interactive API documentation with Swagger UI or Scalar",
    "Create mock servers for parallel frontend-backend development using Prism"
  ],
  "limitations": [
    "Requires initial time investment to write specifications before coding",
    "Complex nested schemas may need manual adjustments after generation",
    "Version management requires careful planning when breaking changes occur",
    "Generated code may need customization for specific business logic"
  ],
  "use_cases": [
    {
      "target_user": "Full-stack developers building new applications",
      "scenario": "You're starting a React/Node.js project and want frontend and backend teams to work in parallel. Use this skill to design the API contract first, generate TypeScript types for both ends, and create a mock server for frontend development while backend implements the actual endpoints."
    },
    {
      "target_user": "Backend engineers documenting existing APIs",
      "scenario": "Your team has a legacy REST API without proper documentation. Use this skill to reverse-engineer the API into an OpenAPI spec, generate interactive documentation, and add type safety to existing endpoints without breaking current implementations."
    },
    {
      "target_user": "API architects standardizing microservices",
      "scenario": "You're managing multiple microservices with inconsistent API patterns. Use this skill to create a standardized OpenAPI template, enforce consistent error handling and pagination patterns, and generate consistent SDKs across all services."
    }
  ],
  "prompt_templates": [
    {
      "level": "beginner",
      "prompt": "Create a basic OpenAPI spec for a todo API with CRUD operations. Include endpoints for listing todos, creating a todo (title, description, dueDate), updating status, and deleting. Define proper schemas and use 400/404 error responses."
    },
    {
      "level": "intermediate",
      "prompt": "Design an OpenAPI spec for an e-commerce product API with advanced features: filtering by category/price range, pagination with cursor-based navigation, search with fuzzy matching, image upload endpoints, and bulk operations. Include proper security schemes and rate limiting headers."
    },
    {
      "level": "advanced",
      "prompt": "Create a complete OpenAPI 3.1 specification for a real-time chat API using WebSocket endpoints, including: message threading, file attachments with presigned URLs, read receipts, typing indicators, message reactions, and thread-specific notifications. Implement discriminator patterns for different message types and use oneOf/anyOf for flexible schemas. Add comprehensive security with OAuth2 and API keys."
    },
    {
      "level": "expert",
      "prompt": "Design a multi-tenant SaaS API with OpenAPI 3.1 featuring: tenant isolation via headers, complex RBAC with 50+ permissions, webhook subscriptions with HMAC verification, GraphQL gateway integration, API versioning via content negotiation, request/response transformation middleware, and custom DSL for business rules. Include x- extensions for code generation hints and implement advanced patterns like polymorphic responses, conditional schemas based on headers, and reusable components across 200+ endpoints."
    }
  ],
  "output_example": {
    "title": "Generated Pet Store API Implementation",
    "description": "Complete TypeScript implementation with types, client, and validation",
    "content": "```typescript\n// Generated types from OpenAPI spec\nexport interface Pet {\n  id: number;\n  name: string;\n  category?: Category;\n  photoUrls: string[];\n  tags?: Tag[];\n  status?: 'available' | 'pending' | 'sold';\n}\n\n// Type-safe API client\nimport createClient from 'openapi-fetch';\nconst client = createClient<paths>({ baseUrl: '/api/v1' });\n\n// Usage with full type safety\nconst { data, error } = await client.GET('/pets/{petId}', {\n  params: { path: { petId: 123 } }\n});\n\n// Zod validation schema\nimport { z } from 'zod';\nconst PetSchema = z.object({\n  id: z.number(),\n  name: z.string().min(1),\n  status: z.enum(['available', 'pending', 'sold']).optional()\n});\n\n// Interactive documentation available at /api-docs\n```\n\n**Generated Files:**\n- `types/api.ts` - Complete TypeScript definitions\n- `lib/api-client.ts` - Type-safe fetch client\n- `schemas/validation.ts` - Zod schemas for validation\n- `api-docs/` - Interactive Swagger UI documentation"
  },
  "best_practices": [
    "Always define operationId for each endpoint to ensure consistent code generation and better developer experience",
    "Use $ref references to split large specs into manageable files, organizing by paths, schemas, and responses",
    "Include comprehensive examples in your schemas to improve documentation quality and help with testing"
  ],
  "anti_patterns": [
    "Don't mix schema-first and code-first approaches in the same project - it leads to inconsistencies and defeats the purpose of contract-driven development",
    "Avoid creating overly complex nested schemas without proper documentation - they become difficult to maintain and understand",
    "Don't skip the review process - API contracts should be treated as critical code requiring peer review before implementation"
  ],
  "faqs": [
    {
      "question": "Which OpenAPI versions are supported?",
      "answer": "The skill focuses on OpenAPI 3.1.0 which offers the latest features including JSON Schema 2020-12 support, webhooks, and improved examples. For legacy projects, most tools also support 3.0.x versions."
    },
    {
      "question": "What's the maximum API size this can handle?",
      "answer": "While there's no hard limit, specs with 1000+ endpoints may experience slower generation times. For large APIs, it's recommended to split into multiple services with separate specs and use composite references."
    },
    {
      "question": "How do I integrate this with my existing Express.js/FastAPI/NestJS backend?",
      "answer": "The generated OpenAPI spec can be used with any backend framework. For Express, use middleware like express-openapi-validator. For FastAPI, it can generate from your code or validate against your spec. NestJS has built-in OpenAPI support via @nestjs/swagger."
    },
    {
      "question": "How is my API specification data handled?",
      "answer": "All processing happens locally in your development environment. The skill helps generate specs and code locally without sending your API designs to external services, ensuring your API contracts remain private and secure."
    },
    {
      "question": "What if the generated TypeScript types are incorrect?",
      "answer": "First verify your OpenAPI spec is valid using Swagger Editor. For edge cases, you can extend generated types using TypeScript's declaration merging or create mapped types. The community-maintained openapi-typescript also accepts bug reports for generation issues."
    },
    {
      "question": "How does this compare to GraphQL or tRPC?",
      "answer": "OpenAPI excels at public API design with multiple consumers, while GraphQL is better for client-driven data fetching. tRPC offers better type safety for TypeScript monorepos but locks you into TypeScript. OpenAPI provides language-agnostic contracts with broader ecosystem support."
    }
  ]
}