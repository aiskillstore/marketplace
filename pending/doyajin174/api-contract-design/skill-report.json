{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T14:26:26.710Z",
    "slug": "doyajin174-api-contract-design",
    "source_url": "https://github.com/Doyajin174/myskills/tree/main/.public/skills/api-contract-design",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "146410c7c0696a27ca12308c03271cdf308582741c063721ee2fdcec3569abdf",
    "tree_hash": "6a59849b7514a4956c210482534b0fab49a97d3edf3ec5b2f89b7bd9f6f577cf"
  },
  "skill": {
    "name": "api-contract-design",
    "description": "Design APIs using schema-first approach with OpenAPI/Swagger. Use when creating new APIs, documenting existing ones, or when frontend/backend teams need to work in parallel. Covers OpenAPI spec, validation, and code generation.",
    "summary": "Design APIs using schema-first approach with OpenAPI/Swagger. Use when creating new APIs, documentin...",
    "icon": "ðŸ“‹",
    "version": "1.0.0",
    "author": "Doyajin174",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "openapi",
      "swagger",
      "api-design",
      "typescript",
      "schema-first"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a documentation-only skill containing educational content about API contract design. No executable code, network calls, file access, or external commands were found. The skill provides guidance on OpenAPI specification writing, TypeScript type generation, and API development workflows.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 517,
    "audit_model": "claude",
    "audited_at": "2026-01-10T14:26:26.710Z"
  },
  "content": {
    "user_title": "Design Type-Safe APIs with OpenAPI Schema-First Approach",
    "value_statement": "Frontend and backend teams often struggle with integration issues when APIs are undefined or change frequently. This skill enables collaborative API design using OpenAPI specifications, generating TypeScript types and clients automatically for type-safe development.",
    "seo_keywords": [
      "OpenAPI design",
      "Swagger specification",
      "TypeScript API client",
      "schema-first development",
      "React Query integration",
      "Claude Code API",
      "Codex OpenAPI",
      "API documentation",
      "TypeScript types",
      "Zod validation"
    ],
    "actual_capabilities": [
      "Create OpenAPI 3.1 specifications with paths, schemas, and responses",
      "Generate TypeScript types from OpenAPI specs using openapi-typescript",
      "Build type-safe API clients with openapi-fetch",
      "Implement request validation with Zod schemas",
      "Set up interactive API documentation with Swagger UI or Scalar",
      "Create mock servers for frontend development"
    ],
    "limitations": [
      "Requires initial time investment to write comprehensive API specifications",
      "Learning curve for OpenAPI specification syntax and best practices",
      "Generated code may need customization for complex business logic",
      "Maintaining spec consistency across large teams requires discipline"
    ],
    "use_cases": [
      {
        "target_user": "Full-stack developers",
        "title": "Build New Applications with API-First Design",
        "description": "Design your entire API contract before writing code, enabling frontend and backend development in parallel with type safety throughout."
      },
      {
        "target_user": "Backend engineers",
        "title": "Document and Standardize Existing APIs",
        "description": "Create comprehensive OpenAPI specifications for legacy APIs, adding validation and generating client SDKs for consumers."
      },
      {
        "target_user": "API architects",
        "title": "Establish API Standards Across Microservices",
        "description": "Define consistent API patterns, versioning strategies, and documentation standards for organization-wide adoption."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Todo API",
        "scenario": "Creating a simple todo management API",
        "prompt": "Help me design a RESTful API for a todo application using OpenAPI 3.1. Include endpoints for creating, reading, updating, and deleting todos. Each todo should have id, title, description, completed status, and timestamps. Add proper error responses and validation."
      },
      {
        "title": "E-commerce Product API",
        "scenario": "Building product catalog with categories",
        "prompt": "Design an OpenAPI specification for an e-commerce product API. Include product CRUD operations, category management, product search with filters, pagination, and image upload endpoints. Define proper schemas for product variants, inventory, and pricing."
      },
      {
        "title": "Real-time Chat API",
        "scenario": "WebSocket-enabled messaging platform",
        "prompt": "Create an OpenAPI spec for a chat application with REST endpoints for user management, chat rooms, and message history. Include WebSocket events for real-time messaging. Add authentication, rate limiting, and file sharing capabilities."
      },
      {
        "title": "Multi-tenant SaaS API",
        "scenario": "Enterprise SaaS with organizations",
        "prompt": "Design a comprehensive OpenAPI 3.1 specification for a multi-tenant SaaS platform. Include tenant isolation, role-based access control, subscription management, audit logging, webhooks, and bulk operations. Use advanced OpenAPI features like discriminators and polymorphism."
      }
    ],
    "output_examples": [
      {
        "input": "Create an OpenAPI specification for a user authentication API with JWT tokens",
        "output": [
          "OpenAPI 3.1 specification with /auth/login, /auth/register, /auth/refresh, and /auth/logout endpoints",
          "TypeScript types automatically generated: LoginRequest, LoginResponse, UserProfile, JWTPayload",
          "Type-safe API client code with proper error handling and token management",
          "Zod validation schemas for request body validation",
          "Interactive Swagger UI documentation at /api-docs with try-it-now functionality",
          "Mock server running on port 3001 for frontend development"
        ]
      }
    ],
    "best_practices": [
      "Always use descriptive operationId values that clearly indicate the action (e.g., createUser, getUserById)",
      "Organize large specifications by splitting paths and schemas into separate files with clear naming conventions",
      "Include comprehensive examples in your schemas to help consumers understand expected data formats"
    ],
    "anti_patterns": [
      "Avoid mixing schema-first and code-first approaches within the same project - choose one and stick to it",
      "Don't skip the team review process - API contracts should be agreed upon before implementation begins",
      "Never expose sensitive data like passwords or API keys in your OpenAPI examples or documentation"
    ],
    "faq": [
      {
        "question": "Which OpenAPI version should I use?",
        "answer": "Use OpenAPI 3.1.0 for new projects. It supports the latest JSON Schema features and is backwards compatible with most tools."
      },
      {
        "question": "How do I handle API versioning?",
        "answer": "Use URL versioning (/v1, /v2) or header-based versioning. Document deprecation policies and maintain backward compatibility when possible."
      },
      {
        "question": "Can I integrate this with my existing React Query setup?",
        "answer": "Yes, use Orval to generate React Query hooks directly from your OpenAPI spec, maintaining type safety throughout your application."
      },
      {
        "question": "Is my API specification data safe?",
        "answer": "The skill only helps you write specifications locally. No API data or specifications are sent to external services during the design process."
      },
      {
        "question": "What if my generated types don't match my backend implementation?",
        "answer": "The schema-first approach ensures your backend implements the spec. Use the generated types as the source of truth and update your backend to match."
      },
      {
        "question": "How does this compare to GraphQL?",
        "answer": "OpenAPI is better for public APIs and standard REST patterns. GraphQL offers more flexibility for complex queries but requires a steeper learning curve."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
