%a{annotate:rdoc:source:from=lib/resolv.rb}
class Resolv
  def self.each_address: (String name) { (String) -> void } -> void

  def self.each_name: (String address) { (String) -> void } -> void

  def self.getaddress: (String name) -> String

  def self.getaddresses: (String name) -> Array[String]

  def self.getname: (String address) -> String

  def self.getnames: (String address) -> Array[String]

  def each_address: (String name) { (String) -> void } -> void

  def each_name: (String name) { (String) -> void } -> void

  def getaddress: (String name) -> String

  def getaddresses: (String name) -> Array[String]

  def getname: (String address) -> String

  def getnames: (String address) -> Array[String]

  private

  def initialize: (?Resolv::Hosts | Resolv::DNS resolvers) -> untyped
end

Resolv::AddressRegex: Regexp

Resolv::DefaultResolver: Resolv

class Resolv::DNS
  type ip_address = Resolv::IPv4 | Resolv::IPv6

  type dns_name = Name | String

  def self.allocate_request_id: (String host, Integer port) -> Integer

  def self.bind_random_port: (UDPSocket udpsock, ?String bind_host) -> void

  def self.free_request_id: (String host, Integer port, Integer id) -> void

  def self.open: (*untyped args) -> instance
               | (*untyped args) { (instance) -> void } -> void

  def self.random: (Integer arg) -> (Integer | Float)

  def close: () -> untyped

  def each_address: (dns_name name) { (ip_address) -> void } -> void

  def each_name: (ip_address | dns_name address) { (Resolv::DNS::Name) -> void } -> void

  def each_resource: (dns_name name, singleton(Resolv::DNS::Query) typeclass) { (Resolv::DNS::Resource) -> void } -> void

  def extract_resources: (Resolv::DNS::Message msg, dns_name name, singleton(Resolv::DNS::Query) typeclass) { (Resolv::DNS::Resource) -> void } -> void

  def fetch_resource: (Resolv::DNS::Name name, singleton(Resolv::DNS::Query) typeclass) { (Resolv::DNS::Message, Resolv::DNS::Name) -> void } -> void

  def getaddress: (dns_name name) -> ip_address

  def getaddresses: (dns_name name) -> Array[ip_address]

  def getname: (ip_address | dns_name address) -> Resolv::DNS::Name

  def getnames: (ip_address | dns_name address) -> Array[Resolv::DNS::Name]

  def getresource: (dns_name name, singleton(Resolv::DNS::Query) typeclass) -> Resolv::DNS::Resource

  def getresources: (dns_name name, singleton(Resolv::DNS::Query) typeclass) -> Array[Resolv::DNS::Resource]

  def lazy_initialize: () -> untyped

  def make_tcp_requester: (String host, Integer port) -> Requester::TCP

  def make_udp_requester: () -> (Requester::ConnectedUDP | Requester::UnconnectedUDP)

  def timeouts=: (Integer | Float | Array[Integer | Float] values) -> void

  private

  def initialize: (?String | Hash[Symbol, untyped] config_info) -> untyped

  def use_ipv6?: () -> untyped
end

Resolv::DNS::Port: Integer

Resolv::DNS::RequestID: Hash[untyped, untyped]

Resolv::DNS::RequestIDMutex: Thread::Mutex

Resolv::DNS::UDPSize: Integer

class Resolv::DNS::Config
  def self.default_config_hash: (?String filename) -> Hash[Symbol, untyped]

  def self.parse_resolv_conf: (String filename) -> Hash[Symbol, untyped]

  def generate_candidates: (String name) -> Array[Resolv::DNS::Name]

  def generate_timeouts: () -> Array[Integer | Float]

  def lazy_initialize: () -> void

  def nameserver_port: () -> Array[[ String, Integer ]]

  def resolv: (String name) { (Resolv::DNS::Name, Integer, String, Integer) -> void } -> void

  def single?: () -> [ String, Integer ]?

  def timeouts=: (Integer | Float | Array[Integer | Float] values) -> void

  private

  def initialize: (?String | Hash[Symbol, untyped] config_info) -> untyped
end

Resolv::DNS::Config::InitialTimeout: Integer

class Resolv::DNS::Config::NXDomain < Resolv::ResolvError
end

class Resolv::DNS::Config::OtherResolvError < Resolv::ResolvError
end

class Resolv::DNS::DecodeError < StandardError
end

class Resolv::DNS::EncodeError < StandardError
end

module Resolv::DNS::Label
  def self.split: (untyped arg) -> untyped
end

class Resolv::DNS::Label::Str
  def eql?: (Resolv::DNS::Label::Str other) -> bool

  def downcase: () -> String

  alias == eql?

  def hash: () -> Integer

  def inspect: () -> String

  def string: () -> String

  def to_s: () -> String

  private

  def initialize: (String string) -> untyped
end

class Resolv::DNS::Message
  def self.decode: (String m) -> instance

  def ==: (self other) -> bool

  def aa: () -> Integer

  def aa=: (Integer) -> void

  def add_additional: (String name, Integer ttl, Resolv::DNS::Resource data) -> void

  def add_answer: (String name, Integer ttl, Resolv::DNS::Resource data) -> void

  def add_authority: (String name, Integer ttl, Resolv::DNS::Resource data) -> void

  def add_question: (String name, singleton(Resolv::DNS::Query) typeclass) -> void

  def additional: () -> Array[[ Resolv::DNS::Name, Integer, Resolv::DNS::Resource ]]

  def answer: () -> Array[[ Resolv::DNS::Name, Integer, Resolv::DNS::Resource ]]

  def authority: () -> Array[[ Resolv::DNS::Name, Integer, Resolv::DNS::Resource ]]

  def each_additional: () { (Resolv::DNS::Name, Integer, Resolv::DNS::Resource) -> void } -> void

  def each_answer: () { (Resolv::DNS::Name, Integer, Resolv::DNS::Resource) -> void } -> void

  def each_authority: () { (Resolv::DNS::Name, Integer, Resolv::DNS::Resource) -> void } -> void

  def each_question: () { (Resolv::DNS::Name, singleton(Resolv::DNS::Query)) -> void } -> void

  def each_resource: () { (Resolv::DNS::Name, Integer, Resolv::DNS::Resource) -> void } -> void

  def encode: () -> String

  def id: () -> Integer

  def id=: (Integer) -> void

  def opcode: () -> Integer

  def opcode=: (Integer) -> void

  def qr: () -> Integer

  def qr=: (Integer) -> void

  def question: () -> Array[[ Resolv::DNS::Name, singleton(Resolv::DNS::Resource) ]]

  def ra: () -> Integer

  def ra=: (Integer) -> void

  def rcode: () -> Integer

  def rcode=: (Integer) -> void

  def rd: () -> Integer

  def rd=: (Integer) -> void

  def tc: () -> Integer

  def tc=: (Integer) -> void

  private

  def initialize: (?Integer id) -> untyped
end

class Resolv::DNS::Message::MessageDecoder
  def get_bytes: (?Integer len) -> String

  def get_label: () -> Resolv::DNS::Label::Str

  def get_labels: () -> Array[Resolv::DNS::Label::Str]

  def get_length16: () { (Integer) -> Integer } -> Integer

  def get_name: () -> Resolv::DNS::Name

  def get_question: () -> Resolv::DNS::Query

  def get_rr: () -> [ Resolv::DNS::Name, Integer, Resolv::DNS::Resource ]

  def get_string: () -> String

  def get_string_list: () -> Array[String]

  def get_unpack: (String template) -> Array[untyped]

  def inspect: () -> String

  private

  def initialize: (String data) { (self) -> void } -> untyped
end

class Resolv::DNS::Message::MessageEncoder
  def put_bytes: (string d) -> void

  def put_label: (_ToS d) -> void

  def put_labels: (Array[_ToS] d) -> void

  def put_length16: () { () -> void } -> void

  def put_name: (Resolv::DNS::Name d) -> void

  def put_pack: (String template, *untyped d) -> void

  def put_string: (String d) -> void

  def put_string_list: (_Each[String] ds) -> void

  def to_s: () -> untyped

  private

  def initialize: () -> untyped
end

class Resolv::DNS::Name
  def self.create: (Resolv::DNS::dns_name arg) -> untyped

  def ==: (self other) -> bool

  def []: (Integer i) -> Resolv::DNS::Label::Str?

  def absolute?: () -> bool

  alias eql? ==

  def hash: () -> Integer

  def inspect: () -> String

  def length: () -> Integer

  def subdomain_of?: (self other) -> bool

  def to_a: () -> Array[Resolv::DNS::Label::Str]

  def to_s: () -> untyped

  private

  def initialize: (Array[Resolv::DNS::Label::Str] labels, ?bool absolute) -> untyped
end

module Resolv::DNS::OpCode
end

Resolv::DNS::OpCode::IQuery: Integer

Resolv::DNS::OpCode::Notify: Integer

Resolv::DNS::OpCode::Query: Integer

Resolv::DNS::OpCode::Status: Integer

Resolv::DNS::OpCode::Update: Integer

class Resolv::DNS::Query
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void
end

module Resolv::DNS::RCode
end

Resolv::DNS::RCode::BADALG: Integer

Resolv::DNS::RCode::BADKEY: Integer

Resolv::DNS::RCode::BADMODE: Integer

Resolv::DNS::RCode::BADNAME: Integer

Resolv::DNS::RCode::BADSIG: Integer

Resolv::DNS::RCode::BADTIME: Integer

Resolv::DNS::RCode::BADVERS: Integer

Resolv::DNS::RCode::FormErr: Integer

Resolv::DNS::RCode::NXDomain: Integer

Resolv::DNS::RCode::NXRRSet: Integer

Resolv::DNS::RCode::NoError: Integer

Resolv::DNS::RCode::NotAuth: Integer

Resolv::DNS::RCode::NotImp: Integer

Resolv::DNS::RCode::NotZone: Integer

Resolv::DNS::RCode::Refused: Integer

Resolv::DNS::RCode::ServFail: Integer

Resolv::DNS::RCode::YXDomain: Integer

Resolv::DNS::RCode::YXRRSet: Integer

class Resolv::DNS::Requester
  def close: () -> void

  def request: (Resolv::DNS::Requester::Sender sender, Numeric tout) -> [ Resolv::DNS::Message, String ]

  def sender_for: (String addr, Resolv::DNS::Message msg) -> Resolv::DNS::Requester::Sender

  private

  def initialize: () -> untyped
end

class Resolv::DNS::Requester::ConnectedUDP < Resolv::DNS::Requester
  def close: () -> void

  def lazy_initialize: () -> void

  def recv_reply: (Array[UDPSocket] readable_socks) -> [ String, String ]

  def sender: (Resolv::DNS::Message msg, String data, ?String host, ?Integer port) -> Resolv::DNS::Requester::Sender

  private

  def initialize: (String host, ?Integer port) -> untyped
end

class Resolv::DNS::Requester::ConnectedUDP::Sender < Resolv::DNS::Requester::Sender
  def data: () -> String

  def send: () -> void
end

class Resolv::DNS::Requester::MDNSOneShot < Resolv::DNS::Requester::UnconnectedUDP
  def sender: (Resolv::DNS::Message msg, String data, ?String host, ?Integer port) -> Resolv::DNS::Requester::Sender

  def recv_reply: (Array[UDPSocket] readable_socks) -> [ String, String ]
end

class Resolv::DNS::Requester::RequestError < StandardError
end

class Resolv::DNS::Requester::Sender
  private

  def initialize: (Resolv::DNS::Message msg, String data, Socket sock) -> untyped
end

class Resolv::DNS::Requester::TCP < Resolv::DNS::Requester
  def close: () -> untyped

  def recv_reply: (Array[TCPSocket] readable_socks) -> [ String, String ]

  def sender: (Resolv::DNS::Message msg, String data, ?String host, ?Integer port) -> Resolv::DNS::Requester::Sender

  private

  def initialize: (String host, ?Integer port) -> untyped
end

class Resolv::DNS::Requester::TCP::Sender < Resolv::DNS::Requester::Sender
  def data: () -> String

  def send: () -> void
end

class Resolv::DNS::Requester::UnconnectedUDP < Resolv::DNS::Requester
  def close: () -> void

  def lazy_initialize: () -> void

  def recv_reply: (Array[UDPSocket] readable_socks) -> [ String, String ]

  def sender: (Resolv::DNS::Message msg, String data, ?String host, ?Integer port) -> Resolv::DNS::Requester::Sender

  private

  def initialize: (*[ String, Integer ] nameserver_port) -> untyped
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender < Resolv::DNS::Requester::Sender
  def data: () -> String

  def send: () -> void

  private

  def initialize: (Resolv::DNS::Message msg, String data, UDPSocket sock, String host, Integer port) -> untyped
end

class Resolv::DNS::Resource < Resolv::DNS::Query
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def self.get_class: (Integer type_value, Integer class_value) -> self

  def eql?: (Resolv::DNS::Resource other) -> bool

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  alias == eql?

  def hash: () -> Integer

  def ttl: () -> Integer
end

Resolv::DNS::Resource::ClassHash: Hash[[ Integer, Integer ], singleton(Resolv::DNS::Resource)]

Resolv::DNS::Resource::ClassInsensitiveTypes: Array[singleton(Resolv::DNS::Resource)]

Resolv::DNS::Resource::ClassValue: Integer?

class Resolv::DNS::Resource::ANY < Resolv::DNS::Query
end

Resolv::DNS::Resource::ANY::TypeValue: Integer

class Resolv::DNS::Resource::CNAME < Resolv::DNS::Resource::DomainName
end

Resolv::DNS::Resource::CNAME::TypeValue: Integer

class Resolv::DNS::Resource::DomainName < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  def name: () -> String

  private

  def initialize: (String name) -> untyped
end

class Resolv::DNS::Resource::Generic < Resolv::DNS::Resource
  def self.create: (Integer type_value, Integer class_value) -> Class

  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def data: () -> String

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  private

  def initialize: (String data) -> untyped
end

class Resolv::DNS::Resource::HINFO < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def cpu: () -> String

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  def os: () -> String

  private

  def initialize: (String cpu, String os) -> untyped
end

Resolv::DNS::Resource::HINFO::TypeValue: Integer

module Resolv::DNS::Resource::IN
end

Resolv::DNS::Resource::IN::ClassValue: Integer

class Resolv::DNS::Resource::IN::A < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def address: () -> Resolv::IPv4

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  private

  def initialize: (String | Resolv::IPv4 address) -> untyped
end

Resolv::DNS::Resource::IN::A::ClassValue: Integer

Resolv::DNS::Resource::IN::A::TypeValue: Integer

class Resolv::DNS::Resource::IN::AAAA < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def address: () -> Resolv::IPv6

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  private

  def initialize: (String | Resolv::IPv6 address) -> untyped
end

Resolv::DNS::Resource::IN::AAAA::ClassValue: Integer

Resolv::DNS::Resource::IN::AAAA::TypeValue: Integer

class Resolv::DNS::Resource::IN::ANY < Resolv::DNS::Resource::ANY
end

Resolv::DNS::Resource::IN::ANY::ClassValue: Integer

Resolv::DNS::Resource::IN::ANY::TypeValue: Integer

class Resolv::DNS::Resource::IN::CNAME < Resolv::DNS::Resource::CNAME
end

Resolv::DNS::Resource::IN::CNAME::ClassValue: Integer

Resolv::DNS::Resource::IN::CNAME::TypeValue: Integer

class Resolv::DNS::Resource::IN::HINFO < Resolv::DNS::Resource::HINFO
end

Resolv::DNS::Resource::IN::HINFO::ClassValue: Integer

Resolv::DNS::Resource::IN::HINFO::TypeValue: Integer

class Resolv::DNS::Resource::IN::LOC < Resolv::DNS::Resource::LOC
end

Resolv::DNS::Resource::IN::LOC::ClassValue: Integer

Resolv::DNS::Resource::IN::LOC::TypeValue: Integer

class Resolv::DNS::Resource::IN::MINFO < Resolv::DNS::Resource::MINFO
end

Resolv::DNS::Resource::IN::MINFO::ClassValue: Integer

Resolv::DNS::Resource::IN::MINFO::TypeValue: Integer

class Resolv::DNS::Resource::IN::MX < Resolv::DNS::Resource::MX
end

Resolv::DNS::Resource::IN::MX::ClassValue: Integer

Resolv::DNS::Resource::IN::MX::TypeValue: Integer

class Resolv::DNS::Resource::IN::NS < Resolv::DNS::Resource::NS
end

Resolv::DNS::Resource::IN::NS::ClassValue: Integer

Resolv::DNS::Resource::IN::NS::TypeValue: Integer

class Resolv::DNS::Resource::IN::PTR < Resolv::DNS::Resource::PTR
end

Resolv::DNS::Resource::IN::PTR::ClassValue: Integer

Resolv::DNS::Resource::IN::PTR::TypeValue: Integer

class Resolv::DNS::Resource::IN::SOA < Resolv::DNS::Resource::SOA
end

Resolv::DNS::Resource::IN::SOA::ClassValue: Integer

Resolv::DNS::Resource::IN::SOA::TypeValue: Integer

class Resolv::DNS::Resource::IN::SRV < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  def port: () -> Integer

  def priority: () -> Integer

  def target: () -> String

  def weight: () -> Integer

  private

  def initialize: (Integer priority, Integer weight, Integer port, String target) -> untyped
end

Resolv::DNS::Resource::IN::SRV::ClassValue: Integer

Resolv::DNS::Resource::IN::SRV::TypeValue: Integer

class Resolv::DNS::Resource::IN::TXT < Resolv::DNS::Resource::TXT
end

Resolv::DNS::Resource::IN::TXT::ClassValue: Integer

Resolv::DNS::Resource::IN::TXT::TypeValue: Integer

class Resolv::DNS::Resource::IN::WKS < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def address: () -> Resolv::IPv4

  def bitmap: () -> Integer

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  def protocol: () -> Integer

  private

  def initialize: (String | Resolv::IPv4 address, Integer protocol, Integer bitmap) -> untyped
end

Resolv::DNS::Resource::IN::WKS::ClassValue: Integer

Resolv::DNS::Resource::IN::WKS::TypeValue: Integer

class Resolv::DNS::Resource::LOC < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def altitude: () -> Integer

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  def hprecision: () -> Integer

  def latitude: () -> Integer

  def longitude: () -> Integer

  def ssize: () -> Integer

  def version: () -> Integer

  def vprecision: () -> Integer

  private

  def initialize: (Integer version, Integer ssize, Integer hprecision, Integer vprecision, Integer latitude, Integer longitude, Integer altitude) -> untyped
end

Resolv::DNS::Resource::LOC::TypeValue: Integer

class Resolv::DNS::Resource::MINFO < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def emailbx: () -> String

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  def rmailbx: () -> String

  private

  def initialize: (String rmailbx, String emailbx) -> untyped
end

Resolv::DNS::Resource::MINFO::TypeValue: Integer

class Resolv::DNS::Resource::MX < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  def exchange: () -> String

  def preference: () -> Integer

  private

  def initialize: (Integer preference, String exchange) -> untyped
end

Resolv::DNS::Resource::MX::TypeValue: Integer

class Resolv::DNS::Resource::NS < Resolv::DNS::Resource::DomainName
end

Resolv::DNS::Resource::NS::TypeValue: Integer

class Resolv::DNS::Resource::PTR < Resolv::DNS::Resource::DomainName
end

Resolv::DNS::Resource::PTR::TypeValue: Integer

class Resolv::DNS::Resource::SOA < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  def expire: () -> Integer

  def minimum: () -> Integer

  def mname: () -> String

  def refresh: () -> Integer

  def retry: () -> Integer

  def rname: () -> String

  def serial: () -> Integer

  private

  def initialize: (String mname, String rname, Integer serial, Integer refresh, Integer retry_, Integer expire, Integer minimum) -> untyped
end

Resolv::DNS::Resource::SOA::TypeValue: Integer

class Resolv::DNS::Resource::TXT < Resolv::DNS::Resource
  def self.decode_rdata: (Resolv::DNS::Message::MessageDecoder msg) -> instance

  def data: () -> String

  def encode_rdata: (Resolv::DNS::Message::MessageEncoder msg) -> void

  def strings: () -> Array[String]

  private

  def initialize: (String first_string, *String rest_strings) -> untyped
end

Resolv::DNS::Resource::TXT::TypeValue: Integer

class Resolv::Hosts
  def each_address: (String name) { (String) -> void } -> void

  def each_name: (String address) { (String) -> void } -> void

  def getaddress: (String name) -> String

  def getaddresses: (String name) -> Array[String]

  def getname: (String address) -> String

  def getnames: (String address) -> Array[String]

  def lazy_initialize: () -> void

  private

  def initialize: (?String filename) -> untyped
end

Resolv::Hosts::DefaultFileName: String

class Resolv::IPv4
  def self.create: (String | instance arg) -> instance

  def ==: (self other) -> bool

  def address: () -> String

  def eql?: (self other) -> bool

  def hash: () -> Integer

  def inspect: () -> String

  def to_name: () -> Resolv::DNS::Name

  def to_s: () -> String

  private

  def initialize: (String address) -> untyped
end

Resolv::IPv4::Regex: Regexp

Resolv::IPv4::Regex256: Regexp

class Resolv::IPv6
  def self.create: (String | instance arg) -> instance

  def ==: (self other) -> bool

  def address: () -> String

  def eql?: (self other) -> bool

  def hash: () -> Integer

  def inspect: () -> String

  def to_name: () -> Resolv::DNS::Name

  def to_s: () -> String

  private

  def initialize: (untyped address) -> untyped
end

Resolv::IPv6::Regex: Regexp

Resolv::IPv6::Regex_6Hex4Dec: Regexp

Resolv::IPv6::Regex_8Hex: Regexp

Resolv::IPv6::Regex_8HexLinkLocal: Regexp

Resolv::IPv6::Regex_CompressedHex: Regexp

Resolv::IPv6::Regex_CompressedHex4Dec: Regexp

Resolv::IPv6::Regex_CompressedHexLinkLocal: Regexp

module Resolv::LOC
end

class Resolv::LOC::Alt
  def self.create: (Resolv::LOC::Alt | String arg) -> instance

  def eql?: (Resolv::LOC::Alt other) -> bool

  def altitude: () -> Integer

  alias == eql?

  def hash: () -> Integer

  def inspect: () -> String

  def to_s: () -> String

  private

  def initialize: (Integer altitude) -> untyped
end

Resolv::LOC::Alt::Regex: Regexp

class Resolv::LOC::Coord
  type orientation = "lat" | "lon"

  def self.create: (Resolv::LOC::Coord | String arg) -> instance

  def eql?: (Resolv::LOC::Coord other) -> bool

  def coordinates: () -> String

  alias == eql?

  def hash: () -> Integer

  def inspect: () -> String

  def orientation: () -> orientation

  def to_s: () -> String

  private

  def initialize: (String coordinates, orientation orientation) -> untyped
end

Resolv::LOC::Coord::Regex: Regexp

class Resolv::LOC::Size
  def self.create: (Resolv::LOC::Size | String arg) -> instance

  def eql?: (Resolv::LOC::Size other) -> bool

  alias == eql?

  def hash: () -> Integer

  def inspect: () -> String

  def scalar: () -> String

  def to_s: () -> String

  private

  def initialize: (String scalar) -> untyped
end

Resolv::LOC::Size::Regex: Regexp

class Resolv::MDNS < Resolv::DNS
  def each_address: (Resolv::DNS::dns_name name) -> Resolv::DNS::ip_address

  def make_udp_requester: () -> (Resolv::DNS::Requester::ConnectedUDP | Resolv::DNS::Requester::UnconnectedUDP)

  private

  def initialize: (?String | Hash[Symbol, untyped] config_info) -> untyped
end

Resolv::MDNS::AddressV4: String

Resolv::MDNS::AddressV6: String

Resolv::MDNS::Addresses: Array[untyped]

Resolv::MDNS::Port: Integer

class Resolv::ResolvError < StandardError
end

class Resolv::ResolvTimeout < Timeout::Error
end
