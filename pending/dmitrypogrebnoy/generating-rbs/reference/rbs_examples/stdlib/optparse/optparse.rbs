class OptionParser
  interface _Pattern
    def match: (untyped other) -> boolish
  end

  interface _Intoable
    def []=: (Symbol, untyped) -> untyped
  end

  interface _LtLtString
    def <<: (String) -> untyped
  end

  def self.accept: (Class t, ?_Pattern pat) ?{ (*untyped) -> untyped } -> void

  def self.getopts: (*String options) -> Hash[String, untyped]
                  | (Array[String] args, *String options) -> Hash[String, untyped]

  def self.inc: (untyped arg, ?_ToI default) -> Integer?

  def self.reject: (Class t) -> void

  def self.terminate: (?String arg) -> bot

  def self.top: () -> OptionParser::List

  def self.with: (?String banner, ?Integer width, ?String indent) ?{ (instance opts) -> void } -> instance

  def abort: (?_ToS mesg) -> bot

  def accept: (Class t, ?_Pattern pat) ?{ (*untyped) -> untyped } -> void

  def add_officious: () -> void

  def additional_message: (untyped typ, untyped opt) -> String?

  attr_accessor banner: String

  def base: () -> List

  def candidate: (String word) -> Array[untyped]

  def compsys: (untyped to, ?untyped name) -> untyped

  alias def_head_option define_head

  alias def_option define

  alias def_tail_option define_tail

  attr_accessor default_argv: Array[String]

  def define: (*String params) ?{ (*untyped) -> untyped } -> untyped
            | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> untyped
            | (*String params, Proc | Method handler) -> untyped
            | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> untyped

  def define_head: (*String params) ?{ (*untyped) -> untyped } -> untyped
                 | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> untyped
                 | (*String params, Proc | Method handler) -> untyped
                 | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> untyped

  def define_tail: (*String params) ?{ (*untyped) -> untyped } -> untyped
                 | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> untyped
                 | (*String params, Proc | Method handler) -> untyped
                 | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> untyped

  def environment: (?String env) -> Array[String]?

  def getopts: (*String options) -> Hash[String, untyped]
             | (Array[String] args, *String options) -> Hash[String, untyped]

  def help: () -> String

  def inc: (*untyped args) -> untyped

  def load: (?String filename) -> bool

  def make_switch: (Array[untyped] opts, ?Proc block) -> [ untyped, untyped, untyped, untyped, untyped ]

  def new: () -> self
         | [T] () { (self) -> T } -> T

  def on: (*String params) ?{ (*untyped) -> untyped } -> self
        | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> self
        | (String short_params, String long_params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> self
        | (*String params, Proc | Method handler) -> self
        | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> self
        | (String short_params, String long_params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> self

  def on_head: (*String params) ?{ (*untyped) -> untyped } -> self
             | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> self
             | (String short_params, String long_params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> self
             | (*String params, Proc | Method handler) -> self
             | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> self
             | (String short_params, String long_params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> self

  def on_tail: (*String params) ?{ (*untyped) -> untyped } -> self
             | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> self
             | (String short_params, String long_params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc) ?{ (*untyped) -> untyped } -> self
             | (*String params, Proc | Method handler) -> self
             | (String params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> self
             | (String short_params, String long_params, Class | Array[String] | Hash[Symbol, untyped] | Regexp obj, ?String desc, Proc | Method handler) -> self

  def order: (*String argv, ?into: _Intoable) ?{ (String) -> void } -> Array[String]
           | (Array[String] argv, ?into: _Intoable) ?{ (String) -> void } -> Array[String]

  def order!: (?Array[String] argv, ?into: _Intoable) ?{ (String) -> void } -> Array[String]

  def parse: (*String argv, ?into: _Intoable) -> Array[String]
           | (Array[String] argv, ?into: _Intoable) -> Array[String]

  def parse!: (?Array[String] argv, ?into: _Intoable) -> Array[String]

  def permute: (*String argv, ?into: _Intoable) -> Array[String]
             | (Array[String] argv, ?into: _Intoable) -> Array[String]

  def permute!: (?Array[String] argv, ?into: _Intoable) -> Array[String]

  attr_accessor program_name: String

  attr_accessor raise_unknown: boolish

  def reject: (Class t) -> void

  def release: () -> untyped

  def release=: (untyped) -> untyped

  def remove: () -> List?

  attr_accessor require_exact: boolish

  def separator: (String string) -> void

  alias set_banner banner=

  alias set_program_name program_name=

  alias set_summary_indent summary_indent=

  alias set_summary_width summary_width=

  def summarize: (?_LtLtString to, ?Integer width, ?Integer max, ?String indent) ?{ (String line) -> void } -> _LtLtString

  attr_accessor summary_indent: String

  attr_accessor summary_width: Integer

  def terminate: (?String arg) -> bot

  def to_a: () -> Array[String]

  alias to_s help

  def top: () -> List

  def ver: () -> String?

  attr_accessor version: String?

  def warn: (?_ToS mesg) -> void

  private

  def complete: (untyped typ, untyped opt, ?untyped icase, *untyped pat) -> untyped

  def initialize: (?String banner, ?Integer width, ?String indent) ?{ (OptionParser) -> void } -> void

  def notwice: (untyped obj, untyped prv, untyped msg) -> untyped

  def parse_in_order: (?untyped argv, ?untyped setter) { (*untyped) -> untyped } -> untyped

  def search: (untyped id, untyped key) -> untyped

  def visit: (untyped id, *untyped args) { (*untyped) -> untyped } -> untyped
end

OptionParser::ArgumentStyle: Hash[untyped, untyped]

OptionParser::COMPSYS_HEADER: String

OptionParser::DecimalInteger: Regexp

OptionParser::DecimalNumeric: Regexp

OptionParser::DefaultList: OptionParser::List

OptionParser::NO_ARGUMENT: Symbol

OptionParser::NoArgument: [ :NONE, nil ]

OptionParser::OPTIONAL_ARGUMENT: Symbol

OptionParser::OctalInteger: Regexp

OptionParser::Officious: Hash[untyped, untyped]

OptionParser::OptionalArgument: Array[untyped]

OptionParser::REQUIRED_ARGUMENT: Symbol

OptionParser::RequiredArgument: Array[untyped]

OptionParser::SPLAT_PROC: Proc

OptionParser::Version: String

module OptionParser::Acceptables
end

OptionParser::Acceptables::DecimalInteger: Regexp

OptionParser::Acceptables::DecimalNumeric: Regexp

OptionParser::Acceptables::OctalInteger: Regexp

class OptionParser::AmbiguousArgument < OptionParser::InvalidArgument
end

OptionParser::AmbiguousArgument::Reason: String

class OptionParser::AmbiguousOption < OptionParser::ParseError
end

OptionParser::AmbiguousOption::Reason: String

module OptionParser::Arguable
  def self.extend_object: (untyped obj) -> untyped

  def getopts: (*String args) -> Hash[String, untyped]

  def options: () -> OptionParser
             | [T] () { (OptionParser) -> T } -> T?

  def options=: (OptionParser? opt) -> untyped

  def order!: () ?{ (String) -> void } -> Array[String]

  def parse!: () -> Array[String]

  def permute!: () -> Array[String]
end

class OptionParser::CompletingHash < Hash[untyped, untyped]
  include OptionParser::Completion

  def match: (untyped key) -> untyped
end

module OptionParser::Completion
  def self.candidate: (untyped key, ?untyped icase, ?untyped pat) { (*untyped) -> untyped } -> untyped

  def self.regexp: (untyped key, untyped icase) -> untyped

  def candidate: (untyped key, ?untyped icase, ?untyped pat) -> untyped

  def complete: (untyped key, ?untyped icase, ?untyped pat) -> untyped

  def convert: (?untyped opt, ?untyped val, *untyped) -> untyped
end

class OptionParser::InvalidArgument < OptionParser::ParseError
end

OptionParser::InvalidArgument::Reason: String

class OptionParser::InvalidOption < OptionParser::ParseError
end

OptionParser::InvalidOption::Reason: String

class OptionParser::List
  def accept: (untyped t, ?untyped pat) { (*untyped) -> untyped } -> untyped

  def add_banner: (untyped to) -> untyped

  def append: (*untyped args) -> untyped

  def atype: () -> untyped

  def complete: (untyped id, untyped opt, ?untyped icase, *untyped pat) { (*untyped) -> untyped } -> untyped

  def compsys: (*untyped args) { (*untyped) -> untyped } -> untyped

  def each_option: () { (*untyped) -> untyped } -> untyped

  def get_candidates: (untyped id) -> untyped

  def list: () -> untyped

  def long: () -> untyped

  def prepend: (*untyped args) -> untyped

  def reject: (untyped t) -> untyped

  def search: (untyped id, untyped key) -> untyped

  def short: () -> untyped

  def summarize: (*untyped args) { (*untyped) -> untyped } -> untyped

  private

  def initialize: () -> void

  def update: (untyped sw, untyped sopts, untyped lopts, ?untyped nsw, ?untyped nlopts) -> untyped
end

class OptionParser::MissingArgument < OptionParser::ParseError
end

OptionParser::MissingArgument::Reason: String

class OptionParser::NeedlessArgument < OptionParser::ParseError
end

OptionParser::NeedlessArgument::Reason: String

class OptionParser::OptionMap < Hash[untyped, untyped]
  include OptionParser::Completion
end

class OptionParser::ParseError < RuntimeError
  def self.filter_backtrace: (untyped array) -> untyped

  def additional: () -> untyped

  def additional=: (untyped) -> untyped

  def args: () -> untyped

  def inspect: () -> untyped

  def message: () -> String

  def reason: () -> untyped

  def reason=: (untyped) -> untyped

  def recover: (untyped argv) -> untyped

  def set_backtrace: (untyped array) -> untyped

  def set_option: (untyped opt, untyped eq) -> untyped

  alias to_s message

  private

  def initialize: (*untyped args, ?additional: untyped) -> void
end

OptionParser::ParseError::Reason: String

class OptionParser::Switch
  def self.guess: (untyped arg) -> untyped

  def self.incompatible_argument_styles: (untyped arg, untyped t) -> untyped

  def self.pattern: () -> untyped

  def add_banner: (untyped to) -> untyped

  def arg: () -> untyped

  def block: () -> untyped

  def compsys: (untyped sdone, untyped ldone) -> untyped

  def conv: () -> untyped

  def desc: () -> untyped

  def long: () -> untyped

  def match_nonswitch?: (untyped str) -> untyped

  def pattern: () -> untyped

  def short: () -> untyped

  def summarize: (?untyped sdone, ?untyped ldone, ?untyped width, ?untyped max, ?untyped indent) -> untyped

  def switch_name: () -> untyped

  private

  def conv_arg: (untyped arg, ?untyped val) -> untyped

  def initialize: (?untyped pattern, ?untyped conv, ?untyped short, ?untyped long, ?untyped arg, ?untyped desc, ?untyped block) { (*untyped) -> untyped } -> void

  def parse_arg: (untyped arg) -> untyped
end

class OptionParser::Switch::NoArgument < OptionParser::Switch
  def self.incompatible_argument_styles: (*untyped) -> untyped

  def self.pattern: () -> untyped

  def parse: (untyped arg, untyped argv) -> untyped
end

class OptionParser::Switch::OptionalArgument < OptionParser::Switch
  def parse: (untyped arg, untyped argv) { (*untyped) -> untyped } -> untyped
end

class OptionParser::Switch::PlacedArgument < OptionParser::Switch
  def parse: (untyped arg, untyped argv) { (*untyped) -> untyped } -> untyped
end

class OptionParser::Switch::RequiredArgument < OptionParser::Switch
  def parse: (untyped arg, untyped argv) -> untyped
end
