class Thread < Object
  def self.current: () -> Thread

  def self.main: () -> Thread

  def []: (interned key) -> untyped

  def []=: (interned key, untyped value) -> untyped

  def alive?: () -> bool

  def kill: () -> Thread?

  def abort_on_exception: () -> bool

  def abort_on_exception=: (boolish abort_on_exception) -> untyped

  def add_trace_func: (untyped proc) -> untyped

  def backtrace: (*untyped args) -> ::Array[untyped]

  def backtrace_locations: (*untyped args) -> ::Array[untyped]?

  def exit: () -> Thread?

  def fetch: (*untyped sym) -> untyped

  def group: () -> ThreadGroup?

  def initialize: (*untyped) { (?) -> void } -> void

  def join: (*untyped limit) -> Thread

  def key?: (Symbol sym) -> bool

  def keys: () -> ::Array[Symbol]

  def name: () -> String

  def name=: (untyped name) -> untyped

  def native_thread_id: () -> Integer

  def pending_interrupt?: (*untyped args) -> bool

  def priority: () -> Integer

  def priority=: (Integer priority) -> untyped

  def report_on_exception: () -> bool

  def report_on_exception=: (boolish report_on_exception) -> untyped

  def run: () -> Thread

  def safe_level: () -> Integer

  def status: () -> (String | bool)?

  def stop?: () -> bool

  def terminate: () -> Thread?

  def thread_variable?: (interned key) -> bool

  def thread_variable_get: (untyped key) -> untyped

  def thread_variable_set: (untyped key, untyped value) -> untyped

  def thread_variables: () -> ::Array[Symbol]

  def value: () -> untyped

  def wakeup: () -> Thread

  def self.abort_on_exception: () -> untyped

  def self.abort_on_exception=: (untyped abort_on_exception) -> untyped

  def self.each_caller_location: () { (Backtrace::Location) -> void } -> nil

  def self.exit: () -> untyped

  def self.fork: (*untyped args) -> untyped

  def self.handle_interrupt: (untyped hash) -> untyped

  def raise: (?String message, ?cause: Exception?) -> nil
           | (_Exception, ?_ToS message, ?Array[Thread::Backtrace::Location] | Array[String] | nil backtrace, ?cause: Exception?) -> nil

  def self.kill: (Thread thread) -> untyped

  def self.list: () -> untyped

  def self.pass: () -> untyped

  def self.pending_interrupt?: (*untyped args) -> bool

  def self.report_on_exception: () -> untyped

  def self.report_on_exception=: (untyped report_on_exception) -> untyped

  def self.start: (*untyped args) { (?) -> void } -> instance

  def self.stop: () -> untyped
end

class Thread::Backtrace < Object
  def self.limit: () -> Integer
end

class Thread::Backtrace::Location
  def absolute_path: () -> String?

  def base_label: () -> String?

  def label: () -> String?

  def lineno: () -> Integer

  def path: () -> String?
end

class Thread::ConditionVariable < Object
  def broadcast: () -> self

  def signal: () -> self

  def wait: (Thread::Mutex mutex, ?Time::_Timeout? timeout) -> Integer?
end

class Thread::Mutex < Object
  def lock: () -> self

  def locked?: () -> bool

  def owned?: () -> bool

  def synchronize: [X] () { () -> X } -> X

  def try_lock: () -> bool

  def unlock: () -> self
end

class Thread::Queue[Elem = untyped] < Object
  alias << push

  def clear: () -> void

  def close: () -> self

  def closed?: () -> bool

  alias deq pop

  def empty?: () -> bool

  alias enq push

  def freeze: () -> bot

  def length: () -> Integer

  def num_waiting: () -> Integer

  def pop: (?boolish non_block, ?timeout: _ToF?) -> Elem?

  def push: (Elem obj) -> void

  alias shift pop

  alias size length
end

class Thread::SizedQueue[Elem = untyped] < Thread::Queue[Elem]
  alias << push

  alias enq push

  def freeze: () -> bot

  def initialize: (Integer max) -> void

  def max: () -> Integer

  def max=: (Integer max) -> void

  def push: (Elem obj, ?boolish non_block) -> void
          | (Elem obj, timeout: _ToF?) -> self?
end

class ConditionVariable = Thread::ConditionVariable

class Mutex = Thread::Mutex

class Queue = Thread::Queue

class SizedQueue = Thread::SizedQueue
