class Range[out Elem] < Object
  include Enumerable[Elem]

  def %: (Numeric | int n) -> Enumerator[Elem, self]
       | (Numeric | int n) { (Elem element) -> void } -> self

  def ==: (untyped obj) -> bool

  def ===: (untyped obj) -> bool

  def begin: () -> Elem

  def bsearch: () -> ::Enumerator[Elem, Elem?]
             | () { (Elem) -> (true | false) } -> Elem?
             | () { (Elem) -> ::Integer } -> Elem?

  def cover?: (untyped obj) -> bool

  def each: () { (Elem arg0) -> untyped } -> self
          | () -> ::Enumerator[Elem, self]

  def end: () -> Elem

  def exclude_end?: () -> bool

  def first: () -> Elem
           | (Integer n) -> ::Array[Elem]

  def hash: () -> Integer

  def include?: (untyped obj) -> bool

  def initialize: (Elem from, Elem to, ?boolish exclude_end) -> void

  def inspect: () -> String

  def last: () -> Elem
          | (Integer n) -> ::Array[Elem]

  def max: ...

  def min: ...

  def minmax: ...

  def overlap?: (Range[untyped]) -> bool

  def reverse_each: () { (Elem) -> void } -> self
                  | () -> ::Enumerator[Elem, self]

  def size: () -> (Integer | Float | nil)

  def count: () -> (Integer | Float)
           | (untyped) -> Integer
           | () { (Elem) -> boolish } -> Integer

  def step: (?Numeric | int) -> Enumerator[Elem, self]
          | (?Numeric | int) { (Elem element) -> void } -> self
          | (untyped) -> Enumerator[Elem, self]
          | (untyped) { (Elem element) -> void } -> self

  def to_s: () -> String

  def eql?: (untyped obj) -> bool

  def member?: (untyped obj) -> bool

  def to_a: ...

  alias entries to_a
end
