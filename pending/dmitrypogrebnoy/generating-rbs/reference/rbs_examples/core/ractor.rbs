class Ractor
  def self._require: (String feature) -> bool

  def self.[]: (Symbol) -> untyped

  def self.[]=: (Symbol, untyped) -> untyped

  def self.count: () -> Integer

  def self.current: () -> untyped

  def self.main: () -> Ractor

  def self.main?: () -> boolish

  def self.make_shareable: [T] (T obj, ?copy: boolish) -> T

  def self.new: (*untyped args, ?name: string) { (?) -> untyped } -> Ractor

  def self.receive: () -> untyped

  alias self.recv self.receive

  def self.select: (?) -> Array[untyped]

  def self.shareable?: (untyped obj) -> bool

  def self.shareable_proc: [T] () { (?) [self: nil] -> T } -> ^(?) [self: nil] -> T
                         | [T, S] (self: S) { (?) [self: S] -> T } -> ^(?) [self: S] -> T

  def self.shareable_lambda: [T] () { (?) [self: nil] -> T } -> ^(?) [self: nil] -> T
                           | [T, S] (self: S) { (?) [self: S] -> T } -> ^(?) [self: S] -> T

  def self.store_if_absent: [A] (Symbol) { (nil) -> A } -> A

  alias << send

  %a{deprecated: Use Ractor.[] instead}
  def []: (interned sym) -> untyped

  %a{deprecated: Use Ractor.[]= instead}
  def []=: [T] (interned sym, T val) -> T

  def default_port: () -> Port[untyped]

  def inspect: () -> String

  def join: () -> self

  def name: () -> String?

  def monitor: [T < Symbol] (Port[T]) -> untyped

  def send: (untyped obj, ?move: boolish) -> Ractor

  alias to_s inspect

  def unmonitor: (Port[untyped]) -> self

  def value: () -> untyped

  private

  def receive: () -> untyped

  def receive_if: () { (untyped) -> boolish } -> untyped

  alias recv receive

  class ClosedError < StopIteration
  end

  class Error < RuntimeError
  end

  class IsolationError < Ractor::Error
  end

  class MovedError < Ractor::Error
  end

  class MovedObject < BasicObject
    def !: (*untyped) -> untyped

    def !=: (*untyped) -> untyped

    def ==: (*untyped) -> untyped

    def __id__: (*untyped) -> untyped

    def __send__: (*untyped) -> untyped

    def equal?: (*untyped) -> untyped

    def instance_eval: (*untyped) -> untyped

    def instance_exec: (*untyped) -> untyped

    def method_missing: (*untyped) -> untyped
  end

  class Port[T = untyped]
    alias << send

    def close: () -> void

    def closed?: () -> bool

    def inspect: () -> String

    def receive: () -> T

    def send: (T obj, ?move: boolish) -> self

    private

    def initialize: () -> void

    def initialize_copy: (untyped) -> untyped
  end

  class RemoteError < Ractor::Error
    def ractor: () -> Ractor
  end

  class UnsafeError < Ractor::Error
  end

  %a{annotate:rdoc:skip}
  class Selector
  end
end
