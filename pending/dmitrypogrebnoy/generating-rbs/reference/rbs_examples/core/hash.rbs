class Hash[unchecked out K, unchecked out V] < Object
  include Enumerable[[ K, V ]]

  interface _Key
    def hash: () -> Integer

    def eql?: (untyped rhs) -> boolish
  end

  def self.[]: [U, V] (_ToHash[U, V]) -> ::Hash[U, V]
             | [U, V] (Array[[ U, V ]]) -> ::Hash[U, V]
             | (*untyped) -> ::Hash[untyped, untyped]

  def self.try_convert: [U, V] (_ToHash[U, V]) -> ::Hash[U, V]
                      | (untyped) -> (::Hash[untyped, untyped] | nil)

  def <: [A, B] (::Hash[A, B]) -> bool

  def <=: [A, B] (::Hash[A, B]) -> bool

  def ==: (untyped other) -> bool

  def >: [A, B] (::Hash[A, B]) -> bool

  def >=: [A, B] (::Hash[A, B]) -> bool

  def []: %a{implicitly-returns-nil} (K arg0) -> V

  def []=: (K arg0, V arg1) -> V

  def any?: () -> bool
          | (untyped pattern) -> bool
          | () { (K, V) -> boolish } -> bool

  def assoc: (K arg0) -> [ K, V ]?

  def clear: () -> self

  def compact: () -> ::Hash[K, V]

  def compact!: () -> self?

  def compare_by_identity: () -> self

  def compare_by_identity?: () -> bool

  def deconstruct_keys: (Array[K] | nil) -> self

  def default: (?K arg0) -> V?

  def default=: (V arg0) -> V

  def default_proc: () -> (Proc | nil)

  def default_proc=: (Proc | _ToProc | nil) -> (Proc | _ToProc | nil)

  def delete: (K arg0) -> V?
            | [U] (K arg0) { (K arg0) -> U } -> (U | V)

  def delete_if: () { (K, V) -> boolish } -> self
               | () -> ::Enumerator[[ K, V ], self]

  def dig: (K, *untyped) -> untyped

  def each: () { ([ K, V ] arg0) -> untyped } -> self
          | () -> ::Enumerator[[ K, V ], self]

  def each_key: () { (K arg0) -> untyped } -> ::Hash[K, V]
              | () -> ::Enumerator[K, self]

  alias each_pair each

  def each_value: () { (V arg0) -> untyped } -> self
                | () -> ::Enumerator[V, self]

  def empty?: () -> bool

  def eql?: (untyped) -> bool

  def except: (*K) -> ::Hash[K, V]

  def fetch: (K arg0) -> V
           | [X] (K arg0, X arg1) -> (V | X)
           | [X] (K arg0) { (K arg0) -> X } -> (V | X)

  def fetch_values: (*K) -> ::Array[V]
                  | [X] (*K) { (K) -> X } -> ::Array[V | X]

  def filter: () { (K, V) -> boolish } -> ::Hash[K, V]
            | () -> ::Enumerator[[ K, V ], ::Hash[K, V]]

  def filter!: () { (K, V) -> boolish } -> self?
             | () -> ::Enumerator[[ K, V ], self?]

  def flatten: () -> ::Array[K | V]
             | (1 level) -> ::Array[K | V]
             | (Integer level) -> Array[untyped]

  def has_key?: (K arg0) -> bool

  def has_value?: (V arg0) -> bool

  def hash: () -> Integer

  alias include? has_key?

  def inspect: () -> String

  def invert: () -> ::Hash[V, K]

  def keep_if: () { (K, V) -> boolish } -> self
             | () -> ::Enumerator[[ K, V ], self]

  def key: (V) -> K?

  alias key? has_key?

  def keys: () -> ::Array[K]

  def length: () -> Integer

  alias member? has_key?

  def merge: [A, B] (*::Hash[A, B] other_hashes) -> ::Hash[A | K, B | V]
           | [A, B, C] (*::Hash[A, B] other_hashes) { (K key, V oldval, B newval) -> C } -> ::Hash[A | K, B | V | C]

  def merge!: (*::Hash[K, V] other_hashes) -> self
            | (*::Hash[K, V] other_hashes) { (K key, V oldval, V newval) -> V } -> self

  def rassoc: (V) -> [ K, V ]?

  def rehash: () -> self

  def reject: () -> ::Enumerator[[ K, V ], ::Hash[K, V]]
            | () { (K, V) -> boolish } -> ::Hash[K, V]

  def reject!: () -> ::Enumerator[[ K, V ], self?]
             | () { (K, V) -> boolish } -> self?

  def replace: (Hash[K, V]) -> self

  alias select filter

  alias select! filter!

  def shift: () -> [ K, V ]?

  alias size length

  def slice: (*K) -> ::Hash[K, V]

  alias store []=

  def to_a: () -> ::Array[[ K, V ]]

  def to_h: () -> Hash[K, V]
          | [A, B] () { (K, V) -> [ A, B ] } -> Hash[A, B]

  def to_hash: () -> self

  def to_proc: () -> ^(K) -> V?

  alias to_s inspect

  def transform_keys: () -> Enumerator[K, Hash[untyped, V]]
                    | [A] () { (K) -> A } -> Hash[A, V]

  def transform_keys!: () -> Enumerator[K, self]
                     | () { (K) -> K } -> self

  def transform_values: () -> Enumerator[V, Hash[K, untyped]]
                      | [A] () { (V) -> A } -> Hash[K, A]

  def transform_values!: () -> Enumerator[V, self]
                       | () { (V) -> V } -> self

  alias update merge!

  alias value? has_value?

  def values: () -> ::Array[V]

  def values_at: (*K arg0) -> ::Array[V?]

  private

  def initialize: (?capacity: int) -> void
                | (V default, ?capacity: int) -> void
                | (?capacity: int) { (Hash[K, V] hash, K key) -> V } -> void

  def initialize_copy: (self object) -> self
end
