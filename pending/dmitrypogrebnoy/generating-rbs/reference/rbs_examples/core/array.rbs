%a{annotate:rdoc:source:from=array.c}
class Array[unchecked out Elem] < Object
  include Enumerable[Elem]

  def initialize: () -> void
                | (::Array[Elem] ary) -> void
                | (int size, ?Elem val) -> void
                | (int size) { (::Integer index) -> Elem } -> void

  def self.[]: [U] (*U) -> ::Array[U]

  def self.try_convert: [U] (untyped) -> ::Array[U]?

  def &: (::Array[untyped] | _ToAry[untyped]) -> ::Array[Elem]

  def *: (string str) -> ::String
       | (int int) -> ::Array[Elem]

  def +: [U] (_ToAry[U]) -> ::Array[Elem | U]

  def -: (_ToAry[untyped]) -> ::Array[Elem]

  def <<: (Elem) -> self

  def <=>: (untyped) -> ::Integer?

  def ==: (untyped other) -> bool

  def []: %a{implicitly-returns-nil} (int index) -> Elem
        | (int start, int length) -> ::Array[Elem]?
        | (::Range[::Integer?] range) -> ::Array[Elem]?

  def []=: (int index, Elem obj) -> Elem
         | (int start, int length, Elem obj) -> Elem
         | (int start, int length, ::Array[Elem]) -> ::Array[Elem]
         | (int start, int length, nil) -> nil
         | (::Range[::Integer?], Elem obj) -> Elem
         | (::Range[::Integer?], ::Array[Elem]) -> ::Array[Elem]
         | (::Range[::Integer?], nil) -> nil

  def all?: () -> bool
          | (_Pattern[Elem] pattern) -> bool
          | () { (Elem obj) -> boolish } -> bool

  alias any? all?

  alias append push

  def assoc: (untyped) -> ::Array[untyped]?

  def at: %a{implicitly-returns-nil} (int index) -> Elem

  def bsearch: () -> ::Enumerator[Elem, Elem?]
             | () { (Elem) -> (true | false) } -> Elem?
             | () { (Elem) -> ::Integer } -> Elem?

  def bsearch_index: () { (Elem) -> (true | false) } -> ::Integer?
                   | () { (Elem) -> ::Integer } -> ::Integer?

  def clear: () -> self

  def collect: [U] () { (Elem item) -> U } -> ::Array[U]
             | () -> ::Enumerator[Elem, ::Array[untyped]]

  def collect!: () { (Elem item) -> Elem } -> self
              | () -> ::Enumerator[Elem, self]

  def combination: (int n) { (::Array[Elem]) -> void } -> self
                 | (int n) -> ::Enumerator[::Array[Elem], self]

  def compact: () -> ::Array[Elem]

  def compact!: () -> self?

  def concat: (*::Array[Elem] arrays) -> self

  def count: () -> ::Integer
           | (Elem obj) -> ::Integer
           | () { (Elem) -> boolish } -> ::Integer

  def cycle: (?int? n) { (Elem) -> void } -> nil
           | (?int? n) -> ::Enumerator[Elem, nil]

  def deconstruct: () -> self

  def delete: (Elem obj) -> Elem?
            | [S, T] (S obj) { (S) -> T } -> (Elem | T)

  def delete_at: %a{implicitly-returns-nil} (int index) -> Elem

  def delete_if: () { (Elem item) -> boolish } -> self
               | () -> ::Enumerator[Elem, self]

  def difference: (*::Array[untyped] arrays) -> ::Array[Elem]

  def dig: (int idx) -> Elem?
         | (int idx, untyped, *untyped) -> untyped

  def drop: (int n) -> ::Array[Elem]

  def drop_while: () { (Elem obj) -> boolish } -> ::Array[Elem]
                | () -> ::Enumerator[Elem, ::Array[Elem]]

  def each: () -> ::Enumerator[Elem, self]
          | () { (Elem item) -> void } -> self

  def each_index: () { (::Integer index) -> void } -> self
                | () -> ::Enumerator[::Integer, self]

  def empty?: () -> bool

  def eql?: (untyped other) -> bool

  def fetch: (int index) -> Elem
           | [T] (int index, T default) -> (Elem | T)
           | [T] (int index) { (int index) -> T } -> (Elem | T)

  def fetch_values: (*int indexes) -> self

  def fill: (Elem obj) -> self
          | (Elem obj, int? start, ?int? length) -> self
          | (Elem obj, ::Range[::Integer] range) -> self
          | (?int? start, ?int? length) { (::Integer index) -> Elem } -> self
          | (::Range[::Integer] range) { (::Integer index) -> Elem } -> self

  def filter: () { (Elem item) -> boolish } -> ::Array[Elem]
            | () -> ::Enumerator[Elem, ::Array[Elem]]

  def filter!: () { (Elem item) -> boolish } -> self?
             | () -> ::Enumerator[Elem, self?]

  def find: () { (Elem) -> boolish } -> Elem?
          | () -> ::Enumerator[Elem, Elem?]
          | [T] (Enumerable::_NotFound[T] ifnone) { (Elem) -> boolish } -> (Elem | T)
          | [T] (Enumerable::_NotFound[T] ifnone) -> ::Enumerator[Elem, Elem | T]

  def find_index: (untyped obj) -> ::Integer?
                | () { (Elem item) -> boolish } -> ::Integer?
                | () -> ::Enumerator[Elem, ::Integer?]

  def first: %a{implicitly-returns-nil} () -> Elem
           | (int n) -> ::Array[Elem]

  def flatten: (?int level) -> ::Array[untyped]

  def flatten!: (?int level) -> self?

  def hash: () -> ::Integer

  def include?: (Elem object) -> bool

  alias index find_index

  def insert: (int index, *Elem obj) -> self

  def inspect: () -> String

  def intersect?: (_ToAry[untyped]) -> bool

  def intersection: (*::Array[untyped] | _ToAry[untyped] other_ary) -> ::Array[Elem]

  def join: (?string separator) -> String

  def keep_if: () { (Elem item) -> boolish } -> self
             | () -> ::Enumerator[Elem, self]

  def last: %a{implicitly-returns-nil} () -> Elem
          | (int n) -> ::Array[Elem]

  def length: () -> ::Integer

  alias map collect

  alias map! collect!

  def max: %a{implicitly-returns-nil} () -> Elem
         | %a{implicitly-returns-nil} () { (Elem a, Elem b) -> ::Integer? } -> Elem
         | (int n) -> ::Array[Elem]
         | (int n) { (Elem a, Elem b) -> ::Integer? } -> ::Array[Elem]

  alias min max

  def minmax: () -> [ Elem?, Elem? ]
            | () { (Elem a, Elem b) -> ::Integer? } -> [ Elem?, Elem? ]

  alias none? all?

  alias one? none?

  def pack: (string fmt, ?buffer: String?) -> String

  def permutation: (?int n) -> ::Enumerator[::Array[Elem], ::Array[Elem]]
                 | (?int n) { (::Array[Elem] p) -> void } -> ::Array[Elem]

  def pop: () -> Elem?
         | (int n) -> ::Array[Elem]

  alias prepend unshift

  def product: () -> ::Array[[ Elem ]]
             | [X] (::Array[X] other_ary) -> ::Array[[ Elem, X ]]
             | [X, Y] (::Array[X] other_ary1, ::Array[Y] other_ary2) -> ::Array[[ Elem, X, Y ]]
             | [U] (*::Array[U] other_arys) -> ::Array[::Array[Elem | U]]

  def push: (*Elem obj) -> self

  alias rassoc assoc

  alias reject delete_if

  def reject!: () { (Elem item) -> boolish } -> self?
             | () -> ::Enumerator[Elem, self?]

  def repeated_combination: (int n) { (::Array[Elem] c) -> void } -> self
                          | (int n) -> ::Enumerator[::Array[Elem], self]

  def repeated_permutation: (int n) { (::Array[Elem] p) -> void } -> self
                          | (int n) -> ::Enumerator[::Array[Elem], self]

  def replace: (::Array[Elem]) -> self

  def reverse: () -> ::Array[Elem]

  def reverse!: () -> ::Array[Elem]

  def reverse_each: () { (Elem item) -> void } -> self
                  | () -> ::Enumerator[Elem, self]

  def rfind: () { (Elem) -> boolish } -> Elem?
           | () -> ::Enumerator[Elem, Elem?]
           | [T] (Enumerable::_NotFound[T] ifnone) { (Elem) -> boolish } -> (Elem | T)
           | [T] (Enumerable::_NotFound[T] ifnone) -> ::Enumerator[Elem, Elem | T]

  def rindex: (untyped obj) -> ::Integer?
            | () { (Elem item) -> boolish } -> ::Integer?
            | () -> ::Enumerator[Elem, ::Integer?]

  def rotate: (?int count) -> ::Array[Elem]

  def rotate!: (?int count) -> self

  def sample: %a{implicitly-returns-nil} (?random: _Rand rng) -> Elem
            | (int n, ?random: _Rand rng) -> ::Array[Elem]

  def select: () { (Elem item) -> boolish } -> ::Array[Elem]
            | () -> ::Enumerator[Elem, ::Array[Elem]]

  def select!: () { (Elem item) -> boolish } -> self?
             | () -> ::Enumerator[Elem, self?]

  def shift: %a{implicitly-returns-nil} () -> Elem
           | (int n) -> ::Array[Elem]

  def shuffle: (?random: _Rand rng) -> ::Array[Elem]

  def shuffle!: (?random: _Rand rng) -> self

  alias size length

  def slice: %a{implicitly-returns-nil} (int index) -> Elem
           | (int start, int length) -> ::Array[Elem]?
           | (::Range[::Integer] range) -> ::Array[Elem]?

  def slice!: %a{implicitly-returns-nil} (int index) -> Elem
            | (int start, int length) -> ::Array[Elem]?
            | (::Range[::Integer] range) -> ::Array[Elem]?

  def sort: () -> ::Array[Elem]
          | () { (Elem a, Elem b) -> ::Integer } -> ::Array[Elem]

  def sort!: () -> self
           | () { (Elem a, Elem b) -> ::Integer } -> self

  def sort_by!: [U] () { (Elem obj) -> U } -> ::Array[Elem]
              | () -> ::Enumerator[Elem, ::Array[Elem]]

  def sum: (?untyped init) -> untyped
         | (?untyped init) { (Elem e) -> untyped } -> untyped

  def take: (int n) -> ::Array[Elem]

  def take_while: () { (Elem obj) -> boolish } -> ::Array[Elem]
                | () -> ::Enumerator[Elem, ::Array[Elem]]

  def to_a: () -> ::Array[Elem]

  def to_ary: () -> self

  def to_h: () -> Hash[untyped, untyped]
          | [T, S] () { (Elem) -> [ T, S ] } -> Hash[T, S]

  alias to_s inspect

  def transpose: () -> ::Array[::Array[untyped]]

  def union: [T] (*::Array[T] other_arys) -> ::Array[T | Elem]

  def uniq: () -> ::Array[Elem]
          | () { (Elem item) -> untyped } -> ::Array[Elem]

  def uniq!: () -> self?
           | () { (Elem) -> untyped } -> self?

  def unshift: (*Elem obj) -> self

  def values_at: (*int | ::Range[::Integer] selector) -> ::Array[Elem?]

  def zip: [U] (_Each[U] arg) -> Array[[ Elem, U? ]]
         | (_Each[untyped] arg, *_Each[untyped] args) -> Array[Array[untyped]]
         | [U] (_Each[U] arg) { ([ Elem, U? ]) -> void } -> nil
         | (_Each[untyped] arg, *_Each[untyped] args) { (Array[untyped]) -> void } -> nil

  def |: [T] (::Array[T] other_ary) -> ::Array[Elem | T]

  private

  def initialize_copy: (self other_ary) -> void
end

interface _Rand
  def rand: (::Integer max) -> ::Integer
end

interface Array::_Pattern[T]
  def ===: (T) -> bool
end
