class Enumerator[unchecked out Elem, out Return = void] < Object
  include Enumerable[Elem]

  interface _Each[out E, out R]
    def each: () { (E) -> void } -> R
            | () -> Enumerator[E, R]
  end

  def self.produce: [T] () { (T? prev) -> T } -> Enumerator[T, bot]
                  | [T] (T initial) { (T prev) -> T } -> Enumerator[T, bot]

  def self.product: [Elem] (*_EachEntry[Elem]) -> Product[Elem]

  def each: () { (Elem arg0) -> untyped } -> Return
          | () -> self

  def feed: (Elem arg0) -> NilClass

  def initialize: (?Integer arg0) { (Enumerator::Yielder arg0) -> Return } -> void

  def inspect: () -> String

  def next: () -> Elem

  def next_values: () -> ::Array[Elem]

  def peek: () -> Elem

  def peek_values: () -> ::Array[Elem]

  def rewind: () -> self

  def size: () -> (Integer | Float)?

  def +: [Elem2] (::_Each[Elem2]) -> ::Enumerator::Chain[Elem | Elem2]

  def with_index: (?Integer offset) { (Elem arg0, Integer arg1) -> untyped } -> Return
                | (?Integer offset) -> ::Enumerator[[ Elem, Integer ], Return]

  def with_object: [U] (U obj) { (Elem, U obj) -> untyped } -> U
                 | [U] (U obj) -> ::Enumerator[[ Elem, U ], U]
end

class Enumerator::Generator[out Elem] < Object
  include Enumerable[Elem]

  def each: () { (Elem) -> void } -> void
end

class Enumerator::Lazy[out Elem, out Return = void] < Enumerator[Elem, Return]
  alias force to_a

  def compact: () -> Enumerator::Lazy[Elem, Return]

  def eager: () -> ::Enumerator[Elem, Return]
end

class Enumerator::Yielder < Object
  def <<: (untyped arg0) -> void

  def yield: (*untyped arg0) -> void

  def to_proc: () -> Proc
end

class Enumerator::Chain[out Elem] < Enumerator[Elem, void]
  def initialize: (*_Each[Elem] enums) -> void

  def each: () { (Elem) -> void } -> self
          | () -> Enumerator[Elem, self]
end
