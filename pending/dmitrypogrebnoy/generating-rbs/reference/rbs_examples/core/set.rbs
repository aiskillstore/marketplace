class Set[unchecked out A]
  include Enumerable[A]

  def initialize: (_Each[A]) -> untyped
                | [X] (_Each[X]) { (X) -> A } -> untyped
                | (?nil) -> untyped

  def self.[]: [X] (*X) -> Set[X]

  def &: (_Each[A]) -> self

  alias intersection &

  def |: (_Each[A]) -> self

  alias union |

  alias + |

  def -: (_Each[A]) -> self

  alias difference -

  def add: (A) -> self

  alias << add

  def add?: (A) -> self?

  def include?: (A) -> bool

  alias member? include?

  def ^: (_Each[A]) -> self

  def classify: [X] () { (A) -> X } -> Hash[X, self]

  def clear: () -> self

  def collect!: () { (A) -> A } -> self

  alias map! collect!

  def delete: (A) -> self

  def delete?: (A) -> self?

  def delete_if: () { (A) -> untyped } -> self

  def reject!: () { (A) -> untyped } -> self?

  def compare_by_identity: () -> self

  def compare_by_identity?: () -> bool

  def disjoint?: (Set[A] | Enumerable[A]) -> bool

  def divide: () { (A, A) -> Hash::_Key } -> Set[self]
            | () { (A) -> Hash::_Key } -> Set[self]

  def each: () { (A) -> void } -> self
          | () -> Enumerator[A, self]

  def empty?: () -> bool

  def flatten: () -> Set[untyped]

  def flatten!: () -> self?

  def intersect?: (Set[A] | Enumerable[A]) -> bool

  def keep_if: () { (A) -> untyped } -> self

  def size: () -> Integer

  alias length size

  def merge: (*_Each[A]) -> self

  def subset?: (self) -> bool

  alias <= subset?

  def proper_subset?: (self) -> bool

  alias < proper_subset?

  def superset?: (self) -> bool

  alias >= superset?

  def proper_superset?: (self) -> bool

  alias > proper_superset?

  def replace: (_Each[A]) -> self

  def reset: () -> self

  def select!: () { (A) -> untyped } -> self?

  alias filter! select!

  def subtract: (_Each[A]) -> self

  def to_a: () -> Array[A]

  def join: (?string separator) -> String
end

%a{annotate:rdoc:skip}
module Enumerable[unchecked out Elem]
  def to_set: () -> Set[Elem]
            | [T] () { (Elem) -> T } -> Set[T]
end
