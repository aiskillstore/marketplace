{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-31T08:39:07.851Z",
    "slug": "vercel-labs-next-cache-components",
    "source_url": "https://github.com/vercel-labs/next-skills/tree/main/skills/next-cache-components/",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "eae0845ff622e953a2647144bfb43b3e2b5297646cbddd19f43a2b1dcfe86e4f",
    "tree_hash": "2ece3cc867a57739f300d7d89004ce370599af0d5579a99ff742f692809a3a16"
  },
  "skill": {
    "name": "next-cache-components",
    "description": "Next.js 16 Cache Components - PPR, use cache directive, cacheLife, cacheTag, updateTag",
    "summary": "Master Next.js 16 caching features for performant web applications",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "vercel-labs",
    "license": "MIT",
    "tags": [
      "Next.js",
      "caching",
      "PPR",
      "performance",
      "React Server Components"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Documentation-only skill containing code examples for Next.js 16 caching features. All 82 static findings are false positives: backticks in code blocks flagged as shell commands, fetch examples in documentation, and crypto APIs in examples. No executable code, network calls, or security risks present.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 361,
    "audit_model": "claude",
    "audited_at": "2026-01-31T08:39:07.851Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Optimize Next.js Performance with Cache Components",
    "value_statement": "Next.js applications often fetch data repeatedly, causing slow page loads. Cache Components enable Partial Prerendering and intelligent caching strategies to serve cached content instantly while streaming dynamic parts.",
    "seo_keywords": [
      "Next.js cache components",
      "Partial Prerendering",
      "use cache directive",
      "cacheLife",
      "cacheTag",
      "Next.js performance",
      "React Server Components",
      "Next.js 16",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Explain Cache Components and Partial Prerendering architecture",
      "Provide code examples for 'use cache' directive at file, component, and function levels",
      "Show cache invalidation patterns using cacheTag, updateTag, and revalidateTag",
      "Demonstrate cache profiles and custom lifetime configuration",
      "Help migrate from older Next.js caching APIs to Cache Components"
    ],
    "limitations": [
      "Cannot access cookies, headers, or searchParams inside 'use cache' blocks",
      "Edge runtime is not supported - requires Node.js server runtime",
      "Static export mode (next export) is not supported",
      "Non-deterministic values like Math.random() execute once at build time"
    ],
    "use_cases": [
      {
        "title": "Optimize Dashboard Pages",
        "description": "Create dashboard pages with static shell, cached stats, and streaming notifications using Suspense boundaries.",
        "target_user": "Full-stack developers building admin panels"
      },
      {
        "title": "Implement CMS Caching Strategy",
        "description": "Cache blog posts and product pages with intelligent invalidation when content changes via cacheTag.",
        "target_user": "Content platform developers"
      },
      {
        "title": "Migrate from Legacy Caching",
        "description": "Update older Next.js projects using experimental.ppr or unstable_cache to modern Cache Components.",
        "target_user": "Legacy Next.js project maintainers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Cache Setup",
        "prompt": "How do I enable Cache Components in Next.js 16? Show me the configuration and basic usage pattern.",
        "scenario": "Getting started with Next.js caching"
      },
      {
        "title": "Cache Invalidation",
        "prompt": "I need to invalidate my product cache when inventory changes. Show me how to use cacheTag and updateTag for immediate invalidation.",
        "scenario": "Implementing cache invalidation for e-commerce"
      },
      {
        "title": "Custom Cache Lifetime",
        "scenario": "Configuring custom cache duration",
        "prompt": "How do I set custom cache lifetime with cacheLife()? Show me both built-in profiles and inline configuration for stale-while-revalidate behavior."
      },
      {
        "title": "Migration Patterns",
        "prompt": "I'm migrating from experimental.ppr and dynamic = 'force-static'. What is the equivalent Cache Components pattern for revalidate = 3600?",
        "scenario": "Migrating from older Next.js versions"
      }
    ],
    "output_examples": [
      {
        "input": "How do I cache a data fetch function in Next.js 16?",
        "output": "Use the 'use cache' directive at the function level:\n\n```tsx\nasync function getBlogPosts() {\n  'use cache'\n  cacheLife('hours')\n  \n  const posts = await db.posts.findMany()\n  return posts\n}\n```\n\nThis caches the function result with hourly revalidation. The cache key includes the build ID, function location, and closure variables."
      },
      {
        "input": "How do I invalidate cache when a product is updated?",
        "output": "Use cacheTag() to tag cached content and updateTag() or revalidateTag() to invalidate:\n\n```tsx\n// Tag during caching\nasync function getProduct(id: string) {\n  'use cache'\n  cacheTag('products', `product-${id}`)\n  return db.products.findUnique({ where: { id } })\n}\n\n// Invalidate on update\n'use server'\nexport async function updateProduct(id: string, data: FormData) {\n  await db.products.update({ where: { id }, data })\n  updateTag(`product-${id}`)  // Immediate invalidation\n}\n```"
      },
      {
        "input": "What are the three content types in Cache Components?",
        "output": "**1. Static** - Synchronous code, imports, pure computations. Prerendered at build time.\n\n**2. Cached** - Async data with 'use cache' directive. Served from cache with optional revalidation.\n\n**3. Dynamic** - Runtime data in Suspense boundaries. Streams in fresh on each request.\n\nMix all three in one page:\n```tsx\nexport default function Page() {\n  return (\n    <>\n      <Header />  {/* Static */}\n      <Stats />    {/* Cached with 'use cache' */}\n      <Suspense fallback={<Loading />}>\n        <UserData />  {/* Dynamic - streams in */}\n      </Suspense>\n    </>\n  )\n}\n```"
      }
    ],
    "best_practices": [
      "Use 'use cache' at the function level for fine-grained control over what gets cached",
      "Apply cacheTag() to enable targeted invalidation when data sources update",
      "Combine cached content with Suspense boundaries to maintain fast initial page loads",
      "Test cache behavior with different profiles (minutes, hours, days) before deploying"
    ],
    "anti_patterns": [
      "Accessing cookies(), headers(), or searchParams directly inside 'use cache' blocks - pass them as arguments instead",
      "Caching highly dynamic user-specific data that changes on every request",
      "Using Math.random() or Date.now() inside cached functions - they execute once at build time",
      "Forgetting to add cacheTag() before implementation - makes invalidation impossible"
    ],
    "faq": [
      {
        "question": "What is the difference between updateTag() and revalidateTag()?",
        "answer": "updateTag() invalidates immediately within the same request, so subsequent reads see fresh data. revalidateTag() triggers background revalidation - the next request sees stale data while revalidating in the background."
      },
      {
        "question": "Can I use 'use cache' with Edge Runtime?",
        "answer": "No. Cache Components require the Node.js server runtime. Edge runtime does not support the caching infrastructure needed for 'use cache' directive."
      },
      {
        "question": "How do I handle user-specific data with Cache Components?",
        "answer": "Pass user-specific data as function arguments. The arguments become part of the cache key, so each user gets their own cached version. Do not access cookies() or headers() inside 'use cache'."
      },
      {
        "question": "What happens to cached data when I deploy a new version?",
        "answer": "Cache is automatically invalidated by the build ID. Deploying a new version changes the build ID, so all cached content is treated as fresh and repopulated on first access."
      },
      {
        "question": "How do I debug cache behavior in development?",
        "answer": "Check the Next.js DevTools cache panel. You can also add console.log statements inside 'use cache' blocks - they only execute when the cache is being populated, not on cache hits."
      },
      {
        "question": "What is the default cache behavior without any configuration?",
        "answer": "Without 'use cache', content is either static (synchronous code) or dynamic (suspended). With 'use cache' alone, it uses the default profile: 5 minutes stale, 15 minutes revalidation."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 361
    }
  ]
}
