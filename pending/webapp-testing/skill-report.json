{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2025-12-31T05:38:58.673Z",
    "slug": "webapp-testing",
    "source_url": "https://github.com/anthropics/skills/tree/main/skills/webapp-testing",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "trust_level": "official"
  },
  "skill": {
    "name": "webapp-testing",
    "description": "Toolkit for interacting with and testing local web applications using Playwright. Supports verifying frontend functionality, debugging UI behavior, capturing browser screenshots, and viewing browser logs.",
    "summary": "Toolkit for interacting with and testing local web applications using Playwright. Supports verifying...",
    "icon": "üåê",
    "version": "1.0.0",
    "author": "Anthropic",
    "license": "Complete terms in LICENSE.txt",
    "category": "automation",
    "tags": [
      "playwright",
      "testing",
      "web-automation",
      "browser",
      "qa",
      "frontend",
      "debugging",
      "screenshots"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Official Anthropic skill with standard Playwright browser automation patterns. No malicious code, arbitrary command execution, or unsafe operations detected. Uses localhost connections and local file operations appropriately.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 6,
    "total_lines": 512,
    "audit_model": "claude",
    "audited_at": "2025-12-31T05:38:58.673Z"
  },
  "content": {
    "user_title": "Web Application Testing with Playwright",
    "value_statement": "Automate browser interactions, test web applications, capture screenshots, and debug frontend behavior using Python and Playwright without manual clicking.",
    "seo_keywords": [
      "playwright automation",
      "web app testing",
      "browser automation",
      "frontend testing",
      "UI testing",
      "web scraping",
      "screenshot capture",
      "console logging",
      "qa automation"
    ],
    "actual_capabilities": [
      "Launch headless Chrome browser and navigate to local or remote web pages",
      "Discover and interact with page elements (buttons, links, forms, inputs)",
      "Capture full-page screenshots for visual debugging",
      "Record browser console logs during page interactions",
      "Test static HTML files using file:// URLs",
      "Manage server lifecycle with automatic startup/shutdown",
      "Support multiple concurrent servers (frontend + backend)",
      "Wait for dynamic content to load before interaction",
      "Fill forms, click buttons, and simulate user interactions"
    ],
    "limitations": [
      "Requires Playwright to be installed in the Python environment",
      "Only supports Chromium browser in headless mode",
      "Cannot interact with pages requiring authentication without explicit credential handling",
      "Limited to localhost or publicly accessible URLs",
      "No built-in support for cross-browser testing (Firefox/Safari)",
      "Requires server to be startable via command-line for with_server.py helper"
    ],
    "use_cases": [
      {
        "title": "Frontend QA Testing",
        "description": "Automate regression testing of web applications by scripting user flows, capturing screenshots, and verifying UI behavior after code changes.",
        "target_user": "QA engineers and frontend developers"
      },
      {
        "title": "UI Debugging",
        "description": "Debug visual issues by capturing screenshots at different stages of interaction and recording console errors that appear during page execution.",
        "target_user": "Frontend developers troubleshooting UI bugs"
      },
      {
        "title": "Local Development Testing",
        "description": "Test web applications during development by automatically starting the dev server, running automation scripts, and shutting down cleanly.",
        "target_user": "Full-stack developers working on local projects"
      },
      {
        "title": "Form Validation Testing",
        "description": "Automate testing of form submissions, input validation, and error handling by programmatically filling fields and submitting data.",
        "target_user": "Developers testing form-heavy applications"
      }
    ],
    "prompt_templates": [
      {
        "title": "Test Login Flow",
        "prompt": "Test the login flow at http://localhost:3000. Fill in username 'testuser' and password 'testpass', click submit, and verify the dashboard loads. Capture screenshots before and after login.",
        "scenario": "When you need to automate and verify authentication flows"
      },
      {
        "title": "Discover Page Elements",
        "prompt": "Open http://localhost:5173 and discover all buttons, links, and form inputs on the page. Save a screenshot and list all interactive elements found.",
        "scenario": "When you need to understand what's available on a page before writing tests"
      },
      {
        "title": "Test Static HTML",
        "prompt": "Test the contact form in ./public/contact.html. Fill in name, email, and message fields, submit the form, and verify the success message appears.",
        "scenario": "When testing standalone HTML files without a server"
      },
      {
        "title": "Capture Console Errors",
        "prompt": "Navigate to http://localhost:8080/dashboard and capture all console logs (including errors) while clicking through the main navigation tabs. Save logs to a file.",
        "scenario": "When debugging JavaScript errors that appear during user interactions"
      },
      {
        "title": "Multi-Server Testing",
        "prompt": "Start both the backend API server (port 3000) and frontend dev server (port 5173), then test that the frontend successfully fetches data from the API.",
        "scenario": "When testing full-stack applications with separate frontend and backend servers"
      }
    ],
    "output_examples": [
      {
        "input": "Navigate to http://localhost:5173, click the 'Dashboard' button, and take a screenshot",
        "output": "Screenshot saved to /tmp/dashboard.png showing the dashboard page after navigation"
      },
      {
        "input": "Discover all buttons on http://localhost:3000",
        "output": "Found 5 buttons:\n  [0] Login\n  [1] Sign Up\n  [2] Forgot Password\n  [3] Submit\n  [4] Cancel"
      },
      {
        "input": "Capture console logs while navigating to http://localhost:8080",
        "output": "Captured 12 console messages\nLogs saved to: /mnt/user-data/outputs/console.log\n[log] App initialized\n[error] Failed to load resource: net::ERR_BLOCKED_BY_CLIENT"
      }
    ],
    "best_practices": [
      "Always use page.wait_for_load_state('networkidle') on dynamic web apps before inspecting DOM",
      "Launch browsers in headless mode for automated testing (headless=True)",
      "Use descriptive selectors: prefer text=, role=, or semantic IDs over generic CSS selectors",
      "Take screenshots during key steps for debugging and visual verification",
      "Use with_server.py helper to manage server lifecycle instead of manual process management",
      "Run helper scripts with --help first to understand usage before implementation",
      "Close browsers properly to avoid resource leaks",
      "Use appropriate waits (wait_for_selector, wait_for_timeout) instead of arbitrary sleeps",
      "Treat bundled scripts as black boxes - invoke directly rather than reading source code"
    ],
    "anti_patterns": [
      "Inspecting DOM before waiting for networkidle on dynamic applications",
      "Reading helper script source code instead of using --help flag",
      "Using arbitrary sleep timeouts instead of waiting for specific conditions",
      "Forgetting to close browser instances after automation completes",
      "Testing without screenshots when visual verification is needed",
      "Manually managing server processes instead of using with_server.py"
    ],
    "faq": [
      {
        "question": "Do I need to install Playwright separately?",
        "answer": "Yes, you need to have Playwright installed in your Python environment. Install it with: pip install playwright && playwright install chromium"
      },
      {
        "question": "Can I test applications that aren't running on localhost?",
        "answer": "Yes, you can navigate to any accessible URL, but the with_server.py helper is designed specifically for managing local development servers."
      },
      {
        "question": "What's the difference between static HTML and dynamic webapp testing?",
        "answer": "Static HTML can be read directly to identify selectors, then automated using file:// URLs. Dynamic webapps require running the server, navigating with a browser, and waiting for networkidle before inspecting the DOM."
      },
      {
        "question": "Can I run tests with visible browser windows?",
        "answer": "While Playwright supports headed mode (headless=False), this skill is designed for headless automation to avoid UI dependencies."
      },
      {
        "question": "How do I debug failed automation scripts?",
        "answer": "Use screenshots at each step (page.screenshot()), capture console logs with page.on('console'), and use page.content() to inspect the DOM state when selectors fail to match."
      }
    ],
    "technical_requirements": {
      "dependencies": [
        "playwright",
        "python3"
      ],
      "permissions": [
        "network access to localhost",
        "file system read/write for screenshots and logs",
        "process execution for server management"
      ],
      "complexity": "intermediate"
    }
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "console_logging.py",
          "type": "file",
          "path": "examples/console_logging.py"
        },
        {
          "name": "element_discovery.py",
          "type": "file",
          "path": "examples/element_discovery.py"
        },
        {
          "name": "static_html_automation.py",
          "type": "file",
          "path": "examples/static_html_automation.py"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "with_server.py",
          "type": "file",
          "path": "scripts/with_server.py"
        }
      ]
    },
    {
      "name": "LICENSE.txt",
      "type": "file",
      "path": "LICENSE.txt"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}