{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2025-12-30T12:35:43.767Z",
    "slug": "webapp-testing",
    "source_url": "https://github.com/anthropics/skills/tree/main/skills/webapp-testing",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "trust_level": "official"
  },
  "skill": {
    "name": "webapp-testing",
    "description": "Toolkit for interacting with and testing local web applications using Playwright. Supports verifying frontend functionality, debugging UI behavior, capturing browser screenshots, and viewing browser logs.",
    "summary": "Toolkit for interacting with and testing local web applications using Playwright. Supports verifying...",
    "icon": "ðŸ§ª",
    "version": "1.0.0",
    "author": "Anthropic",
    "license": "Complete terms in LICENSE.txt",
    "category": "automation",
    "tags": [
      "testing",
      "playwright",
      "web-automation",
      "frontend",
      "browser-testing",
      "ui-testing",
      "debugging"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Official Anthropic skill using standard Playwright browser automation. No malicious code, arbitrary execution risks, or security vulnerabilities detected.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 6,
    "total_lines": 512,
    "audit_model": "claude",
    "audited_at": "2025-12-30T12:35:43.767Z"
  },
  "content": {
    "user_title": "Web Application Testing with Playwright",
    "value_statement": "Automate browser interactions, test web applications, capture screenshots, and debug UI behavior using Python and Playwright for comprehensive frontend testing.",
    "seo_keywords": [
      "playwright",
      "web testing",
      "browser automation",
      "frontend testing",
      "ui testing",
      "selenium alternative",
      "end-to-end testing",
      "screenshot capture",
      "console logging",
      "local webapp testing"
    ],
    "actual_capabilities": [
      "Automate browser interactions with web applications using Playwright",
      "Capture full-page screenshots for visual verification",
      "Extract and analyze console logs during browser sessions",
      "Discover and interact with page elements (buttons, links, inputs)",
      "Test static HTML files using file:// URLs",
      "Manage server lifecycle for testing dynamic applications",
      "Support multiple concurrent servers (backend + frontend)",
      "Wait for network idle states before testing dynamic content",
      "Fill forms and submit data programmatically",
      "Navigate between pages and verify UI behavior"
    ],
    "limitations": [
      "Requires Python and Playwright installation",
      "Limited to localhost/local file testing scenarios",
      "Runs in headless mode only (no visual browser window)",
      "Requires manual selector identification for complex dynamic UIs",
      "Server management script only supports basic lifecycle (start/stop)",
      "No built-in assertion library for advanced test verification"
    ],
    "use_cases": [
      {
        "title": "Frontend Regression Testing",
        "description": "Automatically verify that UI changes haven't broken existing functionality by running Playwright scripts that interact with key user flows and capture screenshots for comparison.",
        "target_user": "Frontend developers and QA engineers"
      },
      {
        "title": "Local Development Debugging",
        "description": "Debug UI issues by capturing console logs and screenshots during automated browser sessions to identify JavaScript errors or unexpected behavior.",
        "target_user": "Web developers troubleshooting local applications"
      },
      {
        "title": "Form Submission Testing",
        "description": "Test form validation, submission flows, and error handling by programmatically filling inputs and verifying responses.",
        "target_user": "Full-stack developers building web forms"
      },
      {
        "title": "Multi-Server Integration Testing",
        "description": "Test full-stack applications by launching both backend and frontend servers simultaneously, then running end-to-end tests against the integrated system.",
        "target_user": "DevOps engineers and full-stack developers"
      },
      {
        "title": "Static HTML Prototyping",
        "description": "Test and validate static HTML prototypes or documentation sites using file:// URLs without requiring a web server.",
        "target_user": "UI/UX designers and technical writers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Test Login Flow",
        "prompt": "Write a Playwright script to test the login flow at http://localhost:3000. Fill in username 'testuser' and password 'password123', click submit, and verify the dashboard page loads.",
        "scenario": "When you need to verify authentication works correctly"
      },
      {
        "title": "Capture Console Errors",
        "prompt": "Create a Playwright script that navigates to http://localhost:5173, captures all console errors and warnings, and saves them to a log file.",
        "scenario": "When debugging JavaScript errors in a local web app"
      },
      {
        "title": "Screenshot Comparison",
        "prompt": "Write a script that takes full-page screenshots of http://localhost:3000 before and after clicking the 'Toggle Theme' button, saving both images for comparison.",
        "scenario": "When verifying visual changes like theme switching"
      },
      {
        "title": "Multi-Server Testing",
        "prompt": "Use with_server.py to start my backend (port 8000) and frontend (port 3000), then run a Playwright script that tests the full registration flow.",
        "scenario": "When testing a feature that requires both backend and frontend running"
      },
      {
        "title": "Element Discovery",
        "prompt": "Navigate to http://localhost:5173 and discover all buttons, links, and form inputs on the page, then print their text and attributes.",
        "scenario": "When exploring an unfamiliar UI to identify selectors for testing"
      }
    ],
    "output_examples": [
      {
        "input": "Test the search functionality on my local app",
        "output": "Created Playwright script that navigates to localhost:3000, fills search input with 'test query', clicks search button, waits for results, and captures screenshot showing 5 search results. Console logs saved to /mnt/user-data/outputs/search_test.log"
      },
      {
        "input": "Find all clickable elements on the homepage",
        "output": "Found 12 buttons: [0] Login, [1] Sign Up, [2] Learn More, [3] Dashboard, [4] Settings... Found 8 links: Home -> /, About -> /about, Contact -> /contact... Screenshot saved to /tmp/page_discovery.png"
      }
    ],
    "best_practices": [
      "Always run helper scripts with --help first to understand usage before reading source code",
      "Use page.wait_for_load_state('networkidle') before interacting with dynamic content to ensure JavaScript has executed",
      "Launch browsers in headless mode for automated testing: browser = p.chromium.launch(headless=True)",
      "Use descriptive selectors (text=, role=, or semantic IDs) rather than brittle CSS selectors",
      "Always close the browser in a try/finally block or context manager to prevent resource leaks",
      "Take screenshots before and after critical actions for debugging and verification",
      "For static HTML, read the file directly to identify selectors before writing automation",
      "Use the reconnaissance-then-action pattern: inspect DOM, identify selectors, then execute actions",
      "Leverage with_server.py for server lifecycle management rather than manual process handling",
      "Add appropriate waits (wait_for_selector, wait_for_timeout) to handle asynchronous UI updates"
    ],
    "anti_patterns": [
      "Don't inspect the DOM before waiting for networkidle on dynamic applications",
      "Don't read helper script source code until after trying --help and finding it insufficient",
      "Don't use fragile XPath or overly specific CSS selectors that break with minor UI changes",
      "Don't forget to close browsers, which can leave zombie processes consuming resources",
      "Don't assume static timing (sleep/timeout) is sufficientâ€”use dynamic waits for element availability",
      "Don't manually manage server processes when with_server.py can handle lifecycle automatically",
      "Don't test against remote servers with this skillâ€”it's designed for localhost development",
      "Don't skip viewport configuration for responsive testingâ€”set explicit dimensions when needed"
    ],
    "faq": [
      {
        "question": "How do I test an app that requires both backend and frontend servers?",
        "answer": "Use the with_server.py script with multiple --server and --port arguments: `python scripts/with_server.py --server 'cd backend && python server.py' --port 8000 --server 'cd frontend && npm run dev' --port 5173 -- python your_test.py`. The script manages both servers and runs your test when they're ready."
      },
      {
        "question": "Why is my Playwright script not finding elements that exist in the HTML?",
        "answer": "For dynamic webapps, you must wait for JavaScript to execute before inspecting the DOM. Use `page.wait_for_load_state('networkidle')` after navigation to ensure the page is fully rendered before interacting with elements."
      },
      {
        "question": "Can I test static HTML files without running a server?",
        "answer": "Yes, use file:// URLs. See examples/static_html_automation.py for the pattern: `file_url = f'file://{os.path.abspath(\"path/to/file.html\")}'; page.goto(file_url)`"
      },
      {
        "question": "How do I capture console errors and logs during testing?",
        "answer": "Set up a console message handler before navigation: `page.on('console', lambda msg: print(f'[{msg.type}] {msg.text}'))`. See examples/console_logging.py for a complete example that saves logs to a file."
      },
      {
        "question": "What's the best way to find selectors for elements I want to interact with?",
        "answer": "Use the reconnaissance pattern: navigate to the page, take a screenshot, then use `page.locator('button').all()` or `page.content()` to inspect the rendered DOM. Prefer semantic selectors like `text=Login` or `role=button` over CSS selectors."
      }
    ],
    "technical_requirements": {
      "dependencies": [
        "python3",
        "playwright",
        "socket",
        "subprocess"
      ],
      "permissions": [
        "Network access to localhost",
        "File system read/write for screenshots and logs",
        "Process execution for server management"
      ],
      "complexity": "intermediate"
    }
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "console_logging.py",
          "type": "file",
          "path": "examples/console_logging.py"
        },
        {
          "name": "element_discovery.py",
          "type": "file",
          "path": "examples/element_discovery.py"
        },
        {
          "name": "static_html_automation.py",
          "type": "file",
          "path": "examples/static_html_automation.py"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "with_server.py",
          "type": "file",
          "path": "scripts/with_server.py"
        }
      ]
    },
    {
      "name": "LICENSE.txt",
      "type": "file",
      "path": "LICENSE.txt"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}