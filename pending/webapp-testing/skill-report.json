{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2025-12-30T13:24:44.650Z",
    "slug": "webapp-testing",
    "source_url": "https://github.com/anthropics/skills/tree/main/skills/webapp-testing",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "trust_level": "official"
  },
  "skill": {
    "name": "webapp-testing",
    "description": "Toolkit for interacting with and testing local web applications using Playwright. Supports verifying frontend functionality, debugging UI behavior, capturing browser screenshots, and viewing browser logs.",
    "summary": "Toolkit for interacting with and testing local web applications using Playwright. Supports verifying...",
    "icon": "ðŸ§ª",
    "version": "1.0.0",
    "author": "Anthropic",
    "license": "Complete terms in LICENSE.txt",
    "category": "automation",
    "tags": [
      "playwright",
      "testing",
      "web-automation",
      "browser-automation",
      "qa",
      "frontend-testing",
      "ui-testing"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Official Anthropic skill with safe browser automation patterns. Uses standard Playwright APIs for local web testing with no network exfiltration or malicious behavior.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 6,
    "total_lines": 512,
    "audit_model": "claude",
    "audited_at": "2025-12-30T13:24:44.649Z"
  },
  "content": {
    "user_title": "Web Application Testing with Playwright",
    "value_statement": "Automate browser interactions, test web UIs, capture screenshots, and debug frontend behavior for local web applications using Python and Playwright.",
    "seo_keywords": [
      "playwright automation",
      "web app testing",
      "browser automation",
      "UI testing",
      "frontend testing",
      "screenshot capture",
      "console logging",
      "localhost testing"
    ],
    "actual_capabilities": [
      "Launch headless Chromium browsers and navigate to local or remote web pages",
      "Discover and interact with page elements (buttons, links, forms)",
      "Capture full-page screenshots for visual verification",
      "Monitor and save browser console logs during automation",
      "Test static HTML files using file:// URLs",
      "Manage server lifecycle with multi-server support via helper scripts",
      "Wait for dynamic content to load before inspection",
      "Fill forms, click elements, and simulate user interactions"
    ],
    "limitations": [
      "Requires Playwright to be installed in the Python environment",
      "Only supports Chromium browser in headless mode",
      "Server management script requires servers to expose TCP ports",
      "Cannot interact with authentication flows requiring real user credentials",
      "May fail on complex SPAs without proper wait strategies"
    ],
    "use_cases": [
      {
        "title": "Frontend Functionality Verification",
        "description": "Automate testing of UI components, form submissions, and navigation flows in local development environments",
        "target_user": "Frontend developers and QA engineers testing web applications"
      },
      {
        "title": "Visual Regression Testing",
        "description": "Capture screenshots of web pages before and after changes to detect unintended visual regressions",
        "target_user": "Development teams implementing CI/CD pipelines"
      },
      {
        "title": "Console Log Debugging",
        "description": "Monitor JavaScript console output during automated workflows to identify errors or warnings",
        "target_user": "Developers debugging client-side JavaScript issues"
      },
      {
        "title": "Multi-Service Integration Testing",
        "description": "Start backend and frontend servers simultaneously, then test their integration automatically",
        "target_user": "Full-stack developers testing complete application stacks"
      },
      {
        "title": "Static HTML Validation",
        "description": "Test local HTML files without running a server using file:// protocol",
        "target_user": "Web designers and developers working with static sites"
      }
    ],
    "prompt_templates": [
      {
        "title": "Test Login Flow",
        "prompt": "Test the login functionality on http://localhost:3000. Fill in the username 'testuser' and password 'testpass', submit the form, and verify successful login by checking for a dashboard element.",
        "scenario": "Automated testing of authentication workflows"
      },
      {
        "title": "Capture Page State",
        "prompt": "Navigate to http://localhost:5173, wait for the page to fully load, take a full-page screenshot, and save all console logs to a file.",
        "scenario": "Debugging frontend issues in development"
      },
      {
        "title": "Element Discovery",
        "prompt": "Explore http://localhost:8080 and list all buttons, links, and input fields on the page with their labels and attributes.",
        "scenario": "Understanding page structure before writing tests"
      },
      {
        "title": "Multi-Server Testing",
        "prompt": "Start the backend server on port 3000 and frontend on port 5173, then test that the frontend can successfully fetch data from the API endpoint /api/users.",
        "scenario": "End-to-end testing with multiple services"
      }
    ],
    "output_examples": [
      {
        "input": "Navigate to localhost:5173, click the 'Dashboard' button, and capture console logs",
        "output": "Screenshot saved to /mnt/user-data/outputs/page.png\nCaptured 12 console messages:\n[log] App initialized\n[log] User data loaded\n[warning] Deprecated API usage in module.js:45\nLogs saved to: /mnt/user-data/outputs/console.log"
      },
      {
        "input": "Discover all buttons on the homepage",
        "output": "Found 5 buttons:\n  [0] Sign In\n  [1] Sign Up\n  [2] Learn More\n  [3] Contact Us\n  [4] [hidden]\nScreenshot saved to /tmp/page_discovery.png"
      }
    ],
    "best_practices": [
      "Always wait for 'networkidle' state on dynamic web apps before inspecting or interacting with elements",
      "Use descriptive selectors (text=, role=, or IDs) for maintainable test scripts",
      "Launch Chromium in headless mode for automated testing environments",
      "Run helper scripts with --help first to understand usage before implementation",
      "Close browser instances properly to avoid resource leaks",
      "Use reconnaissance-then-action pattern: inspect DOM first, then execute actions based on discovered selectors",
      "Treat bundled scripts as black boxes - invoke directly rather than reading source code",
      "Add appropriate waits (wait_for_selector, wait_for_timeout) for dynamic content"
    ],
    "anti_patterns": [
      "Inspecting DOM before waiting for networkidle on dynamic applications",
      "Reading helper script source code instead of using --help flag",
      "Hardcoding selectors without first discovering actual page structure",
      "Launching non-headless browsers in automation scripts",
      "Forgetting to close browser instances after script execution",
      "Testing dynamic apps by reading static HTML source instead of rendered DOM"
    ],
    "faq": [
      {
        "question": "When should I use static HTML vs dynamic app approaches?",
        "answer": "Use static HTML approach (reading HTML files directly) only for truly static pages. For any app with JavaScript, treat it as dynamic - navigate with Playwright, wait for networkidle, then inspect the rendered DOM."
      },
      {
        "question": "How do I test an app that requires both backend and frontend servers?",
        "answer": "Use the with_server.py script with multiple --server and --port arguments. Example: python scripts/with_server.py --server 'cd backend && python server.py' --port 3000 --server 'cd frontend && npm run dev' --port 5173 -- python test.py"
      },
      {
        "question": "Why should I wait for networkidle state?",
        "answer": "Modern web apps load content dynamically via JavaScript. Waiting for networkidle ensures all AJAX requests complete and the DOM is fully rendered before you try to interact with elements."
      },
      {
        "question": "Can I test authenticated pages?",
        "answer": "Yes, but you'll need to programmatically log in first using Playwright's fill() and click() methods, or set authentication cookies/tokens directly if available."
      },
      {
        "question": "What file paths should I use for outputs?",
        "answer": "Use /mnt/user-data/outputs/ for persistent output files that should be available after script execution. Use /tmp/ for temporary files."
      }
    ],
    "technical_requirements": {
      "dependencies": [
        "playwright",
        "python3"
      ],
      "permissions": [
        "network_access",
        "file_system_write"
      ],
      "complexity": "intermediate"
    }
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "console_logging.py",
          "type": "file",
          "path": "examples/console_logging.py"
        },
        {
          "name": "element_discovery.py",
          "type": "file",
          "path": "examples/element_discovery.py"
        },
        {
          "name": "static_html_automation.py",
          "type": "file",
          "path": "examples/static_html_automation.py"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "with_server.py",
          "type": "file",
          "path": "scripts/with_server.py"
        }
      ]
    },
    {
      "name": "LICENSE.txt",
      "type": "file",
      "path": "LICENSE.txt"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}