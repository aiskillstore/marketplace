{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T09:19:34.574Z",
    "slug": "7spade-blueprinteventbus-integration",
    "source_url": "https://github.com/7Spade/ng-dragon/tree/main/.github/skills/event-bus-integration",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "017d5f46145f78fd5617bd4c6cc0d7624d84fb2980fb0072dd77944051920517",
    "tree_hash": "3cd88c78f9ce93ed3cd85f9f9468df5714a6dfe7b21c2a199bff0a6db08f80e1"
  },
  "skill": {
    "name": "BlueprintEventBus Integration",
    "description": "Implement event-driven communication using BlueprintEventBus for cross-module coordination. Use this skill when modules need to communicate without tight coupling, broadcasting domain events (task.created, member.added), subscribing to events with proper lifecycle management, and implementing event-driven workflows. Ensures events follow naming conventions ([module].[action]), include Blueprint context, and use takeUntilDestroyed() for automatic cleanup.",
    "summary": "Implement event-driven communication using BlueprintEventBus for cross-module coordination. Use this...",
    "icon": "ðŸ“¡",
    "version": "1.0.0",
    "author": "7Spade",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "Angular",
      "event-driven",
      "architecture",
      "RxJS",
      "communication"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a documentation-only skill containing purely markdown content with TypeScript code examples. No executable code, scripts, network calls, file system access, or environment variable access is present. The skill provides guidance on implementing event-driven patterns and is safe for publication.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 554,
    "audit_model": "claude",
    "audited_at": "2026-01-10T09:19:34.574Z"
  },
  "content": {
    "user_title": "Implement Event-Driven Architecture",
    "value_statement": "Modules in large applications often become tightly coupled, making updates difficult and error-prone. This skill provides patterns and code examples for implementing BlueprintEventBus to enable loose coupling through events.",
    "seo_keywords": [
      "BlueprintEventBus",
      "event-driven architecture",
      "Angular",
      "cross-module communication",
      "RxJS",
      "loose coupling",
      "domain events",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Publish domain events with Blueprint context",
      "Subscribe to events with lifecycle management using takeUntilDestroyed()",
      "Filter events by Blueprint ID",
      "Implement audit logging via event subscriptions",
      "Create workflow orchestration with event chains"
    ],
    "limitations": [
      "Service implementation code must be written by developer",
      "No runtime event monitoring or debugging provided",
      "Does not generate event types automatically",
      "Requires Angular and RxJS knowledge"
    ],
    "use_cases": [
      {
        "target_user": "Angular developers",
        "title": "Add event-driven patterns",
        "description": "Implement BlueprintEventBus in Angular services for decoupled module communication."
      },
      {
        "target_user": "Architecture leads",
        "title": "Standardize event naming",
        "description": "Establish naming conventions like [module].[action] across teams for consistent event structures."
      },
      {
        "target_user": "Full-stack engineers",
        "title": "Connect UI and backend",
        "description": "Use events to trigger notifications and update UI when backend operations complete."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic event setup",
        "scenario": "Set up BlueprintEventBus",
        "prompt": "Show me how to inject BlueprintEventBus in an Angular service and publish a task.created event with blueprintId and actor fields."
      },
      {
        "title": "Subscribe with filtering",
        "scenario": "Listen to Blueprint events",
        "prompt": "Write Angular component code that subscribes to task events but only reacts to events from a specific Blueprint using input() and takeUntilDestroyed()."
      },
      {
        "title": "Audit logging system",
        "scenario": "Implement audit trail",
        "prompt": "Create an AuditLogService that subscribes to ALL events globally and logs them to a repository with full event metadata."
      },
      {
        "title": "Workflow automation",
        "scenario": "Chain multiple events",
        "prompt": "Implement a TaskWorkflowService that listens for task.completed events and automatically updates dependent tasks and notifies stakeholders."
      }
    ],
    "output_examples": [
      {
        "input": "Help me publish a task.assigned event when a user assigns a task to another team member.",
        "output": [
          "Type the event payload: { type: 'task.assigned', blueprintId, actor, data: { task, assignee, assigneeType } }",
          "Inject BlueprintEventBus and call publish()",
          "Subscription triggers notifications",
          "Event metadata tracks assignment history"
        ]
      }
    ],
    "best_practices": [
      "Always include blueprintId in events to enable Blueprint-specific filtering",
      "Use takeUntilDestroyed() to prevent memory leaks in components",
      "Publish events AFTER successful operations to maintain consistency"
    ],
    "anti_patterns": [
      "Do not use EventBus for simple parent-child component communication; use @Output instead",
      "Avoid circular event chains that cause infinite loops",
      "Do not use events for synchronous request-response patterns; use services directly"
    ],
    "faq": [
      {
        "question": "What versions of Angular does this skill support?",
        "answer": "This skill supports Angular 16+ with the inject() function and takeUntilDestroyed() API for lifecycle management."
      },
      {
        "question": "What are the naming limits for event types?",
        "answer": "Event types follow the [module].[action] pattern. Use lowercase letters, dots, and action verbs like created, updated, deleted."
      },
      {
        "question": "Can I use this with non-Angular frameworks?",
        "answer": "The patterns apply to any RxJS-based system, but code examples require Angular-specific features like inject() and DestroyRef."
      },
      {
        "question": "Is my event data stored or transmitted anywhere?",
        "answer": "No. This skill only provides patterns. Your implementation controls where event data is stored or sent."
      },
      {
        "question": "Why are my event subscriptions not working?",
        "answer": "Common issues include: missing takeUntilDestroyed() causing cleanup, subscribing after events publish, or missing blueprintId filtering."
      },
      {
        "question": "How is this different from Angular Signals?",
        "answer": "EventBus handles cross-module communication. Signals are for reactive state within components or services. Use both together."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
