{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T13:36:09.836Z",
    "slug": "dyai2025-defense-in-depth",
    "source_url": "https://github.com/DYAI2025/Stoppclock-page/tree/main/stoppclock_speckit/.claude/commands/skills/defense-in-depth",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "4a7e027620f74f7fc99a8fea4166250b2cc97565f639af70dbc7c2a6c1dfe805",
    "tree_hash": "b496fa3312436f720145727cdbc91deb780655f30bb19b04c4760435cb7e4dd5"
  },
  "skill": {
    "name": "defense-in-depth",
    "description": "Use when invalid data causes failures deep in execution, requiring validation at multiple system layers - validates at every layer data passes through to make bugs structurally impossible",
    "summary": "Use when invalid data causes failures deep in execution, requiring validation at multiple system lay...",
    "icon": "üõ°Ô∏è",
    "version": "1.0.0",
    "author": "DYAI2025",
    "license": "MIT",
    "category": "security",
    "tags": [
      "validation",
      "security",
      "software-quality",
      "defensive-programming"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill with educational TypeScript examples. No executable code, no network calls, no filesystem access, no external commands. Contains defensive programming patterns for software validation.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 128,
    "audit_model": "claude",
    "audited_at": "2026-01-10T13:36:09.836Z"
  },
  "content": {
    "user_title": "Apply Defense-in-Depth Validation",
    "value_statement": "Invalid data can bypass single validation checks through different code paths, refactoring, or mocks. Apply validation at every layer data passes through to make bugs structurally impossible.",
    "seo_keywords": [
      "defense in depth",
      "input validation",
      "software security",
      "multi-layer validation",
      "bug prevention",
      "Claude",
      "Codex",
      "Claude Code",
      "validation patterns",
      "secure coding"
    ],
    "actual_capabilities": [
      "Validates data at entry points to reject obviously invalid input",
      "Adds business logic validation for domain-specific rules",
      "Implements environment guards to prevent dangerous operations",
      "Adds debug instrumentation for forensics when other layers fail",
      "Traces data flow to map all validation checkpoints",
      "Makes bugs structurally impossible through layered validation"
    ],
    "limitations": [
      "Does not execute code - provides guidance patterns only",
      "Does not modify your codebase automatically",
      "Does not replace testing or code review",
      "Requires developer implementation of suggested patterns"
    ],
    "use_cases": [
      {
        "target_user": "Software Engineers",
        "title": "Fix Persistent Bugs",
        "description": "Fix bugs caused by invalid data that keep reappearing despite single-point fixes"
      },
      {
        "target_user": "Security Engineers",
        "title": "Strengthen Validation",
        "description": "Add defensive validation layers to prevent injection attacks and data corruption"
      },
      {
        "target_user": "QA Engineers",
        "title": "Improve Test Coverage",
        "description": "Design test cases that verify validation works at every system layer"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Bug Fix",
        "scenario": "Fix a bug from invalid data",
        "prompt": "Use defense-in-depth validation. Trace the data flow, identify all checkpoints, and add validation at each layer: entry point, business logic, environment guards, and debug instrumentation."
      },
      {
        "title": "API Input Validation",
        "scenario": "Validate API input",
        "prompt": "Apply defense-in-depth validation to this API endpoint. Validate at the API boundary, in business logic, add environment checks for dangerous operations, and add debug logging."
      },
      {
        "title": "Refactor Legacy Code",
        "scenario": "Add validation to existing code",
        "prompt": "Refactor this function with defense-in-depth validation. Map where invalid data could enter, add validation at each layer, and add stack trace logging for debugging."
      },
      {
        "title": "Test Validation Layers",
        "scenario": "Test validation effectiveness",
        "prompt": "Design tests to verify each validation layer catches bugs. Try to bypass layer 1, ensure layer 2 catches it. Test mocks, edge cases, and different code paths."
      }
    ],
    "output_examples": [
      {
        "input": "Fix a bug where empty project directory causes git init to run in the wrong location",
        "output": [
          "Layer 1 (Entry): Validate directory exists, is writable, and is not empty at function entry",
          "Layer 2 (Business): Re-check projectDir in workspace initialization logic",
          "Layer 3 (Environment): Refuse git operations outside temp directories during tests",
          "Layer 4 (Debug): Log stack trace and context before any git operation",
          "Result: Bug becomes structurally impossible to reproduce"
        ]
      }
    ],
    "best_practices": [
      "Trace the complete data flow before adding validation to identify all checkpoints",
      "Add different types of validation at each layer - type checks, existence checks, business rules",
      "Test each validation layer independently - try to bypass one layer and verify the next catches it"
    ],
    "anti_patterns": [
      "Single validation point - bugs can bypass through different code paths or refactoring",
      "Skipping environment guards - edge cases on different platforms will slip through",
      "No debug instrumentation - harder to diagnose when validation layers fail"
    ],
    "faq": [
      {
        "question": "How is this different from standard input validation?",
        "answer": "Standard validation adds checks at one point. Defense-in-depth validates at EVERY layer data passes through, making bugs structurally impossible."
      },
      {
        "question": "Does this work for all programming languages?",
        "answer": "Yes. The pattern applies to any language. Examples use TypeScript but concepts transfer to Python, Go, Java, and other languages."
      },
      {
        "question": "Can this slow down my application?",
        "answer": "Minimal impact. Validation checks are fast operations. Debug logging can be disabled in production environments."
      },
      {
        "question": "How many validation layers should I add?",
        "answer": "Four layers cover most cases: entry, business logic, environment guards, and debug instrumentation. Add more for critical systems."
      },
      {
        "question": "Does this replace unit testing?",
        "answer": "No. Validation layers work with testing. Write tests to verify each layer catches specific invalid inputs."
      },
      {
        "question": "How do I handle mocked dependencies?",
        "answer": "Layer 2 (business logic) validation catches issues mocks might skip. Layer 3 (environment) guards work regardless of mocks."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    },
    {
      "name": "SKILL.zip",
      "type": "file",
      "path": "SKILL.zip"
    }
  ]
}
