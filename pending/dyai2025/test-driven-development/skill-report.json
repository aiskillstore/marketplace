{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T13:32:50.880Z",
    "slug": "dyai2025-test-driven-development",
    "source_url": "https://github.com/DYAI2025/Stoppclock-page/tree/main/stoppclock_speckit/.claude/commands/skills/test-driven-development",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "86f457914a63eba41001454dc26b176fe8ef4ac52abb5513857b7ba0b495ca82",
    "tree_hash": "dc4ad01ceab11f7e392ffa126a45f702b640b777088a7b5683de017c2ba07abf"
  },
  "skill": {
    "name": "test-driven-development",
    "description": "Use when implementing any feature or bugfix, before writing implementation code - write the test first, watch it fail, write minimal code to pass; ensures tests actually verify behavior by requiring failure first",
    "summary": "Use when implementing any feature or bugfix, before writing implementation code - write the test fir...",
    "icon": "ðŸ§ª",
    "version": "1.0.0",
    "author": "DYAI2025",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "testing",
      "tdd",
      "development",
      "quality",
      "methodology"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a documentation-only skill containing Test-Driven Development guidelines. No executable code, network calls, file system access, or external commands. Pure educational content.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 365,
    "audit_model": "claude",
    "audited_at": "2026-01-10T13:32:50.880Z"
  },
  "content": {
    "user_title": "Apply Test-Driven Development to Your Code",
    "value_statement": "Writing tests after code proves nothing. This skill enforces TDD discipline by making you write failing tests first, ensuring your tests actually verify behavior and catch bugs before they reach production.",
    "seo_keywords": [
      "test-driven development",
      "TDD",
      "unit testing",
      "Claude Code",
      "testing methodology",
      "red green refactor",
      "software testing",
      "code quality",
      "Claude",
      "Codex"
    ],
    "actual_capabilities": [
      "Enforces Red-Green-Refactor TDD cycle",
      "Requires watching tests fail before implementation",
      "Prevents rationalizations for skipping TDD",
      "Provides concrete examples of good vs bad tests",
      "Includes verification checklist for TDD compliance"
    ],
    "limitations": [
      "Requires discipline to delete code written without tests",
      "May slow initial development speed",
      "Not suitable for throwaway prototypes without permission",
      "Needs testing framework setup in project"
    ],
    "use_cases": [
      {
        "target_user": "Software developers",
        "title": "Implement new features with confidence",
        "description": "Use TDD to build features systematically, ensuring each piece works correctly and can be refactored safely later."
      },
      {
        "target_user": "Development teams",
        "title": "Fix bugs without creating new ones",
        "description": "Write a failing test that reproduces the bug, fix it with minimal code, and prevent regressions with comprehensive test coverage."
      },
      {
        "target_user": "Code reviewers",
        "title": "Ensure code quality standards",
        "description": "Verify that all new code follows TDD practices and has proper test coverage before approving pull requests."
      }
    ],
    "prompt_templates": [
      {
        "title": "Start TDD for new feature",
        "scenario": "Building a new API endpoint",
        "prompt": "I need to implement a user authentication endpoint. Using TDD, help me write the first failing test that checks for valid email format before I write any implementation code."
      },
      {
        "title": "Apply TDD to bug fix",
        "scenario": "Fixing a calculation error",
        "prompt": "There's a bug in our discount calculation where 0% discount throws an error. Help me write a failing test first, then implement the minimal fix."
      },
      {
        "title": "Refactor with TDD safety net",
        "scenario": "Improving existing code structure",
        "prompt": "I want to refactor this messy function into smaller ones. First, help me write tests for the current behavior, then guide me through refactoring step by step."
      },
      {
        "title": "Review TDD compliance",
        "scenario": "Checking if TDD was followed",
        "prompt": "Review this code and tests. Did they follow TDD? Check if tests were written first, if they watched them fail, and if the implementation is minimal."
      }
    ],
    "output_examples": [
      {
        "input": "Help me implement a password validator using TDD",
        "output": [
          "First, write a failing test: test('rejects passwords shorter than 8 characters', () => { expect(validatePassword('abc123')).toBe(false); })",
          "Watch it fail - confirms test works and feature missing",
          "Write minimal code: function validatePassword(pwd) { return pwd.length >= 8; }",
          "Watch it pass - confirms implementation works",
          "Next test: test('requires at least one number', () => { expect(validatePassword('longpassword')).toBe(false); })",
          "Continue cycle until all requirements met"
        ]
      }
    ],
    "best_practices": [
      "Always watch the test fail first - passing immediately proves nothing",
      "Write the simplest code possible to pass - no extra features or refactoring",
      "Delete any code written without a failing test - no exceptions",
      "Use real code in tests, avoid mocks unless absolutely necessary"
    ],
    "anti_patterns": [
      "Writing implementation before tests - violates the core principle",
      "Keeping 'reference' code while writing tests - you'll adapt it instead of starting fresh",
      "Testing after implementation - you lose verification that tests actually work",
      "Adding features beyond what the test requires - violates minimal implementation rule"
    ],
    "faq": [
      {
        "question": "Is this compatible with all testing frameworks?",
        "answer": "Yes, TDD is framework-agnostic. Works with Jest, Mocha, PyTest, NUnit, or any testing library."
      },
      {
        "question": "What if I already wrote the code?",
        "answer": "Delete it and start over with TDD. Keeping code means you're testing after, not test-driving."
      },
      {
        "question": "Can I integrate this with existing projects?",
        "answer": "Yes, apply TDD to new features and bug fixes. Gradually add tests for existing code when you modify it."
      },
      {
        "question": "Is my data safe when using this skill?",
        "answer": "This skill only provides guidance - no code execution, file access, or data collection occurs."
      },
      {
        "question": "Test is passing immediately, what should I do?",
        "answer": "Your test is wrong - it's not testing the right thing. Fix the test to properly fail before implementing."
      },
      {
        "question": "How is this different from writing tests after?",
        "answer": "Tests-after verify what you built. Tests-first define what you should build, catching design issues early."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    },
    {
      "name": "SKILL.zip",
      "type": "file",
      "path": "SKILL.zip"
    }
  ]
}
