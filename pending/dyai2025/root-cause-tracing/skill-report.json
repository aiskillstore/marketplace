{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T13:31:05.889Z",
    "slug": "dyai2025-root-cause-tracing",
    "source_url": "https://github.com/DYAI2025/Stoppclock-page/tree/main/stoppclock_speckit/.claude/commands/skills/root-cause-tracing",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "287daace001bad319d7b87c0cff917769988b7ea03db685c897479bc347b1c91",
    "tree_hash": "df4faa6957ed325ff898f6a55b3a7090d6c28c5aeb6e6f83d83f3ffe6c395992"
  },
  "skill": {
    "name": "root-cause-tracing",
    "description": "Use when errors occur deep in execution and you need to trace back to find the original trigger - systematically traces bugs backward through call stack, adding instrumentation when needed, to identify source of invalid data or incorrect behavior",
    "summary": "Use when errors occur deep in execution and you need to trace back to find the original trigger - sy...",
    "icon": "üîç",
    "version": "1.0.0",
    "author": "DYAI2025",
    "license": "MIT",
    "category": "debugging",
    "tags": [
      "debugging",
      "troubleshooting",
      "root-cause-analysis",
      "testing",
      "code-analysis"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Documentation-based debugging methodology skill with a helper bash script for test bisection. No malicious patterns detected. Shell script runs npm test which is expected behavior for test debugging tools.",
    "risk_factor_evidence": [
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "find-polluter.sh",
            "line_start": 1,
            "line_end": 64
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "find-polluter.sh",
            "line_start": 42,
            "line_end": 42
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 239,
    "audit_model": "claude",
    "audited_at": "2026-01-10T13:31:05.889Z"
  },
  "content": {
    "user_title": "Trace bugs to their root cause",
    "value_statement": "Bugs often appear deep in the call stack, but fixing where they appear treats a symptom. This skill provides a systematic approach to trace backward through execution to find the original trigger and add defense-in-depth validation at each layer.",
    "seo_keywords": [
      "root cause analysis",
      "debugging",
      "troubleshooting",
      "bug tracing",
      "stack trace analysis",
      "test debugging",
      "Claude Code debugging",
      "Codex debugging",
      "software testing"
    ],
    "actual_capabilities": [
      "Trace bugs backward through call stacks to find original triggers",
      "Identify where invalid data entered the execution chain",
      "Add instrumentation with stack traces to diagnose hidden issues",
      "Use bisection scripts to find which test causes pollution",
      "Apply defense-in-depth validation at multiple code layers"
    ],
    "limitations": [
      "Does not fix code automatically - provides methodology for humans",
      "Requires access to source code and test files to trace effectively",
      "Cannot diagnose issues in production without proper logging in place",
      "Stack trace quality depends on code quality and error handling"
    ],
    "use_cases": [
      {
        "target_user": "Software Developers",
        "title": "Debug complex call stacks",
        "description": "Trace why git init failed in the wrong directory by tracing back through WorktreeManager, Session, and test setup to find the empty tempDir variable."
      },
      {
        "target_user": "QA Engineers",
        "title": "Find test polluters",
        "description": "Identify which test creates unwanted files or state pollution using the bisection script to run tests one by one until the culprit is found."
      },
      {
        "target_user": "Debugging Assistants",
        "title": "Add stack trace instrumentation",
        "description": "Systematically add console.error logging with Error().stack before operations to capture call chains and diagnose where invalid data originated."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic trace request",
        "scenario": "Error appears deep in stack",
        "prompt": "Trace this error backward through the call stack to find the original trigger. Start at the symptom and work up through callers until you find where invalid data entered the chain."
      },
      {
        "title": "Test pollution",
        "scenario": "Unwanted files appear during tests",
        "prompt": "Use root cause tracing to find which test is creating pollution. Check the test pattern and trace backward from the file creation to the test setup that passed invalid parameters."
      },
      {
        "title": "Add instrumentation",
        "scenario": "Cannot trace manually",
        "prompt": "Add stack trace instrumentation to this code. Use console.error with new Error().stack before the problematic operation to capture the call chain."
      },
      {
        "title": "Defense in depth",
        "scenario": "Root cause identified",
        "prompt": "Now that we found the root cause, add validation at each layer of the call stack so this bug becomes impossible to reintroduce."
      }
    ],
    "output_examples": [
      {
        "input": "Trace why git init failed in /Users/jesse/project/packages/core when we never passed that path",
        "output": [
          "Found the issue through 5-level trace:",
          "1. git init ran in process.cwd() because cwd parameter was empty string",
          "2. Empty projectDir passed to WorktreeManager.createSessionWorktree",
          "3. Session.create() passed empty string from test setup",
          "4. Test accessed context.tempDir before beforeEach initialized it",
          "5. setupCoreTest() returns { tempDir: '' } initially",
          "Root cause: Top-level variable initialization accessing empty value",
          "Fix: Made tempDir a getter that throws if accessed before beforeEach"
        ]
      }
    ],
    "best_practices": [
      "Always trace backward to find the original trigger before fixing symptoms",
      "Add stack trace logging before operations, not after they fail",
      "Use console.error in tests - logger output may be suppressed"
    ],
    "anti_patterns": [
      "Fixing where the error appears instead of tracing to the source",
      "Adding logging after the failure instead of before the operation",
      "Not including context (directory, cwd, environment) in debug output"
    ],
    "faq": [
      {
        "question": "How is this skill different from standard debugging?",
        "answer": "Focuses on backward tracing from symptom to source, then adds validation at each layer to prevent recurrence."
      },
      {
        "question": "What if I cannot trace the call chain manually?",
        "answer": "Add instrumentation with new Error().stack and console.error before the problematic operation to capture call chains."
      },
      {
        "question": "Can this work with any test framework?",
        "answer": "Yes. The methodology works with any testing framework. The bisection script uses npm test which works with Jest, Vitest, and similar tools."
      },
      {
        "question": "Does this skill modify my codebase?",
        "answer": "No. This is a methodology skill. It provides instructions and you apply the fixes yourself."
      },
      {
        "question": "How does the bisection script work?",
        "answer": "It runs tests one by one and checks for pollution after each. Stops at the first test that creates the unwanted file or state."
      },
      {
        "question": "What is defense-in-depth validation?",
        "answer": "Adding checks at multiple layers of the call stack so the bug becomes impossible even if one validation is missed."
      }
    ]
  },
  "file_structure": [
    {
      "name": "find-polluter.sh",
      "type": "file",
      "path": "find-polluter.sh"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    },
    {
      "name": "SKILL.zip",
      "type": "file",
      "path": "SKILL.zip"
    }
  ]
}
