{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T09:03:12.154Z",
    "slug": "2389-research-binary-re",
    "source_url": "https://github.com/2389-research/claude-plugins/tree/main/binary-re/skills",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "4061fd7006c6646815936b91deb516e840c42ee5f45a87d1cc3ea2b02eef6e9c",
    "tree_hash": "4b24223614d892d9e7af3356973d89980d37d6cdd4c424bb433c553d8876c860"
  },
  "skill": {
    "name": "binary-re",
    "description": "This skill should be used when analyzing binaries, executables, or bytecode to understand what they do or how they work. Triggers on \"binary\", \"executable\", \"ELF\", \"what does this do\", \"reverse engineer\", \"disassemble\", \"decompile\", \"pyc file\", \"python bytecode\", \"analyze binary\", \"figure out\", \"marshal\". Routes to sub-skills for triage, static analysis, dynamic analysis, synthesis, or tool setup.",
    "summary": "This skill should be used when analyzing binaries, executables, or bytecode to understand what they ...",
    "icon": "üîç",
    "version": "1.0.0",
    "author": "2389-research",
    "license": "MIT",
    "category": "security",
    "tags": [
      "reverse-engineering",
      "binary-analysis",
      "elf",
      "security-research"
    ],
    "supported_tools": [
      "claude",
      "claude-code"
    ],
    "risk_factors": [
      "external_commands",
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill consists of documentation files providing reverse engineering methodology. All binary execution requires explicit human approval. The skill guides safe tool usage with sandbox recommendations and JSON output patterns. No executable scripts, obfuscated code, or hidden execution paths detected.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 29,
            "line_end": 73
          },
          {
            "file": "triage/SKILL.md",
            "line_start": 29,
            "line_end": 136
          },
          {
            "file": "static-analysis/SKILL.md",
            "line_start": 61,
            "line_end": 241
          },
          {
            "file": "dynamic-analysis/SKILL.md",
            "line_start": 71,
            "line_end": 446
          },
          {
            "file": "tool-setup/SKILL.md",
            "line_start": 37,
            "line_end": 485
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "triage/SKILL.md",
            "line_start": 29,
            "line_end": 44
          },
          {
            "file": "static-analysis/SKILL.md",
            "line_start": 230,
            "line_end": 241
          },
          {
            "file": "dynamic-analysis/SKILL.md",
            "line_start": 370,
            "line_end": 394
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 6,
    "total_lines": 2017,
    "audit_model": "claude",
    "audited_at": "2026-01-10T09:03:12.154Z"
  },
  "content": {
    "user_title": "Analyze ELF binaries for security research",
    "value_statement": "Reverse engineering unknown binaries is complex and error-prone. This skill provides structured methodology, tool selection guidance, and human-in-the-loop safety gates for safe binary analysis across triage, static, dynamic, and synthesis phases.",
    "seo_keywords": [
      "binary reverse engineering",
      "ELF analysis",
      "radare2",
      "Ghidra",
      "QEMU",
      "Claude Code",
      "security research",
      "malware analysis",
      "embedded devices",
      "disassembler"
    ],
    "actual_capabilities": [
      "Fast binary fingerprinting via rabin2 to identify architecture, ABI, and dependencies",
      "Static analysis with radare2 (r2) for function enumeration and cross-reference analysis",
      "Decompilation using Ghidra headless for pseudo-C code output",
      "Dynamic analysis via QEMU user-mode emulation with syscall tracing",
      "GDB debugging with GEF enhancements for instruction-level control",
      "Frida function hooking for runtime interception without binary modification"
    ],
    "limitations": [
      "Cannot analyze binaries for architectures without QEMU or GDB support",
      "Anti-debugging techniques may block dynamic analysis",
      "Analysis depth depends on whether binary is stripped of symbols",
      "No support for Windows PE or macOS Mach-O formats"
    ],
    "use_cases": [
      {
        "target_user": "Security researchers",
        "title": "Analyze embedded device binaries",
        "description": "Investigate firmware from IoT devices, routers, or industrial equipment for vulnerabilities or backdoors"
      },
      {
        "target_user": "Software engineers",
        "title": "Debug cross-compiled binaries",
        "description": "Understand why ARM or MIPS binaries fail and identify missing dependencies or ABI issues"
      },
      {
        "target_user": "Incident responders",
        "title": "Examine suspicious executables",
        "description": "Quickly determine what an unknown binary does before deciding whether to execute it"
      }
    ],
    "prompt_templates": [
      {
        "title": "Quick identify",
        "scenario": "Identify unknown binary",
        "prompt": "What type of binary is this file? Identify its architecture, libc type, and key dependencies using the binary-re:triage skill."
      },
      {
        "title": "Analyze functions",
        "scenario": "Understand code behavior",
        "prompt": "Analyze the main functions in this binary. What network connections does it make? Use binary-re:static-analysis to trace function calls and identify imports."
      },
      {
        "title": "Trace execution",
        "scenario": "Observe runtime behavior",
        "prompt": "Run this binary under QEMU and trace its syscalls. What files does it access? What network connections does it attempt? Requires human approval first."
      },
      {
        "title": "Full analysis",
        "scenario": "Complete binary investigation",
        "prompt": "Perform a complete reverse engineering analysis: triage, static analysis, dynamic analysis with sandbox, and synthesis. Document findings with evidence chains."
      }
    ],
    "output_examples": [
      {
        "input": "What does this thermostat binary do?",
        "output": [
          "**Binary Identification**: ARM 32-bit, musl libc, stripped",
          "**Key Functions**: Main loop at 0x10800, network init at 0x8400",
          "**Capabilities**: HTTPS client to api.thermco.com:443, config reader, periodic 30-second telemetry",
          "**Confirmed By**: curl imports, URL strings, connect() syscall observed",
          "**Risk**: Low - standard IoT telemetry client, no server functionality"
        ]
      }
    ],
    "best_practices": [
      "Always get human approval before executing any binary, even under QEMU",
      "Use sandbox isolation (nsjail, cgroups, or Docker) for dynamic analysis",
      "Document all findings with tool attribution for traceable evidence",
      "Run triage first to understand architecture before deeper analysis"
    ],
    "anti_patterns": [
      "Skipping triage and jumping straight to disassembly wastes time",
      "Executing binaries without sandbox or human approval risks infection",
      "Assuming stripped binaries are malicious - many embedded firmwares are stripped by design",
      "Ignoring discrepancies between static and dynamic findings"
    ],
    "faq": [
      {
        "question": "Which architectures are supported?",
        "answer": "ARM32, ARM64, x86, x86-64, MIPS, and RISC-V. QEMU-user provides emulation; Ghidra supports decompilation for all listed."
      },
      {
        "question": "Can this analyze Windows .exe files?",
        "answer": "No, this skill targets ELF binaries from embedded Linux systems. Windows PE analysis requires different tools like IDA Pro or Ghidra with PE support."
      },
      {
        "question": "Is network isolation available?",
        "answer": "Yes. Use QEMU with blocked networking or run in Docker with network:none. Always confirm sandbox configuration with human before execution."
      },
      {
        "question": "How is my data protected?",
        "answer": "The skill does not transmit data. All analysis runs locally using radare2, QEMU, and Ghidra. No external servers or cloud services are involved."
      },
      {
        "question": "Tool installation failed?",
        "answer": "Run binary-re:tool-setup for platform-specific installation commands. Ubuntu/Debian: apt install radare2 qemu-user gdb-multiarch. macOS: Use Docker for cross-arch or install via Homebrew."
      },
      {
        "question": "How does this compare to Ghidra alone?",
        "answer": "Ghidra provides decompilation but no execution. This skill adds runtime observation via QEMU/GDB, structured methodology across phases, and human-in-the-loop safety gates."
      }
    ]
  },
  "file_structure": [
    {
      "name": "dynamic-analysis",
      "type": "dir",
      "path": "dynamic-analysis",
      "children": [
        {
          "name": "SKILL.md",
          "type": "file",
          "path": "dynamic-analysis/SKILL.md"
        }
      ]
    },
    {
      "name": "static-analysis",
      "type": "dir",
      "path": "static-analysis",
      "children": [
        {
          "name": "SKILL.md",
          "type": "file",
          "path": "static-analysis/SKILL.md"
        }
      ]
    },
    {
      "name": "synthesis",
      "type": "dir",
      "path": "synthesis",
      "children": [
        {
          "name": "SKILL.md",
          "type": "file",
          "path": "synthesis/SKILL.md"
        }
      ]
    },
    {
      "name": "tool-setup",
      "type": "dir",
      "path": "tool-setup",
      "children": [
        {
          "name": "SKILL.md",
          "type": "file",
          "path": "tool-setup/SKILL.md"
        }
      ]
    },
    {
      "name": "triage",
      "type": "dir",
      "path": "triage",
      "children": [
        {
          "name": "SKILL.md",
          "type": "file",
          "path": "triage/SKILL.md"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
