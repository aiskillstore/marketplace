{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T09:05:15.160Z",
    "slug": "2389-research-binary-re-static-analysis",
    "source_url": "https://github.com/2389-research/claude-plugins/tree/main/binary-re/skills/static-analysis",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "a3d94fdbd9b55cca5fe58170e5301717ab9694b4dae2153bd2dbba6126f1cc9a",
    "tree_hash": "e326649866e6e653c8b14bdc4c282f652e05a8b4fe49b31793d83f99c57db735"
  },
  "skill": {
    "name": "binary-re:static-analysis",
    "description": "Use when analyzing binary structure, disassembling code, or decompiling functions. Deep static analysis via radare2 (r2) and Ghidra headless - function enumeration, cross-references (xrefs), decompilation, control flow graphs. Keywords - \"disassemble\", \"decompile\", \"what does this function do\", \"find functions\", \"analyze code\", \"r2\", \"ghidra\", \"pdg\", \"afl\"",
    "summary": "Use when analyzing binary structure, disassembling code, or decompiling functions. Deep static analy...",
    "icon": "üîç",
    "version": "1.0.0",
    "author": "2389-research",
    "license": "MIT",
    "category": "security",
    "tags": [
      "reverse-engineering",
      "binary-analysis",
      "radare2",
      "ghidra",
      "disassembly"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "network",
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure prompt-based skill containing only documentation and methodology for static binary analysis. No executable code, no network access, no file writes. Contains only instructional content for using radare2 and Ghidra.",
    "risk_factor_evidence": [
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 1,
            "line_end": 407
          }
        ]
      },
      {
        "factor": "network",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 245,
            "line_end": 260
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 71,
            "line_end": 78
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 104,
            "line_end": 116
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 407,
    "audit_model": "claude",
    "audited_at": "2026-01-10T09:05:15.160Z"
  },
  "content": {
    "user_title": "Analyze binary structure and disassemble code",
    "value_statement": "Understanding binary behavior without execution requires mapping functions, tracing data flow, and decompiling critical code. This skill provides structured methodology for static analysis using radare2 and Ghidra to discover how a binary works.",
    "seo_keywords": [
      "binary reverse engineering",
      "static analysis",
      "radare2 tutorial",
      "ghidra decompiler",
      "disassembler guide",
      "function analysis",
      "xref analysis",
      "binary research",
      "claude code skill",
      "codex plugin"
    ],
    "actual_capabilities": [
      "Enumerate functions and map binary structure using radare2",
      "Perform cross-reference analysis to trace data and control flow",
      "Decompile functions using r2ghidra and Ghidra headless",
      "Extract and correlate strings with code locations",
      "Analyze control flow graphs and basic blocks",
      "Identify crypto operations and network functions"
    ],
    "limitations": [
      "Cannot execute or run the binary - static analysis only",
      "Obfuscated or packed binaries may require advanced techniques",
      "Analysis quality depends on r2 and Ghidra installation",
      "Stripped binaries may lack function names and symbols"
    ],
    "use_cases": [
      {
        "target_user": "Security researchers",
        "title": "Analyze malware samples safely",
        "description": "Study malicious software behavior without triggering payload execution"
      },
      {
        "target_user": "Embedded device analysts",
        "title": "Reverse engineer firmware binaries",
        "description": "Understand proprietary protocols and hidden features in device firmware"
      },
      {
        "target_user": "Vulnerability researchers",
        "title": "Find security vulnerabilities",
        "description": "Identify potential buffer overflows and input validation issues"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic function analysis",
        "scenario": "Find functions in binary",
        "prompt": "Analyze the binary at [PATH] and list all functions. Identify the main entry point and any network-related functions."
      },
      {
        "title": "String correlation",
        "scenario": "Trace string references",
        "prompt": "Find strings in [BINARY] that reference the string [PATTERN]. Determine which function contains each match."
      },
      {
        "title": "Cross-reference tracing",
        "scenario": "Trace call relationships",
        "prompt": "Trace all callers of function [FUNCTION_NAME] in [BINARY]. Show the call chain from main to this function."
      },
      {
        "title": "Decompilation deep-dive",
        "scenario": "Decompile critical function",
        "prompt": "Decompile function at address [ADDRESS] in [BINARY]. Explain the logic in plain English and identify any security-relevant operations."
      }
    ],
    "output_examples": [
      {
        "input": "Analyze the binary and find how it handles network connections",
        "output": [
          "Binary: thermostat_daemon (ARM 32-bit, musl libc)",
          "Functions analyzed: 47",
          "Key network functions:",
          "  - 0x8400: Calls socket(), connect(), send() - network initialization",
          "  - 0x9200: Parses JSON using jsmn library",
          "  - 0x10800: Main loop calls network function every 30 seconds",
          "Cross-references: main ‚Üí init_network ‚Üí send_telemetry",
          "Strings found: \"api.thermco.com/telemetry\"",
          "Hypothesis: Telemetry client sending data to remote server every 30 seconds"
        ]
      }
    ],
    "best_practices": [
      "Always check episodic memory for previous analysis before starting",
      "Get human approval before comparing binary I/O against expected outputs",
      "Use JSON output (append 'j' to r2 commands) for structured, parseable results",
      "Record all findings in episodic memory with source attribution"
    ],
    "anti_patterns": [
      "Skipping triage phase and jumping directly to disassembly",
      "Running full analysis (aaa) on large binaries without timeout limits",
      "Trusting decompiled output without cross-referencing with assembly",
      "Forgetting to record hypotheses with confidence scores"
    ],
    "faq": [
      {
        "question": "What tools does this skill require?",
        "answer": "radare2 (r2) for analysis, r2ghidra plugin for decompilation, and optionally Ghidra headless for complex functions."
      },
      {
        "question": "Can I analyze x86-64 binaries?",
        "answer": "Yes. This skill supports all architectures that radare2 and Ghidra handle including ARM, MIPS, RISC-V, x86, and MIPS."
      },
      {
        "question": "How does this differ from dynamic analysis?",
        "answer": "Static analysis examines binary structure without execution. Dynamic analysis runs the binary to observe runtime behavior. Use static first, then dynamic for verification."
      },
      {
        "question": "Does this skill execute the binary?",
        "answer": "No. This skill only provides instructions for static analysis commands. Human approval is required before any execution, which is handled by the dynamic-analysis skill."
      },
      {
        "question": "Can stripped binaries be analyzed?",
        "answer": "Yes, but function names will be addresses like sub_8400 instead of symbols. Cross-reference and string correlation become more important."
      },
      {
        "question": "How does this integrate with other binary-re skills?",
        "answer": "Triage identifies the binary, static analysis maps structure and logic, dynamic analysis verifies hypotheses, and synthesis creates the final report."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
