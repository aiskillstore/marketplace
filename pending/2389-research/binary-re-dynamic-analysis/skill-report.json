{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T09:04:08.586Z",
    "slug": "2389-research-binary-re-dynamic-analysis",
    "source_url": "https://github.com/2389-research/claude-plugins/tree/main/binary-re/skills/dynamic-analysis",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "4b3f5689cbc7e7061144ce5a59cfdae86290a27ec9ad0049fbb7fb113172d7f6",
    "tree_hash": "590f49789deeec412956e7aeabda991ce37e6d40aa96b07159a18f7e643fb705"
  },
  "skill": {
    "name": "binary-re:dynamic-analysis",
    "description": "Use when you need to run a binary, trace execution, or observe runtime behavior. Runtime analysis via QEMU emulation, GDB debugging, and Frida hooking - syscall tracing (strace), breakpoints, memory inspection, function interception. Keywords - \"run binary\", \"execute\", \"debug\", \"trace syscalls\", \"set breakpoint\", \"qemu\", \"gdb\", \"frida\", \"strace\", \"watch memory\"",
    "summary": "Use when you need to run a binary, trace execution, or observe runtime behavior. Runtime analysis vi...",
    "icon": "▶️",
    "version": "1.0.0",
    "author": "2389-research",
    "license": "MIT",
    "category": "security",
    "tags": [
      "reverse-engineering",
      "debugging",
      "dynamic-analysis",
      "qemu",
      "frida"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Prompt-based skill providing instructional guidance for binary analysis. Contains example commands and scripts for educational purposes. Includes human-in-the-loop safety requirements before execution.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 564,
    "audit_model": "claude",
    "audited_at": "2026-01-10T09:04:08.586Z"
  },
  "content": {
    "user_title": "Run and debug binaries to observe runtime behavior",
    "value_statement": "Static analysis cannot reveal runtime behavior. This skill provides structured methods for dynamic analysis using QEMU emulation, GDB debugging, and Frida hooking to observe actual binary execution.",
    "seo_keywords": [
      "binary reverse engineering",
      "dynamic analysis",
      "QEMU emulation",
      "GDB debugging",
      "Frida hooking",
      "syscall tracing",
      "Claude Code skill",
      "binary analysis",
      "debugging skill",
      "reverse engineering"
    ],
    "actual_capabilities": [
      "Execute binaries under QEMU with syscall tracing",
      "Debug binaries at instruction level with GDB",
      "Hook functions without modification using Frida",
      "Perform cross-architecture analysis on macOS and Windows",
      "Detect and bypass anti-debugging techniques",
      "Record runtime observations in structured format"
    ],
    "limitations": [
      "Frida cannot attach to QEMU-user mode emulated binaries",
      "strace does not work in Docker/QEMU user-mode (use LD_DEBUG instead)",
      "Some syscalls unsupported in QEMU user-mode (may require on-device analysis)",
      "Requires human approval before executing any binary"
    ],
    "use_cases": [
      {
        "target_user": "Security researchers",
        "title": "Analyze malware behavior",
        "description": "Observe what a suspicious binary actually does at runtime without risking the host system."
      },
      {
        "target_user": "Embedded developers",
        "title": "Debug ARM/MIPS binaries",
        "description": "Debug cross-architecture firmware binaries using QEMU emulation on any host platform."
      },
      {
        "target_user": "Reverse engineers",
        "title": "Verify static analysis findings",
        "description": "Confirm hypotheses from static analysis by observing actual runtime behavior and function calls."
      }
    ],
    "prompt_templates": [
      {
        "title": "Run with strace",
        "scenario": "Quick syscall observation",
        "prompt": "Run this ARM binary under QEMU with syscall tracing to see what files it opens and network connections it makes."
      },
      {
        "title": "Debug with GDB",
        "scenario": "Instruction-level debugging",
        "prompt": "Debug this binary at instruction level. Set a breakpoint at address 0x8400 and inspect registers when hit."
      },
      {
        "title": "Hook function calls",
        "scenario": "Function interception",
        "prompt": "Write a Frida script to hook all connect() calls and log the IP address and port being connected to."
      },
      {
        "title": "Cross-arch on macOS",
        "scenario": "Docker-based execution",
        "prompt": "Run this ARM32 binary on macOS using Docker to observe its library loading behavior."
      }
    ],
    "output_examples": [
      {
        "input": "Run this ARM binary with syscall tracing to see what it accesses",
        "output": [
          "Execution method: qemu-arm -strace",
          "Network activity: socket(2), connect(1) → 192.168.1.100:8443",
          "Files accessed: /etc/config (read), /var/log/app.log (write)",
          "Hypothesis confirmed: Binary makes outbound HTTPS connections"
        ]
      }
    ],
    "best_practices": [
      "Always get human approval before executing any binary in dynamic analysis",
      "Use QEMU-strace first for initial behavior mapping before deeper debugging",
      "Isolate execution with sandbox configuration to contain potential malicious behavior"
    ],
    "anti_patterns": [
      "Running binaries without sandbox isolation or human approval",
      "Using Frida on QEMU-emulated binaries (incompatible architecture)",
      "Skipping anti-analysis detection checks before execution"
    ],
    "faq": [
      {
        "question": "What platforms support QEMU cross-architecture debugging?",
        "answer": "Linux x86_64 supports native ARM32/64 and MIPS. macOS requires Docker with binfmt. Windows requires WSL2."
      },
      {
        "question": "Why does strace fail in Docker?",
        "answer": "ptrace is not implemented in QEMU user-mode. Use LD_DEBUG=libs,files,bindings as an alternative for observation."
      },
      {
        "question": "Can I use Frida with QEMU?",
        "answer": "No. Frida requires native architecture. For cross-arch, use on-device frida-server or QEMU+GDB instead."
      },
      {
        "question": "Is it safe to run unknown binaries?",
        "answer": "Always use sandbox isolation (nsjail, resource limits) and get human approval. QEMU user-mode provides some isolation."
      },
      {
        "question": "What if the binary has anti-debugging checks?",
        "answer": "Use QEMU-strace (fewer detection vectors), patch checks in r2 before execution, or use Frida stalker mode."
      },
      {
        "question": "How is this different from static analysis?",
        "answer": "Static analysis shows code structure. Dynamic analysis reveals actual runtime behavior including hidden strings and network activity."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
