{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:11:38.576Z",
    "slug": "emz1998-hooks-management",
    "source_url": "https://github.com/Emz1998/avaris-ai/tree/master/.claude/skills/hooks-management",
    "source_ref": "master",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "89932398b9a6bd2bfcea42c957761b4f77cad701e3d5ab26e96d4e01c3bd4827",
    "tree_hash": "16a78174f86cad0fa13610dd7863f9c6c29c7718d2a6e6a69e416d9c0a8fd502"
  },
  "skill": {
    "name": "hooks-management",
    "description": "Use PROACTIVELY when you need to create, update, configure, or validate Claude hooks for various events and integrations",
    "summary": "Documentation and reference guide for creating, configuring, and validating Claude Code hooks",
    "icon": "ü™ù",
    "version": "1.0.0",
    "author": "Emz1998",
    "license": "MIT",
    "tags": [
      "hooks",
      "claude-code",
      "automation",
      "configuration",
      "workflow"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill contains only markdown documentation for Claude Code hooks. All static findings are false positives - the detected patterns are code examples and file paths in documentation, not executable code. No security risks present.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 3,
    "total_lines": 1755,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:11:38.576Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Create and manage Claude Code hooks",
    "value_statement": "Claude Code hooks enable custom automation at key workflow moments. This skill provides comprehensive documentation and patterns for configuring hooks that validate actions, enforce policies, and integrate with external systems.",
    "seo_keywords": [
      "Claude",
      "Codex",
      "Claude Code",
      "hooks",
      "automation",
      "workflow automation",
      "event hooks",
      "pre-tool hooks",
      "post-tool hooks",
      "custom commands"
    ],
    "actual_capabilities": [
      "Provides reference documentation for all Claude Code hook events and their JSON input structures",
      "Explains hook configuration patterns including matchers, command types, and timeout settings",
      "Details the dispatcher pattern for implementing new hook logic with proper error handling",
      "Covers hook validation techniques including input testing and security review practices",
      "Documents environment variable usage including CLAUDE_PROJECT_DIR for project-relative script paths"
    ],
    "limitations": [
      "This is a reference/documentation skill - it does not execute hooks but provides patterns and guidance",
      "Does not include pre-built hook scripts - users must implement their own based on documentation",
      "Does not validate or modify existing hook configurations directly"
    ],
    "use_cases": [
      {
        "title": "Set up automated code review hooks",
        "description": "Configure PreToolUse hooks that run linters and formatters before code is written, ensuring all changes meet project standards automatically.",
        "target_user": "Development teams wanting to enforce code quality"
      },
      {
        "title": "Create custom permission workflows",
        "description": "Implement PermissionRequest hooks that integrate with external approval systems, enabling secure human-in-the-loop workflows for sensitive operations.",
        "target_user": "Security-conscious teams requiring manual approvals"
      },
      {
        "title": "Build audit and compliance tooling",
        "description": "Use PostToolUse and SessionEnd hooks to log all actions and generate compliance reports for regulatory requirements.",
        "target_user": "Enterprises with audit and compliance needs"
      }
    ],
    "prompt_templates": [
      {
        "title": "Create a basic PreToolUse hook",
        "prompt": "Create a hook that runs before every Write tool use. The hook should validate that the file being written follows naming conventions and log the attempt. Show me the hook configuration and the script implementation.",
        "scenario": "Setting up a simple validation hook for file writes"
      },
      {
        "title": "Configure tool-specific hooks with matchers",
        "prompt": "I need hooks that only run for Edit and Read operations, not for Write. Configure the matcher patterns and show how to create separate handlers for each tool type.",
        "scenario": "Creating targeted hooks for specific tools"
      },
      {
        "title": "Implement a permission approval workflow",
        "prompt": "Create a hook for PermissionRequest events that integrates with an external API for approval. Include error handling for API timeouts and invalid responses.",
        "scenario": "Building external approval integration"
      },
      {
        "title": "Debug hook execution issues",
        "prompt": "My hook is not firing on PostToolUse events. Review the configuration structure and show how to verify hook execution using echo piping for testing.",
        "scenario": "Troubleshooting hook configuration problems"
      }
    ],
    "output_examples": [
      {
        "input": "How do I configure a hook that runs before Bash commands?",
        "output": [
          "Configure the hook in your settings file like this:",
          "",
          "```json",
          "{",
          "  \"hooks\": {",
          "    \"PreToolUse\": [",
          "      {",
          "        \"matcher\": \"Bash\",",
          "        \"hooks\": [",
          "          {",
          "            \"type\": \"command\",",
          "            \"command\": \"/path/to/your-hook-script.sh\"",
          "          }",
          "        ]",
          "      }",
          "    ]",
          "  }",
          "}"
        ]
      },
      {
        "input": "What input does a PostToolUse hook receive?",
        "output": [
          "PostToolUse hooks receive a JSON object with these key fields:",
          "",
          "- `tool_name`: Name of the tool that was used (e.g., \"Write\", \"Bash\")",
          "- `tool_input`: The arguments passed to the tool",
          "- `tool_output`: The result from tool execution",
          "- `session_id`, `transcript_path`, `cwd`: Session context",
          "- `action`: The action taken (string)",
          "- `duration`: Execution time in seconds (number)"
        ]
      }
    ],
    "best_practices": [
      "Always include proper error handling in hook scripts - failing hooks should not block normal workflow unless critical",
      "Prefer Python over shell scripts for hooks to ensure cross-platform compatibility and better error handling",
      "Test hooks using echo to pipe JSON input before deploying in production"
    ],
    "anti_patterns": [
      "Avoid hardcoding credentials in hook scripts or command strings",
      "Do not create hooks that can cause infinite loops by triggering the same tool recursively",
      "Never bypass security validations - hooks must respect existing permission models"
    ],
    "faq": [
      {
        "question": "What events can I hook into with Claude Code?",
        "answer": "Claude Code supports hooks for: PreToolUse, PostToolUse, PermissionRequest, UserPromptSubmit, SessionStart, SessionEnd, Stop, SubagentStop, and PreCompact events."
      },
      {
        "question": "How do I test my hook before enabling it?",
        "answer": "Use echo to pipe the JSON input to your script for testing. For example: echo '{\"session_id\": \"test\"}' | python your-hook.py"
      },
      {
        "question": "Can I use environment variables in hook commands?",
        "answer": "Yes, use CLAUDE_PROJECT_DIR to reference scripts in your project. This ensures hooks work regardless of Claude's current working directory."
      },
      {
        "question": "What happens if a hook times out?",
        "answer": "Hooks have a configurable timeout (default is 30 seconds). If a hook exceeds its timeout, it is cancelled and the workflow continues. Critical hooks should set appropriate timeout values."
      },
      {
        "question": "Can hooks modify tool input before execution?",
        "answer": "No, hooks cannot modify input. They can only approve, deny, or log. Use PreToolUse for validation and PermissionRequest for interactive approval workflows."
      },
      {
        "question": "Where should I store hook scripts in my project?",
        "answer": "Store hook scripts in the .claude/hooks/ directory within your project. This keeps them version-controlled alongside your project configuration."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "hooks.md",
          "type": "file",
          "path": "references/hooks.md",
          "lines": 1130
        },
        {
          "name": "input-patterns.md",
          "type": "file",
          "path": "references/input-patterns.md",
          "lines": 589
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 36
    }
  ]
}
