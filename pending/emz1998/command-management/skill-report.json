{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:04:13.739Z",
    "slug": "emz1998-command-management",
    "source_url": "https://github.com/Emz1998/nexly-notes/tree/main/.claude/skills/command-management",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "583ff2f8da789f260e20606963a8dbfb193f66635628fc04788309c88b546689",
    "tree_hash": "d35c9345f17e5224630ffbb2394e21dc3c8b8a820d57969cf8e66b7a838a752a"
  },
  "skill": {
    "name": "command-management",
    "description": "Create or update custom slash commands for Claude Code following best practices and template standards",
    "summary": "Create and manage custom slash commands for Claude Code",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "Emz1998",
    "license": "MIT",
    "tags": [
      "claude-code",
      "slash-commands",
      "automation",
      "custom-commands",
      "productivity"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "external_commands",
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Static scanner detected 154 patterns (external_commands, filesystem access) but all are FALSE POSITIVES. Patterns are documentation examples of Claude Code's built-in backtick syntax and references to Claude Code's standard file structure. No actual security vulnerabilities present.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 3,
    "total_lines": 471,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:04:13.739Z",
    "risk_factors": [
      "external_commands",
      "filesystem"
    ],
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "references/command-docs.md",
            "line_start": 139,
            "line_end": 142
          },
          {
            "file": "SKILL.md",
            "line_start": 11,
            "line_end": 16
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "references/command-docs.md",
            "line_start": 68,
            "line_end": 68
          },
          {
            "file": "references/command-docs.md",
            "line_start": 74,
            "line_end": 87
          }
        ]
      }
    ]
  },
  "content": {
    "user_title": "Create custom commands for Claude Code",
    "value_statement": "Creating custom commands manually is time-consuming and error-prone. This skill provides templates and best practices to create standardized slash commands quickly with proper structure and security constraints.",
    "seo_keywords": [
      "Claude",
      "Codex",
      "Claude Code",
      "slash commands",
      "custom commands",
      "automation",
      "productivity",
      "AI assistant",
      "command templates",
      "workflow automation"
    ],
    "actual_capabilities": [
      "Create new custom slash commands using standardized templates",
      "Update existing commands with proper structure and constraints",
      "Follow Claude Code best practices for command organization",
      "Apply least-privilege principles to tool permissions",
      "Test commands using the SlashCommand tool",
      "Organize commands by scope (project vs personal)"
    ],
    "limitations": [
      "Only creates markdown-based slash commands, not executable scripts",
      "Does not execute the created commands - only creates them",
      "Requires manual testing and validation after creation",
      "Does not modify existing command files automatically"
    ],
    "use_cases": [
      {
        "title": "Create a new project command",
        "description": "Set up a standardized git commit command that includes git status checks and follows team conventions",
        "target_user": "Developers working in teams"
      },
      {
        "title": "Build personal productivity commands",
        "description": "Create reusable commands for daily tasks like writing tests, generating documentation, or running code reviews",
        "target_user": "Individual contributors"
      },
      {
        "title": "Standardize command templates across projects",
        "description": "Apply consistent structure and best practices to all custom commands in a repository",
        "target_user": "Team leads and project maintainers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Create a basic command",
        "prompt": "Create a new command called /optimize that analyzes code for performance issues. Use the command-management skill and follow the template. The command should analyze JavaScript files for common performance anti-patterns.",
        "scenario": "Creating a simple code optimization command"
      },
      {
        "title": "Create a command with arguments",
        "prompt": "Create a command called /review-pr that accepts a PR number and priority level as arguments. Use the command template and include proper frontmatter. Make it test the command after creation.",
        "scenario": "Creating a pull request review command with parameters"
      },
      {
        "title": "Update an existing command",
        "prompt": "Update the existing /write-test command to use the sonnet model instead of haiku. Add Bash tool permissions for running test suites. Follow best practices for the update.",
        "scenario": "Modifying an existing command with new requirements"
      },
      {
        "title": "Create a multi-phase command",
        "prompt": "Create a command called /deploy that has three phases: build, test, and deploy. Each phase should have 3-5 tasks. Include proper success criteria for each phase.",
        "scenario": "Creating a complex multi-phase deployment command"
      }
    ],
    "output_examples": [
      {
        "input": "Create a /git-commit command",
        "output": [
          "Created command file: .claude/commands/git-commit.md",
          "Template sections added: Context, Tasks, Constraints, Examples, References, Output Format",
          "Frontmatter configured with allowed-tools: Bash(git add:*), Bash(git status:*), Bash(git commit:*)",
          "Command tested successfully via SlashCommand tool"
        ]
      },
      {
        "input": "Create a /security-review command",
        "output": [
          "Created command file: ~/.claude/commands/security-review.md",
          "Included file reference examples using @ prefix",
          "Set argument-hint: [file-path]",
          "Command follows personal command best practices"
        ]
      }
    ],
    "best_practices": [
      "Always specify minimal required tools in allowed-tools frontmatter - follow the least-privilege principle",
      "Include all 6 template sections (Context, Tasks, Constraints, Examples, References, Output Format)",
      "Test commands using the SlashCommand tool before finalizing",
      "Use sequential task IDs (T001, T002, T003...) for clarity"
    ],
    "anti_patterns": [
      "Using 'all' tool access or overly broad tool permissions",
      "Omitting frontmatter fields like allowed-tools, argument-hint, or model",
      "Skipping the testing phase with SlashCommand tool",
      "Creating non-atomic tasks that describe multiple operations"
    ],
    "faq": [
      {
        "question": "Where should I save project commands?",
        "answer": "Project commands go in .claude/commands/ directory. They are shared with team members. Personal commands go in ~/.claude/commands/"
      },
      {
        "question": "What frontmatter fields are required?",
        "answer": "Required fields are: name, description, allowed-tools, argument-hint, and model. All 6 template sections must also be included."
      },
      {
        "question": "Can I use the haiku model for complex commands?",
        "answer": "No. Use haiku for simple commands and sonnet for complex tasks requiring advanced reasoning. Reserve opus for tasks needing the highest reasoning capability."
      },
      {
        "question": "How do I test a command after creating it?",
        "answer": "Use the SlashCommand tool. Include the command name with its slash in your instructions to trigger it, then verify the output meets your expectations."
      },
      {
        "question": "What is the difference between $ARGUMENTS and $1, $2?",
        "answer": "$ARGUMENTS captures all arguments passed. Use $1, $2, etc. for individual positional arguments when you need specific access to each parameter."
      },
      {
        "question": "How do I prevent a command from being invoked?",
        "answer": "Add disable-model-invocation: true to the command frontmatter. This removes the command from SlashCommand tool context."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "command-docs.md",
          "type": "file",
          "path": "references/command-docs.md",
          "lines": 342
        }
      ]
    },
    {
      "name": "templates",
      "type": "dir",
      "path": "templates",
      "children": [
        {
          "name": "command.md",
          "type": "file",
          "path": "templates/command.md",
          "lines": 88
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 41
    }
  ]
}
