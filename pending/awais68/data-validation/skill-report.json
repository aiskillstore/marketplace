{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T11:01:44.229Z",
    "slug": "awais68-data-validation",
    "source_url": "https://github.com/Awais68/hackathon-2-phase-ii-full-stack-web-app/tree/main/.claude/skills/data-validation",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "bde49690605b0cfc281239e85b10e117075abae31c08b347b1528e758545d81f",
    "tree_hash": "490ff8933f03664ff60e5dbad945fdbf89dfa17559472476d19cd780d12269b0"
  },
  "skill": {
    "name": "data-validation",
    "description": "Use when implementing data validation for API payloads, form inputs, or database writes.\nTriggers for: Pydantic models, Zod schemas, input sanitization, type validation,\nfield constraints, or request/response schemas.\nNOT for: business logic (use domain services) or authentication/authorization.\n",
    "summary": "Use when implementing data validation for API payloads, form inputs, or database writes.\nTriggers fo...",
    "icon": "üîç",
    "version": "1.0.0",
    "author": "Awais68",
    "license": "MIT",
    "category": "data",
    "tags": [
      "validation",
      "pydantic",
      "zod",
      "type-safety"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill is primarily documentation with a lightweight verification script. The verify.py script only reads SKILL.md files and validates YAML frontmatter structure. No network calls, no credential access, no file writes beyond stdout, and behavior matches the stated documentation purpose.",
    "risk_factor_evidence": [
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "scripts/verify.py",
            "line_start": 1,
            "line_end": 62
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 649,
    "audit_model": "claude",
    "audited_at": "2026-01-10T11:01:44.229Z"
  },
  "content": {
    "user_title": "Validate data with Pydantic and Zod schemas",
    "value_statement": "Data validation is error-prone when done manually. This skill provides expert patterns for Pydantic and Zod schemas so you can build type-safe validation pipelines that catch errors early and prevent bad data from entering your system.",
    "seo_keywords": [
      "data validation",
      "Pydantic",
      "Zod",
      "type validation",
      "schema validation",
      "form validation",
      "API validation",
      "input sanitization",
      "Claude",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Create Pydantic models for API request and response validation in Python",
      "Build Zod schemas with type inference for TypeScript frontend forms",
      "Implement custom validators with cross-field validation logic",
      "Add input sanitization to prevent injection attacks",
      "Define separate input/output models for security boundaries",
      "Share validation constraints between frontend and backend"
    ],
    "limitations": [
      "Does not execute validation logic or run on user systems",
      "Does not integrate with specific frameworks beyond general patterns",
      "Does not provide runtime validation execution",
      "Requires manual implementation of shown patterns"
    ],
    "use_cases": [
      {
        "target_user": "Backend developers",
        "title": "API payload validation",
        "description": "Define Pydantic models with field constraints, validators, and error responses for FastAPI endpoints"
      },
      {
        "target_user": "Frontend developers",
        "title": "Form validation",
        "description": "Build Zod schemas with type inference that integrate with React Hook Form for real-time validation"
      },
      {
        "target_user": "Full-stack teams",
        "title": "Shared schema contracts",
        "description": "Maintain consistent validation rules between frontend and backend using shared constants and contract documentation"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Pydantic model",
        "scenario": "Create a user registration model",
        "prompt": "Create a Pydantic model for user registration with email, password, and name fields. Include min length, max length, and pattern constraints."
      },
      {
        "title": "Zod form schema",
        "scenario": "Build a contact form schema",
        "prompt": "Build a Zod schema for a contact form with name, email, message fields. Add required field and email validation."
      },
      {
        "title": "Custom validator",
        "scenario": "Add cross-field validation",
        "prompt": "Add a Pydantic model_validator that checks date_of_birth is in the past and age is between 18 and 120."
      },
      {
        "title": "Input sanitization",
        "scenario": "Prevent XSS in user input",
        "prompt": "Create a sanitize_for_database function that strips HTML tags and limits string length to prevent XSS attacks."
      }
    ],
    "output_examples": [
      {
        "input": "Create a Pydantic model for user registration with email, password, and name fields",
        "output": [
          "‚úì Created UserCreate model with Field constraints",
          "‚úì Added EmailStr validation for email field",
          "‚úì Included password min_length=8 and pattern requirements",
          "‚úì Added model_validator for confirm_password matching",
          "‚úì Configured JSON schema with examples"
        ]
      }
    ],
    "best_practices": [
      "Separate input models (Create/Update) from output models to prevent mass assignment vulnerabilities",
      "Always re-validate on the backend even if client validation exists to prevent bypass attacks",
      "Use type-safe validators like EmailStr and Field constraints rather than custom regex where possible"
    ],
    "anti_patterns": [
      "Trusting client-side validation alone without backend re-validation",
      "Using generic exception handling that exposes internal validation details to users",
      "Including sensitive fields in response models that should only exist in the database"
    ],
    "faq": [
      {
        "question": "Does this skill validate data at runtime?",
        "answer": "No. This skill provides documentation and patterns. You implement the validation logic in your own codebase."
      },
      {
        "question": "What Python versions are supported?",
        "answer": "Pydantic v2 requires Python 3.8 or higher. Most patterns work with Python 3.8+."
      },
      {
        "question": "Can I use this with FastAPI?",
        "answer": "Yes. Pydantic integrates natively with FastAPI. Use response_model in endpoints and Pydantic models in Body parameters."
      },
      {
        "question": "Is the data I validate sent anywhere?",
        "answer": "No. This skill only generates code patterns. Your validation runs entirely within your application."
      },
      {
        "question": "How do I handle validation errors?",
        "answer": "Use Pydantic's ValidationError with detail mode. Return 422 status codes with structured error details in APIs."
      },
      {
        "question": "How is this different from Django forms or WTForms?",
        "answer": "Pydantic and Zod work outside the MVC pattern. They focus on data validation separate from presentation logic."
      }
    ]
  },
  "file_structure": [
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "verify.py",
          "type": "file",
          "path": "scripts/verify.py"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
