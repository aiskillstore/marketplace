{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-02-11T08:59:04.516Z",
    "slug": "ibelick-fixing-motion-performance",
    "source_url": "https://github.com/ibelick/ui-skills/tree/main/skills/fixing-motion-performance/",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "bbef57cfdf5e887d52911e2d5005bdc341f1c9459314048a6d5eac74385bb845",
    "tree_hash": "56e515a3fa2bd7cad102b7b31211636c8017a307e881fcc5a76e52fa8ee7073a"
  },
  "skill": {
    "name": "fixing-motion-performance",
    "description": "Fix animation performance issues by applying browser rendering best practices. Optimize CSS animations, transforms, and motion for smooth 60fps performance.",
    "summary": "Optimize CSS animations and motion for smooth performance",
    "icon": "ðŸŽ¨",
    "version": "1.0.0",
    "author": "ibelick",
    "license": "MIT",
    "tags": [
      "animations",
      "css",
      "performance",
      "frontend",
      "web-development"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All 7 static findings are false positives. The scanner misidentified slash command documentation as external commands, CSS performance terminology as system reconnaissance, and YAML field names as cryptographic patterns. This is a documentation-only skill containing 128 lines of markdown guidelines for animation performance optimization. No code execution, network calls, file operations, or script execution occurs.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 128,
    "audit_model": "claude",
    "audited_at": "2026-02-11T08:59:04.516Z",
    "risk_factors": [],
    "risk_factor_evidence": []
  },
  "content": {
    "user_title": "Optimize Animation Performance",
    "value_statement": "Slow animations frustrate users and hurt engagement. This skill provides proven guidelines for achieving smooth 60fps animations by leveraging browser compositor layers and avoiding costly layout operations.",
    "seo_keywords": [
      "Claude",
      "Codex",
      "Claude Code",
      "CSS animations",
      "animation performance",
      "FPS optimization",
      "browser rendering",
      "transform animations",
      "motion performance",
      "frontend optimization"
    ],
    "actual_capabilities": [
      "Reviews code against animation performance best practices",
      "Identifies layout thrashing and paint-heavy animations",
      "Suggests concrete fixes using transforms and opacity",
      "Recommends Scroll Timelines and IntersectionObserver for scroll-linked motion",
      "Validates CSS variable usage for animations",
      "Enforces layer promotion best practices with will-change"
    ],
    "limitations": [
      "Does not execute or test animations directly",
      "Does not migrate animation libraries or rewrite code",
      "Does not provide browser profiling or real-world metrics",
      "Cannot validate performance on actual user devices"
    ],
    "use_cases": [
      {
        "title": "Frontend Developer Reviewing Components",
        "description": "A frontend developer wants to ensure new animations meet performance standards before merging code.",
        "target_user": "Frontend developers"
      },
      {
        "title": "Refactoring Janky Interactions",
        "description": "A team identifies scroll-linked animations causing jank and needs guidance on optimization approaches.",
        "target_user": "UI engineers"
      },
      {
        "title": "Learning Animation Best Practices",
        "description": "A developer new to web animation wants to learn the fundamentals of browser rendering and efficient motion.",
        "target_user": "Learning developers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Animation Check",
        "prompt": "Apply the fixing-motion-performance skill to review my animation code in {file}. Identify any violations of performance guidelines and suggest specific fixes.",
        "scenario": "Quick review of an animation file"
      },
      {
        "title": "Scroll Animation Optimization",
        "prompt": "Using fixing-motion-performance guidelines, review my scroll-linked animation. Check that it uses appropriate mechanisms like Scroll Timelines or IntersectionObserver, and verify it does not trigger continuous layout or paint.",
        "scenario": "Optimizing scroll-based motion"
      },
      {
        "title": "CSS Variable Animation Review",
        "prompt": "Review my use of animated CSS variables against fixing-motion-performance rules. Ensure variables are scoped locally, not inherited, and do not trigger paint on large surfaces.",
        "scenario": "Auditing CSS variable animations"
      },
      {
        "title": "Layer Promotion Strategy",
        "prompt": "Apply fixing-motion-performance to analyze my layer usage. Validate that will-change is used surgically, layers are not over-promoted, and compositor animations respect layer boundaries.",
        "scenario": "Analyzing compositor layer strategy"
      }
    ],
    "output_examples": [
      {
        "input": "Code that animates height and width continuously on a large container",
        "output": "VIOLATION: Animating layout properties (height, width) continuously on a large surface causes expensive reflow.\n\nWHY IT MATTERS: Layout operations trigger the browser's most expensive rendering phase, blocking the main thread.\n\nFIX: Replace with transform: scale() which runs on the compositor thread. If layout effect is required, measure once with getBoundingClientRect(), then animate using FLIP technique."
      },
      {
        "input": "requestAnimationFrame loop without stop condition",
        "output": "VIOLATION: Animation loop has no stop condition, running continuously.\n\nWHY IT MATTERS: Infinite animation loops consume CPU and battery indefinitely, degrading performance.\n\nFIX: Add requestAnimationFrame loop with clear stop conditions: when animation completes, element is removed, or page visibility changes."
      }
    ],
    "best_practices": [
      "Always prefer transform and opacity over layout or paint-triggering properties for continuous motion.",
      "Measure DOM layout once before animating, then batch all writes to avoid interleaved reads and writes.",
      "Use Scroll Timelines or IntersectionObserver instead of polling scroll position for scroll-linked animations."
    ],
    "anti_patterns": [
      "Driving animations directly from scroll events or scrollTop/scrollY values.",
      "Mixing multiple animation systems that each measure or mutate layout in the same frame.",
      "Animating CSS variables for transform, opacity, or position without understanding inheritance implications."
    ],
    "faq": [
      {
        "question": "What is the most important rule for animation performance?",
        "answer": "Always prefer transform and opacity for animations. These properties run on the compositor thread, avoiding expensive layout and paint operations."
      },
      {
        "question": "How do I fix layout thrashing?",
        "answer": "Batch all DOM reads (like getBoundingClientRect) before any writes. Read once, then write all changes. Use the FLIP technique for layout-like effects."
      },
      {
        "question": "Can I animate blur effects?",
        "answer": "Keep blur animation small (8px or less) and use only for short, one-time effects. Never animate blur continuously or on large surfaces."
      },
      {
        "question": "What should I use for scroll-linked animations?",
        "answer": "Prefer CSS Scroll Timelines when available. Otherwise use IntersectionObserver for visibility detection. Never poll scroll position in requestAnimationFrame loops."
      },
      {
        "question": "How should I use will-change?",
        "answer": "Apply will-change temporarily and surgically, not permanently. Avoid promoting too many or large elements as layers due to memory overhead."
      },
      {
        "question": "Does this skill migrate my animation library?",
        "answer": "No. This skill applies performance guidelines within your existing animation stack. It will not migrate or rewrite animation libraries unless explicitly requested."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 128
    }
  ]
}
