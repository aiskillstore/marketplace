{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-06T07:32:28.269Z",
    "slug": "obra-systematic-debugging",
    "source_url": "https://github.com/obra/superpowers/tree/main/skills/systematic-debugging",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "1a6bb97f9541f57f12c7edb48a9ca62288e84190fbf6713f405dc16e96786af9",
    "tree_hash": "f5739cb15ee65457f7463b994858ee1dc929c5e37cccebc84978126d3bbfde3f"
  },
  "skill": {
    "name": "systematic-debugging",
    "description": "Use when encountering any bug, test failure, or unexpected behavior, before proposing fixes",
    "summary": "Use when encountering any bug, test failure, or unexpected behavior, before proposing fixes",
    "icon": "üîç",
    "version": "1.0.0",
    "author": "obra",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "debugging",
      "root-cause",
      "testing",
      "troubleshooting",
      "process"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure prompt-based skill with minimal TypeScript utilities. No network calls, no credential access, no dangerous code execution patterns. The supporting code consists of safe polling utilities and a test-bisection script for debugging.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 11,
    "total_lines": 1800,
    "audit_model": "claude",
    "audited_at": "2026-01-06T07:32:28.269Z"
  },
  "content": {
    "user_title": "Debug systematically before fixing",
    "value_statement": "Random fixes waste time and create new bugs. This skill provides a four-phase process to find root cause before attempting any fix. It prevents symptom-whack-a-mole and ensures fixes actually solve the problem.",
    "seo_keywords": [
      "systematic debugging",
      "root cause analysis",
      "debugging process",
      "bug fixing",
      "test failures",
      "Claude debugging",
      "Claude Code debugging",
      "Codex debugging",
      "troubleshooting",
      "diagnostics"
    ],
    "actual_capabilities": [
      "Four-phase debugging process (Root Cause ‚Üí Pattern ‚Üí Hypothesis ‚Üí Implementation)",
      "Backward tracing through call stack to find original trigger",
      "Condition-based waiting patterns to replace arbitrary timeouts",
      "Defense-in-depth validation at multiple layers",
      "Test pollution detection with bisection script",
      "Anti-pattern recognition for debugging shortcuts"
    ],
    "limitations": [
      "Requires discipline to follow process under time pressure",
      "Does not execute code or run tests automatically",
      "Cannot diagnose issues without access to relevant code and logs",
      "Effectiveness depends on accurate problem description"
    ],
    "use_cases": [
      {
        "target_user": "Software developers",
        "title": "Fix recurring bugs properly",
        "description": "Stop the cycle of temporary fixes by tracing issues to their root cause and solving them permanently."
      },
      {
        "target_user": "QA engineers",
        "title": "Investigate test failures",
        "description": "Move beyond flaky tests and arbitrary timeouts to understand why tests actually fail."
      },
      {
        "target_user": "DevOps engineers",
        "title": "Debug production incidents",
        "description": "Maintain systematic discipline when pressure mounts to guess quick fixes during outages."
      }
    ],
    "prompt_templates": [
      {
        "title": "Quick check",
        "scenario": "Unexpected behavior noticed",
        "prompt": "Use systematic-debugging skill. Before proposing any fix: 1) Read error messages completely, 2) Identify steps to reproduce, 3) Check recent changes, 4) Trace data flow backward to find root cause. Report findings before any fix attempt."
      },
      {
        "title": "Multi-layer issue",
        "scenario": "Complex system failure",
        "prompt": "Use systematic-debugging skill. This is a multi-component system. Before proposing fixes, gather diagnostic evidence at each component boundary. Show where data flow breaks, then investigate that specific component only."
      },
      {
        "title": "Test flakiness",
        "scenario": "Flaky or timing-sensitive tests",
        "prompt": "Use systematic-debugging skill. Replace arbitrary sleep/wait calls with condition-based waiting. Trace why timing matters. Create failing test case first. Find root cause of timing dependency."
      },
      {
        "title": "Failed fix attempt",
        "scenario": "Previous fix did not work",
        "prompt": "Use systematic-debugging skill. Stop adding more fixes. Return to Phase 1 with new information. How many fixes have been attempted? If 3+, question whether the architectural pattern itself is sound."
      }
    ],
    "output_examples": [
      {
        "input": "The payment API is returning status 'pending' when it should be 'completed'",
        "output": [
          "Root Cause Investigation: Checking error messages and logs for the status transition",
          "Pattern Analysis: Finding working payment examples to compare",
          "Hypothesis: Forming specific theory about why status update is delayed",
          "Testing: Creating minimal test case to verify hypothesis",
          "Implementation: Fixing at the source, not at symptom point"
        ]
      }
    ],
    "best_practices": [
      "Always complete Phase 1 before attempting any fix, even under time pressure",
      "Create a failing test case before implementing a fix to prove root cause",
      "When fixes fail repeatedly, question whether the architecture is sound rather than adding more fixes",
      "Add validation at multiple layers after finding root cause for defense-in-depth"
    ],
    "anti_patterns": [
      "Quick fix now, investigate later - this guarantees the root cause remains and creates new bugs",
      "Changing multiple things at once - you cannot isolate what actually worked",
      "Skipping investigation because the issue seems simple - simple bugs have root causes too",
      "Adding arbitrary timeouts instead of understanding why timing matters"
    ],
    "faq": [
      {
        "question": "Is this skill compatible with all programming languages?",
        "answer": "Yes. The debugging process is language-agnostic. Only the code examples are in TypeScript, but the four-phase approach works for any codebase."
      },
      {
        "question": "What are the limits of this skill?",
        "answer": "The skill guides the process but does not execute tests or analyze code automatically. Users must provide access to relevant logs, code, and error messages."
      },
      {
        "question": "How does this integrate with test-driven development?",
        "answer": "This skill complements TDD. Phase 4 specifically requires creating a failing test case before fixing, which aligns with TDD principles while focusing on root cause."
      },
      {
        "question": "Is my data safe when using this skill?",
        "answer": "Yes. This is a prompt-based skill that only provides guidance. It does not read files, access credentials, or make network calls."
      },
      {
        "question": "What if the debugging process reveals no clear root cause?",
        "answer": "Document what was investigated. Implement appropriate handling like retry logic or error messages. Add monitoring for future investigation. Most 'no root cause' cases indicate incomplete investigation."
      },
      {
        "question": "How does this compare to other debugging approaches?",
        "answer": "Unlike guess-and-check or symptom-focused fixes, this skill mandates finding root cause first. It resists time pressure rationalizations and provides explicit anti-patterns to avoid common shortcuts."
      }
    ]
  },
  "file_structure": [
    {
      "name": "condition-based-waiting-example.ts",
      "type": "file",
      "path": "condition-based-waiting-example.ts"
    },
    {
      "name": "condition-based-waiting.md",
      "type": "file",
      "path": "condition-based-waiting.md"
    },
    {
      "name": "CREATION-LOG.md",
      "type": "file",
      "path": "CREATION-LOG.md"
    },
    {
      "name": "defense-in-depth.md",
      "type": "file",
      "path": "defense-in-depth.md"
    },
    {
      "name": "find-polluter.sh",
      "type": "file",
      "path": "find-polluter.sh"
    },
    {
      "name": "root-cause-tracing.md",
      "type": "file",
      "path": "root-cause-tracing.md"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    },
    {
      "name": "test-academic.md",
      "type": "file",
      "path": "test-academic.md"
    },
    {
      "name": "test-pressure-1.md",
      "type": "file",
      "path": "test-pressure-1.md"
    },
    {
      "name": "test-pressure-2.md",
      "type": "file",
      "path": "test-pressure-2.md"
    },
    {
      "name": "test-pressure-3.md",
      "type": "file",
      "path": "test-pressure-3.md"
    }
  ]
}
