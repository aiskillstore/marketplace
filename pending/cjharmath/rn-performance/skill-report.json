{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T11:58:34.505Z",
    "slug": "cjharmath-rn-performance",
    "source_url": "https://github.com/CJHarmath/claude-agents-skills/tree/main/skills/rn-performance",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "cce65b92850e54fb9c2ea0dedb2f4c516702e28cd6b1dc4c3456cafec921af8b",
    "tree_hash": "e1dda0b8ae6e33b61b4c79316916f9874d2b059406276effe27511490ae8d6bf"
  },
  "skill": {
    "name": "rn-performance",
    "description": "Performance optimization for React Native. Use when optimizing lists, preventing re-renders, memoizing components, or debugging performance issues in Expo/React Native apps.",
    "summary": "Performance optimization for React Native. Use when optimizing lists, preventing re-renders, memoizi...",
    "icon": "⚡",
    "version": "1.0.0",
    "author": "CJHarmath",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "react-native",
      "performance",
      "optimization",
      "flatlist",
      "react"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a pure documentation skill containing only markdown content with React Native code examples. No executable code, network calls, file access, or system modifications. Zero security risk.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 423,
    "audit_model": "claude",
    "audited_at": "2026-01-10T11:58:34.505Z"
  },
  "content": {
    "user_title": "Optimize React Native Performance",
    "value_statement": "React Native apps often suffer from scroll jank, unnecessary re-renders, and slow list performance. This skill provides proven patterns for FlatList optimization, memoization, and state management that eliminate performance bottlenecks.",
    "seo_keywords": [
      "React Native performance",
      "FlatList optimization",
      "React.memo",
      "useCallback",
      "useMemo",
      "Expo performance",
      "React Native optimization",
      "Claude Code",
      "Codex",
      "list rendering"
    ],
    "actual_capabilities": [
      "Optimize FlatList with keyExtractor, getItemLayout, and memoized renderItem",
      "Apply React.memo and useCallback to prevent unnecessary component re-renders",
      "Use Zustand selectors to minimize store subscription re-renders",
      "Optimize images with expo-image caching and priority loading",
      "Debug re-renders using React DevTools Profiler and why-did-you-render",
      "Offload heavy computations using InteractionManager"
    ],
    "limitations": [
      "Does not modify your codebase automatically - provides patterns you apply manually",
      "Requires React Native or Expo project to use the patterns",
      "Does not include runtime performance monitoring or profiling tools"
    ],
    "use_cases": [
      {
        "target_user": "Mobile Developers",
        "title": "Fix Scroll Jank",
        "description": "Optimize FlatList performance in React Native apps experiencing frame drops during scrolling."
      },
      {
        "target_user": "React Native Teams",
        "title": "Reduce Re-renders",
        "description": "Implement memoization patterns to prevent unnecessary component updates and improve UI responsiveness."
      },
      {
        "target_user": "Expo Developers",
        "title": "Optimize Image Loading",
        "description": "Configure expo-image with caching and priority loading for smoother image display in lists."
      }
    ],
    "prompt_templates": [
      {
        "title": "FlatList Basics",
        "scenario": "Optimize a list that scrolls poorly",
        "prompt": "My React Native FlatList is scrolling slowly. Show me how to add keyExtractor with useCallback, getItemLayout for fixed-height items, and memoize the renderItem function."
      },
      {
        "title": "Memoization Deep Dive",
        "scenario": "Prevent component re-renders",
        "prompt": "Help me apply React.memo and useCallback to a list item component. Show me how to create a stable callback and use shallow comparison for complex props."
      },
      {
        "title": "State Management",
        "scenario": "Optimize Zustand store selectors",
        "description": "Avoid full store subscriptions that cause unnecessary re-renders",
        "prompt": "My Zustand store is causing all components to re-render when any state changes. Show me how to use selectors with useShallow to only re-render when specific values change."
      },
      {
        "title": "Performance Debugging",
        "scenario": "Diagnose performance issues",
        "prompt": "Help me set up why-did-you-render in my React Native project and use the React DevTools Profiler to identify which components are rendering unnecessarily."
      }
    ],
    "output_examples": [
      {
        "input": "My FlatList with 1000 items scrolls poorly and causes jank",
        "output": [
          "• Add keyExtractor with useCallback for stable keys",
          "• Use getItemLayout for fixed-height items to skip measurement",
          "• Memoize renderItem with useCallback",
          "• Enable removeClippedSubviews to unmount off-screen items",
          "• Set maxToRenderPerBatch={10} and windowSize={5}",
          "• Consider FlashList for lists over 1000 items"
        ]
      }
    ],
    "best_practices": [
      "Always wrap FlatList renderItem with useCallback to prevent new function references on each render",
      "Use getItemLayout for lists with fixed-height items to eliminate measurement overhead",
      "Apply shallow selectors in Zustand to subscribe only to the specific state values your component needs"
    ],
    "anti_patterns": [
      "Using inline arrow functions for keyExtractor or renderItem (creates new functions every render)",
      "Selecting the entire Zustand store instead of specific selectors (causes global re-renders)",
      "Memoizing simple primitive prop access where overhead exceeds benefit"
    ],
    "faq": [
      {
        "question": "Does this skill work with Expo Go?",
        "answer": "Yes. All patterns work in Expo Go including FlatList optimizations, memoization, and expo-image."
      },
      {
        "question": "How many items before I need FlashList instead of FlatList?",
        "answer": "Consider FlashList for lists over 1000 items or when FlatList still janks after optimization."
      },
      {
        "question": "Can I use these patterns with React Navigation?",
        "answer": "Yes. Use useCallback for navigation callbacks and memoize screen components to prevent re-renders."
      },
      {
        "question": "Does this skill modify my project files?",
        "answer": "No. This skill provides patterns and code examples. You apply them to your codebase manually."
      },
      {
        "question": "Why is my memoized component still re-rendering?",
        "answer": "Check that props are stable (use useCallback for functions, useMemo for objects). Also verify parent re-renders."
      },
      {
        "question": "How is this different from React Native Performance Monitor?",
        "answer": "This skill provides optimization patterns. Performance Monitor shows frame rates in real-time during development."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
