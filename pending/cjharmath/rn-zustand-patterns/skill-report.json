{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T11:54:31.855Z",
    "slug": "cjharmath-rn-zustand-patterns",
    "source_url": "https://github.com/CJHarmath/claude-agents-skills/tree/main/skills/rn-zustand-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "4808db2b93513d86ad2083bad97caa41fb9be243952404e0390b7840921d5050",
    "tree_hash": "9337d1df888d75d6ae99cbf95711228015a4e6d9fd44853e55021d981474dddd"
  },
  "skill": {
    "name": "rn-zustand-patterns",
    "description": "Zustand state management patterns for React Native. Use when working with Zustand stores, debugging state timing issues, or implementing async actions in Zustand.",
    "summary": "Zustand state management patterns for React Native. Use when working with Zustand stores, debugging ...",
    "icon": "⚛️",
    "version": "1.0.0",
    "author": "CJHarmath",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "react-native",
      "zustand",
      "state-management",
      "patterns"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a documentation-only skill containing a single SKILL.md file with educational content about Zustand patterns. No executable code, scripts, network calls, file system access, or environment variable reads were detected. Purely informational content safe for publication.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 342,
    "audit_model": "claude",
    "audited_at": "2026-01-10T11:54:31.855Z"
  },
  "content": {
    "user_title": "Apply Zustand patterns for React Native",
    "value_statement": "Zustand state management in React Native has subtle timing behaviors that cause hard-to-debug issues. This skill provides proven patterns to handle synchronous set() calls, avoid stale closures in async operations, and implement reliable store subscriptions.",
    "seo_keywords": [
      "zustand patterns",
      "react native state management",
      "zustand async actions",
      "zustand stale closures",
      "zustand debugging",
      "react native zustand store",
      "zustand selectors",
      "zustand subscriptions",
      "claude code",
      "claude"
    ],
    "actual_capabilities": [
      "Explain set() synchronous behavior vs React render batching",
      "Prevent stale closures in async store actions using get()",
      "Implement proper async actions with try/catch and state checks",
      "Optimize selectors to avoid unnecessary re-renders",
      "Create store subscriptions for side effects outside components",
      "Debug state changes with devtools middleware and logging"
    ],
    "limitations": [
      "Does not generate complete store implementations from requirements",
      "Does not test or validate existing Zustand code",
      "Does not provide runtime performance profiling",
      "Does not cover non-React Native Zustand usage patterns"
    ],
    "use_cases": [
      {
        "target_user": "React Native developers",
        "title": "Debug state timing issues",
        "description": "Understand why set() updates state immediately but components show old values until re-render"
      },
      {
        "target_user": "Full-stack developers",
        "title": "Fix async action bugs",
        "description": "Implement async store actions that correctly read state after await without stale closure problems"
      },
      {
        "target_user": "Mobile app architects",
        "title": "Optimize store subscriptions",
        "description": "Set up reactive side effects that trigger on specific state changes outside React components"
      }
    ],
    "prompt_templates": [
      {
        "title": "Understanding set()",
        "scenario": "Confused about state update timing",
        "prompt": "Explain why set() is synchronous but my React Native component still shows the old value after calling set(). Include how to verify the actual state immediately after set()."
      },
      {
        "title": "Fixing stale closures",
        "scenario": "Async callbacks capturing old state",
        "prompt": "Show me how to fix stale closure issues in my Zustand store when I have async callbacks. After await operations, how do I ensure I am reading the current state?"
      },
      {
        "title": "Async action patterns",
        "scenario": "Implementing proper async store actions",
        "prompt": "Write a pattern for a Zustand async action that properly handles loading state, errors, and ensures the caller can await the result. Include race condition protection."
      },
      {
        "title": "Selector optimization",
        "scenario": "Unnecessary re-renders from selectors",
        "prompt": "My Zustand selectors are causing too many re-renders in my React Native app. Show me how to use shallow comparison and multiple selectors to optimize performance."
      }
    ],
    "output_examples": [
      {
        "input": "Why does my component show stale data after calling set() in my Zustand store?",
        "output": [
          "set() updates state synchronously, but React re-renders are batched asynchronously",
          "getState() immediately reflects the new value (use for verification)",
          "Components only update on the next render cycle",
          "After await in async functions, always use get() instead of closure-captured values",
          "For immediate reads outside components, use useStore.getState()"
        ]
      }
    ],
    "best_practices": [
      "Always use get() or getState() after any await to avoid stale closures",
      "Use shallow comparison for object selectors to prevent unnecessary re-renders",
      "Implement subscribe() for side effects that should run outside React components"
    ],
    "anti_patterns": [
      "Relying on closure-captured state after async operations without re-reading with get()",
      "Returning non-Promise results from async actions that callers try to await",
      "Creating new objects in selectors without shallow comparison, causing excessive re-renders"
    ],
    "faq": [
      {
        "question": "What Zustand versions does this skill cover?",
        "answer": "Covers both Zustand 4.x and 5.x, including migration notes for shallow comparison and useShallow hook differences."
      },
      {
        "question": "Can I use these patterns in plain React?",
        "answer": "Yes, most patterns apply to React web apps. Only React Native specific debugging tools differ."
      },
      {
        "question": "Does this skill write code to my project?",
        "answer": "No, this skill provides patterns and guidance. It does not modify files or execute code."
      },
      {
        "question": "How do I test Zustand stores?",
        "answer": "Add a reset action to your store, call getState() to access store methods directly, and reset state before each test."
      },
      {
        "question": "What causes selectors to trigger extra re-renders?",
        "answer": "Returning new object instances from selectors breaks reference equality. Use shallow comparison or split into multiple selectors."
      },
      {
        "question": "How is this different from Redux patterns?",
        "answer": "Zustand avoids boilerplate but requires understanding its synchronous set() behavior versus asynchronous React renders. No middleware chain exists."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
