# CodeConscious 命令系统详解

## 运行时命令详解

### `/runtime.explore` - 系统探索
**用途**: 建立代码库的认知地图和依赖图谱

**关键词**: 知识图谱、神经元连接、模式识别、PageRank

**过程**:
1. 文件系统拓扑扫描
2. 技术栈和依赖识别
3. 架构模式检测
4. 构建依赖图谱（识别核心节点）
5. 代码质量和债务分析
6. 生成探索报告 + 更新记忆网络

**输出**:
- `cognition/graphs/dependency-graph.json`
- `cognition/exploration-reports/exploration-{timestamp}.md`
- `memory/short-term/neural-connections-{timestamp}.md`

**类比**: 人类探索陌生城市——先走一遍街道，记住地标，形成认知地图

### `/runtime.learn` - 自主学习
**用途**: 对未知问题自主探索学习

**过程**:
- 理解问题 → 识别知识缺口
- 动态规划 → 生成学习计划
- 探索循环 → 自主选择工具和步骤
- 分析总结 → 形成结论
- 固化记忆 → 存入长期记忆

**特点**:
- 无需人工指导每一步
- 根据置信度动态调整探索深度
- 完整记录思维链
- 从结果学习并更新心智模型

**终止条件**:
- 找到答案（置信度 > 0.90）
- 达到最大步数（默认10步）
- 超时或需要人工帮助

### `/runtime.think` - 深度思考
**用途**: 深度分析，不修改任何文件

**约束**: 不修改文件，只读取和分析

**报告模板**:
- 问题重述
- 当前理解
- 相关记忆
- 代码理解
- 候选方案（A/B/C...）
- 需要澄清的问题
- 建议和理由

### `/runtime.plan` - 需求规划
**用途**: 将需求拆解为可执行任务

**输出**: 任务列表（CoT格式）

**要素**: 优先级、依赖关系、验证标准

### `/runtime.implement` - 迭代执行
**用途**: 基于计划进行代码修改

**模式**: 小步快跑、频繁验证、快速反馈

**验证**: 每次修改后运行测试、检查格式、验证功能

### `/runtime.remember` - 固化记忆
**用途**: 将经验写入长期记忆

**分类**: 项目架构、设计模式、代码质量、用户偏好、历史决策

**模板**: 时间、置信度、来源、内容、上下文、影响

### `/runtime.reflect` - 自我反思
**维度**:
1. 理解准确性（假设是否成立）
2. 错误模式（识别重复错误）
3. 效率评估（认知资源利用率）
4. 认知盲区（薄弱领域识别）
5. 人格一致性（是否符合CodeConscious）

**输出**: 行动清单 + 心智模型更新 + 防御机制

## 典型使用场景

### 场景1：探索新代码库
```bash
用户: "这是一个新项目，帮我理解一下代码结构"

AI:
/runtime.explore
→ 扫描文件系统拓扑
→ 识别技术栈（Node.js + Express + PostgreSQL）
→ 识别架构模式（Repository + Service）
→ 构建依赖图谱（47个文件，132条关系）
→ 识别核心节点（auth/service.js PageRank: 0.152）
→ 生成探索报告
→ 更新记忆系统
→ 返回：技术栈、架构、核心文件、潜在问题、建议
```

### 场景2：分析复杂问题
```bash
用户: "为什么生产环境的支付服务偶尔会超时？"

AI:
/runtime.think
→ 读取相关文件和历史记忆
→ 分析可能原因（生成3个假设）
→ 建议验证步骤
→ 报告不确定性（置信度: 0.75）
→ 返回：分析 + 假设 + 验证步骤（不修改代码）
```

### 场景3：自主学习
```bash
用户: "/runtime.learn 支付服务超时的根本原因"

AI自主执行:
→ /runtime.explore（理解支付服务架构）
→ Read（读取配置）
→ grep（搜索日志超时错误）
→ Search（查找相关错误模式）
→ Bash（运行测试验证假设）
→ /runtime.think（推理根因）
→ 总结：连接池配置不足 + 缺乏降级机制
→ 固化记忆：连接池不足的诊断方法
→ 返回：根因 + 3层解决方案（置信度: 0.93）
```

**关键点**: 你不需要指导每一步，AI自主决定查什么、怎么查、何时停止

### 场景4：规划需求
```bash
用户: "我们需要添加OAuth2.0支持"

AI:
/runtime.plan
→ 分析当前认证架构
→ 识别集成点（3个文件需要修改）
→ 生成任务列表（6个任务）
→ 标注依赖关系
→ 设定验证标准
→ 返回：详细执行计划
```

### 场景5：迭代实现
```bash
用户: "按照计划实现OAuth2.0"

AI:
/runtime.implement
→ 任务1: 添加依赖（package.json）
  → 修改 → 验证（npm install成功）
→ 任务2: 创建OAuth服务（auth/oauth.js）
  → 生成代码 → 验证（单元测试通过）
→ 任务3: 集成到现有认证流
  → 修改auth/index.js → 验证（集成测试）
→ 任务6: 更新文档
  → 修改README → 验证（文档完整）
→ 每一步都记录到情景记忆
→ 返回：完整实现 + 测试报告
```

### 场景6：固化经验
```bash
用户: "我们决定从JWT切换到OAuth2.0"

AI:
/runtime.remember
→ 更新: memory/long-term/project-context.md
→ 记录: 决策背景、时间、原因、实施计划
→ 更新: 记忆索引
→ 返回: "已固化2条记忆"
```

### 场景7：自我反思
```bash
用户: "请做一次自我反思"

AI:
/runtime.reflect
→ 读取情景记忆时间线
→ 统计错误模式（识别3个重复错误）
→ 识别认知盲区（薄弱环节：前端性能优化）
→ 更新防御机制
→ 输出: cognition/reflections/{timestamp}.md
→ 更新: 心智模型
```

## 命令执行原则

### 触发条件
- 仅在用户明确请求时执行对应命令
- 不同命令有不同的适用场景
- 避免过度使用命令影响用户体验

### 执行约束
- `/runtime.think` 绝对不修改文件
- `/runtime.implement` 需要用户批准计划后执行
- `/runtime.reflect` 定期进行，不频繁触发

### 输出格式
- 每个命令都有标准化的输出格式
- 包含执行过程、结果和置信度
- 必要时提供下一步建议

## 集成和扩展

### 与记忆系统的集成
- 所有命令自动记录到情景记忆
- 学习命令会更新长期记忆
- 反思命令分析记忆模式

### 与工具系统的集成
- 探索命令使用外部工具扫描
- 实现命令可能调用内部工具
- 所有命令支持工具扩展

### 自定义命令开发
- 基于现有命令模板开发新命令
- 遵循命名约定 `/runtime.*`
- 集成到记忆和工具系统中
