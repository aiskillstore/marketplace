{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T08:49:47.281Z",
    "slug": "0xbigboss-python-best-practices",
    "source_url": "https://github.com/0xBigBoss/claude-code/tree/main/.claude/skills/python-best-practices",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "c0019f9fea234b80b38ad6a516fa051f270a0fdafc1ddcdf266777e520f5e88c",
    "tree_hash": "c613635ec315dcaa21637c523198c74abb01f36f8c7df999a4df71540ea1379c"
  },
  "skill": {
    "name": "python-best-practices",
    "description": "Provides Python patterns for type-first development with dataclasses, discriminated unions, NewType, and Protocol. Must use when reading or writing Python files.",
    "summary": "Provides Python patterns for type-first development with dataclasses, discriminated unions, NewType,...",
    "icon": "üêç",
    "version": "1.0.0",
    "author": "0xBigBoss",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "python",
      "type-safety",
      "patterns",
      "best-practices",
      "dataclasses"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing only markdown guidance. No executable code, no file system access, no network calls, and no external command execution. This skill only provides informational content when loaded by an AI agent.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 271,
    "audit_model": "claude",
    "audited_at": "2026-01-10T08:49:47.281Z"
  },
  "content": {
    "user_title": "Apply Python type-first patterns",
    "value_statement": "Writing Python without type definitions leads to runtime errors and hard-to-maintain code. This skill provides battle-tested patterns for type-first development using dataclasses, discriminated unions, Protocols, and other modern Python features to make illegal states unrepresentable.",
    "seo_keywords": [
      "Python best practices",
      "type-first development",
      "Claude Code Python",
      "dataclasses patterns",
      "Python type hints",
      "Protocol typing",
      "NewType Python",
      "discriminated unions"
    ],
    "actual_capabilities": [
      "Provides dataclass patterns for immutable data structures",
      "Guides discriminated union implementation with Literal types",
      "Documents NewType usage for domain primitive wrappers",
      "Explains Protocol for structural typing",
      "Covers TypedDict for external data shape validation",
      "Shares functional patterns and error handling best practices"
    ],
    "limitations": [
      "Does not execute or validate Python code",
      "Does not access or modify user project files",
      "Does not install dependencies or run type checkers",
      "Does not provide real-time code completion or linting"
    ],
    "use_cases": [
      {
        "target_user": "Python developers",
        "title": "Design type-safe data models",
        "description": "Learn to use dataclasses, NewType, and discriminated unions to encode domain constraints at the type level."
      },
      {
        "target_user": "Code reviewers",
        "title": "Review Python type patterns",
        "description": "Apply consistent typing patterns across codebases using Protocols, TypedDict, and exhaustively matched unions."
      },
      {
        "target_user": "AI agents",
        "title": "Generate idiomatic Python",
        "description": "Produce Python code that follows modern type-first patterns when working with Claude, Codex, or Claude Code."
      }
    ],
    "prompt_templates": [
      {
        "title": "Create data model",
        "scenario": "Define a type-safe data structure",
        "prompt": "Create a frozen dataclass with proper type hints for a user profile including required fields and optional avatar. Use the python-best-practices patterns."
      },
      {
        "title": "Handle state machine",
        "scenario": "Model state transitions",
        "prompt": "Model a request state machine with idle, loading, success, and failure states using discriminated unions and pattern matching. Apply python-best-practices patterns."
      },
      {
        "title": "Add type safety",
        "scenario": "Wrap primitive types",
        "prompt": "Create NewType wrappers for UserId and OrderId to prevent mixing them up. Show how to validate input and create the wrapped types."
      },
      {
        "title": "Define interface",
        "scenario": "Create protocol for duck typing",
        "prompt": "Define a Protocol for a file-like object with read method, then show how to use it as a type hint for functions that accept any read-compatible object."
      }
    ],
    "output_examples": [
      {
        "input": "Create a frozen dataclass for a product with required name and price, optional description",
        "output": [
          "Use @dataclass(frozen=True) for immutability",
          "Mark required fields without defaults first",
          "Add optional fields with default values after required fields",
          "The frozen=True flag prevents accidental mutation",
          "Example output shows proper field ordering and type hints"
        ]
      }
    ],
    "best_practices": [
      "Define types before implementation; let the type checker guide completeness",
      "Use frozen dataclasses and immutable patterns to prevent accidental state mutation",
      "Validate data at system boundaries with runtime checks alongside type hints"
    ],
    "anti_patterns": [
      "Using mutable default arguments in function signatures",
      "Skipping type hints for 'obvious' return types",
      "Catching exceptions without re-raising or adding context"
    ],
    "faq": [
      {
        "question": "What Python versions support these patterns?",
        "answer": "Pattern matching requires Python 3.10+. Dataclasses and typing features work on 3.7+. Use pyright or mypy for older projects."
      },
      {
        "question": "How does this compare to Pydantic?",
        "answer": "Dataclasses provide compile-time types. Pydantic adds runtime validation. Use both together for maximum safety."
      },
      {
        "question": "Can I use this with FastAPI or Django?",
        "answer": "Yes. These patterns complement web frameworks. Define models with dataclasses, use them in route handlers."
      },
      {
        "question": "Does this skill access my code?",
        "answer": "No. This is a knowledge-only skill. It provides guidance but cannot read, write, or execute your code."
      },
      {
        "question": "What type checker should I use?",
        "answer": "pyright offers best inference and VS Code integration. mypy has more plugins. ty is fastest for large codebases."
      },
      {
        "question": "When should I use TypedDict vs dataclass?",
        "answer": "Use dataclasses for internal Python objects. Use TypedDict when matching external JSON or dict structures."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
