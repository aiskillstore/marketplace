{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T13:51:02.196Z",
    "slug": "danielpodolsky-frontend-fundamentals",
    "source_url": "https://github.com/DanielPodolsky/mentor-spec/tree/main/.claude/skills/fundamentals/frontend",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "0554efcd45e4de02e333c79cf2056a436f2c8dac123d2bb726e07ba6a5e0c953",
    "tree_hash": "04c2a474047890c0bdafd6c293fd9e26af0767568f7f1b36eb0fa2d1581214f3"
  },
  "skill": {
    "name": "Frontend Fundamentals",
    "description": "Auto-invoke when reviewing React, Vue, or frontend component code. Enforces component architecture, state management patterns, and UI best practices.",
    "summary": "Auto-invoke when reviewing React, Vue, or frontend component code. Enforces component architecture, ...",
    "icon": "üîç",
    "version": "1.0.0",
    "author": "DanielPodolsky",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "frontend",
      "react",
      "vue",
      "components",
      "code-review"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a pure documentation skill with no executable code. It contains only markdown content with frontend development guidelines and best practices. No security risks detected.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 121,
    "audit_model": "claude",
    "audited_at": "2026-01-10T13:51:02.196Z"
  },
  "content": {
    "user_title": "Review Frontend Code Automatically",
    "value_statement": "Frontend code reviews often miss architectural issues and anti-patterns. This skill automatically applies proven frontend standards to catch component design flaws, state management mistakes, and performance issues before they reach production.",
    "seo_keywords": [
      "frontend review",
      "React components",
      "Vue components",
      "code quality",
      "component architecture",
      "state management",
      "Claude Code",
      "AI code review",
      "frontend best practices"
    ],
    "actual_capabilities": [
      "Automatically reviews React, Vue, and Svelte components",
      "Checks component size and prop count limits",
      "Identifies state management anti-patterns",
      "Provides accessibility compliance checks",
      "Suggests performance optimizations"
    ],
    "limitations": [
      "Only works with frontend component code",
      "Cannot execute or test the actual code",
      "Limited to architectural patterns, not business logic"
    ],
    "use_cases": [
      {
        "target_user": "Senior developers mentoring juniors",
        "title": "Mentor Junior Developers",
        "description": "Automatically catch architectural mistakes in junior developers' code and provide educational feedback with specific examples."
      },
      {
        "target_user": "Code review teams",
        "title": "Standardize Code Reviews",
        "description": "Ensure consistent code review standards across your team with automated checks for component architecture best practices."
      },
      {
        "target_user": "Open source maintainers",
        "title": "Review Community Contributions",
        "description": "Quickly assess pull requests for frontend architectural issues and provide actionable feedback to contributors."
      }
    ],
    "prompt_templates": [
      {
        "title": "Review Component",
        "scenario": "Analyzing a new React component",
        "prompt": "Please review this React component for architectural issues, performance problems, and accessibility concerns. Focus on component size, prop count, state management, and whether it follows single responsibility principle."
      },
      {
        "title": "Check State Management",
        "scenario": "Reviewing state management patterns",
        "prompt": "Analyze this code for state management anti-patterns. Check if state is properly colocated, if prop drilling exists, and whether server state is handled correctly."
      },
      {
        "title": "Performance Audit",
        "scenario": "Identifying performance issues",
        "prompt": "Review this frontend code for performance bottlenecks. Look for unnecessary re-renders, missing memoization, and opportunities for code splitting."
      },
      {
        "title": "Accessibility Review",
        "scenario": "Ensuring accessibility compliance",
        "prompt": "Check this component for accessibility issues. Verify semantic HTML usage, ARIA attributes, and keyboard navigation support."
      }
    ],
    "output_examples": [
      {
        "input": "Review this React component for architectural issues",
        "output": [
          "Component exceeds 200 lines - consider splitting into smaller components",
          "Found 8 props - try to reduce to under 7 for better maintainability",
          "State management looks good - properly colocated with useState",
          "Performance: Add useMemo for the filtered users calculation",
          "Accessibility: Button needs aria-label for screen readers"
        ]
      }
    ],
    "best_practices": [
      "Apply the single responsibility principle - each component should do one thing well",
      "Keep components under 200 lines and props under 7 for maintainability",
      "Colocate state as close as possible to where it's actually used"
    ],
    "anti_patterns": [
      "Creating god components that handle data fetching, state, and UI rendering",
      "Prop drilling through more than 3 levels of components",
      "Putting expensive calculations directly in render without memoization"
    ],
    "faq": [
      {
        "question": "Which frontend frameworks does this support?",
        "answer": "Works with React, Vue, Svelte, and other component-based frameworks. Focuses on universal patterns applicable to all."
      },
      {
        "question": "What are the size limits for components?",
        "answer": "Recommends keeping components under 200 lines and using fewer than 7 props for optimal maintainability."
      },
      {
        "question": "How does this integrate with my development workflow?",
        "answer": "Automatically activates when reviewing frontend code in Claude Code, providing instant feedback during code reviews."
      },
      {
        "question": "Is my code data safe during review?",
        "answer": "Yes, this is a documentation-only skill that doesn't execute code or make network requests. Your code stays local."
      },
      {
        "question": "What if the skill flags something that's actually correct?",
        "answer": "These are guidelines, not rules. Use your judgment - the skill helps identify potential issues for your consideration."
      },
      {
        "question": "How does this compare to linters like ESLint?",
        "answer": "This focuses on architectural patterns and design principles, while linters catch syntax and style issues. They complement each other."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
