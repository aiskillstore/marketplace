{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T14:11:29.768Z",
    "slug": "doubleslashse-cqs-patterns",
    "source_url": "https://github.com/DoubleslashSE/claude-workflows/tree/main/Plugins/dotnet-tdd/skills/cqs-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "5802c561daa0dc873a391bc44b458d01452692cc7894dbeeca55a6ae579d407d",
    "tree_hash": "a837f50163706bf1cc2d4848e362d1ef4b195d054afb5f963640207ed71c6122"
  },
  "skill": {
    "name": "cqs-patterns",
    "description": "Command Query Separation (CQS) and CQRS patterns for .NET. Use when designing methods, handlers, and application architecture. Ensures predictable, testable code.",
    "summary": "Command Query Separation (CQS) and CQRS patterns for .NET. Use when designing methods, handlers, and...",
    "icon": "ðŸ”€",
    "version": "1.0.0",
    "author": "DoubleslashSE",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "csharp",
      "dotnet",
      "architecture",
      "patterns",
      "cqrs"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing only markdown guidance on CQS/CQRS architecture patterns. No executable code, network calls, file system access, or external commands detected.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 532,
    "audit_model": "claude",
    "audited_at": "2026-01-10T14:11:29.768Z"
  },
  "content": {
    "user_title": "Apply CQS and CQRS patterns",
    "value_statement": "Mixed command and query responsibilities create code that is hard to test and maintain. This skill provides comprehensive guidance on implementing Command Query Separation and CQRS patterns in .NET applications.",
    "seo_keywords": [
      "cqs pattern",
      "cqrs pattern",
      "dotnet architecture",
      "csharp patterns",
      "command query separation",
      "claude code",
      "claude",
      "codex",
      "software design"
    ],
    "actual_capabilities": [
      "Apply CQS principle at method level",
      "Design command and query handlers",
      "Implement dispatcher pattern for routing",
      "Separate read and write models",
      "Identify valid CQS exceptions"
    ],
    "limitations": [
      "Does not generate code automatically",
      "Does not integrate with build tools",
      "Requires understanding of .NET fundamentals"
    ],
    "use_cases": [
      {
        "target_user": ".NET developers",
        "title": "Design clean methods",
        "description": "Apply CQS to write methods that either change state or return data, never both"
      },
      {
        "target_user": "Software architects",
        "title": "Structure application layers",
        "description": "Implement CQRS to separate read and write responsibilities in complex domains"
      },
      {
        "target_user": "Backend engineers",
        "title": "Build handler patterns",
        "description": "Create command and query handlers with clear separation of concerns"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic CQS check",
        "scenario": "Review method design",
        "prompt": "Check if this method follows CQS principle. If not, show how to separate the command and query responsibilities."
      },
      {
        "title": "Command design",
        "scenario": "Create new command",
        "prompt": "Design a command for [action] following CQS. Include the command class, handler interface, and basic implementation structure."
      },
      {
        "title": "Query design",
        "scenario": "Create read operation",
        "prompt": "Design a query for [data] following CQS. Include the query record, handler interface, and return type definition."
      },
      {
        "title": "CQRS architecture",
        "scenario": "Architectural review",
        "prompt": "Review this code structure and suggest how to apply CQRS. Show the command/query separation and dispatcher pattern implementation."
      }
    ],
    "output_examples": [
      {
        "input": "Review this method: public User CreateUser(string email, string name) { var user = new User { Email = email, Name = name }; _repository.Add(user); return user; }",
        "output": [
          "This method violates CQS by both creating a user and returning the created object.",
          "Split into two operations: CreateUser command returns Guid, GetUser query retrieves the user.",
          "Command handler creates user, query handler fetches data from repository."
        ]
      }
    ],
    "best_practices": [
      "Keep commands focused on a single action with no return value except optional ID",
      "Make queries pure with no side effects for predictable testing",
      "Use separate read models optimized for queries, write models for business rules"
    ],
    "anti_patterns": [
      "Combining state mutation with data return in the same method",
      "Using getters with side effects that modify internal state",
      "Applying CQRS to simple CRUD applications without clear read/write separation needs"
    ],
    "faq": [
      {
        "question": "What is the difference between CQS and CQRS?",
        "answer": "CQS applies at method level, CQRS at architectural level. CQS separates command/query methods; CQRS separates read/write models and databases."
      },
      {
        "question": "When should I return an ID from a command?",
        "answer": "Returning a generated ID (Guid) is acceptable as it identifies the created resource without exposing internal state."
      },
      {
        "question": "Does this skill generate code?",
        "answer": "No, this skill provides patterns and guidance. You apply the patterns when writing code with your AI assistant."
      },
      {
        "question": "Can I use these patterns with minimal APIs?",
        "answer": "Yes, the dispatcher pattern works with any .NET web framework including minimal APIs and controllers."
      },
      {
        "question": "Are there valid exceptions to CQS?",
        "answer": "Yes, atomic operations like Interlocked methods, fluent builders returning this, and factory methods are acceptable exceptions."
      },
      {
        "question": "Should every .NET project use CQRS?",
        "answer": "No, CQRS adds complexity. Use it for complex domains with different read/write patterns, not simple CRUD applications."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
