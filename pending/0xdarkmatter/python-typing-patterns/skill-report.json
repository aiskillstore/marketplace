{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T08:41:43.022Z",
    "slug": "0xdarkmatter-python-typing-patterns",
    "source_url": "https://github.com/0xDarkMatter/claude-mods/tree/main/skills/python-typing-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "7365b3b15c2018d2a44fe44806bbe7bbba7cdbeb375978698c6c92ae6cae0942",
    "tree_hash": "a86919b04bd8f285df63c0ad52f17e255f29eeb54331cf1f671f6a499e28e16a"
  },
  "skill": {
    "name": "python-typing-patterns",
    "description": "Python type hints and type safety patterns. Triggers on: type hints, typing, TypeVar, Generic, Protocol, mypy, pyright, type annotation, overload, TypedDict.",
    "summary": "Python type hints and type safety patterns. Triggers on: type hints, typing, TypeVar, Generic, Proto...",
    "icon": "ðŸ",
    "version": "1.0.0",
    "author": "0xDarkMatter",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "python",
      "type-hints",
      "static-analysis",
      "mypy",
      "pyright"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill provides documentation and patterns for Python type hints. It includes a shell script that runs mypy and pyright type checkers on specified targets. No network calls, no credential access, no data exfiltration. All capabilities match stated purpose.",
    "risk_factor_evidence": [
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "scripts/check-types.sh",
            "line_start": 1,
            "line_end": 152
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "scripts/check-types.sh",
            "line_start": 51,
            "line_end": 74
          },
          {
            "file": "scripts/check-types.sh",
            "line_start": 76,
            "line_end": 108
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [
      {
        "title": "External command execution in type checker script",
        "description": "The check-types.sh script executes mypy and pyright type checkers using subprocess calls. Lines 67 and 99 invoke these tools directly. This is necessary for the stated purpose of running type checks, but any script that executes external processes carries inherent risk. An attacker could potentially exploit this if the target path could be manipulated to execute arbitrary code.",
        "locations": [
          {
            "file": "scripts/check-types.sh",
            "line_start": 67,
            "line_end": 67
          },
          {
            "file": "scripts/check-types.sh",
            "line_start": 99,
            "line_end": 99
          }
        ]
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 9,
    "total_lines": 1963,
    "audit_model": "claude",
    "audited_at": "2026-01-10T08:41:43.021Z"
  },
  "content": {
    "user_title": "Apply Python type hints for safer code",
    "value_statement": "Python type hints improve code quality and catch bugs at development time. This skill provides patterns and examples for using type annotations, generics, protocols, and type checkers like mypy and pyright.",
    "seo_keywords": [
      "python type hints",
      "python typing",
      "mypy",
      "pyright",
      "type annotations",
      "generics",
      "Protocol",
      "TypeVar",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Provides patterns for basic type annotations with modern Python syntax",
      "Documents advanced generics with TypeVar, ParamSpec, and TypeVarTuple",
      "Explains Protocol patterns for structural typing",
      "Covers type narrowing techniques with isinstance and TypeGuard",
      "Includes runtime validation patterns with Pydantic and beartype",
      "Documents mypy and pyright configuration for strict type checking"
    ],
    "limitations": [
      "Does not automatically add type hints to untyped code",
      "Requires manual installation of mypy or pyright for the script to work",
      "Only covers Python 3.10+ syntax; older Python versions require different patterns"
    ],
    "use_cases": [
      {
        "target_user": "Python developers",
        "title": "Add type hints to code",
        "description": "Learn modern Python type annotation patterns for variables, functions, and classes."
      },
      {
        "target_user": "Library maintainers",
        "title": "Design type-safe APIs",
        "description": "Use Protocol and generics to create flexible, well-documented APIs."
      },
      {
        "target_user": "DevOps engineers",
        "title": "Configure type checkers",
        "description": "Set up mypy and pyright with strict mode for CI pipelines."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic annotations",
        "scenario": "Adding type hints to a function",
        "prompt": "Write a Python function that takes a list of strings and returns a dictionary mapping each string to its length. Use modern Python type annotations."
      },
      {
        "title": "Generic functions",
        "scenario": "Creating reusable type-safe functions",
        "prompt": "Create a generic Stack class in Python that works with any type T. Include push, pop, and peek methods."
      },
      {
        "title": "Protocol patterns",
        "scenario": "Defining structural interfaces",
        "prompt": "Define a Protocol called Serializable that requires a to_dict method. Show how a regular class can satisfy this Protocol without explicit inheritance."
      },
      {
        "title": "Type narrowing",
        "scenario": "Narrowing union types in conditionals",
        "prompt": "Write a function that accepts str | int | list[str] and returns different types based on which branch is true. Use isinstance for type narrowing."
      }
    ],
    "output_examples": [
      {
        "input": "Add type annotations to this function: def process(data, multiplier): return [x * multiplier for x in data]",
        "output": [
          "def process(data: list[float], multiplier: float) -> list[float]:",
          "    return [x * multiplier for x in data]"
        ]
      }
    ],
    "best_practices": [
      "Use modern Python 3.10+ union syntax (X | Y) instead of Union[X, Y]",
      "Prefer Protocol over ABC for structural typing and duck typing",
      "Enable strict mode in mypy or pyright to catch more type errors"
    ],
    "anti_patterns": [
      "Using Any everywhere to silence type checker errors",
      "Forgetting to install type stubs for third-party libraries",
      "Mixing implicit Optional[X] with explicit X | None syntax"
    ],
    "faq": [
      {
        "question": "What Python versions support these type patterns?",
        "answer": "Basic patterns work with Python 3.10+. Self and TypeVarTuple require Python 3.11+. TypeIs requires Python 3.13+."
      },
      {
        "question": "How strict should my type checking be?",
        "answer": "Start with standard mode in pyright or basic mypy settings. Gradually enable strict mode as your codebase becomes fully typed."
      },
      {
        "question": "Can I use this skill with existing untyped code?",
        "answer": "Yes. Type checkers can analyze mixed typed and untyped code. Use ignore_missing_imports for third-party libraries without stubs."
      },
      {
        "question": "Is my data safe when running type checkers?",
        "answer": "Type checkers only read and parse Python source files. They do not execute code or access network, environment variables, or credentials."
      },
      {
        "question": "Why do I get false positives with mypy or pyright?",
        "answer": "Install type stubs for third-party packages. Use # type: ignore comments sparingly. Enable reportMissingTypeStubs to find missing stubs."
      },
      {
        "question": "How does this compare to Pyre or other type checkers?",
        "answer": "mypy and pyright are the most widely used. Pyre is faster but requires Python 3.7+. This skill focuses on mypy and pyright as they have the best documentation and ecosystem support."
      }
    ]
  },
  "file_structure": [
    {
      "name": "assets",
      "type": "dir",
      "path": "assets",
      "children": [
        {
          "name": "pyproject-typing.toml",
          "type": "file",
          "path": "assets/pyproject-typing.toml"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "generics-advanced.md",
          "type": "file",
          "path": "references/generics-advanced.md"
        },
        {
          "name": "mypy-config.md",
          "type": "file",
          "path": "references/mypy-config.md"
        },
        {
          "name": "overloads.md",
          "type": "file",
          "path": "references/overloads.md"
        },
        {
          "name": "protocols-patterns.md",
          "type": "file",
          "path": "references/protocols-patterns.md"
        },
        {
          "name": "runtime-validation.md",
          "type": "file",
          "path": "references/runtime-validation.md"
        },
        {
          "name": "type-narrowing.md",
          "type": "file",
          "path": "references/type-narrowing.md"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "check-types.sh",
          "type": "file",
          "path": "scripts/check-types.sh"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
