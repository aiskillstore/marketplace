{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T10:37:28.389Z",
    "slug": "astrabit-cpt-repo-metadata",
    "source_url": "https://github.com/AstraBit-CPT/astrabit-docs/tree/master/.claude/skills/repo-metadata",
    "source_ref": "master",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "1f6ab4ba58aabecd038d5abe0081f1ce385101e6fa89b3784c146cda5a22df36",
    "tree_hash": "4ebab117ba43a3e36760d55a3499ee1b4feac65c8b150d62a88b7358ff36e96a"
  },
  "skill": {
    "name": "repo-metadata",
    "description": "This skill should be used when the user asks to \"generate repository metadata\", \"create catalog-info.yaml\", \"add repo metadata\", \"document repository structure\", or mentions generating structured metadata for service catalog or architecture documentation.",
    "summary": "This skill should be used when the user asks to \"generate repository metadata\", \"create catalog-info...",
    "icon": "ðŸ“‹",
    "version": "1.0.0",
    "author": "AstraBit-CPT",
    "license": "MIT",
    "category": "documentation",
    "tags": [
      "metadata",
      "catalog",
      "service",
      "architecture",
      "documentation"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a legitimate documentation generation skill that analyzes repositories to generate service catalog metadata. The Python script reads local files, parses code patterns, and outputs YAML metadata. No network calls, no credential access, no data exfiltration. Standard filesystem operations for documentation purposes.",
    "risk_factor_evidence": [
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "scripts/generate-metadata.py",
            "line_start": 1,
            "line_end": 483
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "scripts/generate-metadata.py",
            "line_start": 85,
            "line_end": 134
          },
          {
            "file": "scripts/generate-metadata.py",
            "line_start": 182,
            "line_end": 202
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 7,
    "total_lines": 1119,
    "audit_model": "claude",
    "audited_at": "2026-01-10T10:37:28.389Z"
  },
  "content": {
    "user_title": "Generate Service Catalog Metadata",
    "value_statement": "Service catalogs require standardized metadata to enable cross-repository architecture analysis and dependency mapping. This skill automatically generates catalog-info.yaml files by analyzing repository structure and code patterns.",
    "seo_keywords": [
      "repo metadata",
      "catalog-info",
      "service catalog",
      "Backstage",
      "architecture documentation",
      "component metadata",
      "repository documentation",
      "Claude Code",
      "Codex",
      "Claude"
    ],
    "actual_capabilities": [
      "Analyze repository structure to detect language, framework, and integrations",
      "Generate catalog-info.yaml following Backstage conventions",
      "Identify service types (gateway, service, worker, library, frontend, database)",
      "Detect dependencies from code patterns and import statements",
      "Scan for Kafka producers and consumers",
      "Extract description from README.md"
    ],
    "limitations": [
      "Requires access to repository files for analysis",
      "Cannot auto-detect domain and owner - requires user input",
      "May miss undocumented dependencies not present in code imports",
      "Service type detection is heuristic-based and may need manual review"
    ],
    "use_cases": [
      {
        "target_user": "Platform Engineers",
        "title": "Service Catalog Setup",
        "description": "Generate catalog-info.yaml files for all microservices in your organization"
      },
      {
        "target_user": "DevOps Teams",
        "title": "Architecture Documentation",
        "description": "Create standardized metadata for dependency graphs and architecture views"
      },
      {
        "target_user": "Documentation Specialists",
        "title": "Repository Onboarding",
        "description": "Automatically generate metadata for new repositories joining the service catalog"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Generation",
        "scenario": "Generate metadata for current repo",
        "prompt": "Generate repository metadata and create a catalog-info.yaml file for this repository"
      },
      {
        "title": "Specific Path",
        "scenario": "Analyze external repository",
        "prompt": "Generate catalog-info.yaml metadata for the repository at /path/to/repo"
      },
      {
        "title": "With Format",
        "scenario": "JSON output for inspection",
        "prompt": "Analyze this repository and output the catalog metadata in JSON format for review before writing the YAML file"
      },
      {
        "title": "Full Analysis",
        "scenario": "Complete architecture scan",
        "prompt": "Perform a full repository analysis including detecting all integration points, dependencies, event producers and consumers, then generate a complete catalog-info.yaml with all detected values"
      }
    ],
    "output_examples": [
      {
        "input": "Generate catalog-info.yaml for my user-service repository",
        "output": [
          "Generated catalog-info.yaml with detected values:",
          "â€¢ name: user-service (from package.json)",
          "â€¢ type: service (detected: has HTTP routes)",
          "â€¢ runtime: nodejs (from package.json)",
          "â€¢ framework: nestjs (from @nestjs/core dependency)",
          "â€¢ domain: user (detected from name pattern)",
          "â€¢ owner: backend-team (detected from name pattern)",
          "â€¢ dependsOn: auth-service, user-db",
          "â€¢ providesApis: User Service API (REST)",
          "â€¢ routes: /api/users/* â†’ this",
          "Please review and fill in: domain, owner"
        ]
      }
    ],
    "best_practices": [
      "Review auto-detected values for accuracy before committing",
      "Fill in domain and owner fields to enable proper team ownership",
      "Keep catalog-info.yaml in sync with actual service architecture",
      "Run generation after significant architecture changes"
    ],
    "anti_patterns": [
      "Using auto-detection without reviewing detected dependencies",
      "Leaving domain and owner as unknown values",
      "Generating once and never updating as architecture evolves",
      "Ignoring detected integration points that should be documented"
    ],
    "faq": [
      {
        "question": "What languages does this skill support?",
        "answer": "Node.js, Python, Go, Java, Rust, and Ruby. Detection is based on common package and build files."
      },
      {
        "question": "Can I use this with GitHub Actions workflows?",
        "answer": "Yes. The skill can generate metadata that syncs with GitHub Actions for consistent repository information."
      },
      {
        "question": "What service types can it detect?",
        "answer": "gateway, service, worker, library, frontend, and database. Detection is based on code patterns like routes, consumers, and API definitions."
      },
      {
        "question": "Is my repository data safe?",
        "answer": "Yes. The skill only reads files within the repository and outputs metadata. No data is sent anywhere."
      },
      {
        "question": "Why are domain and owner unknown?",
        "answer": "These require organizational knowledge that cannot be auto-detected. The skill marks them for manual input."
      },
      {
        "question": "How accurate is dependency detection?",
        "answer": "Detection finds dependencies through code imports and patterns. Undocumented or dynamically loaded dependencies may be missed."
      }
    ]
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "catalog-info-gateway.yaml",
          "type": "file",
          "path": "examples/catalog-info-gateway.yaml"
        },
        {
          "name": "catalog-info-library.yaml",
          "type": "file",
          "path": "examples/catalog-info-library.yaml"
        },
        {
          "name": "catalog-info-template.yaml",
          "type": "file",
          "path": "examples/catalog-info-template.yaml"
        },
        {
          "name": "catalog-info-worker.yaml",
          "type": "file",
          "path": "examples/catalog-info-worker.yaml"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "schema.md",
          "type": "file",
          "path": "references/schema.md"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "generate-metadata.py",
          "type": "file",
          "path": "scripts/generate-metadata.py"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
