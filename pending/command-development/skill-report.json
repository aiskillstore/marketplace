{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2025-12-30T14:25:28.024Z",
    "slug": "command-development",
    "source_url": "https://github.com/anthropics/claude-code/tree/main/plugins/plugin-dev/skills/command-development",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "trust_level": "official"
  },
  "skill": {
    "name": "Command Development",
    "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
    "summary": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a ...",
    "icon": "⚡",
    "version": "0.2.0",
    "author": "Anthropic",
    "license": "Not specified",
    "category": "development",
    "tags": [
      "claude-code",
      "commands",
      "automation",
      "workflow",
      "slash-commands",
      "yaml",
      "frontmatter",
      "plugin-development",
      "developer-tools"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is an official Anthropic skill for Claude Code command development. Contains comprehensive documentation and examples for creating slash commands. No malicious code detected - purely instructional content.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 11,
    "total_lines": 7237,
    "audit_model": "claude",
    "audited_at": "2025-12-30T14:25:28.023Z"
  },
  "content": {
    "user_title": "Claude Code Command Development Guide",
    "value_statement": "Learn to create powerful, reusable slash commands for Claude Code with YAML frontmatter, dynamic arguments, file references, bash execution, and interactive user prompts.",
    "seo_keywords": [
      "claude code commands",
      "slash commands",
      "command development",
      "yaml frontmatter",
      "dynamic arguments",
      "bash execution",
      "plugin development",
      "workflow automation",
      "interactive commands",
      "claude code plugins"
    ],
    "actual_capabilities": [
      "Create slash commands with Markdown and YAML frontmatter",
      "Use dynamic arguments ($ARGUMENTS, $1, $2, etc.) for parameterized commands",
      "Reference files with @ syntax to include file contents",
      "Execute bash commands inline with !` syntax for dynamic context",
      "Configure tool access, model selection, and argument hints",
      "Organize commands with namespaces and subdirectories",
      "Create plugin-specific commands using ${CLAUDE_PLUGIN_ROOT}",
      "Build interactive commands with AskUserQuestion for multi-step workflows",
      "Integrate commands with plugin agents, skills, and hooks",
      "Implement validation patterns for arguments and resources",
      "Design multi-stage workflows with state management",
      "Create marketplace-ready commands with proper documentation"
    ],
    "limitations": [
      "Commands are Markdown files that must follow specific format conventions",
      "Bash execution requires explicit tool permissions in allowed-tools",
      "File references are limited by Claude's context window size",
      "Commands cannot modify their own definition at runtime",
      "Plugin-specific features only work within plugin context",
      "No built-in testing framework - testing is primarily manual"
    ],
    "use_cases": [
      {
        "title": "Code Review Automation",
        "description": "Create commands that automatically review code for security issues, style consistency, and best practices using bash execution to gather git diffs and file references to analyze specific files.",
        "target_user": "Development teams wanting consistent code review standards"
      },
      {
        "title": "Deployment Workflows",
        "description": "Build multi-step deployment commands that validate environment configs, execute deployment scripts from plugins, and coordinate with hooks for safety checks.",
        "target_user": "DevOps engineers managing deployment pipelines"
      },
      {
        "title": "Documentation Generation",
        "description": "Generate standardized documentation using plugin templates and file references to analyze source code and create API docs, README files, or component documentation.",
        "target_user": "Technical writers and developers maintaining documentation"
      },
      {
        "title": "Interactive Project Setup",
        "description": "Create wizard-style commands using AskUserQuestion to guide users through project configuration, technology selection, and initial scaffolding with validation.",
        "target_user": "Developers starting new projects or configuring tools"
      },
      {
        "title": "Testing Workflows",
        "description": "Automate test execution with commands that run specific test files, analyze failures, and generate coverage reports using bash execution and result parsing.",
        "target_user": "QA engineers and developers running tests frequently"
      },
      {
        "title": "Plugin Development",
        "description": "Build plugin-specific commands that leverage ${CLAUDE_PLUGIN_ROOT} to access scripts, templates, and configs, integrating with plugin agents and skills.",
        "target_user": "Plugin authors creating reusable command libraries"
      }
    ],
    "prompt_templates": [
      {
        "title": "Create a Basic Code Review Command",
        "prompt": "Create a slash command called /review that analyzes the current git diff for security issues, code quality, and best practices. The command should use bash execution to get the diff and provide specific line-by-line feedback.",
        "scenario": "When you need a reusable command for PR reviews"
      },
      {
        "title": "Build a Deployment Command with Arguments",
        "prompt": "Create a /deploy command that takes two arguments: [environment] and [version]. It should validate the environment is one of dev/staging/prod, reference a config file at .claude/deploy-${environment}.json, and execute deployment steps.",
        "scenario": "When you need parameterized deployment workflows"
      },
      {
        "title": "Create an Interactive Setup Wizard",
        "prompt": "Create a /setup command that uses AskUserQuestion to gather: 1) Project type (React/Vue/Svelte), 2) Testing framework based on project type, 3) Features to enable (multiselect for linting, type checking, CI/CD). Generate appropriate config files based on selections.",
        "scenario": "When you need user input to customize command behavior"
      },
      {
        "title": "Build a Plugin Command with Templates",
        "prompt": "Create a plugin command /generate-docs that uses ${CLAUDE_PLUGIN_ROOT}/templates/api-docs.md as a template and generates API documentation for a file passed as an argument. Include validation that the template exists.",
        "scenario": "When creating commands for plugin distribution"
      },
      {
        "title": "Create a Multi-Step Workflow Command",
        "prompt": "Create a /release command that: 1) Runs tests with bash, 2) Validates version number argument, 3) Builds the project, 4) Creates git tag, 5) Generates changelog. Include error handling at each step.",
        "scenario": "When orchestrating complex multi-step processes"
      }
    ],
    "output_examples": [
      {
        "input": "User runs: /review",
        "output": "Command executes 'git diff' via bash, analyzes the changes, and provides structured feedback like:\n\n**Security Issues Found:**\n- Line 45 in users.ts: SQL injection risk - user input not sanitized\n- Line 67 in api.ts: Missing authentication check\n\n**Code Quality:**\n- Line 23: Consider extracting this logic into a separate function\n- Line 89: Variable naming could be more descriptive\n\n**Best Practices:**\n- Add error handling for async operations\n- Include JSDoc comments for public functions"
      },
      {
        "input": "User runs: /deploy staging v1.2.3",
        "output": "Command validates arguments, loads .claude/deploy-staging.json, and executes:\n\n**Deployment to Staging**\nVersion: v1.2.3\nEnvironment: staging\n\nPre-deployment checks:\n✓ Configuration valid\n✓ Version tag exists\n✓ Tests passing\n\nDeploying...\n✓ Build successful\n✓ Deployment complete\n✓ Health checks passed\n\nNext steps:\n- Monitor logs: /logs staging\n- Run smoke tests: /smoke-test staging"
      },
      {
        "input": "User runs: /setup (interactive command)",
        "output": "Command prompts with AskUserQuestion:\n\nQuestion 1: Which project type?\n- React (Component-based UI library)\n- Vue (Progressive framework)\n- Svelte (Compiled framework)\n\n[User selects React]\n\nQuestion 2: Which testing framework?\n- Jest (React recommended)\n- Vitest (Fast alternative)\n\n[User selects Jest]\n\nQuestion 3: Enable features? (multi-select)\n- ESLint\n- TypeScript\n- CI/CD\n\n[User selects ESLint and TypeScript]\n\nGenerating configuration...\n✓ Created package.json with React + Jest\n✓ Created .eslintrc.json\n✓ Created tsconfig.json\n✓ Created README.md\n\nSetup complete! Run 'npm install' to get started."
      }
    ],
    "best_practices": [
      "Write commands as instructions FOR Claude, not messages TO users (imperative/infinitive form)",
      "Use single responsibility - one command should do one thing well",
      "Always provide clear descriptions (under 60 chars) for discoverability in /help",
      "Document arguments with argument-hint to improve user experience",
      "Use most restrictive allowed-tools that works (e.g., Bash(git:*) not Bash(*))",
      "Validate inputs early - check for required arguments and file existence",
      "Handle errors gracefully with helpful messages and recovery suggestions",
      "Use ${CLAUDE_PLUGIN_ROOT} for all plugin-internal paths for portability",
      "Keep bash commands fast - long execution slows command invocation",
      "Organize commands with namespaces when you have 15+ commands",
      "Test commands across different environments before distribution",
      "Include usage examples and requirements in command comments",
      "Use haiku model for simple/fast commands, opus for complex analysis",
      "Prefer editing existing commands over creating new ones",
      "Document integration with plugin agents, skills, and hooks"
    ],
    "anti_patterns": [
      "Writing commands as user-facing messages instead of Claude instructions",
      "Using hardcoded absolute paths instead of ${CLAUDE_PLUGIN_ROOT} in plugins",
      "Allowing unrestricted bash access (Bash(*)) when specific commands suffice",
      "Creating overly generic command names that conflict (e.g., /test, /run)",
      "Missing argument validation leading to cryptic errors",
      "Using relative paths like ./file instead of @ syntax for file references",
      "Creating separate commands for minor variations instead of using arguments",
      "Omitting descriptions making commands hard to discover in /help",
      "Long-running bash commands that block command execution",
      "Not handling missing arguments or files gracefully",
      "Forgetting to document required dependencies or setup",
      "Using disable-model-invocation unnecessarily, limiting automation",
      "Creating commands without testing on different platforms",
      "Mixing user messaging with Claude instructions in command content"
    ],
    "faq": [
      {
        "question": "What's the difference between $ARGUMENTS and $1, $2, $3?",
        "answer": "$ARGUMENTS captures all arguments as a single string, while $1, $2, $3 capture individual positional arguments. Use $ARGUMENTS for simple commands with one logical input. Use positional arguments when you need to handle multiple distinct parameters separately (e.g., environment, version, options)."
      },
      {
        "question": "When should I use the @ syntax vs Read tool?",
        "answer": "Use @ syntax in commands for static file references that get loaded before Claude processes the command. The @ syntax is shorthand that makes commands more concise. Both approaches work, but @ is preferred for readability in command definitions."
      },
      {
        "question": "How do I make bash commands work in my command?",
        "answer": "Add allowed-tools: Bash(command:*) to your frontmatter, where 'command' is the specific command you want to allow (e.g., git, npm, docker). Use the !`command here` syntax in your command content. The output will be included in the prompt Claude receives."
      },
      {
        "question": "What's ${CLAUDE_PLUGIN_ROOT} and when do I need it?",
        "answer": "${CLAUDE_PLUGIN_ROOT} is an environment variable that resolves to your plugin's absolute path. Use it in plugin commands to reference scripts, templates, configs, or other plugin files. It ensures portability across different installations. Example: !`node ${CLAUDE_PLUGIN_ROOT}/scripts/analyze.js`"
      },
      {
        "question": "Can I create interactive commands that ask users questions?",
        "answer": "Yes! Include instructions in your command to use the AskUserQuestion tool. Define questions with options, headers, and whether to allow multi-select. This is perfect for setup wizards, configuration builders, or any workflow requiring user input during execution."
      },
      {
        "question": "How do I organize commands when I have many of them?",
        "answer": "Use subdirectories in .claude/commands/ to create namespaces. For example, commands/ci/build.md becomes /build (project:ci). This groups related commands logically and makes them easier to discover. Use flat structure for <15 commands, namespaces for 15+."
      },
      {
        "question": "What's the difference between project, personal, and plugin commands?",
        "answer": "Project commands (.claude/commands/) are shared with your team via git. Personal commands (~/.claude/commands/) are available only to you across all projects. Plugin commands (plugin-name/commands/) are bundled with plugins and distributed together."
      },
      {
        "question": "Should I validate arguments in my commands?",
        "answer": "Yes, always validate required arguments and provide helpful error messages. Use bash to check argument validity (e.g., !`echo \"$1\" | grep -E \"^(dev|staging|prod)$\"`), verify files exist before processing them, and explain expected values when validation fails."
      },
      {
        "question": "How do I test commands before distributing them?",
        "answer": "Test manually by invoking with various arguments, edge cases (missing args, invalid values), and on different platforms. Create validation scripts to check YAML syntax and frontmatter fields. Have others test before wide release. See references/testing-strategies.md for comprehensive testing approaches."
      },
      {
        "question": "Can commands launch agents or use skills from plugins?",
        "answer": "Yes! Commands can instruct Claude to launch plugin agents using the Task tool for complex workflows. Reference plugin skills by name to leverage specialized knowledge. Commands can also coordinate with plugin hooks that execute automatically on events."
      }
    ],
    "technical_requirements": {
      "dependencies": [
        "Claude Code CLI",
        "Markdown file support",
        "YAML frontmatter parser",
        "Bash (for commands using bash execution)",
        "Git (for commands using git operations)"
      ],
      "permissions": [
        "File system read access for command discovery",
        "Write access to .claude/commands/ for project commands",
        "Bash execution permissions (when specified in allowed-tools)",
        "Read tool access (for @ file references)"
      ],
      "complexity": "intermediate"
    }
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "plugin-commands.md",
          "type": "file",
          "path": "examples/plugin-commands.md"
        },
        {
          "name": "simple-commands.md",
          "type": "file",
          "path": "examples/simple-commands.md"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "advanced-workflows.md",
          "type": "file",
          "path": "references/advanced-workflows.md"
        },
        {
          "name": "documentation-patterns.md",
          "type": "file",
          "path": "references/documentation-patterns.md"
        },
        {
          "name": "frontmatter-reference.md",
          "type": "file",
          "path": "references/frontmatter-reference.md"
        },
        {
          "name": "interactive-commands.md",
          "type": "file",
          "path": "references/interactive-commands.md"
        },
        {
          "name": "marketplace-considerations.md",
          "type": "file",
          "path": "references/marketplace-considerations.md"
        },
        {
          "name": "plugin-features-reference.md",
          "type": "file",
          "path": "references/plugin-features-reference.md"
        },
        {
          "name": "testing-strategies.md",
          "type": "file",
          "path": "references/testing-strategies.md"
        }
      ]
    },
    {
      "name": "README.md",
      "type": "file",
      "path": "README.md"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}