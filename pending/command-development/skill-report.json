{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2025-12-30T09:23:34.810Z",
    "slug": "command-development",
    "source_url": "https://github.com/anthropics/claude-code/tree/main/plugins/plugin-dev/skills/command-development",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "trust_level": "official"
  },
  "skill": {
    "name": "Command Development",
    "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
    "summary": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a ...",
    "icon": "⚙️",
    "version": "0.2.0",
    "author": "Anthropic",
    "license": "Not specified",
    "category": "development",
    "tags": [
      "slash-commands",
      "workflows",
      "automation",
      "claude-code",
      "plugins",
      "templates",
      "yaml",
      "markdown"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Official Anthropic skill for command development. No malicious code detected. Contains educational examples of bash execution and file operations with proper security guidance.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 11,
    "total_lines": 7237,
    "audit_model": "claude",
    "audited_at": "2025-12-30T09:23:34.809Z"
  },
  "content": {
    "user_title": "Slash Command Developer",
    "value_statement": "Master the art of creating powerful, reusable slash commands for Claude Code with comprehensive guides, patterns, and best practices for everything from simple prompts to complex multi-step workflows.",
    "seo_keywords": [
      "slash commands",
      "claude code",
      "command development",
      "yaml frontmatter",
      "workflow automation",
      "plugin development",
      "markdown commands",
      "bash execution",
      "interactive commands",
      "command templates"
    ],
    "actual_capabilities": [
      "Create slash commands with YAML frontmatter configuration",
      "Implement dynamic arguments using $1, $2, $ARGUMENTS syntax",
      "Reference files using @ syntax to include content",
      "Execute bash commands inline with !` syntax for dynamic context",
      "Organize commands with namespacing and subdirectories",
      "Design interactive commands using AskUserQuestion tool",
      "Build plugin commands with CLAUDE_PLUGIN_ROOT variable",
      "Integrate commands with plugin agents, skills, and hooks",
      "Implement validation patterns for arguments and resources",
      "Create multi-step workflows with state management",
      "Design commands for marketplace distribution",
      "Test commands comprehensively with automated strategies"
    ],
    "limitations": [
      "Commands are for Claude Code only, not compatible with other AI tools",
      "Bash execution requires allowed-tools permission and command filters",
      "File references limited by Claude's context window size",
      "Interactive questions limited to 1-4 questions with 2-4 options each",
      "Plugin commands require plugin installation to be accessible",
      "No built-in command versioning or automatic update mechanism",
      "Testing requires manual invocation for full workflow validation"
    ],
    "use_cases": [
      {
        "title": "Code Review Automation",
        "description": "Create commands that automatically review code for security vulnerabilities, quality issues, and best practices using bash execution and file references",
        "target_user": "Development teams wanting consistent code review standards"
      },
      {
        "title": "Deployment Workflows",
        "description": "Build multi-step deployment commands with environment-specific configurations, validation checks, and rollback capabilities",
        "target_user": "DevOps engineers automating deployment processes"
      },
      {
        "title": "Documentation Generation",
        "description": "Generate standardized documentation using plugin templates and source code analysis",
        "target_user": "Technical writers and developers maintaining documentation"
      },
      {
        "title": "Interactive Setup Wizards",
        "description": "Create guided setup experiences using AskUserQuestion for complex configuration tasks",
        "target_user": "Plugin authors providing user-friendly onboarding"
      },
      {
        "title": "Testing Orchestration",
        "description": "Coordinate test execution, result analysis, and failure reporting with integrated bash commands",
        "target_user": "QA engineers and developers running test suites"
      },
      {
        "title": "Plugin Development",
        "description": "Build distributable plugin commands with portable paths, resource validation, and multi-component integration",
        "target_user": "Plugin developers creating marketplace-ready tools"
      }
    ],
    "prompt_templates": [
      {
        "title": "Create a simple code review command",
        "prompt": "Create a slash command called 'review' that analyzes code for security issues and best practices",
        "scenario": "When you need a basic command without arguments or complex features"
      },
      {
        "title": "Build a deployment command with arguments",
        "prompt": "Create a deployment command that takes environment and version as arguments, validates them, and deploys using bash scripts",
        "scenario": "When you need parameterized commands with validation"
      },
      {
        "title": "Design an interactive setup command",
        "prompt": "Create an interactive command that uses AskUserQuestion to gather deployment platform, environment count, and feature selections, then generates configuration",
        "scenario": "When users need guided configuration with multiple choices"
      },
      {
        "title": "Create a plugin command with templates",
        "prompt": "Create a plugin command that uses CLAUDE_PLUGIN_ROOT to load a template and generate documentation for a given source file",
        "scenario": "When building plugin commands that reference plugin resources"
      },
      {
        "title": "Build a multi-step workflow command",
        "prompt": "Create a command that orchestrates build, test, and deployment steps with state management and rollback capability",
        "scenario": "When you need complex workflows with multiple phases"
      }
    ],
    "output_examples": [
      {
        "input": "User asks: 'Create a command to review PRs'",
        "output": "I'll create a PR review command at .claude/commands/review-pr.md with:\n\n---\ndescription: Review pull request for code quality\nargument-hint: [pr-number]\nallowed-tools: Bash(gh:*), Read\n---\n\nPR details: !`gh pr view $1`\nFiles changed: !`gh pr diff $1 --name-only`\n\nReview each file for:\n1. Code quality and style\n2. Security issues\n3. Test coverage\n4. Documentation\n\nProvide specific feedback with file and line references."
      },
      {
        "input": "User asks: 'How do I use arguments in commands?'",
        "output": "You can use arguments in commands three ways:\n\n1. $ARGUMENTS - captures all arguments as one string\n2. $1, $2, $3... - captures individual positional arguments\n3. Combined - mix positional and remaining args\n\nExample with argument-hint:\n---\nargument-hint: [env] [version]\n---\nDeploy $1 to version $2\n\nUsage: /deploy staging v1.2.3"
      }
    ],
    "best_practices": [
      "Write commands as instructions FOR Claude, not messages TO users (use imperative voice)",
      "Always use argument-hint to document expected arguments",
      "Keep descriptions under 60 characters for clean /help display",
      "Use most restrictive allowed-tools setting (e.g., Bash(git:*) not Bash(*))",
      "Validate arguments and file existence early in commands",
      "Use ${CLAUDE_PLUGIN_ROOT} for all plugin-internal paths",
      "Provide helpful error messages with troubleshooting steps",
      "Test commands with edge cases (missing args, invalid inputs, special characters)",
      "Document complex commands with inline comments explaining sections",
      "Use namespacing (subdirectories) when you have 15+ commands",
      "Choose appropriate model: haiku for speed, sonnet for standard, opus for complexity",
      "Handle bash command failures gracefully with error messages",
      "Keep bash commands fast to avoid slowing command invocation",
      "Design for distribution: no hardcoded paths, check dependencies, cross-platform compatible"
    ],
    "anti_patterns": [
      "Writing commands as user-facing messages instead of Claude instructions",
      "Using relative paths like ./scripts instead of ${CLAUDE_PLUGIN_ROOT}/scripts in plugins",
      "Omitting argument-hint when commands accept arguments",
      "Using Bash(*) wildcard instead of specific command filters like Bash(git:*)",
      "Creating overly long descriptions (>80 chars) that clutter /help output",
      "Not validating required arguments, leading to confusing error messages",
      "Hardcoding file paths that won't work across different installations",
      "Using vague descriptions like 'Do the thing' instead of action-oriented ones",
      "Creating generic command names like /test or /run that conflict with common names",
      "Running long-running bash commands that slow down command invocation",
      "Not handling missing files or invalid inputs gracefully",
      "Forgetting to document plugin file structure and dependencies",
      "Using allowed-tools: '*' when only specific tools are needed",
      "Not testing commands with edge cases before distribution"
    ],
    "faq": [
      {
        "question": "What's the difference between project and personal commands?",
        "answer": "Project commands live in .claude/commands/ and are shared with your team via git. Personal commands live in ~/.claude/commands/ and are available across all your projects but only for you."
      },
      {
        "question": "How do I use bash commands in my slash command?",
        "answer": "Use the !`command` syntax and add Bash(command:*) to allowed-tools. Example: !`git status` with allowed-tools: Bash(git:*). The command output is included in the prompt Claude processes."
      },
      {
        "question": "Can I reference multiple files in a command?",
        "answer": "Yes, use @ syntax multiple times. Example: 'Compare @file1.js with @file2.js' will load both files into context before Claude processes the command."
      },
      {
        "question": "What is ${CLAUDE_PLUGIN_ROOT} and when do I use it?",
        "answer": "It's an environment variable in plugin commands that resolves to the plugin's absolute path. Use it for all plugin-internal paths: scripts, configs, templates. Example: !`node ${CLAUDE_PLUGIN_ROOT}/scripts/analyze.js`"
      },
      {
        "question": "How do I create interactive commands that ask users questions?",
        "answer": "Instruct Claude to use the AskUserQuestion tool within your command prompt. Provide 1-4 questions with 2-4 options each. Users can select answers or choose 'Other' for custom input."
      },
      {
        "question": "Which model should I specify in frontmatter?",
        "answer": "Use haiku for fast, simple commands; sonnet for standard workflows (default); opus for complex analysis requiring deep understanding. Omit the model field to inherit from conversation."
      },
      {
        "question": "How do I organize commands when I have many of them?",
        "answer": "Use subdirectories for namespacing when you have 15+ commands. Example: commands/ci/build.md becomes /build (project:ci). Group related commands logically."
      },
      {
        "question": "Can commands launch agents or use skills?",
        "answer": "Yes! Commands can instruct Claude to launch plugin agents using the Task tool, or reference plugin skills by name to trigger their invocation. Document what the agent/skill will do."
      },
      {
        "question": "How do I test commands before distributing them?",
        "answer": "Test at multiple levels: validate YAML syntax, test argument substitution, verify bash execution, check file references, test edge cases (missing args, invalid inputs), and have others beta test for UX."
      },
      {
        "question": "What's the difference between $ARGUMENTS and $1, $2, $3?",
        "answer": "$ARGUMENTS captures all arguments as a single string. $1, $2, $3 capture individual positional arguments. Use $ARGUMENTS for simple commands, positional for structured multi-argument commands."
      }
    ],
    "technical_requirements": {
      "dependencies": [
        "Claude Code installation",
        "Markdown file support",
        "YAML parser for frontmatter",
        "Bash for command execution (if using !` syntax)",
        "Git (for project commands in version control)"
      ],
      "permissions": [
        "File system access to .claude/commands/ or ~/.claude/commands/",
        "Tool permissions defined in allowed-tools frontmatter field",
        "Bash execution permissions for specific command filters",
        "Read permissions for @ file references"
      ],
      "complexity": "intermediate"
    }
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "plugin-commands.md",
          "type": "file",
          "path": "examples/plugin-commands.md"
        },
        {
          "name": "simple-commands.md",
          "type": "file",
          "path": "examples/simple-commands.md"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "advanced-workflows.md",
          "type": "file",
          "path": "references/advanced-workflows.md"
        },
        {
          "name": "documentation-patterns.md",
          "type": "file",
          "path": "references/documentation-patterns.md"
        },
        {
          "name": "frontmatter-reference.md",
          "type": "file",
          "path": "references/frontmatter-reference.md"
        },
        {
          "name": "interactive-commands.md",
          "type": "file",
          "path": "references/interactive-commands.md"
        },
        {
          "name": "marketplace-considerations.md",
          "type": "file",
          "path": "references/marketplace-considerations.md"
        },
        {
          "name": "plugin-features-reference.md",
          "type": "file",
          "path": "references/plugin-features-reference.md"
        },
        {
          "name": "testing-strategies.md",
          "type": "file",
          "path": "references/testing-strategies.md"
        }
      ]
    },
    {
      "name": "README.md",
      "type": "file",
      "path": "README.md"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}