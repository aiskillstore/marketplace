{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-09T14:57:47.783Z",
    "slug": "hook-development",
    "source_url": "https://github.com/anthropics/claude-code/tree/main/plugins/plugin-dev/skills/hook-development",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "official",
    "content_hash": "271528377492e4c5d328c9851785c52bb6efefdbf17e89fe5be16c12fa4adea0",
    "tree_hash": "ceb76ed5cfd6d14d2a8a3fb632a6bd09f92999822672f3230329e03bfebbc583"
  },
  "skill": {
    "name": "Hook Development",
    "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
    "summary": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop ...",
    "icon": "ü™ù",
    "version": "0.1.0",
    "author": "anthropics",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "hooks",
      "plugin-development",
      "automation",
      "validation",
      "security"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Official Anthropic skill containing documentation and example scripts for Claude Code hook development. No execution of external commands, network operations, or file system modifications. Educational content only.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 8,
    "total_lines": 2214,
    "audit_model": "claude",
    "audited_at": "2026-01-09T14:57:47.782Z"
  },
  "content": {
    "user_title": "Create hooks for Claude Code automation",
    "value_statement": "Hooks enable event-driven automation in Claude Code plugins. Use hooks to validate tool calls, enforce completion standards, load project context, and integrate external tools into workflows. The skill covers both prompt-based hooks for intelligent decisions and command hooks for deterministic checks.",
    "seo_keywords": [
      "Claude Code hooks",
      "PreToolUse hook",
      "PostToolUse hook",
      "Stop hook",
      "plugin automation",
      "prompt-based hooks",
      "event-driven automation",
      "hook development",
      "Claude",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Create PreToolUse hooks to validate and modify tool calls before execution",
      "Implement PostToolUse hooks to react to tool results and provide feedback",
      "Build Stop hooks to verify task completion before agent stops",
      "Configure SessionStart hooks to load project context automatically",
      "Use prompt-based hooks for intelligent context-aware decisions",
      "Write command hooks for fast deterministic validation checks"
    ],
    "limitations": [
      "Hooks cannot be hot-swapped during a session. Changes require restarting Claude Code.",
      "Hooks run in parallel, so they cannot rely on execution order or share state directly.",
      "Prompt-based hooks require additional processing time for LLM inference."
    ],
    "use_cases": [
      {
        "target_user": "Plugin developers",
        "title": "Build security validation hooks",
        "description": "Create hooks that block dangerous file writes, validate bash commands, and detect secrets before operations execute."
      },
      {
        "target_user": "Team leads",
        "title": "Enforce completion standards",
        "description": "Set up Stop hooks that require tests to run and builds to succeed before allowing the agent to complete tasks."
      },
      {
        "target_user": "DevOps engineers",
        "title": "Automate context loading",
        "description": "Configure SessionStart hooks to detect project type, set environment variables, and load configuration automatically."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic validation",
        "scenario": "Validate file writes",
        "prompt": "File path: $TOOL_INPUT.file_path. Check: not in system directories, not credentials, no path traversal. Return 'approve' or 'deny'."
      },
      {
        "title": "Command safety check",
        "scenario": "Analyze bash commands",
        "prompt": "Command: $TOOL_INPUT.command. Look for destructive operations, privilege escalation, or unauthorized network access. Return 'approve', 'ask', or 'deny'."
      },
      {
        "title": "Task completion check",
        "scenario": "Verify all work complete",
        "prompt": "Review the transcript. Were tests run after code changes? Did the build succeed? Are all user questions answered? Return 'approve' or 'block' with reason."
      },
      {
        "title": "Context-aware review",
        "scenario": "Check full session state",
        "prompt": "Read the transcript at $TRANSCRIPT_PATH. Evaluate: test coverage, build status, code quality, question completion. Return detailed assessment."
      }
    ],
    "output_examples": [
      {
        "input": "Create a hook that validates before Claude writes any files",
        "output": [
          "Hook configuration for PreToolUse event",
          "Matcher: Write|Edit tools",
          "Type: prompt-based hook",
          "Validation checks: system paths, credentials, path traversal",
          "Output: permissionDecision (allow/deny/ask), systemMessage"
        ]
      }
    ],
    "best_practices": [
      "Use prompt-based hooks for complex logic that benefits from LLM reasoning.",
      "Set appropriate timeouts: 30 seconds for prompt hooks, 60 seconds for command hooks.",
      "Validate all input in command hooks to prevent injection vulnerabilities."
    ],
    "anti_patterns": [
      "Hardcoding paths instead of using ${CLAUDE_PLUGIN_ROOT} for portability.",
      "Relying on hook execution order since hooks run in parallel.",
      "Creating long-running hooks that timeout and block the workflow."
    ],
    "faq": [
      {
        "question": "Which hook types does Claude Code support?",
        "answer": "PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, and Notification."
      },
      {
        "question": "What is the difference between prompt and command hooks?",
        "answer": "Prompt hooks use LLM for context-aware decisions. Command hooks run bash scripts for fast deterministic checks."
      },
      {
        "question": "Can hooks share state between events?",
        "answer": "Only through temporary files. Hooks run in parallel so sequential events cannot rely on order."
      },
      {
        "question": "Are hooks safe to use?",
        "answer": "Yes when properly configured. Always validate input, quote variables, and set appropriate timeouts."
      },
      {
        "question": "Why is my hook not executing?",
        "answer": "Check script has shebang, is executable, and uses correct paths with ${CLAUDE_PLUGIN_ROOT}. Restart Claude Code after changes."
      },
      {
        "question": "When should I use command hooks over prompt hooks?",
        "answer": "Use command hooks for fast deterministic checks, external tool integration, or mathematical validations. Use prompt hooks for complex reasoning."
      }
    ]
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "load-context.sh",
          "type": "file",
          "path": "examples/load-context.sh"
        },
        {
          "name": "validate-bash.sh",
          "type": "file",
          "path": "examples/validate-bash.sh"
        },
        {
          "name": "validate-write.sh",
          "type": "file",
          "path": "examples/validate-write.sh"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "advanced.md",
          "type": "file",
          "path": "references/advanced.md"
        },
        {
          "name": "migration.md",
          "type": "file",
          "path": "references/migration.md"
        },
        {
          "name": "patterns.md",
          "type": "file",
          "path": "references/patterns.md"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "hook-linter.sh",
          "type": "file",
          "path": "scripts/hook-linter.sh"
        },
        {
          "name": "README.md",
          "type": "file",
          "path": "scripts/README.md"
        },
        {
          "name": "test-hook.sh",
          "type": "file",
          "path": "scripts/test-hook.sh"
        },
        {
          "name": "validate-hook-schema.sh",
          "type": "file",
          "path": "scripts/validate-hook-schema.sh"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
