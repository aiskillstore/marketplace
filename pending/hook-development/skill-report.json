{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2025-12-30T09:25:32.623Z",
    "slug": "hook-development",
    "source_url": "https://github.com/anthropics/claude-code/tree/main/plugins/plugin-dev/skills/hook-development",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "trust_level": "official"
  },
  "skill": {
    "name": "Hook Development",
    "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
    "summary": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop ...",
    "icon": "ü™ù",
    "version": "0.1.0",
    "author": "Anthropic",
    "license": "Not specified",
    "category": "development",
    "tags": [
      "hooks",
      "automation",
      "validation",
      "security",
      "plugins",
      "claude-code",
      "event-driven",
      "workflow"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Official Anthropic skill focused on hook development for Claude Code plugins. All example scripts follow security best practices including input validation, path sanitization, and proper quoting. Educational content promoting secure development patterns.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 11,
    "total_lines": 2781,
    "audit_model": "claude",
    "audited_at": "2025-12-30T09:25:32.622Z"
  },
  "content": {
    "user_title": "Hook Development for Claude Code Plugins",
    "value_statement": "Enable event-driven automation in Claude Code by creating hooks that validate operations, enforce policies, load context, and integrate external tools into your development workflow.",
    "seo_keywords": [
      "claude code hooks",
      "plugin hooks",
      "pretooluse hooks",
      "posttooluse hooks",
      "validation hooks",
      "event-driven automation",
      "prompt-based hooks",
      "bash hooks",
      "claude plugins"
    ],
    "actual_capabilities": [
      "Create PreToolUse hooks to validate tool calls before execution",
      "Implement PostToolUse hooks to react to tool results and provide feedback",
      "Build Stop/SubagentStop hooks to enforce completion standards",
      "Design SessionStart hooks to load project context automatically",
      "Develop prompt-based hooks using LLM reasoning for context-aware decisions",
      "Write command hooks for deterministic validation and external tool integration",
      "Configure matchers for tool names using exact match, regex, or wildcards",
      "Validate hook configurations with provided utility scripts",
      "Test hooks before deployment using sample inputs",
      "Implement security validation for file writes and bash commands",
      "Create temporarily active hooks with flag files or configuration"
    ],
    "limitations": [
      "Hooks load at session start and require Claude Code restart to update",
      "Cannot hot-swap hooks during an active session",
      "Hooks run in parallel with non-deterministic ordering",
      "Prompt-based hooks only fully supported on Stop, SubagentStop, UserPromptSubmit, and PreToolUse events",
      "Maximum timeout of 600 seconds per hook",
      "Hooks cannot see each other's output due to parallel execution"
    ],
    "use_cases": [
      {
        "title": "Security Validation",
        "description": "Prevent dangerous file writes and bash commands by validating paths, checking for path traversal, and blocking system directory modifications",
        "target_user": "Security-conscious developers and teams requiring policy enforcement"
      },
      {
        "title": "Test Enforcement",
        "description": "Ensure tests are run before stopping work by checking transcript for test execution after code modifications",
        "target_user": "Development teams enforcing quality standards and CI/CD practices"
      },
      {
        "title": "Project Context Loading",
        "description": "Automatically detect project type (Node.js, Rust, Go, Python, etc.) at session start and set environment variables for Claude",
        "target_user": "Developers working across multiple project types and languages"
      },
      {
        "title": "MCP Tool Monitoring",
        "description": "Monitor and validate MCP tool usage, especially destructive operations like deletions, with user confirmation",
        "target_user": "Teams using MCP integrations requiring safeguards"
      },
      {
        "title": "Build Verification",
        "description": "Verify project builds successfully after code changes before allowing session to stop",
        "target_user": "Teams wanting to catch build errors early in development workflow"
      },
      {
        "title": "Code Quality Checks",
        "description": "Run linters, formatters, and quality checks automatically after file edits",
        "target_user": "Teams enforcing code quality standards across repositories"
      }
    ],
    "prompt_templates": [
      {
        "title": "File Write Validation",
        "prompt": "Create a PreToolUse hook that validates Write and Edit operations to prevent writing to system directories (/etc, /sys), credential files (.env, secrets), and paths with traversal patterns (..)",
        "scenario": "When you need to protect against dangerous file operations"
      },
      {
        "title": "Test Enforcement Hook",
        "prompt": "Create a Stop hook that checks the transcript to verify tests were run if any code was modified using Write or Edit tools",
        "scenario": "When you want to ensure quality standards before completing work"
      },
      {
        "title": "Project Context Detection",
        "prompt": "Create a SessionStart hook that detects the project type (Node.js, Python, Rust, Go, etc.) and sets environment variables accordingly",
        "scenario": "When you want Claude to automatically understand your project environment"
      },
      {
        "title": "Bash Command Safety Check",
        "prompt": "Create a PreToolUse hook for Bash commands that blocks destructive operations (rm -rf, dd, mkfs), privilege escalation (sudo), and asks for user confirmation on risky commands",
        "scenario": "When you need to prevent dangerous terminal commands"
      },
      {
        "title": "MCP Deletion Protection",
        "prompt": "Create a PreToolUse hook that matches all MCP delete tools (mcp__.*__delete.*) and prompts for verification that deletion is intentional and has backups",
        "scenario": "When using MCP integrations with destructive capabilities"
      }
    ],
    "output_examples": [
      {
        "input": "User asks: Create a hook to prevent writes to .env files",
        "output": "Creates hooks/hooks.json with PreToolUse hook matching Write|Edit, using prompt-based validation that checks if file_path contains .env or similar credential patterns, returns 'deny' if detected"
      },
      {
        "input": "User asks: Add a hook to verify tests run before stopping",
        "output": "Creates Stop hook with prompt that reviews transcript for Write/Edit tool usage and Bash test execution, blocks with reason 'Tests must be run after code changes' if tests missing"
      },
      {
        "input": "User asks: Load project context at session start",
        "output": "Creates SessionStart command hook running load-context.sh that detects project files (package.json, Cargo.toml, etc.) and exports PROJECT_TYPE to CLAUDE_ENV_FILE"
      }
    ],
    "best_practices": [
      "Use prompt-based hooks for complex, context-aware validation logic",
      "Use command hooks only for deterministic checks or external tool integration",
      "Always use ${CLAUDE_PLUGIN_ROOT} for portable file references in hook commands",
      "Validate all inputs in command hooks with proper quoting to prevent injection",
      "Set appropriate timeouts (10-30s for command hooks, 15-30s for prompt hooks)",
      "Check for path traversal (..) and system directories in file validation hooks",
      "Test hooks thoroughly with utility scripts before deployment",
      "Use matchers to target specific tools or patterns (Write|Edit, mcp__.*__, etc.)",
      "Design hooks to be independent since they run in parallel",
      "Document hook activation mechanisms and requirements in README",
      "Use exit code 0 for approval/success and exit code 2 for blocking/denial",
      "Return structured JSON output with permissionDecision or decision fields",
      "Validate hooks.json schema with provided validation script"
    ],
    "anti_patterns": [
      "Using hardcoded absolute paths instead of ${CLAUDE_PLUGIN_ROOT}",
      "Trusting user input without validation in command hooks",
      "Creating long-running hooks that exceed timeout limits",
      "Relying on specific hook execution order (they run in parallel)",
      "Leaving variables unquoted in bash scripts (injection risk)",
      "Modifying global state unpredictably across hooks",
      "Logging sensitive information in hook output",
      "Expecting hooks to hot-reload without restarting Claude Code",
      "Using prompt-based hooks on unsupported events without testing",
      "Creating hooks without testing with utility scripts first",
      "Missing input validation for path traversal and system paths",
      "Implementing complex logic in command hooks instead of prompt hooks"
    ],
    "faq": [
      {
        "question": "When should I use prompt-based hooks vs command hooks?",
        "answer": "Use prompt-based hooks for complex, context-aware validation that requires reasoning (checking intent, understanding context, handling edge cases). Use command hooks for fast deterministic checks, external tool integration, or performance-critical validations under 50ms."
      },
      {
        "question": "How do I update hooks after making changes?",
        "answer": "Hooks load at session start only. After editing hooks/hooks.json or hook scripts, you must exit and restart Claude Code for changes to take effect. Changes do not hot-reload during an active session."
      },
      {
        "question": "What's the difference between plugin hooks.json and settings format?",
        "answer": "Plugin hooks/hooks.json uses wrapper format with optional 'description' and required 'hooks' fields containing events. User settings use direct format with events at top level. Examples show event structure that goes inside either format."
      },
      {
        "question": "How can I make hooks temporarily active?",
        "answer": "Check for a flag file or configuration at the start of your hook script. If not present, exit 0 immediately. Users enable by creating the flag file (touch .enable-hook) and disable by removing it (rm .enable-hook). Requires Claude Code restart."
      },
      {
        "question": "Why use ${CLAUDE_PLUGIN_ROOT} instead of hardcoded paths?",
        "answer": "CLAUDE_PLUGIN_ROOT ensures portability across different installations and users. Hardcoded paths like /home/user/plugin break when deployed to other systems. Always use ${CLAUDE_PLUGIN_ROOT} for plugin-relative paths."
      },
      {
        "question": "How do I debug hooks that aren't working?",
        "answer": "Run 'claude --debug' to see hook registration, execution logs, and input/output JSON. Test command hooks directly with echo input | bash script.sh. Validate JSON output with jq. Use utility scripts in scripts/ directory to validate and test before deployment."
      },
      {
        "question": "Can hooks modify tool inputs before execution?",
        "answer": "Yes, PreToolUse hooks can return 'updatedInput' in hookSpecificOutput to modify tool parameters. This allows rewriting paths, sanitizing content, or adjusting parameters before the tool executes."
      },
      {
        "question": "What happens when multiple hooks match the same tool?",
        "answer": "All matching hooks run in parallel. If any hook denies/blocks, the operation is blocked. If all approve, it proceeds. Hooks don't see each other's output, so design them to be independent."
      }
    ],
    "technical_requirements": {
      "dependencies": [
        "bash",
        "jq"
      ],
      "permissions": [
        "File system read/write for hook scripts",
        "Execute bash commands"
      ],
      "complexity": "intermediate"
    }
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "load-context.sh",
          "type": "file",
          "path": "examples/load-context.sh"
        },
        {
          "name": "validate-bash.sh",
          "type": "file",
          "path": "examples/validate-bash.sh"
        },
        {
          "name": "validate-write.sh",
          "type": "file",
          "path": "examples/validate-write.sh"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "advanced.md",
          "type": "file",
          "path": "references/advanced.md"
        },
        {
          "name": "migration.md",
          "type": "file",
          "path": "references/migration.md"
        },
        {
          "name": "patterns.md",
          "type": "file",
          "path": "references/patterns.md"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "hook-linter.sh",
          "type": "file",
          "path": "scripts/hook-linter.sh"
        },
        {
          "name": "README.md",
          "type": "file",
          "path": "scripts/README.md"
        },
        {
          "name": "test-hook.sh",
          "type": "file",
          "path": "scripts/test-hook.sh"
        },
        {
          "name": "validate-hook-schema.sh",
          "type": "file",
          "path": "scripts/validate-hook-schema.sh"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}