{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2025-12-30T09:53:47.819Z",
    "slug": "hook-development",
    "source_url": "https://github.com/anthropics/claude-code/tree/main/plugins/plugin-dev/skills/hook-development",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "trust_level": "official"
  },
  "skill": {
    "name": "Hook Development",
    "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
    "summary": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop ...",
    "icon": "ðŸª",
    "version": "0.1.0",
    "author": "Anthropic",
    "license": "Not specified",
    "category": "development",
    "tags": [
      "hooks",
      "automation",
      "validation",
      "plugins",
      "security",
      "events",
      "claude-code",
      "workflow"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is an official Anthropic skill providing educational examples and utilities for hook development. All scripts are validation/testing utilities with no malicious code. Example hooks demonstrate security best practices including input validation, path traversal prevention, and proper quoting.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 11,
    "total_lines": 2781,
    "audit_model": "claude",
    "audited_at": "2025-12-30T09:53:47.818Z"
  },
  "content": {
    "user_title": "Hook Development for Claude Code Plugins",
    "value_statement": "Build event-driven automation hooks to validate operations, enforce quality standards, and integrate external tools into Claude Code workflows.",
    "seo_keywords": [
      "claude code hooks",
      "plugin development",
      "automation",
      "validation hooks",
      "pretooluse",
      "posttooluse",
      "event-driven",
      "workflow automation",
      "security validation",
      "prompt hooks"
    ],
    "actual_capabilities": [
      "Create prompt-based hooks using LLM reasoning for context-aware validation",
      "Implement command hooks for deterministic checks and external tool integration",
      "Validate tool operations before execution (PreToolUse hooks)",
      "React to tool results and provide feedback (PostToolUse hooks)",
      "Enforce completion standards before stopping (Stop/SubagentStop hooks)",
      "Load project context automatically at session start (SessionStart hooks)",
      "Block dangerous operations like rm -rf, path traversal, and writes to sensitive files",
      "Set up conditional/temporary hooks based on flag files or configuration",
      "Test and validate hook scripts with included utility tools",
      "Use environment variables for portable plugin paths"
    ],
    "limitations": [
      "Hooks only load at session start - requires restarting Claude Code to apply changes",
      "Hooks run in parallel with non-deterministic ordering",
      "Hooks cannot see each other's output within the same event",
      "Default timeouts: 60s for command hooks, 30s for prompt hooks",
      "Hot-swapping hooks during a session is not supported",
      "Prompt-based hooks only fully supported on Stop, SubagentStop, UserPromptSubmit, and PreToolUse events"
    ],
    "use_cases": [
      {
        "title": "Security Validation",
        "description": "Prevent dangerous file writes to system directories, credential files, or paths with traversal patterns using prompt-based validation",
        "target_user": "Plugin developers who want to enforce security policies"
      },
      {
        "title": "Test Enforcement",
        "description": "Ensure tests run before stopping work by checking the transcript for test execution after code modifications",
        "target_user": "Teams enforcing quality standards and preventing incomplete work"
      },
      {
        "title": "Project Context Loading",
        "description": "Automatically detect project type (Node.js, Rust, Go, Python, Java) and set environment variables at session start",
        "target_user": "Developers working across multiple project types who want automatic configuration"
      },
      {
        "title": "Bash Command Safety",
        "description": "Validate bash commands for destructive operations (rm -rf), privilege escalation (sudo), and dangerous system operations before execution",
        "target_user": "Security-conscious teams preventing accidental destructive operations"
      },
      {
        "title": "Build Verification",
        "description": "Verify the project builds successfully after code changes before allowing the session to stop",
        "target_user": "Development teams catching build errors before committing"
      },
      {
        "title": "MCP Tool Monitoring",
        "description": "Monitor and validate MCP tool usage, especially destructive operations like deletions, with pattern-based matchers",
        "target_user": "Plugin developers integrating with MCP tools who need safety guardrails"
      }
    ],
    "prompt_templates": [
      {
        "title": "Create File Write Validation Hook",
        "prompt": "Create a PreToolUse prompt hook that validates Write and Edit operations. Check for: 1) system directories (/etc, /sys, /usr), 2) credential files (.env, secrets, tokens), 3) path traversal (..), 4) sensitive content in the file. Return 'approve' or 'deny'.",
        "scenario": "When you need to prevent writes to sensitive files or system paths"
      },
      {
        "title": "Create Test Enforcement Hook",
        "prompt": "Create a Stop hook that reviews the transcript and blocks stopping if code was modified (Write/Edit tools used) but tests weren't executed. Return 'block' with reason 'Tests must be run after code changes' if tests are missing.",
        "scenario": "When you want to enforce that tests run before completing work"
      },
      {
        "title": "Create Bash Command Safety Hook",
        "prompt": "Create a PreToolUse prompt hook for the Bash tool that analyzes commands for: 1) destructive operations (rm -rf, dd, mkfs), 2) privilege escalation (sudo, su), 3) network operations without consent. Return 'approve', 'deny', or 'ask' with explanation.",
        "scenario": "When you need to validate bash commands before execution"
      },
      {
        "title": "Create Project Context Loader",
        "prompt": "Create a SessionStart command hook script that detects project type by checking for package.json, Cargo.toml, go.mod, pyproject.toml, pom.xml, or build.gradle. Set PROJECT_TYPE environment variable via $CLAUDE_ENV_FILE.",
        "scenario": "When you want automatic project type detection at session start"
      },
      {
        "title": "Create MCP Tool Safety Hook",
        "prompt": "Create a PreToolUse prompt hook with matcher 'mcp__.*__delete.*' that validates deletion operations. Check if deletion is intentional, can be undone, and backups exist. Return 'approve' only if safe.",
        "scenario": "When you need to protect against destructive MCP operations"
      }
    ],
    "output_examples": [
      {
        "input": "User asks: 'Create a hook to prevent writing to .env files'",
        "output": "{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"File path: $TOOL_INPUT.file_path. If the file is .env or contains 'secret', 'credential', 'token', or 'password' in the name, return 'deny' with reason 'Cannot write to credential files'. Otherwise return 'approve'.\"\n        }\n      ]\n    }\n  ]\n}"
      },
      {
        "input": "User asks: 'Add a hook to check tests were run before stopping'",
        "output": "{\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"Review the transcript at $TRANSCRIPT_PATH. If any Write or Edit tools were used to modify code, verify that tests were executed (look for test commands, test output, or test results). If code was changed but no tests were run, return 'block' with reason 'Tests must be run after code changes'. Otherwise return 'approve'.\"\n        }\n      ]\n    }\n  ]\n}"
      }
    ],
    "best_practices": [
      "Use prompt-based hooks for complex, context-aware validation requiring natural language reasoning",
      "Use command hooks for fast deterministic checks, external tool integration, or performance-critical validation",
      "Always use ${CLAUDE_PLUGIN_ROOT} for portable file references in hook commands",
      "Quote all bash variables to prevent injection vulnerabilities",
      "Validate all inputs in command hooks - check for empty values, unexpected formats, path traversal",
      "Set appropriate timeouts (10-15s for prompts, 5-10s for commands)",
      "Design hooks to be independent since they run in parallel",
      "Test hooks with provided utility scripts (validate-hook-schema.sh, test-hook.sh, hook-linter.sh) before deployment",
      "Use flag files or configuration for temporarily active hooks",
      "Document hook activation mechanisms in plugin README",
      "Return structured JSON output with clear decision and reason fields",
      "Use SessionStart hooks to persist environment variables via $CLAUDE_ENV_FILE"
    ],
    "anti_patterns": [
      "Using hardcoded absolute paths instead of ${CLAUDE_PLUGIN_ROOT}",
      "Trusting user input without validation in command hooks",
      "Creating long-running hooks (>60s) that block workflows",
      "Relying on hook execution order (hooks run in parallel)",
      "Leaving variables unquoted in bash scripts (injection risk)",
      "Using command hooks for complex logic better suited to prompt hooks",
      "Forgetting to restart Claude Code after modifying hook configuration",
      "Outputting sensitive information in hook logs or error messages",
      "Creating hooks that modify global state unpredictably",
      "Not testing hooks before deployment"
    ],
    "faq": [
      {
        "question": "When should I use prompt-based hooks vs command hooks?",
        "answer": "Use prompt-based hooks for context-aware validation requiring natural language reasoning, flexible evaluation logic, and better edge case handling. Use command hooks for fast deterministic checks (<50ms), external tool integration, and performance-critical validation. For multi-stage validation, combine both: command hook for quick checks, prompt hook for complex reasoning."
      },
      {
        "question": "How do I test hooks before deploying to users?",
        "answer": "Use the provided utility scripts: 1) validate-hook-schema.sh to validate hooks.json structure, 2) test-hook.sh to test individual hook scripts with sample input, 3) hook-linter.sh to check scripts for common issues and security vulnerabilities. Then test in Claude Code with `claude --debug` to see detailed execution logs."
      },
      {
        "question": "Do hook configuration changes apply immediately?",
        "answer": "No. Hooks are loaded when Claude Code session starts. Changes to hooks.json or hook scripts require restarting Claude Code to take effect. You cannot hot-swap hooks during a session. To test changes: exit Claude Code, make edits, restart with `claude` or `cc`."
      },
      {
        "question": "How do hooks handle parallel execution?",
        "answer": "All matching hooks for an event run in parallel with non-deterministic ordering. Hooks cannot see each other's output and should be designed to be independent. If you need sequential logic, use a single hook that performs multiple checks, or use temporary files with session-specific identifiers."
      },
      {
        "question": "What's the difference between plugin hooks.json format and settings format?",
        "answer": "Plugin hooks.json uses wrapper format: {\"description\": \"...\", \"hooks\": {\"PreToolUse\": [...]}}, while user settings use direct format: {\"PreToolUse\": [...]}. The wrapper is required for plugins but not for user settings. The hook event structure is the same in both."
      },
      {
        "question": "How can I create temporary or conditional hooks?",
        "answer": "Use flag files or configuration checks at the start of your hook script. Exit 0 early if the flag file doesn't exist or configuration isn't enabled. This allows hooks to be dormant until activated. Example: check for .enable-strict-validation flag file, or read .claude/plugin-config.json for strictMode setting."
      },
      {
        "question": "What environment variables are available in hooks?",
        "answer": "$CLAUDE_PROJECT_DIR (project root), $CLAUDE_PLUGIN_ROOT (plugin directory - use for portable paths), $CLAUDE_ENV_FILE (SessionStart only - persist env vars here), $CLAUDE_CODE_REMOTE (set if remote context). Always use ${CLAUDE_PLUGIN_ROOT} in hook commands for portability."
      },
      {
        "question": "How do I block or approve operations in hooks?",
        "answer": "For PreToolUse: return JSON with permissionDecision: 'allow'|'deny'|'ask' via exit code 2 to stderr. For Stop/SubagentStop: return decision: 'approve'|'block'. Exit 0 for success/approve, exit 2 to block with message to stderr. Include systemMessage for context to Claude."
      }
    ],
    "technical_requirements": {
      "dependencies": [
        "bash",
        "jq"
      ],
      "permissions": [
        "file system access for hook scripts",
        "ability to execute bash commands"
      ],
      "complexity": "intermediate"
    }
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "load-context.sh",
          "type": "file",
          "path": "examples/load-context.sh"
        },
        {
          "name": "validate-bash.sh",
          "type": "file",
          "path": "examples/validate-bash.sh"
        },
        {
          "name": "validate-write.sh",
          "type": "file",
          "path": "examples/validate-write.sh"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "advanced.md",
          "type": "file",
          "path": "references/advanced.md"
        },
        {
          "name": "migration.md",
          "type": "file",
          "path": "references/migration.md"
        },
        {
          "name": "patterns.md",
          "type": "file",
          "path": "references/patterns.md"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "hook-linter.sh",
          "type": "file",
          "path": "scripts/hook-linter.sh"
        },
        {
          "name": "README.md",
          "type": "file",
          "path": "scripts/README.md"
        },
        {
          "name": "test-hook.sh",
          "type": "file",
          "path": "scripts/test-hook.sh"
        },
        {
          "name": "validate-hook-schema.sh",
          "type": "file",
          "path": "scripts/validate-hook-schema.sh"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}