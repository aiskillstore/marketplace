{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2025-12-30T14:27:53.496Z",
    "slug": "hook-development",
    "source_url": "https://github.com/anthropics/claude-code/tree/main/plugins/plugin-dev/skills/hook-development",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "trust_level": "official"
  },
  "skill": {
    "name": "Hook Development",
    "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
    "summary": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop ...",
    "icon": "ðŸª",
    "version": "0.1.0",
    "author": "Anthropic",
    "license": "Not specified",
    "category": "development",
    "tags": [
      "hooks",
      "automation",
      "validation",
      "claude-code",
      "plugins",
      "event-driven",
      "security",
      "quality-control",
      "testing",
      "workflow"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is an OFFICIAL Anthropic skill for developing Claude Code hooks. All example scripts demonstrate proper security practices including input validation, path traversal prevention, variable quoting, and safe exit codes. No malicious code detected.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 11,
    "total_lines": 2781,
    "audit_model": "claude",
    "audited_at": "2025-12-30T14:27:53.495Z"
  },
  "content": {
    "user_title": "Hook Development for Claude Code Plugins",
    "value_statement": "Build event-driven automation hooks that validate tool usage, enforce quality standards, and seamlessly integrate external tools into your Claude Code workflow using intelligent prompt-based or deterministic command-based validation.",
    "seo_keywords": [
      "claude code hooks",
      "plugin development",
      "pretooluse",
      "automation",
      "validation hooks",
      "claude code plugins",
      "event-driven",
      "prompt hooks",
      "workflow automation",
      "security validation"
    ],
    "actual_capabilities": [
      "Create PreToolUse hooks to validate or block tool calls before execution",
      "Implement PostToolUse hooks to react to tool results and provide feedback",
      "Build Stop/SubagentStop hooks to ensure tasks meet completion criteria",
      "Set up SessionStart hooks to automatically load project context and environment",
      "Use prompt-based hooks for context-aware LLM-driven validation without scripting",
      "Create command hooks for deterministic checks and external tool integration",
      "Validate file writes to prevent system file modification and credential exposure",
      "Block dangerous bash commands like rm -rf, privilege escalation, and destructive operations",
      "Enforce testing and build requirements before stopping work",
      "Configure hooks with tool matchers (exact, regex, wildcard) for targeted validation",
      "Persist environment variables across sessions using SessionStart hooks",
      "Test and validate hook scripts with provided utility tools",
      "Debug hooks with comprehensive logging and JSON output validation"
    ],
    "limitations": [
      "Hooks are loaded at session start only - configuration changes require restarting Claude Code",
      "Cannot hot-swap or dynamically update hooks during an active session",
      "Hooks run in parallel with non-deterministic ordering - cannot rely on execution sequence",
      "Prompt-based hooks only supported on Stop, SubagentStop, UserPromptSubmit, and PreToolUse events",
      "Default timeouts: 60s for command hooks, 30s for prompt hooks (configurable up to 600s)",
      "Hooks do not have access to previous hook outputs when running in parallel"
    ],
    "use_cases": [
      {
        "title": "Security Validation for File Operations",
        "description": "Automatically validate all file writes and edits to prevent accidental modification of system files, credentials, or sensitive configuration. Uses prompt-based hooks to understand context and intent, catching variations like path traversal, .env files, and secret patterns.",
        "target_user": "Developers working with sensitive codebases who need to prevent accidental credential commits or system file modifications"
      },
      {
        "title": "Test and Build Enforcement",
        "description": "Ensure tests run and builds succeed before allowing work to stop. Stop hooks verify the transcript to confirm tests were executed and passed after code modifications, preventing incomplete or broken commits.",
        "target_user": "Teams enforcing quality standards and CI/CD best practices in their development workflow"
      },
      {
        "title": "Dangerous Command Prevention",
        "description": "Block destructive bash commands like rm -rf, dd, mkfs, and privilege escalation attempts. Prompt-based validation understands intent and catches variations that regex patterns might miss.",
        "target_user": "Users working in production environments or shared systems who need protection against accidental destructive operations"
      },
      {
        "title": "Project Context Auto-Loading",
        "description": "Automatically detect project type (Node.js, Rust, Python, Go, Java) at session start and set environment variables. Enables context-aware assistance without manual configuration.",
        "target_user": "Developers working across multiple projects who want Claude to automatically understand project structure and tooling"
      },
      {
        "title": "MCP Tool Validation",
        "description": "Monitor and validate Model Context Protocol (MCP) tool usage, especially for destructive operations. Use matchers like 'mcp__.*__delete.*' to intercept deletion operations and confirm intent.",
        "target_user": "Users with MCP integrations who need oversight on external tool operations"
      },
      {
        "title": "Code Quality Automation",
        "description": "Run linters, formatters, or security scanners automatically after file edits using PostToolUse hooks. Provides immediate feedback on code quality issues.",
        "target_user": "Teams maintaining code quality standards with automated linting and formatting requirements"
      }
    ],
    "prompt_templates": [
      {
        "title": "Create PreToolUse Security Validation Hook",
        "prompt": "Create a PreToolUse hook that validates Write and Edit operations. Block writes to system directories (/etc, /sys, /usr), credential files (.env, secrets, tokens), and paths with traversal (..). Use a prompt-based hook for intelligent validation.",
        "scenario": "When you need to prevent accidental modification of sensitive files"
      },
      {
        "title": "Add Stop Hook for Test Enforcement",
        "prompt": "Create a Stop hook that reviews the transcript to verify tests were run after any code modifications (Write/Edit tool usage). Block stopping if tests weren't executed and explain what's needed.",
        "scenario": "When enforcing quality standards that require testing after code changes"
      },
      {
        "title": "Implement SessionStart Context Loading",
        "prompt": "Create a SessionStart hook that detects project type (package.json, Cargo.toml, go.mod, pyproject.toml) and sets PROJECT_TYPE environment variable. Also detect if the project uses TypeScript or has CI configuration.",
        "scenario": "When you want Claude to automatically understand your project structure"
      },
      {
        "title": "Build Bash Command Safety Hook",
        "prompt": "Create a PreToolUse hook for Bash tool that blocks dangerous commands: destructive operations (rm -rf, dd, mkfs), privilege escalation (sudo, su), and asks for confirmation on network operations. Use prompt-based validation.",
        "scenario": "When working in environments where destructive bash commands could cause damage"
      },
      {
        "title": "Add MCP Tool Monitoring",
        "prompt": "Create a PreToolUse hook that matches all MCP delete operations (mcp__.*__delete.*) and validates the deletion is intentional, can be undone, and has backups available before approving.",
        "scenario": "When using MCP integrations that can perform destructive operations"
      },
      {
        "title": "Create Conditional Hook with Flag File",
        "prompt": "Create a command hook that only runs when a flag file exists (.enable-strict-validation). The hook should exit immediately if the flag isn't present, otherwise perform comprehensive validation. Include instructions for enabling/disabling.",
        "scenario": "When you want temporary or opt-in validation that can be easily toggled"
      }
    ],
    "output_examples": [
      {
        "input": "User attempts to write to /etc/passwd via Write tool",
        "output": "PreToolUse hook blocks the operation with: {\"hookSpecificOutput\": {\"permissionDecision\": \"deny\"}, \"systemMessage\": \"Cannot write to system directory: /etc/passwd\"}"
      },
      {
        "input": "User tries to stop after modifying code but without running tests",
        "output": "Stop hook blocks with: {\"decision\": \"block\", \"reason\": \"Tests must be run after code changes\", \"systemMessage\": \"Please run the test suite before stopping\"}"
      },
      {
        "input": "SessionStart in a Node.js project with TypeScript",
        "output": "Hook outputs: \"ðŸ“¦ Node.js project detected\" and sets PROJECT_TYPE=nodejs and USES_TYPESCRIPT=true in environment file"
      },
      {
        "input": "User attempts command 'rm -rf /' via Bash tool",
        "output": "PreToolUse hook denies with: {\"hookSpecificOutput\": {\"permissionDecision\": \"deny\"}, \"systemMessage\": \"Dangerous command detected: rm -rf\"}"
      }
    ],
    "best_practices": [
      "Use prompt-based hooks for complex validation logic that requires context awareness",
      "Reserve command hooks for deterministic checks and external tool integrations",
      "Always use ${CLAUDE_PLUGIN_ROOT} for portable file paths in hook commands",
      "Quote all bash variables to prevent injection vulnerabilities",
      "Validate all inputs in command hooks - never trust user-provided data",
      "Set appropriate timeouts: short for quick checks, longer for LLM-based validation",
      "Test hooks thoroughly with validate-hook-schema.sh and test-hook.sh before deployment",
      "Design hooks to be independent since they run in parallel with non-deterministic ordering",
      "Return structured JSON output with clear decision reasons and system messages",
      "Document hook activation mechanisms, especially for flag-based conditional hooks",
      "Use matcher patterns strategically: exact match for specific tools, regex for patterns, wildcard sparingly",
      "Provide clear error messages in systemMessage for denied operations",
      "Cache validation results when performing expensive checks multiple times"
    ],
    "anti_patterns": [
      "Using hardcoded absolute paths instead of ${CLAUDE_PLUGIN_ROOT}",
      "Relying on hook execution order (hooks run in parallel)",
      "Creating long-running hooks that exceed timeout limits",
      "Trusting user input without validation in command hooks",
      "Leaving variables unquoted in bash scripts (injection risk)",
      "Modifying hook configuration without restarting Claude Code session",
      "Using prompt hooks on unsupported events like SessionStart or PostToolUse",
      "Creating hooks that modify global state unpredictably",
      "Logging sensitive information in hook output",
      "Missing error handling for edge cases and malformed input",
      "Using command hooks for complex logic better suited to prompt-based validation",
      "Forgetting to set executable permissions on hook scripts",
      "Not testing hook JSON output validity before deployment"
    ],
    "faq": [
      {
        "question": "When should I use prompt-based hooks vs command hooks?",
        "answer": "Use prompt-based hooks for context-aware validation requiring natural language reasoning and flexible logic. Use command hooks for fast deterministic checks, external tool integrations, and performance-critical validations. Prompt hooks are best for PreToolUse, Stop, SubagentStop, and UserPromptSubmit events."
      },
      {
        "question": "Why aren't my hook changes taking effect?",
        "answer": "Hooks are loaded only at session start. You must exit Claude Code and restart it for hook configuration changes to apply. Use 'claude --debug' to verify hooks loaded correctly."
      },
      {
        "question": "How do I make hooks portable across different installations?",
        "answer": "Always use ${CLAUDE_PLUGIN_ROOT} for file paths in hook commands instead of hardcoded absolute paths. This ensures hooks work regardless of where the plugin is installed."
      },
      {
        "question": "Can hooks see the output of other hooks?",
        "answer": "No. All matching hooks run in parallel with non-deterministic ordering. Design hooks to be independent and don't rely on shared state or execution order."
      },
      {
        "question": "How do I test hooks before deploying them?",
        "answer": "Use the provided utility scripts: validate-hook-schema.sh for configuration validation, test-hook.sh to test scripts with sample input, and hook-linter.sh to check for common issues. Then test in Claude Code with 'claude --debug'."
      },
      {
        "question": "What's the difference between plugin hooks.json format and settings format?",
        "answer": "Plugin hooks use a wrapper format with {\"hooks\": {...}} containing events. Settings use direct format with events at top level. Plugin hooks also support an optional description field."
      },
      {
        "question": "How can I create hooks that only run sometimes?",
        "answer": "Use flag files or configuration files. Check for a flag file's existence at the start of your hook script and exit early if not present. This allows opt-in activation without changing hook configuration."
      },
      {
        "question": "What exit codes should hooks return?",
        "answer": "Exit 0 for success (stdout shown in transcript), exit 2 for blocking errors (stderr fed to Claude), other codes for non-blocking errors. PreToolUse and Stop hooks should output decision JSON before exiting."
      },
      {
        "question": "How do I persist environment variables from SessionStart hooks?",
        "answer": "Use $CLAUDE_ENV_FILE in SessionStart hooks: echo 'export VAR=value' >> \"$CLAUDE_ENV_FILE\". These variables will be available throughout the session."
      },
      {
        "question": "Can I use hooks to modify tool inputs?",
        "answer": "Yes, PreToolUse hooks can return updatedInput in hookSpecificOutput to modify tool parameters before execution. This allows input transformation and sanitization."
      }
    ],
    "technical_requirements": {
      "dependencies": [
        "bash (for command hooks)",
        "jq (for JSON parsing in command hooks)",
        "Claude Code plugin system"
      ],
      "permissions": [
        "File system read access for validation hooks",
        "Execute permissions on hook scripts",
        "Write access to CLAUDE_ENV_FILE (SessionStart only)"
      ],
      "complexity": "intermediate"
    }
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "load-context.sh",
          "type": "file",
          "path": "examples/load-context.sh"
        },
        {
          "name": "validate-bash.sh",
          "type": "file",
          "path": "examples/validate-bash.sh"
        },
        {
          "name": "validate-write.sh",
          "type": "file",
          "path": "examples/validate-write.sh"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "advanced.md",
          "type": "file",
          "path": "references/advanced.md"
        },
        {
          "name": "migration.md",
          "type": "file",
          "path": "references/migration.md"
        },
        {
          "name": "patterns.md",
          "type": "file",
          "path": "references/patterns.md"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "hook-linter.sh",
          "type": "file",
          "path": "scripts/hook-linter.sh"
        },
        {
          "name": "README.md",
          "type": "file",
          "path": "scripts/README.md"
        },
        {
          "name": "test-hook.sh",
          "type": "file",
          "path": "scripts/test-hook.sh"
        },
        {
          "name": "validate-hook-schema.sh",
          "type": "file",
          "path": "scripts/validate-hook-schema.sh"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}