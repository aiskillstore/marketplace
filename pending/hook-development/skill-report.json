{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2025-12-30T09:07:46.506Z",
    "slug": "hook-development",
    "source_url": "https://github.com/anthropics/claude-code/tree/main/plugins/plugin-dev/skills/hook-development",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "trust_level": "official"
  },
  "skill": {
    "name": "Hook Development",
    "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
    "summary": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop ...",
    "icon": "ü™ù",
    "version": "0.1.0",
    "author": "Anthropic",
    "license": "Not specified",
    "category": "development",
    "tags": [
      "hooks",
      "automation",
      "validation",
      "plugin-development",
      "event-driven",
      "security",
      "workflow",
      "claude-code"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Official Anthropic skill providing educational examples and utilities for hook development. All scripts demonstrate proper security practices including input validation, path safety, and quoted variables.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 11,
    "total_lines": 2781,
    "audit_model": "claude",
    "audited_at": "2025-12-30T09:07:46.506Z"
  },
  "content": {
    "user_title": "Claude Code Hook Development Assistant",
    "value_statement": "Learn to create powerful event-driven hooks that validate operations, enforce quality standards, and automate workflows in your Claude Code plugins.",
    "seo_keywords": [
      "claude code hooks",
      "plugin hooks",
      "pretooluse",
      "posttooluse",
      "event-driven automation",
      "tool validation",
      "prompt-based hooks",
      "bash hooks",
      "claude code plugin development"
    ],
    "actual_capabilities": [
      "Guide users through creating PreToolUse, PostToolUse, Stop, and other hook types",
      "Provide working examples of security validation hooks",
      "Show how to implement prompt-based hooks with LLM reasoning",
      "Demonstrate command hooks for deterministic checks",
      "Explain hook configuration formats for plugins and settings",
      "Teach proper use of environment variables like ${CLAUDE_PLUGIN_ROOT}",
      "Provide validation and testing utilities for hook development",
      "Show patterns for context loading, test enforcement, and build verification",
      "Explain hook lifecycle, parallel execution, and performance optimization"
    ],
    "limitations": [
      "Does not execute hooks directly (only provides guidance)",
      "Requires Claude Code environment to test hooks",
      "Hooks require session restart to reload changes",
      "Cannot debug hooks that are already running in a session",
      "Hook configuration format differs between plugins and user settings"
    ],
    "use_cases": [
      {
        "title": "Security Validation",
        "description": "Block dangerous file writes, command execution, or operations on system directories before they happen using PreToolUse hooks",
        "target_user": "Security-conscious developers who want to prevent accidental destructive operations"
      },
      {
        "title": "Quality Enforcement",
        "description": "Ensure tests run and builds succeed before stopping work using Stop hooks with transcript analysis",
        "target_user": "Teams wanting to enforce quality standards and prevent incomplete work"
      },
      {
        "title": "Context Loading",
        "description": "Automatically detect project type and load relevant environment variables at session start",
        "target_user": "Developers working across multiple project types who want automatic configuration"
      },
      {
        "title": "MCP Tool Monitoring",
        "description": "Validate and control MCP tool usage, especially for destructive operations like deletions",
        "target_user": "Plugin developers integrating external tools who need validation layers"
      },
      {
        "title": "Workflow Automation",
        "description": "Chain hooks across events (SessionStart, PreToolUse, PostToolUse, Stop) for complete workflow automation",
        "target_user": "Advanced users building sophisticated automation pipelines"
      }
    ],
    "prompt_templates": [
      {
        "title": "Create Security Validation Hook",
        "prompt": "Create a PreToolUse hook that prevents writing to system directories (/etc, /sys, /usr) and credential files (.env, secrets, tokens)",
        "scenario": "When you want to add safety guardrails to prevent accidental destructive file operations"
      },
      {
        "title": "Implement Test Enforcement",
        "prompt": "Create a Stop hook that checks the transcript to verify tests were run if code was modified, and blocks stopping if tests weren't executed",
        "scenario": "When you want to enforce that tests run before finishing work"
      },
      {
        "title": "Add Context Loading",
        "prompt": "Create a SessionStart hook that detects project type (Node.js, Rust, Go, Python) and sets environment variables accordingly",
        "scenario": "When you want automatic project detection and configuration at session start"
      },
      {
        "title": "Validate Bash Commands",
        "prompt": "Create a PreToolUse hook for Bash tool that blocks destructive operations (rm -rf, dd, mkfs) and asks for confirmation on privilege escalation (sudo)",
        "scenario": "When you want to prevent dangerous command execution"
      }
    ],
    "output_examples": [
      {
        "input": "Create a hook that prevents writing to .env files",
        "output": "{\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"prompt\",\n          \"prompt\": \"File path: $TOOL_INPUT.file_path. If this is a .env file or contains credentials/secrets, return 'deny'. Otherwise return 'approve'.\"\n        }\n      ]\n    }\n  ]\n}"
      },
      {
        "input": "Show me how to load project context at session start",
        "output": "SessionStart hook with bash script that detects package.json, Cargo.toml, etc. and writes PROJECT_TYPE to $CLAUDE_ENV_FILE for persistence across the session"
      }
    ],
    "best_practices": [
      "Use prompt-based hooks for complex, context-aware validation instead of bash scripting",
      "Always use ${CLAUDE_PLUGIN_ROOT} for portable file paths in hook commands",
      "Quote all bash variables to prevent injection vulnerabilities",
      "Set appropriate timeouts (10-30s for prompts, 5-60s for commands)",
      "Validate all inputs in command hooks before processing",
      "Test hooks with validation scripts before deploying to production",
      "Use command hooks for fast deterministic checks, prompt hooks for reasoning",
      "Design hooks to be independent since they execute in parallel",
      "Document hook activation mechanisms and configuration options",
      "Use exit code 0 for success, 2 for blocking errors"
    ],
    "anti_patterns": [
      "Using hardcoded absolute paths instead of ${CLAUDE_PLUGIN_ROOT}",
      "Creating long-running hooks that exceed timeout limits",
      "Relying on hook execution order (they run in parallel)",
      "Leaving variables unquoted in bash scripts (injection risk)",
      "Forgetting to restart Claude Code after changing hook configuration",
      "Using command hooks for complex logic that would be clearer with prompt-based hooks",
      "Not validating hook JSON output structure",
      "Assuming hooks see each other's output (they don't)",
      "Using hooks for conversational responses instead of validation/automation"
    ],
    "faq": [
      {
        "question": "What's the difference between prompt-based and command hooks?",
        "answer": "Prompt-based hooks use LLM reasoning for context-aware decisions and are easier to maintain. Command hooks execute bash scripts for fast deterministic checks and external tool integration. Use prompts for complex validation, commands for performance-critical checks."
      },
      {
        "question": "Why do I need to restart Claude Code after changing hooks?",
        "answer": "Hooks are loaded when the session starts. Changes to hooks.json or hook scripts won't affect the current session. You must exit and restart Claude Code for new hook configuration to load."
      },
      {
        "question": "How do I make hook paths work across different environments?",
        "answer": "Always use ${CLAUDE_PLUGIN_ROOT} for plugin-relative paths instead of hardcoded absolute paths. This ensures hooks work regardless of where the plugin is installed."
      },
      {
        "question": "Can hooks modify tool inputs before execution?",
        "answer": "Yes, PreToolUse hooks can return updatedInput in hookSpecificOutput to modify tool parameters before execution."
      },
      {
        "question": "Do hooks run sequentially or in parallel?",
        "answer": "All matching hooks for an event run in parallel. Design hooks to be independent and don't rely on execution order or shared state between hooks."
      },
      {
        "question": "What's the difference between plugin hooks.json and settings format?",
        "answer": "Plugin hooks.json uses wrapper format with optional description and required hooks field. Settings use direct format with events at top level. The skill examples show the event structure that goes inside either format."
      },
      {
        "question": "How do I test hooks before deploying?",
        "answer": "Use the provided utility scripts: validate-hook-schema.sh for configuration validation, test-hook.sh for testing with sample input, and hook-linter.sh for checking scripts against best practices."
      },
      {
        "question": "Can I create temporarily active hooks?",
        "answer": "Yes, use flag files or configuration files to conditionally activate hooks. Check for a flag file at the start of your hook script and exit early if not present. Document the activation mechanism for users."
      }
    ],
    "technical_requirements": {
      "dependencies": [
        "jq",
        "bash"
      ],
      "permissions": [
        "File system read/write for hook scripts",
        "Execution permissions for command hooks"
      ],
      "complexity": "intermediate"
    }
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "load-context.sh",
          "type": "file",
          "path": "examples/load-context.sh"
        },
        {
          "name": "validate-bash.sh",
          "type": "file",
          "path": "examples/validate-bash.sh"
        },
        {
          "name": "validate-write.sh",
          "type": "file",
          "path": "examples/validate-write.sh"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "advanced.md",
          "type": "file",
          "path": "references/advanced.md"
        },
        {
          "name": "migration.md",
          "type": "file",
          "path": "references/migration.md"
        },
        {
          "name": "patterns.md",
          "type": "file",
          "path": "references/patterns.md"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "hook-linter.sh",
          "type": "file",
          "path": "scripts/hook-linter.sh"
        },
        {
          "name": "README.md",
          "type": "file",
          "path": "scripts/README.md"
        },
        {
          "name": "test-hook.sh",
          "type": "file",
          "path": "scripts/test-hook.sh"
        },
        {
          "name": "validate-hook-schema.sh",
          "type": "file",
          "path": "scripts/validate-hook-schema.sh"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}