{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-06T01:52:06.527Z",
    "slug": "labring-workflow-stop-design",
    "source_url": "https://github.com/labring/FastGPT/tree/main/.claude/skills/core/app/workflow/stop",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "9a79330c875e63a85e739ab7e1be3072faa8452d5d0acb90c454b4fe06f783b3",
    "tree_hash": "e0cec4378f1f8a3d77a13454c52b49cea0516b2322dfe54bc9b5687b14832e88"
  },
  "skill": {
    "name": "workflow-stop-design",
    "description": "工作流暂停逻辑设计方案",
    "summary": "工作流暂停逻辑设计方案",
    "icon": "⏹️",
    "version": "1.0.0",
    "author": "labring",
    "license": "AGPL-3.0",
    "category": "development",
    "tags": [
      "workflow",
      "redis",
      "api",
      "stop"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "纯文档文件，包含工作流停止功能的设计规范。无恶意代码、无脚本执行、无敏感数据访问。网络调用仅限内部 Redis 服务和 API 端点。",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 673,
    "audit_model": "claude",
    "audited_at": "2026-01-06T01:52:06.527Z"
  },
  "content": {
    "user_title": "设计工作流停止机制",
    "value_statement": "AI 工作流运行时需要能够被用户安全停止。设计使用 Redis 存储停止状态，通过定时轮询检测和 API 接口实现优雅停止，确保用户体验和数据一致性。",
    "seo_keywords": [
      "Claude 工作流设计",
      "FastGPT 停止功能",
      "Redis 状态管理",
      "Claude Code 插件",
      "工作流优雅退出",
      "API 接口设计",
      "TypeScript 开发",
      "AI Agent 控制"
    ],
    "actual_capabilities": [
      "设计 Redis 键值存储停止标志",
      "实现 100ms 定时轮询检测机制",
      "设计 /api/v2/chat/stop API 接口",
      "处理并发停止请求和超时场景",
      "实现工作流完成后清理机制"
    ],
    "limitations": [
      "HTTP 请求节点无法立即中断",
      "依赖 Redis 服务可用性",
      "设计文档，不包含可执行代码"
    ],
    "use_cases": [
      {
        "target_user": "后端开发者",
        "title": "实现工作流停止功能",
        "description": "为 AI Agent 平台添加用户可控制的运行中断能力"
      },
      {
        "target_user": "架构设计师",
        "title": "设计分布式状态管理",
        "description": "使用 Redis 实现跨服务状态同步和优雅降级"
      },
      {
        "target_user": "测试工程师",
        "title": "编写停止功能测试用例",
        "description": "验证并发场景、超时处理和边界条件"
      }
    ],
    "prompt_templates": [
      {
        "title": "基础使用",
        "scenario": "了解停止机制",
        "prompt": "查看 SKILL.md 了解工作流停止功能的设计方案，包括 Redis 状态管理和 API 接口规范"
      },
      {
        "title": "API 实现",
        "scenario": "实现停止接口",
        "prompt": "参考 SKILL.md 第 4 节，帮我实现 /api/v2/chat/stop 接口，包含认证、设置停止标志和超时等待"
      },
      {
        "title": "状态检测",
        "scenario": "添加停止检测",
        "prompt": "根据 SKILL.md 第 3.3 节的说明，在节点执行前添加停止状态检测逻辑"
      },
      {
        "title": "测试验证",
        "scenario": "编写单元测试",
        "prompt": "参考 SKILL.md 第 7 节的测试策略，为 setAgentRuntimeStop、shouldWorkflowStop 等函数编写测试用例"
      }
    ],
    "output_examples": [
      {
        "input": "查看 SKILL.md 了解工作流停止功能的设计方案",
        "output": [
          "Redis Key 格式: agent_runtime_stopping:{appId}:{chatId}",
          "停止标志使用 SETEX 设置，TTL 为 60 秒",
          "后端每 100ms 轮询检查 Redis 状态",
          "API 接口最多等待 5 秒后返回成功",
          "工作流完成后自动清理 Redis 记录"
        ]
      }
    ],
    "best_practices": [
      "使用 TTL 防止 Redis 键泄漏",
      "Redis 操作失败时降级为继续执行",
      "stop 接口不区分超时，统一返回成功"
    ],
    "anti_patterns": [
      "不在生产环境禁用停止检测轮询",
      "不要移除 Redis 操作的错误处理",
      "不建议前端无限等待停止结果"
    ],
    "faq": [
      {
        "question": "停止功能支持所有节点类型吗？",
        "answer": "LLM 流式输出可立即中断，HTTP 请求节点需等待请求完成，其他节点等待当前操作。"
      },
      {
        "question": "Redis 服务不可用时如何处理？",
        "answer": "所有 Redis 操作包含错误处理，出错时降级为继续执行，不阻塞工作流。"
      },
      {
        "question": "如何与现有系统集成？",
        "answer": "参考 SKILL.md 第 3 节修改 dispatch/index.ts，添加停止检测和清理逻辑。"
      },
      {
        "question": "用户数据是否会被泄露？",
        "answer": "设计仅存储 appId 和 chatId，不包含对话内容，采用内部 Redis 服务。"
      },
      {
        "question": "停止请求并发时如何处理？",
        "answer": "Redis SETEX 是幂等操作，多次设置停止标志是安全的。"
      },
      {
        "question": "与其他停止方案相比有何优势？",
        "answer": "使用 Redis 实现分布式状态同步，支持多实例部署，优雅降级不影响主流程。"
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
