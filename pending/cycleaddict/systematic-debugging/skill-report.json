{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T12:55:06.068Z",
    "slug": "cycleaddict-systematic-debugging",
    "source_url": "https://github.com/Cycleaddict/generic-superpowers/tree/main/skills/systematic-debugging",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "1a6bb97f9541f57f12c7edb48a9ca62288e84190fbf6713f405dc16e96786af9",
    "tree_hash": "f5739cb15ee65457f7463b994858ee1dc929c5e37cccebc84978126d3bbfde3f"
  },
  "skill": {
    "name": "systematic-debugging",
    "description": "Use when encountering any bug, test failure, or unexpected behavior, before proposing fixes",
    "summary": "Use when encountering any bug, test failure, or unexpected behavior, before proposing fixes",
    "icon": "üîç",
    "version": "1.0.0",
    "author": "Cycleaddict",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "debugging",
      "root-cause",
      "testing",
      "methodology",
      "troubleshooting"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Prompt-based debugging methodology skill with supporting code examples. The helper script (find-polluter.sh) is a diagnostic tool that runs npm test and checks for file pollution. No network access, no credential access, no persistence mechanisms.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [
      {
        "title": "Shell script executes npm test",
        "description": "The find-polluter.sh script runs `npm test` with file arguments (line 42) to identify which test causes state pollution. This executes the project's test suite. The script is a diagnostic debugging aid and does not make system modifications beyond temporary test state.",
        "locations": [
          {
            "file": "find-polluter.sh",
            "line_start": 42,
            "line_end": 42
          }
        ]
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 11,
    "total_lines": 1243,
    "audit_model": "claude",
    "audited_at": "2026-01-10T12:55:06.068Z"
  },
  "content": {
    "user_title": "Debug systematically before fixing",
    "value_statement": "Random fixes waste time and create new bugs. This skill provides a 4-phase framework to find root causes before attempting any solution. Stop guessing and start investigating.",
    "seo_keywords": [
      "systematic debugging",
      "root cause analysis",
      "debugging methodology",
      "test failure debugging",
      "Claude debugging",
      "Codex debugging",
      "Claude Code debugging",
      "bug investigation",
      "troubleshooting framework",
      "debugging process"
    ],
    "actual_capabilities": [
      "Enforces 4-phase debugging process (Root Cause, Pattern Analysis, Hypothesis, Implementation)",
      "Prevents symptom-only fixes by requiring root cause identification first",
      "Provides backward tracing technique for bugs deep in call stack",
      "Includes defense-in-depth validation pattern for robust fixes",
      "Offers condition-based waiting to replace flaky timeout tests",
      "Provides helper script to identify which test pollutes shared state"
    ],
    "limitations": [
      "Does not execute code or run tests directly",
      "Does not access external debugging tools or profilers",
      "Does not provide IDE integration or breakpoint management",
      "Requires user to follow the prescribed process"
    ],
    "use_cases": [
      {
        "target_user": "Developers fixing production bugs",
        "title": "Production incident response",
        "description": "Use when production is down to prevent quick fixes that mask underlying issues. Find root cause before deploying any fix."
      },
      {
        "target_user": "QA engineers",
        "title": "Debug flaky tests",
        "description": "Use the condition-based waiting pattern and bisection script to find why tests fail intermittently."
      },
      {
        "target_user": "AI assistants",
        "title": "Debug code systematically",
        "description": "Follow the 4-phase process to investigate bugs instead of proposing multiple untested fixes."
      }
    ],
    "prompt_templates": [
      {
        "title": "Quick bug report",
        "scenario": "Simple test failure",
        "prompt": "Debug this issue using systematic debugging. The test fails with [error message]. Follow Phase 1: read errors, reproduce consistently, check recent changes."
      },
      {
        "title": "Complex multi-layer bug",
        "scenario": "Cross-component failure",
        "prompt": "Investigate this bug that spans multiple services. Use root cause tracing to find where the invalid data originated, not where it manifests."
      },
      {
        "title": "After failed fix",
        "scenario": "Previous fix did not work",
        "prompt": "My previous fix did not work. According to systematic debugging, if 3+ fixes failed, this indicates an architectural problem. Analyze whether the pattern is sound."
      },
      {
        "title": "Flaky test",
        "scenario": "Test passes sometimes",
        "prompt": "This test is flaky. Apply condition-based waiting: replace arbitrary timeouts with actual condition polling until the state you need exists."
      }
    ],
    "output_examples": [
      {
        "input": "Debug this test failure: Expected status 'completed' but received 'pending'",
        "output": [
          "Phase 1 - Root Cause Investigation:",
          "  ‚Ä¢ Error: Status mismatch between expected and actual",
          "  ‚Ä¢ Reproduce: Test fails intermittently when status update is slow",
          "  ‚Ä¢ Check recent changes: No recent commits to payment module",
          "  ‚Ä¢ Data flow trace: Test calls paymentProcessor.process() which sets status asynchronously",
          "Root cause: Test uses fixed timeout instead of waiting for status update completion",
          "",
          "Phase 2 - Pattern Analysis:",
          "  ‚Ä¢ Compare with similar working tests in codebase",
          "  ‚Ä¢ Other tests use waitFor() helper to poll for status",
          "",
          "Recommended fix: Replace timeout with condition-based waiting"
        ]
      }
    ],
    "best_practices": [
      "Complete all 4 phases before proposing any fix. Phase 1 must finish before Phase 2 begins.",
      "When a fix fails, form a new hypothesis instead of adding more fixes on top.",
      "After finding root cause, add validation at every layer the data passes through.",
      "If 3+ fixes have failed, question the architecture rather than continuing to fix symptoms."
    ],
    "anti_patterns": [
      "Proposing fixes before reading error messages and stack traces completely",
      "Adding multiple changes at once to see what works",
      "Skipping investigation when the issue seems simple",
      "Using arbitrary timeouts instead of condition-based waiting for async operations"
    ],
    "faq": [
      {
        "question": "Is this skill compatible with all programming languages?",
        "answer": "Yes. The debugging methodology is language-agnostic. Only the code examples are in TypeScript and Bash."
      },
      {
        "question": "What are the limits of this skill?",
        "answer": "The skill provides methodology only. It does not execute tests, run debuggers, or access external tools directly."
      },
      {
        "question": "How does this integrate with other debugging skills?",
        "answer": "Use this first for any bug investigation. It references test-driven-development skill for Phase 4 test creation."
      },
      {
        "question": "Does this skill access any files or send data externally?",
        "answer": "No. The skill is purely prompt-based. Helper scripts exist for local debugging but are not executed by the skill."
      },
      {
        "question": "What if the systematic process takes too long?",
        "answer": "The skill explicitly addresses this: systematic debugging is faster than guess-and-check. Three failed quick fixes cost more time than 30 minutes of investigation."
      },
      {
        "question": "How does this compare to test-driven development?",
        "answer": "TDD writes tests before code. This skill investigates bugs after they occur. Phase 4 creates failing test cases to verify root cause."
      }
    ]
  },
  "file_structure": [
    {
      "name": "condition-based-waiting-example.ts",
      "type": "file",
      "path": "condition-based-waiting-example.ts"
    },
    {
      "name": "condition-based-waiting.md",
      "type": "file",
      "path": "condition-based-waiting.md"
    },
    {
      "name": "CREATION-LOG.md",
      "type": "file",
      "path": "CREATION-LOG.md"
    },
    {
      "name": "defense-in-depth.md",
      "type": "file",
      "path": "defense-in-depth.md"
    },
    {
      "name": "find-polluter.sh",
      "type": "file",
      "path": "find-polluter.sh"
    },
    {
      "name": "root-cause-tracing.md",
      "type": "file",
      "path": "root-cause-tracing.md"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    },
    {
      "name": "test-academic.md",
      "type": "file",
      "path": "test-academic.md"
    },
    {
      "name": "test-pressure-1.md",
      "type": "file",
      "path": "test-pressure-1.md"
    },
    {
      "name": "test-pressure-2.md",
      "type": "file",
      "path": "test-pressure-2.md"
    },
    {
      "name": "test-pressure-3.md",
      "type": "file",
      "path": "test-pressure-3.md"
    }
  ]
}
