{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T13:01:44.918Z",
    "slug": "cycleaddict-parametric-scribe",
    "source_url": "https://github.com/Cycleaddict/parametric-scribe/tree/main/",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "9072a9a7be50d33ba8ecc239b4fd63cffcc68411e799c2d9da4934b0eda65ee3",
    "tree_hash": "893cbbf1178dab9760648c80c6975692eda3dd3e12698f86ab31148231ad317a"
  },
  "skill": {
    "name": "parametric-scribe",
    "description": "Enables \"Time Machine\" coding. Records tasks as a Recipe and allows intelligent replay/modification of history.",
    "summary": "Enables \"Time Machine\" coding. Records tasks as a Recipe and allows intelligent replay/modification ...",
    "icon": "üï∞Ô∏è",
    "version": "1.0.0",
    "author": "Cycleaddict",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "version-control",
      "history",
      "replay",
      "parametric",
      "time-travel"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill contains no executable code and poses no security risks. It operates purely through documentation that instructs AI assistants to maintain a YAML history file of coding tasks.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 3,
    "total_lines": 51,
    "audit_model": "claude",
    "audited_at": "2026-01-10T13:01:44.918Z"
  },
  "content": {
    "user_title": "Enable Time Machine Coding with Parametric History",
    "value_statement": "Traditional AI coding is destructive - once you change direction, previous work is lost. Parametric Scribe creates a non-linear editing experience for code, recording each task as a replayable step that can be modified and intelligently reapplied to new contexts.",
    "seo_keywords": [
      "parametric scribe",
      "time machine coding",
      "AI coding history",
      "Claude Code",
      "Codex",
      "replay coding",
      "non-linear editing",
      "parametric history",
      "intelligent replay",
      "coding timeline"
    ],
    "actual_capabilities": [
      "Records every coding task as a discrete step with intent and outcome",
      "Maintains project history in docs/recipe.yaml file",
      "Enables replay of any step with modifications",
      "Intelligently adapts subsequent steps to new contexts",
      "Supports forking to create variants without losing original history"
    ],
    "limitations": [
      "Requires git for full functionality including hard resets",
      "History is stored locally in docs/recipe.yaml",
      "Replay accuracy depends on AI interpretation of intents",
      "Cannot handle merge conflicts during replay"
    ],
    "use_cases": [
      {
        "target_user": "Software developers",
        "title": "Experiment with Architecture Changes",
        "description": "Try different frameworks or patterns and replay subsequent features to see how they adapt to the new foundation."
      },
      {
        "target_user": "Product teams",
        "title": "Maintain Feature Branches",
        "description": "Keep a clean history of feature development and easily rebase changes when requirements evolve."
      },
      {
        "target_user": "AI coding assistants",
        "title": "Build Non-Destructive Workflows",
        "description": "Enable clients to modify previous decisions without losing the work that followed."
      }
    ],
    "prompt_templates": [
      {
        "title": "Start Recording",
        "scenario": "Begin a new project with history tracking",
        "prompt": "Read parametric-scribe/SKILL.md and start recording our development history. Create a basic Python API server as the first step."
      },
      {
        "title": "Change Previous Step",
        "scenario": "Modify an earlier architectural decision",
        "prompt": "Change Step 2 from using SQLite to PostgreSQL, then replay all subsequent steps to adapt them to the new database."
      },
      {
        "title": "Create Variant",
        "scenario": "Explore alternative implementation paths",
        "prompt": "Create a variant called recipe-fastapi.yaml that changes Step 1 from Flask to FastAPI, then replay the authentication features."
      },
      {
        "title": "Review History",
        "scenario": "Analyze development patterns and decisions",
        "prompt": "Read the recipe.yaml file and summarize the project's evolution, highlighting key architectural decisions and their impacts."
      }
    ],
    "output_examples": [
      {
        "input": "Change Step 1 from Flask to Django and replay subsequent steps",
        "output": [
          "‚úì Loaded recipe.yaml (7 steps recorded)",
          "‚úì Reset to state before Step 1 (empty project)",
          "‚úì Executed: Create Django project instead of Flask",
          "‚úì Replaying Step 2: Authentication adapted for Django (using django-rest-framework)",
          "‚úì Replaying Step 3: Database models converted to Django ORM",
          "‚úì Replaying Step 4: API endpoints updated to Django patterns",
          "‚úì Recipe updated with new file paths and commit SHAs",
          "History successfully replayed with Django foundation"
        ]
      }
    ],
    "best_practices": [
      "Commit changes to git before each major step to ensure clean replay points",
      "Write clear, specific intents in prompts to enable better intelligent replay",
      "Review recipe.yaml periodically to understand project evolution patterns"
    ],
    "anti_patterns": [
      "Making manual changes without updating the recipe file breaks replay capability",
      "Using vague intents like fix stuff prevents intelligent adaptation during replay",
      "Skipping git commits makes it impossible to reset to previous states accurately"
    ],
    "faq": [
      {
        "question": "Is this compatible with my existing git workflow?",
        "answer": "Yes, it enhances git by providing AI-powered replay capabilities. It uses git commits as replay anchors."
      },
      {
        "question": "What are the limits on recipe size?",
        "answer": "No hard limits, but very large projects may require more processing time during intelligent replay."
      },
      {
        "question": "Can I integrate this with my CI/CD pipeline?",
        "answer": "The recipe.yaml file can be version controlled and shared, enabling collaborative history tracking."
      },
      {
        "question": "How is my code data kept safe?",
        "answer": "All data stays local. The skill only reads/writes the recipe.yaml file and uses git commands you already trust."
      },
      {
        "question": "What if replay fails or produces errors?",
        "answer": "You can always checkout any previous git commit to restore a working state. The original history remains intact."
      },
      {
        "question": "How does this compare to git rebase?",
        "answer": "Git rebase only handles code changes. Parametric Scribe also adapts the intent of subsequent steps to new contexts."
      }
    ]
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "recipe.yaml",
          "type": "file",
          "path": "examples/recipe.yaml"
        }
      ]
    },
    {
      "name": "README.md",
      "type": "file",
      "path": "README.md"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
