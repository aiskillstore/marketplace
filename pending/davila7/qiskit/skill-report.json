{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-07T01:26:40.509Z",
    "slug": "davila7-qiskit",
    "source_url": "https://github.com/davila7/claude-code-templates/tree/main/cli-tool/components/skills/scientific/qiskit",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "d6250fb65871960ca64831510a48a4906a5661fb0a7f08500f03187033f41390",
    "tree_hash": "59051afd2443d6c878ef238f4a66251b2cdf4f3097fe8325fee4003cc1a6ced5"
  },
  "skill": {
    "name": "qiskit",
    "description": "Comprehensive quantum computing toolkit for building, optimizing, and executing quantum circuits. Use when working with quantum algorithms, simulations, or quantum hardware including (1) Building quantum circuits with gates and measurements, (2) Running quantum algorithms (VQE, QAOA, Grover), (3) Transpiling/optimizing circuits for hardware, (4) Executing on IBM Quantum or other providers, (5) Quantum chemistry and materials science, (6) Quantum machine learning, (7) Visualizing circuits and results, or (8) Any quantum computing development task.",
    "summary": "Comprehensive quantum computing toolkit for building, optimizing, and executing quantum circuits. Us...",
    "icon": "⚛️",
    "version": "1.0.0",
    "author": "davila7",
    "license": "MIT",
    "category": "research",
    "tags": [
      "quantum-computing",
      "qiskit",
      "ibm-quantum",
      "algorithms",
      "simulation"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation and knowledge skill containing markdown references with code examples. No executable code, scripts, file operations, or network calls. This is a prompt-based skill that provides quantum computing guidance to the AI.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 9,
    "total_lines": 2517,
    "audit_model": "claude",
    "audited_at": "2026-01-07T01:26:40.509Z"
  },
  "content": {
    "user_title": "Build and run quantum circuits",
    "value_statement": "Quantum computing development requires understanding complex circuit design, transpilation, and hardware-specific optimization. This skill provides comprehensive guidance for building quantum circuits, running algorithms like VQE and QAOA on simulators or real hardware, and visualizing results.",
    "seo_keywords": [
      "qiskit",
      "quantum computing",
      "claude",
      "quantum circuits",
      "IBM Quantum",
      "VQE",
      "QAOA",
      "quantum algorithms",
      "quantum machine learning",
      "quantum chemistry"
    ],
    "actual_capabilities": [
      "Build quantum circuits with single-qubit and multi-qubit gates",
      "Execute circuits on local simulators or IBM Quantum hardware",
      "Implement quantum algorithms (VQE, QAOA, Grover)",
      "Transpile and optimize circuits for specific backends",
      "Visualize circuits, results, and quantum states",
      "Create quantum machine learning models with kernels and QNNs"
    ],
    "limitations": [
      "Does not provide actual quantum computing resources (requires IBM Quantum account for hardware)",
      "Does not install Qiskit packages (user must run pip install)",
      "Does not execute circuits on the user's behalf (provides code examples)",
      "Simulator execution is limited by local computational resources"
    ],
    "use_cases": [
      {
        "target_user": "Quantum researchers",
        "title": "Quantum chemistry simulation",
        "description": "Calculate molecular ground state energies and simulate chemical reactions using VQE algorithm"
      },
      {
        "target_user": "Algorithm developers",
        "title": "Optimization algorithms",
        "description": "Implement QAOA for combinatorial optimization problems like MaxCut and portfolio optimization"
      },
      {
        "target_user": "Data scientists",
        "title": "Quantum machine learning",
        "description": "Build quantum kernels and neural networks for classification and pattern recognition tasks"
      }
    ],
    "prompt_templates": [
      {
        "title": "Create Bell state",
        "scenario": "Build first quantum circuit",
        "prompt": "Create a Bell state circuit with Qiskit that entangles two qubits and measures them. Show how to run it with StatevectorSampler locally."
      },
      {
        "title": "Run VQE algorithm",
        "scenario": "Calculate molecular energy",
        "prompt": "Show me how to implement Variational Quantum Eigensolver (VQE) to find the ground state energy of H2 molecule using Qiskit."
      },
      {
        "title": "Transpile for hardware",
        "scenario": "Optimize circuits",
        "prompt": "Write code to transpile a quantum circuit for IBM Quantum hardware with optimization_level=3 and explain the transpilation stages."
      },
      {
        "title": "QAOA for MaxCut",
        "scenario": "Solve optimization problems",
        "prompt": "Implement Quantum Approximate Optimization Algorithm (QAOA) to solve MaxCut on a 4-node graph with Qiskit primitives."
      }
    ],
    "output_examples": [
      {
        "input": "Create a quantum circuit that creates a Bell state and run it on a local simulator",
        "output": [
          "✓ Created 2-qubit quantum circuit with Hadamard and CNOT gates",
          "✓ Applied H(0) for superposition then CX(0,1) for entanglement",
          "✓ Added measurements to both qubits",
          "✓ Ran with StatevectorSampler: 1024 shots",
          "✓ Results: {'00': ~512, '11': ~512} - perfect entanglement confirmed"
        ]
      }
    ],
    "best_practices": [
      "Test circuits with local simulators before running on expensive hardware backends",
      "Always transpile circuits with optimization_level=3 for production workloads",
      "Use Session mode for iterative algorithms like VQE and QAOA to reduce queue times"
    ],
    "anti_patterns": [
      "Running untranspiled circuits directly on hardware without optimization",
      "Using the wrong primitive (Sampler vs Estimator) for your use case",
      "Skipping error mitigation when running on noisy quantum hardware"
    ],
    "faq": [
      {
        "question": "What is the difference between Sampler and Estimator primitives?",
        "answer": "Sampler returns measurement bitstrings and probabilities. Estimator returns expectation values of observables. Use Sampler for optimization/search, Estimator for chemistry/physics."
      },
      {
        "question": "How many qubits can I use on IBM Quantum?",
        "answer": "IBM Quantum offers 100+ qubit systems. Free tier provides access to smaller backends. Check backend.num_qubits and queue times before submitting."
      },
      {
        "question": "Can I run this skill offline?",
        "answer": "Yes, local simulators (StatevectorSampler, AerSimulator) work without accounts. Hardware access requires IBM Quantum account and API token."
      },
      {
        "question": "Is my data safe when running on quantum hardware?",
        "answer": "IBM Quantum may retain job data for quality purposes. Use local simulators for sensitive workloads. Review IBM Quantum terms for compliance needs."
      },
      {
        "question": "Why does my circuit look different after transpilation?",
        "answer": "Transpilation rewrites circuits to use hardware-native gates and respect qubit connectivity. This adds SWAP gates and may increase depth but is necessary for execution."
      },
      {
        "question": "How does Qiskit compare to other quantum frameworks?",
        "answer": "Qiskit offers 83x faster transpilation and 29% fewer two-qubit gates than alternatives. It supports IBM Quantum, IonQ, Amazon Braket, and local simulators."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "algorithms.md",
          "type": "file",
          "path": "references/algorithms.md"
        },
        {
          "name": "backends.md",
          "type": "file",
          "path": "references/backends.md"
        },
        {
          "name": "circuits.md",
          "type": "file",
          "path": "references/circuits.md"
        },
        {
          "name": "patterns.md",
          "type": "file",
          "path": "references/patterns.md"
        },
        {
          "name": "primitives.md",
          "type": "file",
          "path": "references/primitives.md"
        },
        {
          "name": "setup.md",
          "type": "file",
          "path": "references/setup.md"
        },
        {
          "name": "transpilation.md",
          "type": "file",
          "path": "references/transpilation.md"
        },
        {
          "name": "visualization.md",
          "type": "file",
          "path": "references/visualization.md"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
