{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-07T01:19:50.347Z",
    "slug": "davila7-pymc-bayesian-modeling",
    "source_url": "https://github.com/davila7/claude-code-templates/tree/main/cli-tool/components/skills/scientific/pymc",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "00e19da749f7bb73c2f3e77a0f2702908bc3ead862d6f8becf107740e3d48a88",
    "tree_hash": "16518f296356005dcedff3875385d4d328c8be589db78d524f5bca96aa9d6e13"
  },
  "skill": {
    "name": "pymc-bayesian-modeling",
    "description": "Bayesian modeling with PyMC. Build hierarchical models, MCMC (NUTS), variational inference, LOO/WAIC comparison, posterior checks, for probabilistic programming and inference.",
    "summary": "Bayesian modeling with PyMC. Build hierarchical models, MCMC (NUTS), variational inference, LOO/WAIC...",
    "icon": "ðŸ“Š",
    "version": "1.0.0",
    "author": "davila7",
    "license": "MIT",
    "category": "research",
    "tags": [
      "bayesian",
      "probabilistic",
      "mcmc",
      "statistics",
      "data-science"
    ],
    "supported_tools": [
      "claude",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a pure documentation and code template skill with no network calls, no external commands, no credential access, and no file access outside user-specified paths. All code is standard PyMC and scientific Python patterns for Bayesian modeling.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 8,
    "total_lines": 2788,
    "audit_model": "claude",
    "audited_at": "2026-01-07T01:19:50.347Z"
  },
  "content": {
    "user_title": "Build Bayesian Models with PyMC",
    "value_statement": "Bayesian modeling enables uncertainty quantification and probabilistic inference. PyMC provides a modern Python API for building hierarchical models, running MCMC sampling, and comparing models with LOO/WAIC criteria.",
    "seo_keywords": [
      "PyMC Bayesian modeling",
      "MCMC sampling",
      "NUTS sampler",
      "hierarchical models",
      "Bayesian inference",
      "probabilistic programming",
      "LOO model comparison",
      "ArviZ diagnostics",
      "Claude Code",
      "variational inference"
    ],
    "actual_capabilities": [
      "Build Bayesian regression models with PyMC (linear, logistic, Poisson)",
      "Create hierarchical multilevel models with non-centered parameterization",
      "Run MCMC sampling using NUTS algorithm with diagnostic checks",
      "Compare models using LOO and WAIC information criteria",
      "Perform prior and posterior predictive checks",
      "Generate predictions with uncertainty intervals"
    ],
    "limitations": [
      "Requires PyMC, ArviZ, NumPy, and Matplotlib dependencies",
      "Does not provide pre-trained models or data",
      "Does not include visualization beyond basic diagnostic plots",
      "Cannot run on GPU without proper CUDA configuration"
    ],
    "use_cases": [
      {
        "target_user": "Data Scientists",
        "title": "Uncertainty Quantification",
        "description": "Build regression models that provide full posterior distributions instead of point estimates."
      },
      {
        "target_user": "Researchers",
        "title": "Hierarchical Analysis",
        "description": "Analyze grouped data with population-level and group-level parameters using multilevel models."
      },
      {
        "target_user": "Statisticians",
        "title": "Model Comparison",
        "description": "Compare competing models using LOO cross-validation and select the best approach."
      }
    ],
    "prompt_templates": [
      {
        "title": "Simple Linear Model",
        "scenario": "Build a basic Bayesian linear regression",
        "prompt": "Build a Bayesian linear regression model using PyMC with prior predictive checks. Use a Normal prior for coefficients, HalfNormal for sigma, and show how to interpret the posterior distribution."
      },
      {
        "title": "Hierarchical Model",
        "scenario": "Create a multilevel model for grouped data",
        "prompt": "Create a hierarchical model in PyMC with non-centered parameterization. Show hyperpriors for group-level means and standard deviations, and demonstrate shrinkage estimation."
      },
      {
        "title": "Model Diagnostics",
        "scenario": "Check convergence and sampling quality",
        "prompt": "Run diagnostic checks on a PyMC model. Check R-hat values, effective sample size, and divergences. Explain what to do if convergence issues are found."
      },
      {
        "title": "Model Comparison",
        "scenario": "Compare multiple Bayesian models",
        "prompt": "Compare two or more PyMC models using LOO. Explain Pareto-k diagnostics, model weights, and how to interpret the comparison results for model selection."
      }
    ],
    "output_examples": [
      {
        "input": "Build a simple Bayesian linear regression with PyMC",
        "output": [
          "Key steps for Bayesian linear regression:",
          "1. Define priors: alpha ~ Normal(0,1), beta ~ Normal(0,1) for each predictor, sigma ~ HalfNormal(1)",
          "2. Create linear predictor: mu = alpha + X @ beta",
          "3. Set likelihood: y_obs ~ Normal(mu, sigma, observed=y)",
          "4. Run prior predictive check before sampling",
          "5. Sample with pm.sample(draws=2000, tune=1000, chains=4)",
          "6. Check diagnostics: R-hat < 1.01, ESS > 400, no divergences",
          "7. Interpret posterior: az.plot_posterior() for coefficient distributions",
          "8. Generate predictions with uncertainty using sample_posterior_predictive()"
        ]
      }
    ],
    "best_practices": [
      "Always standardize predictors before modeling to improve sampling efficiency",
      "Use weakly informative priors rather than flat priors to avoid sampling issues",
      "Check prior predictive distributions before fitting to validate prior choices",
      "Run at least 4 chains and verify R-hat values below 1.01 before interpreting results"
    ],
    "anti_patterns": [
      "Using flat Uniform(0, 1) or Normal(0, 1000) priors which can cause sampling problems",
      "Skipping prior predictive checks which can lead to misspecified models",
      "Interpreting posterior results without checking convergence diagnostics first",
      "Ignoring divergences which indicate biased sampling in difficult posterior regions"
    ],
    "faq": [
      {
        "question": "What PyMC version is supported?",
        "answer": "PyMC 5.x and later. The API changed significantly from version 4 to 5."
      },
      {
        "question": "How many samples do I need?",
        "answer": "At least 400 effective samples per chain. Draws of 2000 with 4 chains typically provide sufficient samples."
      },
      {
        "question": "Can this integrate with my data pipeline?",
        "answer": "Yes. PyMC models work with pandas DataFrames and NumPy arrays. Use pm.Data() for mutable inputs."
      },
      {
        "question": "Is my data safe?",
        "answer": "All computation runs locally. No data leaves your machine. Models run entirely in your Python environment."
      },
      {
        "question": "Why are my chains not converging?",
        "answer": "Common causes: insufficient tuning, high posterior correlation, or model misspecification. Try increasing target_accept to 0.95 or reparameterizing."
      },
      {
        "question": "How does this compare to sklearn regression?",
        "answer": "PyMC provides full posterior distributions quantifying uncertainty, handles missing data naturally, and supports hierarchical structures sklearn cannot."
      }
    ]
  },
  "file_structure": [
    {
      "name": "assets",
      "type": "dir",
      "path": "assets",
      "children": [
        {
          "name": "hierarchical_model_template.py",
          "type": "file",
          "path": "assets/hierarchical_model_template.py"
        },
        {
          "name": "linear_regression_template.py",
          "type": "file",
          "path": "assets/linear_regression_template.py"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "distributions.md",
          "type": "file",
          "path": "references/distributions.md"
        },
        {
          "name": "sampling_inference.md",
          "type": "file",
          "path": "references/sampling_inference.md"
        },
        {
          "name": "workflows.md",
          "type": "file",
          "path": "references/workflows.md"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "model_comparison.py",
          "type": "file",
          "path": "scripts/model_comparison.py"
        },
        {
          "name": "model_diagnostics.py",
          "type": "file",
          "path": "scripts/model_diagnostics.py"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
