{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-07T01:34:38.723Z",
    "slug": "davila7-systematic-debugging",
    "source_url": "https://github.com/davila7/claude-code-templates/tree/main/cli-tool/components/skills/development/systematic-debugging",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "1a6bb97f9541f57f12c7edb48a9ca62288e84190fbf6713f405dc16e96786af9",
    "tree_hash": "f5739cb15ee65457f7463b994858ee1dc929c5e37cccebc84978126d3bbfde3f"
  },
  "skill": {
    "name": "systematic-debugging",
    "description": "Use when encountering any bug, test failure, or unexpected behavior, before proposing fixes",
    "summary": "Use when encountering any bug, test failure, or unexpected behavior, before proposing fixes",
    "icon": "üîç",
    "version": "1.0.0",
    "author": "davila7",
    "license": "MIT",
    "category": "development",
    "tags": [
      "debugging",
      "root-cause",
      "testing",
      "methodology",
      "troubleshooting"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure prompt-based methodology skill with minimal code artifacts. The single bash helper script (find-polluter.sh) is a transparent diagnostic tool limited to local test execution. No network access, no credential handling, no persistence mechanisms.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 11,
    "total_lines": 1462,
    "audit_model": "claude",
    "audited_at": "2026-01-07T01:34:38.723Z"
  },
  "content": {
    "user_title": "Find root causes before fixing bugs",
    "value_statement": "Random fixes waste time and create new bugs. This skill provides a four-phase framework to systematically investigate issues, trace problems to their source, and implement fixes that actually resolve the underlying cause rather than masking symptoms.",
    "seo_keywords": [
      "systematic debugging",
      "root cause analysis",
      "bug fixing methodology",
      "debugging framework",
      "Claude Code skill",
      "troubleshooting",
      "test-driven debugging",
      "code debugging",
      "error investigation",
      "debugging process"
    ],
    "actual_capabilities": [
      "Four-phase debugging framework: Root Cause Investigation, Pattern Analysis, Hypothesis Testing, and Implementation",
      "Root cause tracing technique to trace bugs backward through call stacks",
      "Defense-in-depth validation patterns for adding validation at multiple layers",
      "Condition-based waiting patterns to replace arbitrary timeouts with polling",
      "Test pollution detection using bisection script",
      "Anti-pattern recognition to avoid common debugging shortcuts"
    ],
    "limitations": [
      "This is a methodology skill - it guides problem-solving but does not execute code fixes automatically",
      "Requires user to follow the process steps; the skill cannot force compliance",
      "Does not provide debugging tools for specific languages or frameworks",
      "Assumes user has access to codebase and can run tests"
    ],
    "use_cases": [
      {
        "target_user": "Software Developers",
        "title": "Fix bugs systematically",
        "description": "Follow the four-phase framework to find root causes and implement lasting fixes instead of quick patches."
      },
      {
        "target_user": "QA Engineers",
        "title": "Debug test failures",
        "description": "Trace flaky tests to their source using condition-based waiting and bisection testing techniques."
      },
      {
        "target_user": "DevOps Engineers",
        "title": "Investigate production issues",
        "description": "Use the structured investigation process to diagnose issues under time pressure without cutting corners."
      }
    ],
    "prompt_templates": [
      {
        "title": "Start debugging",
        "scenario": "Encountered a bug",
        "prompt": "Use the systematic-debugging skill to investigate this issue. Follow the four phases: Root Cause Investigation, Pattern Analysis, Hypothesis and Testing, and Implementation. Do not propose any fixes until you complete Phase 1 and understand the root cause."
      },
      {
        "title": "Test failure",
        "scenario": "Test is failing",
        "prompt": "Apply systematic debugging to this test failure. First, reproduce the failure consistently. Then trace the data flow backward through the call stack to find where the invalid data originated. Document your findings before attempting any fix."
      },
      {
        "title": "Flaky test",
        "scenario": "Intermittent test failure",
        "prompt": "Use condition-based waiting techniques from systematic-debugging to fix this flaky test. Replace arbitrary timeouts with polling that waits for actual conditions. Run tests to verify reliability."
      },
      {
        "title": "Multi-layer bug",
        "scenario": "Complex system failure",
        "prompt": "Apply root cause tracing to trace this issue through all system layers. For each layer boundary, add diagnostic logging. Then apply defense-in-depth validation at every layer the data passes through."
      }
    ],
    "output_examples": [
      {
        "input": "The API returns 500 errors intermittently",
        "output": [
          "Phase 1: Investigating root cause",
          "  - Error message: Connection timeout to payments.api.com",
          "  - Pattern: Occurs during high traffic periods",
          "  - Recent changes: Last deploy 2 days ago",
          "  - Hypothesis: Connection pool exhausted under load",
          "Phase 2: Finding patterns",
          "  - Working services use connection pooling with retry",
          "  - This service has no retry logic",
          "Phase 3: Testing hypothesis",
          "  - Added connection pool metrics",
          "  - Confirmed pool exhaustion at 1000 concurrent requests",
          "Phase 4: Implementing fix",
          "  - Created failing test case for pool exhaustion",
          "  - Added connection retry logic with exponential backoff",
          "  - All tests pass, issue resolved"
        ]
      }
    ],
    "best_practices": [
      "Always complete Phase 1 (Root Cause Investigation) before attempting any fix, even under time pressure",
      "Trace problems backward through the call stack to find the original trigger, not just where symptoms appear",
      "Add validation at every layer data passes through (defense-in-depth) to make bugs structurally impossible"
    ],
    "anti_patterns": [
      "Quick fixes without investigation - this guarantees rework and new bugs",
      "Skipping root cause analysis because the issue seems simple",
      "Trying multiple fixes simultaneously - you cannot isolate what works"
    ],
    "faq": [
      {
        "question": "Is this skill compatible with all programming languages?",
        "answer": "Yes. The debugging methodology is language-agnostic. The principles apply to any codebase regardless of language or framework."
      },
      {
        "question": "How long does the full four-phase process take?",
        "answer": "For simple bugs, 5-10 minutes. Complex issues may take 30-60 minutes. This is faster than the hours of rework from symptom fixes."
      },
      {
        "question": "Can I integrate this with existing debugging tools?",
        "answer": "Yes. The skill complements your existing tools. Use your IDE debugger, logging, and test frameworks while following the systematic process."
      },
      {
        "question": "Does this skill modify my codebase?",
        "answer": "No. The skill provides guidance and prompts. It does not automatically write or modify code. You implement the fixes."
      },
      {
        "question": "What if I cannot reproduce the issue consistently?",
        "answer": "The skill addresses this in Phase 1. Gather more diagnostic data, add logging, and use bisection testing to isolate conditions that trigger the issue."
      },
      {
        "question": "How is this different from test-driven development?",
        "answer": "TDD focuses on writing tests before code. This skill focuses on investigating existing bugs. Phase 4 references TDD for creating failing test cases as proof of reproduction."
      }
    ]
  },
  "file_structure": [
    {
      "name": "condition-based-waiting-example.ts",
      "type": "file",
      "path": "condition-based-waiting-example.ts"
    },
    {
      "name": "condition-based-waiting.md",
      "type": "file",
      "path": "condition-based-waiting.md"
    },
    {
      "name": "CREATION-LOG.md",
      "type": "file",
      "path": "CREATION-LOG.md"
    },
    {
      "name": "defense-in-depth.md",
      "type": "file",
      "path": "defense-in-depth.md"
    },
    {
      "name": "find-polluter.sh",
      "type": "file",
      "path": "find-polluter.sh"
    },
    {
      "name": "root-cause-tracing.md",
      "type": "file",
      "path": "root-cause-tracing.md"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    },
    {
      "name": "test-academic.md",
      "type": "file",
      "path": "test-academic.md"
    },
    {
      "name": "test-pressure-1.md",
      "type": "file",
      "path": "test-pressure-1.md"
    },
    {
      "name": "test-pressure-2.md",
      "type": "file",
      "path": "test-pressure-2.md"
    },
    {
      "name": "test-pressure-3.md",
      "type": "file",
      "path": "test-pressure-3.md"
    }
  ]
}
