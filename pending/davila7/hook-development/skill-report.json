{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-07T01:16:41.730Z",
    "slug": "davila7-hook-development",
    "source_url": "https://github.com/davila7/claude-code-templates/tree/main/cli-tool/components/skills/development/hook-development",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "271528377492e4c5d328c9851785c52bb6efefdbf17e89fe5be16c12fa4adea0",
    "tree_hash": "ceb76ed5cfd6d14d2a8a3fb632a6bd09f92999822672f3230329e03bfebbc583"
  },
  "skill": {
    "name": "Hook Development",
    "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
    "summary": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop ...",
    "icon": "ü™ù",
    "version": "0.1.0",
    "author": "davila7",
    "license": "MIT",
    "category": "development",
    "tags": [
      "hooks",
      "automation",
      "validation",
      "security",
      "claude-code"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a documentation and guidance skill containing shell scripts for hook validation and testing. All scripts are development utilities that read local files, parse JSON, and execute basic shell commands. No network calls, credential access, or data exfiltration patterns detected. Scripts follow security best practices including proper input validation and variable quoting.",
    "risk_factor_evidence": [
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "scripts/hook-linter.sh",
            "line_start": 1,
            "line_end": 154
          },
          {
            "file": "scripts/validate-hook-schema.sh",
            "line_start": 1,
            "line_end": 160
          },
          {
            "file": "scripts/test-hook.sh",
            "line_start": 1,
            "line_end": 253
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "scripts/hook-linter.sh",
            "line_start": 31,
            "line_end": 34
          },
          {
            "file": "scripts/validate-hook-schema.sh",
            "line_start": 22,
            "line_end": 25
          },
          {
            "file": "examples/load-context.sh",
            "line_start": 13,
            "line_end": 52
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "scripts/hook-linter.sh",
            "line_start": 50,
            "line_end": 50
          },
          {
            "file": "scripts/validate-hook-schema.sh",
            "line_start": 32,
            "line_end": 32
          },
          {
            "file": "scripts/test-hook.sh",
            "line_start": 190,
            "line_end": 190
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 11,
    "total_lines": 2781,
    "audit_model": "claude",
    "audited_at": "2026-01-07T01:16:41.730Z"
  },
  "content": {
    "user_title": "Create Claude Code hooks for validation and automation",
    "value_statement": "Claude Code hooks enable event-driven automation for validation, security enforcement, and workflow automation. This skill provides comprehensive guidance for implementing prompt-based and command hooks to control tool execution, enforce policies, and integrate with development workflows.",
    "seo_keywords": [
      "claude code hooks",
      "pretooluse hook",
      "posttooluse hook",
      "stop hook",
      "claude plugin hooks",
      "event-driven automation",
      "hook development",
      "claude code automation",
      "security hooks",
      "validation hooks"
    ],
    "actual_capabilities": [
      "Create PreToolUse hooks to validate and modify tool calls before execution",
      "Create PostToolUse hooks to react to tool results, provide feedback, and log operations",
      "Create Stop and SubagentStop hooks to verify task completion and enforce quality standards",
      "Create SessionStart hooks to load project context and set environment variables",
      "Implement prompt-based hooks using LLM reasoning for complex validation scenarios",
      "Use command hooks with bash scripts for deterministic checks and external tool integration"
    ],
    "limitations": [
      "Hooks load at session start and require Claude Code restart to apply changes",
      "Hooks run in parallel so execution order is non-deterministic",
      "Prompt-based hooks have limited event support (Stop, SubagentStop, UserPromptSubmit, PreToolUse)"
    ],
    "use_cases": [
      {
        "target_user": "Plugin Developers",
        "title": "Build secure plugins",
        "description": "Implement validation hooks in plugins to block dangerous operations, validate file writes, and enforce security policies"
      },
      {
        "target_user": "DevOps Engineers",
        "title": "Automate workflows",
        "description": "Create hooks that enforce test runs, verify builds, and ensure compliance before task completion"
      },
      {
        "target_user": "Security Teams",
        "title": "Enforce policies",
        "description": "Deploy hooks that detect sensitive file access, block privilege escalation, and audit command execution"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic hook setup",
        "scenario": "User wants to create a validation hook",
        "prompt": "Create a PreToolUse hook that validates Write operations. Block writes to system directories like /etc and /sys. Also block writes to files matching .env, secrets, or credentials patterns. Use prompt-based hook type."
      },
      {
        "title": "Security validation",
        "scenario": "User needs bash command validation",
        "prompt": "Create a PreToolUse hook for Bash commands. Block commands containing rm -rf, dd, mkfs, or redirects to /dev/null. For sudo commands, return ask instead of deny. Use both command hook for quick checks and prompt hook for deep analysis."
      },
      {
        "title": "Task completion check",
        "scenario": "User wants to verify task completion",
        "prompt": "Create a Stop hook that reviews the transcript. Verify that if code was modified (Write/Edit tools used), tests were run. Also verify the project builds successfully. Block task completion with a clear reason if requirements are not met."
      },
      {
        "title": "Context loading",
        "scenario": "User needs project context at session start",
        "prompt": "Create a SessionStart hook that detects the project type. Check for package.json (Node.js), Cargo.toml (Rust), go.mod (Go), pyproject.toml (Python), or pom.xml (Java). Set PROJECT_TYPE environment variable in CLAUDE_ENV_FILE. Also detect CI configuration."
      }
    ],
    "output_examples": [
      {
        "input": "Create a hook that blocks dangerous bash commands",
        "output": [
          "‚úÖ PreToolUse hook created for Bash commands",
          "üîí Blocks: rm -rf, dd, mkfs, /dev/null redirects (deny)",
          "‚ö†Ô∏è  Warns: sudo, su commands (ask user)",
          "‚úÖ Approves safe commands: ls, pwd, echo, date, whoami",
          "üìù Configuration saved to hooks/hooks.json"
        ]
      }
    ],
    "best_practices": [
      "Use prompt-based hooks for complex validation that requires context-aware reasoning",
      "Set appropriate timeouts: 5-10s for command hooks, 15-30s for prompt hooks",
      "Always validate JSON output and use set -euo pipefail in bash scripts"
    ],
    "anti_patterns": [
      "Don't use hardcoded paths - use CLAUDE_PLUGIN_ROOT and CLAUDE_PROJECT_DIR environment variables",
      "Don't assume hook execution order - hooks run in parallel",
      "Don't create long-running hooks - they will timeout and block workflows"
    ],
    "faq": [
      {
        "question": "Which Claude tools are supported?",
        "answer": "Works with Claude Code desktop app and CLI. Compatible with Claude, Codex, and Claude Code platforms."
      },
      {
        "question": "What are the timeout limits for hooks?",
        "answer": "Default timeout is 60s for command hooks, 30s for prompt hooks. Maximum is 600s. Keep hooks fast."
      },
      {
        "question": "Can hooks integrate with external tools?",
        "answer": "Yes. Command hooks can run security scanners, linters, or send notifications via curl to webhooks."
      },
      {
        "question": "Is user data safe with hooks?",
        "answer": "Yes. Hooks run locally in your environment. No data is sent to external servers unless your scripts explicitly call external APIs."
      },
      {
        "question": "Why are my hook changes not applying?",
        "answer": "Hooks load at session start. Edit hooks.json, then exit and restart Claude Code for changes to take effect."
      },
      {
        "question": "How do hooks differ from agent instructions?",
        "answer": "Hooks enforce mandatory checks on every tool call or event. Agent instructions guide behavior. Hooks cannot be bypassed by the agent."
      }
    ]
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "load-context.sh",
          "type": "file",
          "path": "examples/load-context.sh"
        },
        {
          "name": "validate-bash.sh",
          "type": "file",
          "path": "examples/validate-bash.sh"
        },
        {
          "name": "validate-write.sh",
          "type": "file",
          "path": "examples/validate-write.sh"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "advanced.md",
          "type": "file",
          "path": "references/advanced.md"
        },
        {
          "name": "migration.md",
          "type": "file",
          "path": "references/migration.md"
        },
        {
          "name": "patterns.md",
          "type": "file",
          "path": "references/patterns.md"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "hook-linter.sh",
          "type": "file",
          "path": "scripts/hook-linter.sh"
        },
        {
          "name": "README.md",
          "type": "file",
          "path": "scripts/README.md"
        },
        {
          "name": "test-hook.sh",
          "type": "file",
          "path": "scripts/test-hook.sh"
        },
        {
          "name": "validate-hook-schema.sh",
          "type": "file",
          "path": "scripts/validate-hook-schema.sh"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
