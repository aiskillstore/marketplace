{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T10:37:00.358Z",
    "slug": "asmayaseen-fetching-library-docs",
    "source_url": "https://github.com/Asmayaseen/hackathon-2/tree/main/.claude/skills/fetching-library-docs",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "10faf7deb12e07515d593f65700dff6e6e86843e6a2520020ded3e5c7f3d1eeb",
    "tree_hash": "3567693c88c130fe846a16a18cb76aa8ba2e9f974752921790a1d16004c044c5"
  },
  "skill": {
    "name": "fetching-library-docs",
    "description": "Token-efficient library API documentation fetcher using Context7 MCP with 77% token savings.\nFetches code examples, API references, and usage patterns for published libraries (React,\nNext.js, Prisma, etc). Use when users ask \"how do I use X library\", need code examples,\nwant API syntax, or are learning a framework's official API. Triggers: \"Show me React hooks\",\n\"Prisma query syntax\", \"Next.js routing API\". NOT for exploring repo internals/source code\n(use researching-with-deepwiki) or local files.\n",
    "summary": "Token-efficient library API documentation fetcher using Context7 MCP with 77% token savings.\nFetches...",
    "icon": "ðŸ“š",
    "version": "1.0.0",
    "author": "Asmayaseen",
    "license": "MIT",
    "category": "documentation",
    "tags": [
      "documentation",
      "mcp",
      "api-reference",
      "code-examples",
      "context7"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "external_commands",
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Legitimate documentation fetcher using Context7 MCP. Contains shell scripts and subprocess execution for MCP server communication. Minor concerns around library name handling in shell commands but purpose matches behavior. No credential or sensitive data access attempts.",
    "risk_factor_evidence": [
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "scripts/fetch-docs.sh",
            "line_start": 1,
            "line_end": 207
          },
          {
            "file": "scripts/mcp-client.py",
            "line_start": 1,
            "line_end": 490
          },
          {
            "file": "scripts/extract-code-blocks.sh",
            "line_start": 1,
            "line_end": 56
          },
          {
            "file": "scripts/extract-signatures.sh",
            "line_start": 1,
            "line_end": 42
          },
          {
            "file": "scripts/extract-notes.sh",
            "line_start": 1,
            "line_end": 12
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "scripts/start-server.sh",
            "line_start": 15,
            "line_end": 15
          },
          {
            "file": "scripts/fetch-raw.sh",
            "line_start": 35,
            "line_end": 35
          },
          {
            "file": "scripts/mcp-client.py",
            "line_start": 204,
            "line_end": 212
          }
        ]
      },
      {
        "factor": "network",
        "evidence": [
          {
            "file": "scripts/mcp-client.py",
            "line_start": 146,
            "line_end": 182
          },
          {
            "file": "scripts/fetch-raw.sh",
            "line_start": 1,
            "line_end": 38
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [
      {
        "title": "Shell injection via library name parameter",
        "description": "Library name is passed to subprocess without full sanitization in fetch-docs.sh line 93-96. The command constructs a JSON payload with the library name embedded in a shell-executed string. While basic escaping is present, a specially crafted library name could potentially inject shell commands. The vulnerable pattern: python3 \"$SCRIPT_DIR/mcp-client.py\" call -s \"npx -y @upstash/context7-mcp\" -t resolve-library-id -p \"{\\\"libraryName\\\": \\\"$LIBRARY_NAME\\\"}\"",
        "locations": [
          {
            "file": "scripts/fetch-docs.sh",
            "line_start": 93,
            "line_end": 96
          }
        ]
      }
    ],
    "low_findings": [
      {
        "title": "Subprocess with shell=True for stdio transport",
        "description": "mcp-client.py uses subprocess.Popen with shell=True for stdio transport at line 204. This is standard for MCP servers but creates an attack surface. The shell=True flag allows command injection if input is not properly sanitized. Code: self._process = subprocess.Popen(self.command, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, bufsize=1)",
        "locations": [
          {
            "file": "scripts/mcp-client.py",
            "line_start": 204,
            "line_end": 212
          }
        ]
      },
      {
        "title": "PID file creation in /tmp directory",
        "description": "start-server.sh creates PID files in /tmp with predictable names at line 6 and 16. While not a critical vulnerability, PID files in /tmp with world-writable permissions could potentially be exploited in certain scenarios. Pattern: PID_FILE=\"/tmp/context7-mcp-${PORT}.pid\"",
        "locations": [
          {
            "file": "scripts/start-server.sh",
            "line_start": 6,
            "line_end": 16
          }
        ]
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 11,
    "total_lines": 1363,
    "audit_model": "claude",
    "audited_at": "2026-01-10T10:37:00.358Z"
  },
  "content": {
    "user_title": "Fetch Library Documentation Efficiently",
    "value_statement": "Library API documentation fetcher that reduces token usage by 77% through shell-based filtering. Fetches code examples, API references, and usage patterns for popular libraries without filling context with verbose documentation.",
    "seo_keywords": [
      "Claude documentation fetcher",
      "Context7 MCP library docs",
      "React API documentation",
      "Next.js documentation",
      "Prisma documentation",
      "code examples fetcher",
      "API reference generator",
      "Claude Code documentation tool",
      "library documentation lookup",
      "token-efficient docs"
    ],
    "actual_capabilities": [
      "Fetch code examples for any library (React, Next.js, Prisma, Express, etc.)",
      "Extract API signatures and type definitions from documentation",
      "Filter documentation to essential content using shell pipelines",
      "Resolve library names to Context7 IDs automatically",
      "Support code mode (examples) and info mode (concepts)",
      "Provide pagination for deep documentation exploration"
    ],
    "limitations": [
      "Requires Context7 MCP server to be running or available",
      "Cannot access local repository source code (use researching-with-deepwiki instead)",
      "Only works with libraries that have Context7-compatible documentation",
      "Token savings depend on documentation size and topic specificity"
    ],
    "use_cases": [
      {
        "target_user": "Frontend Developers",
        "title": "Get React Hook Examples",
        "description": "Quickly fetch useState, useEffect, and custom hook examples with proper API signatures."
      },
      {
        "target_user": "Backend Developers",
        "title": "Look Up Prisma Queries",
        "description": "Find Prisma ORM query syntax, model definitions, and database patterns without reading full docs."
      },
      {
        "target_user": "Learning Developers",
        "title": "Explore Next.js Routing",
        "description": "Understand Next.js app router, file-based routing, and dynamic segments with focused examples."
      }
    ],
    "prompt_templates": [
      {
        "title": "Quick Code Lookup",
        "scenario": "User wants library code examples",
        "prompt": "Show me {library} {topic} examples with the fetching-library-docs skill"
      },
      {
        "title": "API Signature Search",
        "scenario": "User needs specific API syntax",
        "prompt": "Find the API signatures for {library} {feature} using fetching-library-docs"
      },
      {
        "title": "Concept Learning",
        "scenario": "User wants to understand concepts",
        "prompt": "Explain how {library} {topic} works with info mode from fetching-library-docs"
      },
      {
        "title": "Deep Dive",
        "scenario": "User needs comprehensive information",
        "prompt": "Get comprehensive documentation on {library} {topic} across multiple pages using fetching-library-docs"
      }
    ],
    "output_examples": [
      {
        "input": "Show me React useState examples",
        "output": [
          "## Code Examples",
          "### Example 1: Basic useState",
          "```jsx",
          "import { useState } from 'react';",
          "function Counter() {",
          "  const [count, setCount] = useState(0);",
          "  return <button onClick={() => setCount(count + 1)}>{count}</button>;",
          "}",
          "```",
          "## API Signatures",
          "- `useState(initialValue): [value, setValue]`",
          "## Important Notes",
          "- State updates are asynchronous",
          "- Functional updates available when new state depends on previous"
        ]
      }
    ],
    "best_practices": [
      "Use the main fetch-docs.sh script for all documentation requests to benefit from token filtering",
      "Specify --mode code for examples or --mode info for conceptual explanations based on your needs",
      "Use --library-id directly when you know the exact library ID for faster lookups",
      "Add --verbose flag to monitor token savings and ensure efficiency"
    ],
    "anti_patterns": [
      "Do not call mcp-client.py directly as it bypasses the token-efficient filtering pipeline",
      "Avoid using broad topics like 'all features' which reduces filtering effectiveness",
      "Do not use for local repository source code exploration (use researching-with-deepwiki instead)",
      "Avoid assuming library names without trying variations (react, react.js, reactjs)"
    ],
    "faq": [
      {
        "question": "Which AI tools support this skill?",
        "answer": "Works with Claude, Codex, and Claude Code. Requires Context7 MCP server to be running."
      },
      {
        "question": "What libraries are supported?",
        "answer": "Any library with Context7-compatible documentation including React, Next.js, Prisma, Express, MongoDB, Vue, FastAPI, Django, and many more."
      },
      {
        "question": "How much token savings can I expect?",
        "answer": "Typical savings of 77% compared to raw MCP responses. A 934-token response becomes approximately 205 tokens after filtering."
      },
      {
        "question": "Is my data sent to external servers?",
        "answer": "Documentation is fetched from library sources via Context7 MCP. Only filtered content enters your AI context. No user data is stored or transmitted."
      },
      {
        "question": "Why am I getting no results?",
        "answer": "Try name variations like 'react' vs 'react.js', use --mode info for concepts, or broaden your topic. Check that Context7 MCP server is running."
      },
      {
        "question": "How does this compare to direct MCP calls?",
        "answer": "This skill uses shell pipelines to filter documentation before it enters your context. Direct MCP calls return full documentation. This skill returns only code examples, signatures, and key notes."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "context7-tools.md",
          "type": "file",
          "path": "references/context7-tools.md"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "extract-code-blocks.sh",
          "type": "file",
          "path": "scripts/extract-code-blocks.sh"
        },
        {
          "name": "extract-notes.sh",
          "type": "file",
          "path": "scripts/extract-notes.sh"
        },
        {
          "name": "extract-signatures.sh",
          "type": "file",
          "path": "scripts/extract-signatures.sh"
        },
        {
          "name": "fetch-docs.sh",
          "type": "file",
          "path": "scripts/fetch-docs.sh"
        },
        {
          "name": "fetch-raw.sh",
          "type": "file",
          "path": "scripts/fetch-raw.sh"
        },
        {
          "name": "mcp-client.py",
          "type": "file",
          "path": "scripts/mcp-client.py"
        },
        {
          "name": "start-server.sh",
          "type": "file",
          "path": "scripts/start-server.sh"
        },
        {
          "name": "stop-server.sh",
          "type": "file",
          "path": "scripts/stop-server.sh"
        },
        {
          "name": "verify.py",
          "type": "file",
          "path": "scripts/verify.py"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
