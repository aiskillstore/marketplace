{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T11:12:56.524Z",
    "slug": "barissozen-latency-tracker",
    "source_url": "https://github.com/BarisSozen/claude/tree/main/.claude/skills/latency-tracker",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "d21363bdc47e7e18070da249076aab64778daac6a4387397026b8ff5b0f31122",
    "tree_hash": "78d748784f370a3738ffc95a059714891e7e6513dc59646cd01435698dd46357"
  },
  "skill": {
    "name": "Latency Tracker",
    "description": "---",
    "summary": "---",
    "icon": "⏱️",
    "version": "1.0.0",
    "author": "BarisSozen",
    "license": "MIT",
    "category": "data",
    "tags": [
      "performance",
      "monitoring",
      "latency",
      "mev",
      "instrumentation"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill consists of a single SKILL.md documentation file with no executable code. The file contains only markdown documentation, YAML frontmatter, and illustrative TypeScript code examples. No network calls, filesystem access, environment variable reading, external commands, or scripts were detected.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 59,
    "audit_model": "claude",
    "audited_at": "2026-01-10T11:12:56.524Z"
  },
  "content": {
    "user_title": "Track latency across MEV infrastructure",
    "value_statement": "MEV infrastructure requires precise latency monitoring to maintain competitive edge. This skill provides per-call and aggregated latency tracking to identify bottlenecks, debug slow operations, and set alerting thresholds for performance anomalies.",
    "seo_keywords": [
      "latency tracking",
      "performance monitoring",
      "MEV infrastructure",
      "debugging slow operations",
      "instrumentation",
      "latency alerts",
      "Claude performance",
      "Codex tracing",
      "speed optimization",
      "timing analysis"
    ],
    "actual_capabilities": [
      "Track per-call latency with nested span hierarchy",
      "Monitor aggregated latency across e2e flows",
      "Debug slow operations with granular timing data",
      "Configure alert thresholds for latency anomalies",
      "Instrument code paths with tracker.span() calls",
      "Structure spans from root e2e_flow to individual calls"
    ],
    "limitations": [
      "Requires integration with existing MEV infrastructure code",
      "Alert thresholds must be configured manually",
      "Does not provide automatic latency optimization",
      "Performance impact from instrumentation not quantified"
    ],
    "use_cases": [
      {
        "target_user": "MEV traders",
        "title": "Optimize execution speed",
        "description": "Track latency across transaction flow to identify and eliminate performance bottlenecks in trading strategies."
      },
      {
        "target_user": "DevOps engineers",
        "title": "Monitor infrastructure health",
        "description": "Set up latency alerts to detect performance degradation in RPC calls and transaction processing."
      },
      {
        "target_user": "Protocol developers",
        "title": "Profile smart contract interactions",
        "description": "Instrument contract calls to understand timing characteristics and optimize gas usage patterns."
      }
    ],
    "prompt_templates": [
      {
        "title": "Track transaction flow",
        "scenario": "Monitoring MEV transaction latency",
        "prompt": "Track the latency of my transaction flow from submission to confirmation using the latency tracker skill."
      },
      {
        "title": "Debug slow RPC calls",
        "scenario": "Investigating RPC performance issues",
        "prompt": "Instrument my eth_call RPC operations to identify which specific calls are causing latency spikes."
      },
      {
        "title": "Set latency alerts",
        "scenario": "Configuring performance monitoring",
        "prompt": "Set up alert thresholds for my hot path operations where expected latency is 5-15ms."
      },
      {
        "title": "Profile complete flow",
        "scenario": "End-to-end latency analysis",
        "prompt": "Create a span hierarchy for my complete MEV strategy from e2e_flow through rust_call to tx_confirm."
      }
    ],
    "output_examples": [
      {
        "input": "Track the latency of my transaction flow",
        "output": [
          "✓ Span hierarchy created: e2e_flow (root)",
          "  ├── rust_hotpath_call (5-15ms target)",
          "  │   └── rpc_eth_call (5-20ms target)",
          "  ├── tx_submit (10-50ms target)",
          "  └── tx_confirm (1-15s target)",
          "✓ Alert thresholds configured: rust_hotpath >30ms, rpc_eth_call >50ms"
        ]
      }
    ],
    "best_practices": [
      "Define span hierarchy before instrumentation to ensure consistent tracking across all code paths.",
      "Set alert thresholds based on actual production measurements, not theoretical limits.",
      "Use nested spans to isolate whether latency originates from hot path or submission logic."
    ],
    "anti_patterns": [
      "Creating spans without defined expected latency ranges makes alert configuration impossible.",
      "Instrumenting every single function call creates excessive overhead and noise.",
      "Setting alert thresholds too tight causes alert fatigue and masks real issues."
    ],
    "faq": [
      {
        "question": "What latency ranges should I expect for MEV operations?",
        "answer": "Typical targets: rust_hotpath_call 5-15ms, rpc_eth_call 5-20ms, tx_submit 10-50ms, tx_confirm 1-15s."
      },
      {
        "question": "How do I configure alert thresholds?",
        "answer": "Set thresholds based on expected latency plus margin. For hot path, alert at 2x expected (e.g., >30ms for 5-15ms target)."
      },
      {
        "question": "Does latency tracking impact performance?",
        "answer": "Minimal overhead from span creation and timing capture. Avoid instrumenting high-frequency micro-operations."
      },
      {
        "question": "What spans should I create for a new strategy?",
        "answer": "Start with root e2e_flow, then add children for each major operation: rust_call, RPC calls, submit, confirm."
      },
      {
        "question": "Is my latency data stored or transmitted?",
        "answer": "This skill generates tracking code and metrics locally. Data handling depends on your implementation."
      },
      {
        "question": "How does this differ from generic profiling tools?",
        "answer": "This skill is purpose-built for MEV workflows with predefined spans for common operations like tx_confirm."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
