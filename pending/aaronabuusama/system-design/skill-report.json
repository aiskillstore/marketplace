{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T09:56:09.622Z",
    "slug": "aaronabuusama-system-design",
    "source_url": "https://github.com/AaronAbuUsama/alpha-arena/tree/develop/.claude/skills/system-design",
    "source_ref": "develop",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "c159bf1f9d6fa22198170b31ea93a2127ee67466bd8867da8f87556c2622ffd2",
    "tree_hash": "5b48f9ba347812696288fdddbd29ed0ff89be56952ef6708ae82eeab604f662f"
  },
  "skill": {
    "name": "system-design",
    "description": "CTO's deputy for software architecture using Clean/Hexagonal Architecture principles.\nSocratic approach - asks probing questions to help YOU make informed design decisions.\nGuides through Discovery ‚Üí Modeling ‚Üí Boundaries ‚Üí Scaffolding phases.\nOutputs TypeScript scaffolds with ports, adapters, and domain layers.\nUSE WHEN user says 'architect', 'system design', 'hexagonal', 'clean architecture',\n'ports and adapters', 'design this system', 'structure this project', or needs\nhelp thinking through complex software structure.\n",
    "summary": "CTO's deputy for software architecture using Clean/Hexagonal Architecture principles.\nSocratic appro...",
    "icon": "üèõÔ∏è",
    "version": "1.0.0",
    "author": "AaronAbuUsama",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "architecture",
      "clean-code",
      "domain-driven-design",
      "typescript",
      "hexagonal-architecture"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation and template skill with no executable code. Contains markdown guides and TypeScript code examples for software architecture patterns. No network calls, file system access, command execution, or environment variable access. All content is educational reference material.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 18,
    "total_lines": 2590,
    "audit_model": "claude",
    "audited_at": "2026-01-10T09:56:09.622Z"
  },
  "content": {
    "user_title": "Design maintainable software architecture",
    "value_statement": "Software projects often suffer from poor architecture that leads to technical debt and slow development. This skill guides you through a structured Socratic process to design Clean/Hexagonal Architecture systems with clear boundaries, testable components, and documented decisions.",
    "seo_keywords": [
      "system design",
      "clean architecture",
      "hexagonal architecture",
      "ports and adapters",
      "domain driven design",
      "typescript architecture",
      "software architecture",
      "claude code",
      "claude",
      "codex"
    ],
    "actual_capabilities": [
      "Guides 4-phase architecture workflow (Discovery, Modeling, Boundaries, Scaffolding)",
      "Generates TypeScript project scaffolds with domain/application/infrastructure/interface layers",
      "Creates Mermaid diagrams for domain models and relationship mappings",
      "Produces Architecture Decision Records (ADRs) with context and tradeoffs",
      "Provides port and adapter interface templates for dependency inversion"
    ],
    "limitations": [
      "Does not implement business logic or application features",
      "Does not generate complete working code - creates scaffolding only",
      "Does not execute code or interact with external systems",
      "Requires user decisions at each architectural checkpoint"
    ],
    "use_cases": [
      {
        "target_user": "Senior developers",
        "title": "Architect new microservices",
        "description": "Design new service architecture with clear boundaries, dependency isolation, and swappable adapters"
      },
      {
        "target_user": "Tech leads",
        "title": "Document architectural decisions",
        "description": "Create ADRs that capture context, tradeoffs, and consequences for team alignment"
      },
      {
        "target_user": "Mid-level developers",
        "title": "Learn clean architecture patterns",
        "description": "Understand domain entities, value objects, aggregates, and how to structure maintainable code"
      }
    ],
    "prompt_templates": [
      {
        "title": "New system design",
        "scenario": "Starting fresh architecture",
        "prompt": "I need to architect [describe your system]. Start with Phase 1 Discovery."
      },
      {
        "title": "Resume session",
        "scenario": "Continuing from phase",
        "prompt": "Continue from [phase name] for our existing architecture session."
      },
      {
        "title": "Generate scaffold",
        "scenario": "Quick project setup",
        "prompt": "Generate a TypeScript hexagonal scaffold for a [entity name] feature with these decisions: [list known ports/adapters]."
      },
      {
        "title": "Review architecture",
        "scenario": "Existing code review",
        "prompt": "Review my current code structure and help me refactor to Clean Architecture. Here's my current file layout: [describe structure]."
      }
    ],
    "output_examples": [
      {
        "input": "Design a payment processing service using Clean Architecture",
        "output": [
          "üìã Phase 1: Discovery Questions",
          "‚Ä¢ Who is the primary user (merchant, customer, internal system)?",
          "‚Ä¢ What payment methods must be supported?",
          "‚Ä¢ What are the regulatory constraints?",
          "‚Ä¢ How do you define success for this service?",
          "",
          "üí° Key insight: Start by understanding the problem before defining solutions."
        ]
      }
    ],
    "best_practices": [
      "Never skip the Discovery phase - understanding the problem prevents expensive architectural mistakes",
      "Define ports (interfaces) before implementations - this ensures dependency inversion",
      "Document decisions as ADRs while context is fresh - future developers will thank you"
    ],
    "anti_patterns": [
      "Jumping to code before understanding the domain and identifying bounded contexts",
      "Putting business logic in controllers or infrastructure instead of domain layer",
      "Using technology-specific terms in domain interfaces (leaky abstractions)"
    ],
    "faq": [
      {
        "question": "What is the difference between Clean and Hexagonal Architecture?",
        "answer": "They share the same core principle (dependency inversion) but structure layers differently. Clean uses concentric circles; Hexagonal uses a hexagon with ports/adapters on each side."
      },
      {
        "question": "How long does a full architecture session take?",
        "answer": "A complete session from Discovery to Scaffolding typically takes 1-2 hours depending on system complexity and user decisions required."
      },
      {
        "question": "Can I use this with existing projects?",
        "answer": "Yes. Use the boundary definition and ADR templates to document current architecture, then plan incremental refactoring to cleaner separation."
      },
      {
        "question": "What data does this skill access?",
        "answer": "None. This skill only reads its own documentation files and generates text/code output. No access to your project files or system data."
      },
      {
        "question": "How is this different from generic code generation?",
        "answer": "This skill asks questions first and generates scaffolding based on user decisions. It creates architectural structure, not implementation code."
      },
      {
        "question": "Which patterns does this skill recommend?",
        "answer": "It presents multiple options with tradeoffs (ports/adapters, dependency injection, domain events, value objects) and lets users choose based on their context."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "clean-architecture.md",
          "type": "file",
          "path": "references/clean-architecture.md"
        },
        {
          "name": "common-mistakes.md",
          "type": "file",
          "path": "references/common-mistakes.md"
        },
        {
          "name": "dependency-inversion.md",
          "type": "file",
          "path": "references/dependency-inversion.md"
        },
        {
          "name": "domain-modeling.md",
          "type": "file",
          "path": "references/domain-modeling.md"
        },
        {
          "name": "hexagonal-architecture.md",
          "type": "file",
          "path": "references/hexagonal-architecture.md"
        }
      ]
    },
    {
      "name": "templates",
      "type": "dir",
      "path": "templates",
      "children": [
        {
          "name": "adr-template.md",
          "type": "file",
          "path": "templates/adr-template.md"
        },
        {
          "name": "controller-template.md",
          "type": "file",
          "path": "templates/controller-template.md"
        },
        {
          "name": "entity-template.md",
          "type": "file",
          "path": "templates/entity-template.md"
        },
        {
          "name": "port-adapter-interface.md",
          "type": "file",
          "path": "templates/port-adapter-interface.md"
        },
        {
          "name": "repository-template.md",
          "type": "file",
          "path": "templates/repository-template.md"
        },
        {
          "name": "ts-hexagonal-scaffold.md",
          "type": "file",
          "path": "templates/ts-hexagonal-scaffold.md"
        },
        {
          "name": "use-case-template.md",
          "type": "file",
          "path": "templates/use-case-template.md"
        },
        {
          "name": "value-object-template.md",
          "type": "file",
          "path": "templates/value-object-template.md"
        }
      ]
    },
    {
      "name": "workflows",
      "type": "dir",
      "path": "workflows",
      "children": [
        {
          "name": "01-discovery.md",
          "type": "file",
          "path": "workflows/01-discovery.md"
        },
        {
          "name": "02-modeling.md",
          "type": "file",
          "path": "workflows/02-modeling.md"
        },
        {
          "name": "03-boundaries.md",
          "type": "file",
          "path": "workflows/03-boundaries.md"
        },
        {
          "name": "04-scaffolding.md",
          "type": "file",
          "path": "workflows/04-scaffolding.md"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
