{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-02-07T08:40:20.873Z",
    "slug": "jeffallan-flutter-expert",
    "source_url": "https://github.com/jeffallan/claude-skills/tree/main/skills/flutter-expert/",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "46650eb47239809ea01ff1438810f775043b42940ecc624d7b52c7afdab46a76",
    "tree_hash": "22191655ae0608fe26bdbb5c85e0a4b982375e5272f32f33910c9d08a6cd9cdd"
  },
  "skill": {
    "name": "flutter-expert",
    "description": "Use when building cross-platform applications with Flutter 3+ and Dart. Invoke for widget development, Riverpod/Bloc state management, GoRouter navigation, platform-specific implementations, performance optimization.",
    "summary": "Specialist skill for building high-performance cross-platform Flutter applications with Dart, Riverpod, Bloc, and GoRouter.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "Jeffallan",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "Flutter",
      "Dart",
      "mobile-development",
      "cross-platform",
      "state-management",
      "Riverpod",
      "Bloc",
      "GoRouter"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill is a documentation/reference skill for Flutter development. Static scanner flagged 88 external_command patterns and 1 network pattern, but all findings are FALSE POSITIVES. The scanner misidentified Dart code blocks and CLI command documentation examples as shell execution. No actual security risks exist. All content is legitimate Flutter/Dart documentation with no prompt injection attempts.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 7,
    "total_lines": 937,
    "audit_model": "claude",
    "audited_at": "2026-02-07T08:41:00.000Z",
    "risk_factors": [],
    "risk_factor_evidence": []
  },
  "content": {
    "user_title": "Build cross-platform Flutter apps",
    "value_statement": "Building mobile applications across iOS, Android, and web requires deep expertise in Flutter, state management, and platform-specific implementations. This skill provides comprehensive guidance for Flutter 3+ development with Riverpod, Bloc, and GoRouter patterns.",
    "seo_keywords": [
      "Flutter",
      "Dart",
      "mobile development",
      "cross-platform",
      "state management",
      "Riverpod",
      "Bloc",
      "GoRouter",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Implement Flutter widgets with const optimization and proper state management",
      "Set up Riverpod providers, Notifiers, and AsyncNotifier patterns",
      "Create Bloc and Cubit architectures for complex state flows",
      "Configure GoRouter navigation with deep linking and auth guards",
      "Optimize Flutter performance using DevTools profiling and const constructors",
      "Structure Flutter projects with clean architecture principles"
    ],
    "limitations": [
      "Does not generate complete production apps from scratch",
      "Does not provide backend API implementation",
      "Does not handle platform-specific native code beyond guidance",
      "Does not test or execute generated code"
    ],
    "use_cases": [
      {
        "title": "Mobile developer building new Flutter app",
        "description": "Get guidance on setting up project structure, choosing state management approach, and implementing core widgets following Flutter best practices.",
        "target_user": "Mobile developers new to Flutter"
      },
      {
        "title": "Experienced Flutter engineer optimizing performance",
        "description": "Learn performance optimization techniques including const widgets, selective rebuilding, RepaintBoundary usage, and DevTools profiling.",
        "target_user": "Experienced Flutter developers"
      },
      {
        "title": "Full-stack developer adding Flutter to stack",
        "description": "Understand Flutter patterns and architecture to integrate with existing backend services and implement cross-platform features.",
        "target_user": "Full-stack developers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Create a new Flutter screen",
        "prompt": "Create a Flutter screen with Riverpod state management that displays a list of items from an API. Include error handling, loading states, and pull-to-refresh functionality.",
        "scenario": "Building a new feature screen with async data"
      },
      {
        "title": "Implement authentication flow",
        "prompt": "Design a Bloc-based authentication flow with login, logout, and protected routes using GoRouter with auth redirect. Include session management and error states.",
        "scenario": "Implementing user authentication"
      },
      {
        "title": "Optimize widget rebuilds",
        "prompt": "Review this Flutter widget and optimize unnecessary rebuilds. Show how to use const constructors, RepaintBoundary, and selective provider watching with select().",
        "scenario": "Improving app performance"
      },
      {
        "title": "Set up project structure",
        "prompt": "Create a clean Flutter project structure for a medium-sized app. Include feature-based directory organization, dependency injection setup, and routing configuration.",
        "scenario": "Starting a new Flutter project"
      }
    ],
    "output_examples": [
      {
        "input": "Create a Riverpod Notifier for a todo list with add, toggle, and remove functionality",
        "output": [
          "A complete Dart file with @riverpod TodoList class extending StateNotifier<List<Todo>>",
          "Methods for add, toggle, and remove with proper state updates",
          "Example usage in a ConsumerWidget with ref.watch and ref.read",
          "Type-safe state management following Riverpod 2.0 patterns"
        ]
      },
      {
        "input": "Set up GoRouter with auth guard and deep linking",
        "output": [
          "GoRouter configuration with initialLocation and redirect handler",
          "AuthBloc integration in redirect to check authentication state",
          "Route parameters for deep linking (e.g., /details/:id)",
          "ShellRoute for persistent bottom navigation"
        ]
      }
    ],
    "best_practices": [
      "Use const constructors on all static widgets to minimize rebuild overhead",
      "Choose Riverpod for simple state and Bloc for complex event-driven workflows",
      "Profile with DevTools before optimizing - measure, do not guess",
      "Separate UI and business logic using proper state management patterns"
    ],
    "anti_patterns": [
      "Building widgets inside build() methods - extract to const constructors",
      "Using setState for app-wide state - use Riverpod providers instead",
      "Skipping keys on list items - causes performance and animation issues",
      "Blocking UI thread with heavy computation - use compute() and isolates"
    ],
    "faq": [
      {
        "question": "When should I use Riverpod vs Bloc?",
        "answer": "Use Riverpod for simple to moderate state management needs, particularly with reactive patterns. Use Bloc when you need explicit event-driven state transitions, complex business logic, or highly testable flows. Riverpod is generally simpler to set up."
      },
      {
        "question": "How do I optimize Flutter app performance?",
        "answer": "Use const constructors everywhere possible, implement keys on list items, use ref.watch with select() for selective rebuilding, wrap expensive widgets in RepaintBoundary, and use ListView.builder for long lists. Always profile with DevTools first."
      },
      {
        "question": "What is the recommended project structure?",
        "answer": "Use feature-based organization with folders for features, core services, shared widgets, and DI. Separate models, providers, and widgets within each feature. Avoid god files and keep widgets small and focused."
      },
      {
        "question": "How do I implement deep linking in Flutter?",
        "answer": "Use GoRouter with path parameters (e.g., /details/:id). Configure platform-specific intent filters in AndroidManifest.xml and Info.plist. Test with flutter run and use uni_links package for handling incoming links."
      },
      {
        "question": "How do I test Flutter widgets and state?",
        "answer": "Use flutter_test for widget tests with pumpWidget and find.byType. Test providers by reading values directly. Test Blocs using bloc_test package with expect() assertions on states."
      },
      {
        "question": "What are const constructors and why use them?",
        "answer": "Const constructors create compile-time constant widgets that Flutter can reuse across rebuilds. They prevent unnecessary widget recreation, reducing rebuild overhead and improving performance. Always use const on static widgets."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "bloc-state.md",
          "type": "file",
          "path": "references/bloc-state.md",
          "lines": 260
        },
        {
          "name": "gorouter-navigation.md",
          "type": "file",
          "path": "references/gorouter-navigation.md",
          "lines": 120
        },
        {
          "name": "performance.md",
          "type": "file",
          "path": "references/performance.md",
          "lines": 100
        },
        {
          "name": "project-structure.md",
          "type": "file",
          "path": "references/project-structure.md",
          "lines": 119
        },
        {
          "name": "riverpod-state.md",
          "type": "file",
          "path": "references/riverpod-state.md",
          "lines": 131
        },
        {
          "name": "widget-patterns.md",
          "type": "file",
          "path": "references/widget-patterns.md",
          "lines": 124
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 83
    }
  ]
}
