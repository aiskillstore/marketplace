{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T11:42:25.313Z",
    "slug": "brownfinesecurity-telnetshell",
    "source_url": "https://github.com/BrownFineSecurity/iothackbot/tree/master/skills/telnetshell",
    "source_ref": "master",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "344d2fb9421d274c0427ecd4e1f4e424d2ef115e76f08a8e7402eabf29db387e",
    "tree_hash": "86bd2e3867460468d2096d3b7684d0cfe32daa3d630dfdb4c673c25e90b9730c"
  },
  "skill": {
    "name": "telnetshell",
    "description": "Use telnet to interact with IoT device shells for pentesting operations including device enumeration, vulnerability discovery, credential testing, and post-exploitation. Use when the user needs to interact with network-accessible shells, IoT devices, or telnet services.",
    "summary": "Use telnet to interact with IoT device shells for pentesting operations including device enumeration...",
    "icon": "ðŸ”’",
    "version": "1.0.0",
    "author": "BrownFineSecurity",
    "license": "MIT",
    "category": "security",
    "tags": [
      "iot",
      "pentesting",
      "telnet",
      "enumeration",
      "security-testing"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "external_commands",
      "network",
      "filesystem",
      "scripts"
    ]
  },
  "security_audit": {
    "risk_level": "medium",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a legitimate penetration testing tool for IoT device security assessment. The skill enables telnet connections to remote devices for enumeration and security testing. All network connections are to user-specified targets. The tool includes session logging for transparency. Use requires explicit authorization.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "telnet_helper.py",
            "line_start": 105,
            "line_end": 106
          }
        ]
      },
      {
        "factor": "network",
        "evidence": [
          {
            "file": "telnet_helper.py",
            "line_start": 36,
            "line_end": 51
          },
          {
            "file": "telnet_helper.py",
            "line_start": 94,
            "line_end": 134
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "telnet_helper.py",
            "line_start": 72,
            "line_end": 81
          },
          {
            "file": "telnet_helper.py",
            "line_start": 440,
            "line_end": 442
          }
        ]
      },
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 486,
            "line_end": 501
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 8,
    "total_lines": 2015,
    "audit_model": "claude",
    "audited_at": "2026-01-10T11:42:25.313Z"
  },
  "content": {
    "user_title": "Execute telnet commands on IoT devices",
    "value_statement": "Security testing of IoT devices requires reliable shell access via telnet. This skill provides a Python helper script with prompt detection, output cleaning, and session logging for safe and transparent device interaction.",
    "seo_keywords": [
      "IoT telnet",
      "pentesting",
      "device enumeration",
      "shell access",
      "busybox",
      "telnet helper",
      "IoT security",
      "Claude Code",
      "Claude",
      "Codex"
    ],
    "actual_capabilities": [
      "Connect to IoT devices via telnet protocol on standard or custom ports",
      "Execute single commands or batch scripts on remote devices",
      "Detect and handle various shell prompts including BusyBox",
      "Log all telnet sessions to file for observation and documentation",
      "Parse and clean command output by removing echoes and ANSI codes",
      "Support interactive mode for manual exploration"
    ],
    "limitations": [
      "Requires telnet service to be accessible on target device",
      "Limited to BusyBox-style commands on most IoT devices",
      "Cannot interact with password prompts automatically",
      "Requires Python 3 and pexpect library installed"
    ],
    "use_cases": [
      {
        "target_user": "Security researchers",
        "title": "IoT vulnerability research",
        "description": "Enumerate and assess security posture of IoT devices on your network for research purposes"
      },
      {
        "target_user": "Network engineers",
        "title": "Device diagnostics",
        "description": "Connect to network devices for troubleshooting and configuration verification on authorized equipment"
      },
      {
        "target_user": "Penetration testers",
        "title": "Authorized security tests",
        "description": "Conduct authorized penetration testing engagements against IoT devices with client permission"
      }
    ],
    "prompt_templates": [
      {
        "title": "Quick connection",
        "scenario": "Connect to device",
        "prompt": "Connect to 192.168.1.100 on port 2222 and run uname -a"
      },
      {
        "title": "System enumeration",
        "scenario": "Gather device info",
        "prompt": "Enumerate the target device by running system information commands: hostname, uname -a, cat /proc/version, cat /proc/cpuinfo"
      },
      {
        "title": "Batch enumeration",
        "scenario": "Full security assessment",
        "prompt": "Run a complete security assessment using the enum scripts. First run enum_system.txt, then enum_network.txt, then enum_security.txt"
      },
      {
        "title": "Custom prompt",
        "scenario": "Handle unusual prompts",
        "prompt": "Connect to 192.168.1.100 with custom prompt pattern ^MyDevice> and run ps aux"
      }
    ],
    "output_examples": [
      {
        "input": "Connect to 192.168.1.100 and run uname -a",
        "output": [
          "Device Information:",
          "  Hostname: GM",
          "  Kernel: Linux 3.3.0 #8 PREEMPT",
          "  Architecture: armv5tel",
          "  Use --logfile to monitor session in another terminal"
        ]
      }
    ],
    "best_practices": [
      "Always use --logfile to monitor sessions in real-time with tail -f",
      "Verify you have explicit authorization before testing any device",
      "Use custom --prompt patterns for devices with non-standard shells"
    ],
    "anti_patterns": [
      "Do not use this skill on devices you do not own or lack permission to test",
      "Do not rely on default timeouts for long-running commands like find /",
      "Do not skip session logging when automating tests"
    ],
    "faq": [
      {
        "question": "What devices are compatible with this skill?",
        "answer": "Any device with an accessible telnet service. Most IoT devices like cameras, routers, and embedded systems use telnet."
      },
      {
        "question": "What are the timeout limits for commands?",
        "answer": "Default timeout is 3 seconds. Use --timeout to increase for long-running commands like find operations."
      },
      {
        "question": "How do I integrate this with other tools?",
        "answer": "Use --json output for programmatic parsing. Results can be piped to jq or saved for analysis."
      },
      {
        "question": "Is my data safe when using this skill?",
        "answer": "This skill only accesses devices you specify. All sessions are logged to /tmp/telnet_session.log for transparency."
      },
      {
        "question": "Why are my commands timing out?",
        "answer": "Increase timeout with --timeout flag. Long commands like find / need 10-30 seconds. Use --debug to diagnose."
      },
      {
        "question": "How does this compare to SSH?",
        "answer": "Telnet is common on IoT devices without SSH. This skill handles telnet-specific issues like prompt detection and output cleaning."
      }
    ]
  },
  "file_structure": [
    {
      "name": "enum_files.txt",
      "type": "file",
      "path": "enum_files.txt"
    },
    {
      "name": "enum_network.txt",
      "type": "file",
      "path": "enum_network.txt"
    },
    {
      "name": "enum_security.txt",
      "type": "file",
      "path": "enum_security.txt"
    },
    {
      "name": "enum_system.txt",
      "type": "file",
      "path": "enum_system.txt"
    },
    {
      "name": "examples.md",
      "type": "file",
      "path": "examples.md"
    },
    {
      "name": "OBSERVING_SESSIONS.md",
      "type": "file",
      "path": "OBSERVING_SESSIONS.md"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    },
    {
      "name": "telnet_helper.py",
      "type": "file",
      "path": "telnet_helper.py"
    }
  ]
}
