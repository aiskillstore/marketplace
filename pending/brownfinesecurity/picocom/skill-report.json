{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T11:40:19.439Z",
    "slug": "brownfinesecurity-picocom",
    "source_url": "https://github.com/BrownFineSecurity/iothackbot/tree/master/skills/picocom",
    "source_ref": "master",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "a89076995a575c2f485b7582ab80773a9c0e801d2265280b7528c31f3f725db0",
    "tree_hash": "3fa0ed69e1e8d3ae58b446da14534085e1c2235d8e90eae0e94cb7c0f17d11be"
  },
  "skill": {
    "name": "picocom",
    "description": "Use picocom to interact with IoT device UART consoles for pentesting operations including device enumeration, vulnerability discovery, bootloader manipulation, and gaining root shells. Use when the user needs to interact with embedded devices, IoT hardware, or serial consoles.",
    "summary": "Use picocom to interact with IoT device UART consoles for pentesting operations including device enu...",
    "icon": "ðŸ”Œ",
    "version": "1.0.0",
    "author": "BrownFineSecurity",
    "license": "MIT",
    "category": "security",
    "tags": [
      "iot",
      "embedded",
      "serial",
      "uart",
      "pentesting"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "external_commands",
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "medium",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Legitimate IoT security testing tool with documented external command execution capability for trigger scripts in monitor mode. The subprocess execution is user-controlled, timeout-limited, and intended for legitimate security testing workflows. No network calls or credential theft patterns detected.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "serial_helper.py",
            "line_start": 593,
            "line_end": 598
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "serial_helper.py",
            "line_start": 103,
            "line_end": 103
          },
          {
            "file": "serial_helper.py",
            "line_start": 819,
            "line_end": 820
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [
      {
        "title": "Subprocess execution in monitor mode",
        "description": "The serial_helper.py script can execute external trigger scripts via subprocess.run with shell=True (lines 593-598). This is a documented feature for pentesting workflows where users trigger external events (like API calls) while monitoring UART output. The capability is user-controlled via --trigger-script argument, has a 30-second timeout limit, and requires explicit invocation. While this could theoretically be misused, it is an intentional design for legitimate security testing scenarios.",
        "locations": [
          {
            "file": "serial_helper.py",
            "line_start": 593,
            "line_end": 618
          }
        ]
      }
    ],
    "low_findings": [
      {
        "title": "File operations for logging",
        "description": "The script opens log files for writing session data (line 103) and reads script files for batch command execution (lines 819-820). These are standard file operations for a serial communication tool. Log files are created with user-specified paths and can contain sensitive session data including commands and device responses.",
        "locations": [
          {
            "file": "serial_helper.py",
            "line_start": 103,
            "line_end": 103
          },
          {
            "file": "serial_helper.py",
            "line_start": 819,
            "line_end": 820
          }
        ]
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 4,
    "total_lines": 2611,
    "audit_model": "claude",
    "audited_at": "2026-01-10T11:40:19.439Z"
  },
  "content": {
    "user_title": "Connect to IoT UART Serial Consoles",
    "value_statement": "IoT devices often expose debug interfaces via serial connections. This skill provides tools to connect to UART consoles, enumerate device information, interact with bootloaders, and perform security testing on embedded systems.",
    "seo_keywords": [
      "picocom",
      "iot security",
      "uart serial",
      "embedded device",
      "claude code",
      "serial console",
      "device enumeration",
      "bootloader",
      "claude",
      "codex"
    ],
    "actual_capabilities": [
      "Connect to IoT devices via UART serial ports using picocom or Python helper",
      "Execute commands on device consoles with prompt detection and output cleaning",
      "Monitor UART output passively to capture boot logs and debug information",
      "Interact with bootloaders like U-Boot for device manipulation",
      "Support AT command mode for cellular and satellite modems",
      "Log all serial I/O to files for observation and documentation"
    ],
    "limitations": [
      "Requires physical access to device UART pins and serial adapter",
      "Cannot test devices without appropriate permissions or authorization",
      "Does not provide wireless or network-based device interaction",
      "Effectiveness depends on device-specific configurations and prompts"
    ],
    "use_cases": [
      {
        "target_user": "Security Researchers",
        "title": "IoT Vulnerability Research",
        "description": "Analyze IoT device firmware, discover vulnerabilities, and document security findings through UART access."
      },
      {
        "target_user": "Embedded Engineers",
        "title": "Device Debugging",
        "description": "Debug embedded systems, examine boot logs, and interact with device consoles during development."
      },
      {
        "target_user": "Penetration Testers",
        "title": "Hardware Pentesting",
        "description": "Test IoT device security through serial interfaces, enumerate configurations, and identify attack vectors."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Connection",
        "scenario": "Connect to UART device",
        "prompt": "Connect to serial device /dev/ttyUSB0 at 115200 baud and run help command. Log the session to /tmp/serial_session.log."
      },
      {
        "title": "Device Enumeration",
        "scenario": "Gather device info",
        "prompt": "Enumerate the connected IoT device by running: uname -a, ifconfig, cat /etc/passwd, and ps aux. Log all output."
      },
      {
        "title": "Boot Monitor",
        "scenario": "Capture device boot",
        "prompt": "Monitor the UART console for 60 seconds capturing boot logs. Run a trigger script to reboot the device after 5 seconds."
      },
      {
        "title": "AT Commands",
        "scenario": "Cellular modem interaction",
        "prompt": "Send AT commands to the cellular modem on /dev/ttyUSB0 in AT mode. Query IMEI with AT+CGSN and network info with AT+CSQ."
      }
    ],
    "output_examples": [
      {
        "input": "Connect to /dev/ttyUSB0 at 115200 baud and enumerate the device with help, date, and ifconfig commands",
        "output": [
          "Connected to /dev/ttyUSB0 @ 115200 baud",
          "Detected prompt pattern: User@[^>]+>",
          "Command output:",
          "help - Available commands listed",
          "date - Device system date/time displayed",
          "ifconfig - Network interfaces with IP addresses shown"
        ]
      }
    ],
    "best_practices": [
      "Always use logging to capture sessions for documentation and later analysis",
      "Research device-specific configurations before attempting bootloader interaction",
      "Test baud rates systematically if output appears garbled or unreadable"
    ],
    "anti_patterns": [
      "Do not assume devices have no authentication - always check for login prompts",
      "Do not attempt unauthorized testing on devices you do not own",
      "Do not modify bootloader settings without understanding potential consequences"
    ],
    "faq": [
      {
        "question": "What baud rates are supported?",
        "answer": "Common rates include 115200, 57600, 38400, 19200, and 9600. 115200 is the default for most IoT devices."
      },
      {
        "question": "What serial devices can I connect to?",
        "answer": "USB-to-serial adapters appear as /dev/ttyUSB* and CDC devices as /dev/ttyACM*. Built-in ports are /dev/ttyS*."
      },
      {
        "question": "Can this skill brick my device?",
        "answer": "Bootloader manipulation can potentially damage devices. Always research before making changes and have backup plans."
      },
      {
        "question": "Is my session data safe?",
        "answer": "Log files contain all commands and responses. Use secure locations for sensitive data and delete logs after use."
      },
      {
        "question": "What if I see no output?",
        "answer": "Check physical connections, verify baud rate, try pressing Enter, and ensure device is powered on."
      },
      {
        "question": "How is this different from screen or minicom?",
        "answer": "This skill provides scripted access through a Python helper for automation, with output parsing and logging built-in."
      }
    ]
  },
  "file_structure": [
    {
      "name": "examples.md",
      "type": "file",
      "path": "examples.md"
    },
    {
      "name": "OBSERVING_SESSIONS.md",
      "type": "file",
      "path": "OBSERVING_SESSIONS.md"
    },
    {
      "name": "serial_helper.py",
      "type": "file",
      "path": "serial_helper.py"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
