{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T12:40:15.663Z",
    "slug": "consiliency-library-detection",
    "source_url": "https://github.com/Consiliency/treesitter-chunker/tree/main/.ai-dev-kit/skills/library-detection",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "4d170c576cb6f82ad6dcddc5ae296b363da8e4ad6a25729749803248d9215ec8",
    "tree_hash": "322929fb8fcd405fa6177057e2ee85f8b7caed7d2a3d25e7b6002b5ce697780b"
  },
  "skill": {
    "name": "library-detection",
    "description": "Detect project stack from package manifests (package.json, pyproject.toml, go.mod, Cargo.toml, pubspec.yaml, CMakeLists.txt). Auto-identify frameworks, test tools, and build systems for onboarding.",
    "summary": "Detect project stack from package manifests (package.json, pyproject.toml, go.mod, Cargo.toml, pubsp...",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "Consiliency",
    "license": "MIT",
    "category": "documentation",
    "tags": [
      "dependency-detection",
      "stack-analysis",
      "project-discovery",
      "framework-detection"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure prompt-based skill containing only documentation and instructional content for analyzing package manifests. No executable code, network calls, file writes, or system access capabilities.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 543,
    "audit_model": "claude",
    "audited_at": "2026-01-10T12:40:15.663Z"
  },
  "content": {
    "user_title": "Detect project technology stacks from manifests",
    "value_statement": "This skill identifies the technology stack of any project by scanning package manifests and configuration files. It helps developers quickly understand project dependencies, frameworks, and build tools without manual investigation.",
    "seo_keywords": [
      "library detection",
      "dependency analysis",
      "framework detection",
      "stack identification",
      "package manifest parsing",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Scans package manifests across 12+ file types",
      "Identifies frameworks from dependency patterns",
      "Detects test frameworks and build tools",
      "Classifies dependencies into production and development",
      "Outputs structured JSON, markdown, or toon format",
      "Recognizes databases and cloud providers"
    ],
    "limitations": [
      "Only analyzes manifest files, not actual code imports",
      "Cannot detect implicit dependencies or dynamic imports",
      "Requires manifests to be present in standard locations",
      "Version detection depends on manifest format"
    ],
    "use_cases": [
      {
        "target_user": "Onboarding developers",
        "title": "New team member onboarding",
        "description": "Quickly understand project tech stack when joining a new codebase"
      },
      {
        "target_user": "Documentation writers",
        "title": "Automated documentation",
        "description": "Generate stack documentation and identify relevant doc sources automatically"
      },
      {
        "target_user": "DevOps engineers",
        "title": "Environment setup",
        "description": "Identify required tools, test frameworks, and build systems for CI/CD configuration"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic stack scan",
        "scenario": "Scan a project directory",
        "prompt": "Use library-detection to identify the technology stack of this project. List the languages, frameworks, test tools, and build systems found."
      },
      {
        "title": "Framework verification",
        "scenario": "Verify framework assumptions",
        "prompt": "Run library-detection to confirm the frameworks and libraries used in this project. Check both production and development dependencies."
      },
      {
        "title": "Test framework discovery",
        "scenario": "Find test tools",
        "prompt": "Use library-detection to identify all test frameworks and testing utilities in this project. Include version information where available."
      },
      {
        "title": "Full stack report",
        "scenario": "Generate comprehensive report",
        "prompt": "Execute library-detection with full detail. Output the complete stack analysis including languages, frameworks, databases, cloud providers, and CI/CD tools."
      }
    ],
    "output_examples": [
      {
        "input": "Scan this project to identify its technology stack",
        "output": [
          "Languages: TypeScript, Python",
          "Frameworks: React 18.2.0 (frontend), FastAPI 0.109.0 (backend)",
          "Test Frameworks: Vitest 1.2.0, pytest 7.4.0",
          "Build Tools: Vite, uv",
          "Databases: PostgreSQL (via Prisma)",
          "Cloud Providers: Vercel",
          "CI/CD: GitHub Actions"
        ]
      }
    ],
    "best_practices": [
      "Always verify detected frameworks against actual imports when precision is critical",
      "Use the OUTPUT_FORMAT variable to match downstream processing requirements",
      "Cross-reference requirements.txt with pyproject.toml for Python projects"
    ],
    "anti_patterns": [
      "Assuming framework usage without checking actual imports or configuration",
      "Skipping manifest analysis for supposedly simple projects",
      "Reporting libraries without verifying they are actually used in the codebase"
    ],
    "faq": [
      {
        "question": "Which package manifest formats are supported?",
        "answer": "Supports package.json, pyproject.toml, requirements.txt, go.mod, Cargo.toml, pubspec.yaml, CMakeLists.txt, meson.build, pom.xml, build.gradle, Gemfile, composer.json."
      },
      {
        "question": "What is the maximum scan depth?",
        "answer": "Default depth is 3 directories. Configure with SCAN_DEPTH variable. Deeper scans may impact performance on large monorepos."
      },
      {
        "question": "Can this skill integrate with other skills?",
        "answer": "Yes. Other skills can reference library-detection output for documentation discovery, tool configuration, and agent routing based on detected stack."
      },
      {
        "question": "Is project data sent anywhere?",
        "answer": "No. This skill only reads local manifest files and outputs analysis. No network calls are made and no data leaves the local environment."
      },
      {
        "question": "Why did detection miss some dependencies?",
        "answer": "Ensure manifests exist in standard locations. Some dependencies may be dynamically imported or defined in lock files not directly parsed."
      },
      {
        "question": "How does this compare to dependency scanning tools?",
        "answer": "This skill analyzes manifest structure rather than lock files. It provides faster broad-stroke identification suitable for onboarding and documentation."
      }
    ]
  },
  "file_structure": [
    {
      "name": "cookbook",
      "type": "dir",
      "path": "cookbook",
      "children": [
        {
          "name": "manifest-parsing.md",
          "type": "file",
          "path": "cookbook/manifest-parsing.md"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
