{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T12:38:18.024Z",
    "slug": "consiliency-supabase-patterns",
    "source_url": "https://github.com/Consiliency/treesitter-chunker/tree/main/.ai-dev-kit/skills/supabase-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "0332a76c9b1b3dffec3a676207bfbfad6317ad8d580bff902c14d67b0e5f79d6",
    "tree_hash": "488473a0793d28523bfaddbab577f6f83b28e40d7700caa5eeb024789d24fad9"
  },
  "skill": {
    "name": "supabase-patterns",
    "description": "Generic Supabase best practices for Row Level Security, realtime subscriptions, storage, and edge functions. Framework-agnostic.",
    "summary": "Generic Supabase best practices for Row Level Security, realtime subscriptions, storage, and edge fu...",
    "icon": "üîí",
    "version": "1.0.0",
    "author": "Consiliency",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "supabase",
      "database",
      "security",
      "rls",
      "postgresql"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill contains only documentation and best practices for Supabase security patterns. No executable code, network calls, or file system access detected. The content focuses on secure database practices and RLS policy implementation.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 536,
    "audit_model": "claude",
    "audited_at": "2026-01-10T12:38:18.024Z"
  },
  "content": {
    "user_title": "Implement Secure Supabase Patterns",
    "value_statement": "Build secure Supabase applications with confidence. This skill provides battle-tested patterns for Row Level Security, realtime subscriptions, and database best practices that protect your data.",
    "seo_keywords": [
      "supabase",
      "row level security",
      "rls policies",
      "database security",
      "postgresql",
      "claude",
      "claude code",
      "realtime subscriptions",
      "edge functions",
      "secure patterns"
    ],
    "actual_capabilities": [
      "Generate RLS policies for user ownership and role-based access",
      "Provide secure database migration patterns",
      "Configure realtime subscriptions with security best practices",
      "Implement team and organization access controls",
      "Create testing strategies for database security"
    ],
    "limitations": [
      "Requires Supabase PostgreSQL database",
      "Does not generate actual migration files",
      "Security patterns need testing in your environment",
      "Assumes basic Supabase knowledge"
    ],
    "use_cases": [
      {
        "target_user": "Full-stack developers",
        "title": "Secure Database Design",
        "description": "Implement proper RLS policies to protect user data and ensure users only access their own records."
      },
      {
        "target_user": "Security engineers",
        "title": "Audit Database Access",
        "description": "Review and improve existing Supabase security implementations with proven patterns."
      },
      {
        "target_user": "Startup teams",
        "title": "Multi-tenant Applications",
        "description": "Build team-based access controls for SaaS applications with proper data isolation."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic RLS Setup",
        "scenario": "Creating a posts table with user access",
        "prompt": "Create RLS policies for a posts table where users can only see and edit their own posts. Include SELECT, INSERT, UPDATE, and DELETE policies."
      },
      {
        "title": "Team Access Control",
        "scenario": "Multi-user organization access",
        "prompt": "Design RLS policies for team-based access where team members can view shared documents and team admins can modify any team document."
      },
      {
        "title": "Public Content Pattern",
        "scenario": "Mixed public and private content",
        "prompt": "Create policies for a content table where public posts are visible to everyone but only authors can edit, and private posts are only visible to the author."
      },
      {
        "title": "Advanced Security Functions",
        "scenario": "Complex role-based permissions",
        "prompt": "Write helper functions for checking admin status and user teams, then use them in RLS policies for a sensitive data table."
      }
    ],
    "output_examples": [
      {
        "input": "Create RLS policies for a todo app where users manage their own tasks",
        "output": [
          "‚úì Enable RLS on todos table",
          "‚úì SELECT policy: Users can view only their todos (auth.uid() = user_id)",
          "‚úì INSERT policy: Users can create todos assigned to themselves (auth.uid() = user_id)",
          "‚úì UPDATE policy: Users can edit only their todos with ownership check",
          "‚úì DELETE policy: Users can delete only their todos",
          "‚úì Migration file created with idempotent policy drops",
          "‚ö†Ô∏è Remember to test with different user contexts before deploying"
        ]
      }
    ],
    "best_practices": [
      "Always enable RLS immediately after creating tables - never leave data unprotected",
      "Test policies with actual user contexts using SET request.jwt.claims before deploying",
      "Use migrations for all schema changes and include policy drops for idempotency"
    ],
    "anti_patterns": [
      "Creating tables without RLS policies - this leaves data open to all authenticated users",
      "Using auth.uid() IS NOT NULL as policy check - this allows any user to access everything",
      "Forgetting WITH CHECK on INSERT policies - USING clause doesn't apply to inserts"
    ],
    "faq": [
      {
        "question": "Is this compatible with all Supabase projects?",
        "answer": "Yes, these patterns work with any Supabase PostgreSQL database regardless of framework or frontend technology."
      },
      {
        "question": "What's the minimum Supabase knowledge required?",
        "answer": "Basic understanding of SQL, PostgreSQL, and Supabase authentication is recommended to implement these patterns effectively."
      },
      {
        "question": "Can I use these patterns with other databases?",
        "answer": "The RLS concepts are PostgreSQL-specific, but the security principles apply to other databases with row-level security features."
      },
      {
        "question": "How do I test RLS policies locally?",
        "answer": "Use SET request.jwt.claims to simulate different users, then run your queries to verify policies work correctly."
      },
      {
        "question": "What if I need custom security requirements?",
        "answer": "The patterns are modular - combine basic policies or create custom functions for complex authorization logic."
      },
      {
        "question": "Does this cover Supabase Storage security?",
        "answer": "The skill focuses on database RLS policies. Storage bucket policies require separate configuration using similar principles."
      }
    ]
  },
  "file_structure": [
    {
      "name": "cookbook",
      "type": "dir",
      "path": "cookbook",
      "children": [
        {
          "name": "rls-policies.md",
          "type": "file",
          "path": "cookbook/rls-policies.md"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
