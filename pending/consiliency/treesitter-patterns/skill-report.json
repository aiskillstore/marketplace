{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T12:44:12.281Z",
    "slug": "consiliency-treesitter-patterns",
    "source_url": "https://github.com/Consiliency/treesitter-chunker/tree/main/.ai-dev-kit/skills/treesitter-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "dfa701011e55e426d20f36d189cc7fe8dd2dba20a6b69d3deda1adddce2cd2c5",
    "tree_hash": "798854889242f957a22fe08ebb052abd6964b6d371184e2f623020b544415873"
  },
  "skill": {
    "name": "treesitter-patterns",
    "description": "Universal patterns for tree-sitter code parsing. Covers AST visitors, query patterns, and language plugin development. Framework-agnostic.",
    "summary": "Universal patterns for tree-sitter code parsing. Covers AST visitors, query patterns, and language p...",
    "icon": "ðŸŒ³",
    "version": "1.0.0",
    "author": "Consiliency",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "tree-sitter",
      "AST",
      "code parsing",
      "query patterns",
      "language plugins"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a pure documentation skill containing only markdown content with tree-sitter patterns, examples, and best practices. No executable code, network calls, file system access, or external commands detected.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 260,
    "audit_model": "claude",
    "audited_at": "2026-01-10T12:44:12.281Z"
  },
  "content": {
    "user_title": "Parse code with tree-sitter patterns",
    "value_statement": "Working with tree-sitter requires understanding AST navigation, query patterns, and visitor implementations. This skill provides ready-to-use patterns for parsing any programming language.",
    "seo_keywords": [
      "tree-sitter",
      "AST parsing",
      "code analysis",
      "Claude Code",
      "Claude",
      "Codex",
      "query patterns",
      "language parser",
      "visitor pattern",
      "code extraction"
    ],
    "actual_capabilities": [
      "Parse source code into AST using tree-sitter parsers",
      "Navigate and traverse AST nodes with visitors",
      "Write tree-sitter query patterns for code extraction",
      "Handle parse errors and edge cases gracefully",
      "Build language plugins with framework-agnostic patterns",
      "Extract functions, classes, and imports from code"
    ],
    "limitations": [
      "Does not install tree-sitter language parsers automatically",
      "Requires existing tree-sitter language bindings",
      "Does not execute or evaluate parsed code",
      "Does not handle parser compilation or grammar creation"
    ],
    "use_cases": [
      {
        "target_user": "Code analysis developers",
        "title": "Extract code structures",
        "description": "Pull function definitions, class declarations, and imports from any codebase for analysis."
      },
      {
        "target_user": "Plugin developers",
        "title": "Build language tools",
        "description": "Create new language plugins using visitor patterns and query optimizations."
      },
      {
        "target_user": "Documentation engineers",
        "title": "Generate code references",
        "description": "Parse source files to auto-generate API documentation and code inventories."
      }
    ],
    "prompt_templates": [
      {
        "title": "Parse function",
        "scenario": "Extract functions from Python code",
        "prompt": "Use tree-sitter to parse this Python code and extract all function definitions with their names and parameters."
      },
      {
        "title": "Build AST visitor",
        "scenario": "Create custom AST traversal",
        "prompt": "Create an AST visitor class that walks the parse tree and collects all class definitions."
      },
      {
        "title": "Write query pattern",
        "scenario": "Match code patterns",
        "prompt": "Write a tree-sitter query to find all decorated functions with @pytest.mark decorators."
      },
      {
        "title": "Handle errors",
        "scenario": "Graceful parse handling",
        "prompt": "Parse this code with error handling. Return both the tree and any parse errors encountered."
      }
    ],
    "output_examples": [
      {
        "input": "Parse this JavaScript file and list all exported functions",
        "output": [
          "â€¢ parseModule - line 12-45 - Parses module dependencies",
          "â€¢ validateSchema - line 48-72 - Validates JSON schema",
          "â€¢ buildAST - line 75-98 - Constructs abstract syntax tree"
        ]
      }
    ],
    "best_practices": [
      "Always implement error handling for parse errors and missing nodes",
      "Use tree-sitter queries instead of manual tree traversal when possible",
      "Test query patterns on real code samples before production use"
    ],
    "anti_patterns": [
      "Assuming all source files parse successfully without error handling",
      "Using manual child iteration instead of optimized query patterns",
      "Ignoring performance implications when parsing large codebases"
    ],
    "faq": [
      {
        "question": "What languages does tree-sitter support?",
        "answer": "Tree-sitter supports 40+ languages including Python, JavaScript, TypeScript, Go, Rust, Ruby, C, C++, and many more."
      },
      {
        "question": "How do I install language parsers?",
        "answer": "Install parsers via npm (tree-sitter-javascript), pip (tree-sitter-python), or compile from the official tree-sitter-lang repos."
      },
      {
        "question": "Can I use this with any framework?",
        "answer": "Yes. Patterns are framework-agnostic. Use with Code-Index-MCP, treesitter-chunker, or custom implementations."
      },
      {
        "question": "Is parsed code executed?",
        "answer": "No. Tree-sitter only parses source text into an AST. It never executes or evaluates the parsed code."
      },
      {
        "question": "Why are my queries returning no matches?",
        "answer": "Check node type names match the language grammar. Use (editor.tree-sitter-query-test) to verify queries against sample code."
      },
      {
        "question": "How is this different from regex?",
        "answer": "Tree-sitter understands code structure via the AST. Queries can match nested patterns that regex cannot capture."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
