{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-02T00:41:34.218Z",
    "slug": "wshobson-microservices-patterns",
    "source_url": "https://github.com/wshobson/agents/tree/main/plugins/backend-development/skills/microservices-patterns",
    "source_ref": "main",
    "model": "codex",
    "analysis_version": "2.0.0",
    "source_type": "community"
  },
  "skill": {
    "name": "microservices-patterns",
    "description": "Design microservices architectures with service boundaries, event-driven communication, and resilience patterns. Use when building distributed systems, decomposing monoliths, or implementing microservices.",
    "summary": "Design microservices architectures with service boundaries, event-driven communication, and resilien...",
    "icon": "ðŸ§©",
    "version": "1.0.0",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "microservices",
      "architecture",
      "distributed-systems",
      "resilience",
      "patterns"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "No credential access, environment harvesting, or exfiltration patterns found. Code samples focus on architectural patterns and standard service communication.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 585,
    "audit_model": "codex",
    "audited_at": "2026-01-02T00:41:34.218Z"
  },
  "content": {
    "user_title": "Design microservices patterns fast",
    "value_statement": "Teams struggle to define microservice boundaries and reliable communication. This skill provides proven patterns and examples to structure resilient services.",
    "seo_keywords": [
      "microservices patterns",
      "service decomposition",
      "event driven architecture",
      "API gateway",
      "saga pattern",
      "circuit breaker",
      "Claude",
      "Codex",
      "Claude Code",
      "distributed systems"
    ],
    "actual_capabilities": [
      "Explain service decomposition by business capability and DDD subdomains",
      "Outline synchronous and asynchronous communication options",
      "Describe database per service and saga transaction patterns",
      "Provide API gateway aggregation and resilience examples",
      "Show circuit breaker and retry with backoff concepts"
    ],
    "limitations": [
      "Does not provision infrastructure or deploy services",
      "Does not include vendor specific cloud configurations",
      "Examples are templates and require adaptation to your stack"
    ],
    "use_cases": [
      {
        "target_user": "Backend architect",
        "title": "Decompose a monolith",
        "description": "Plan service boundaries, data ownership, and migration using the strangler approach"
      },
      {
        "target_user": "Platform engineer",
        "title": "Design resilience",
        "description": "Apply circuit breakers, retries, and bulkheads for stable inter service calls"
      },
      {
        "target_user": "Tech lead",
        "title": "Define communication",
        "description": "Choose REST, gRPC, or event driven messaging per service interaction"
      }
    ],
    "prompt_templates": [
      {
        "title": "Starter plan",
        "scenario": "Small team moving from monolith",
        "prompt": "Propose microservice boundaries for an e commerce monolith with orders, payments, and inventory. Include data ownership and contracts."
      },
      {
        "title": "Communication choice",
        "scenario": "Mixed sync and async needs",
        "prompt": "Recommend synchronous and asynchronous communication patterns for order creation, payment, and inventory reservation."
      },
      {
        "title": "Saga design",
        "scenario": "Distributed transaction flow",
        "prompt": "Design a saga for order fulfillment with steps, compensations, and failure handling."
      },
      {
        "title": "Resilience review",
        "scenario": "Production reliability upgrade",
        "prompt": "Suggest circuit breaker, retry, and bulkhead strategies for three services with high latency."
      }
    ],
    "output_examples": [
      {
        "input": "Design service boundaries and communication for a subscription platform",
        "output": [
          "Services: Billing, Subscription, Customer, Notification",
          "Events: SubscriptionCreated, PaymentFailed, RenewalDue",
          "API gateway aggregates customer and subscription views",
          "Use saga for renewal and compensation on payment failure"
        ]
      }
    ],
    "best_practices": [
      "Align services with business capabilities and bounded contexts",
      "Prefer async events for loose coupling and scalability",
      "Apply resilience patterns on all cross service calls"
    ],
    "anti_patterns": [
      "Sharing a single database across multiple services",
      "Making every interaction synchronous",
      "Ignoring compensation logic in distributed flows"
    ],
    "faq": [
      {
        "question": "Is this compatible with Claude, Codex, and Claude Code?",
        "answer": "Yes. It is a text based skill usable in Claude, Codex, and Claude Code."
      },
      {
        "question": "What are the limits of the examples?",
        "answer": "Examples are templates and may omit production details like auth, observability, and deployment."
      },
      {
        "question": "Can it integrate with my existing stack?",
        "answer": "Yes. The patterns are stack agnostic and can be adapted to your languages and frameworks."
      },
      {
        "question": "Does it access or store sensitive data?",
        "answer": "No. It provides guidance only and does not access files, credentials, or networks."
      },
      {
        "question": "What if the guidance seems too complex?",
        "answer": "Start with simpler boundaries and add patterns gradually as your system grows."
      },
      {
        "question": "How does it compare to generic architecture advice?",
        "answer": "It focuses on concrete microservices patterns, tradeoffs, and example flows."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}