{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T13:44:56.979Z",
    "slug": "dasblueyeddevil-daem0nmcp-protocol",
    "source_url": "https://github.com/DasBluEyedDevil/Daem0n-MCP/tree/main/.claude/skills/daem0nmcp-protocol",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "c5a08a9499b05e820733a6d510b999c3d9185dcf57c37e9e504c103aeb7add8b",
    "tree_hash": "18a67a895bf6b4074ebc47a779461fe13cf6155a830b235e4c2a850f85576aff"
  },
  "skill": {
    "name": "daem0nmcp-protocol",
    "description": "Use when Daem0nMCP tools are available - enforces the sacred covenant (commune at session start, seek counsel before changes, inscribe decisions, seal outcomes)",
    "summary": "Use when Daem0nMCP tools are available - enforces the sacred covenant (commune at session start, see...",
    "icon": "ðŸ§ ",
    "version": "1.0.0",
    "author": "DasBluEyedDevil",
    "license": "MIT",
    "category": "productivity",
    "tags": [
      "memory",
      "workflow",
      "context",
      "decisions",
      "protocol"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a pure prompt-based skill containing only markdown documentation and workflow guidelines. No executable code, scripts, network calls, file system access, or external commands are defined. The MCP tool references are external tool definitions requiring a separate Daem0nMCP server.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 350,
    "audit_model": "claude",
    "audited_at": "2026-01-10T13:44:56.979Z"
  },
  "content": {
    "user_title": "Use Daem0nMCP Memory Tools with Protocol Discipline",
    "value_statement": "Memory tools require discipline to be useful. This skill enforces a workflow that checks context before changes, records decisions, tracks outcomes, and links related memories across sessions.",
    "seo_keywords": [
      "Daem0nMCP",
      "Claude Code",
      "Claude",
      "Codex",
      "memory management",
      "context tracking",
      "decision logging",
      "project memory",
      "MCP skills",
      "AI workflow"
    ],
    "actual_capabilities": [
      "Enforce session start with get_briefing() to load past decisions",
      "Check context before making code changes with context_check()",
      "Record decisions and rationale with remember()",
      "Track implementation outcomes to learn from failures",
      "Link related memories to build causal knowledge graphs"
    ],
    "limitations": [
      "Requires Daem0nMCP server to be running and accessible",
      "Only works when Daem0nMCP MCP tools are available",
      "Cannot function without MCP tool access",
      "No offline memory capability"
    ],
    "use_cases": [
      {
        "target_user": "Project maintainers",
        "title": "Track architectural decisions",
        "description": "Record design choices, rationales, and outcomes to build institutional memory"
      },
      {
        "target_user": "Development teams",
        "title": "Learn from failures",
        "description": "Log failed approaches so the system surfaces warnings before repeating mistakes"
      },
      {
        "target_user": "Codebase contributors",
        "title": "Link related decisions",
        "description": "Connect causally related decisions to understand project evolution"
      }
    ],
    "prompt_templates": [
      {
        "title": "Start a session",
        "scenario": "Begin working on a project",
        "prompt": "Check if Daem0nMCP tools are available. If so, call get_briefing() to load past decisions and context."
      },
      {
        "title": "Before editing files",
        "scenario": "About to make code changes",
        "prompt": "Call context_check(description=\"what you are about to do\") and recall_for_file() for specific files. Acknowledge any warnings returned."
      },
      {
        "title": "Record a decision",
        "scenario": "Made an architectural or design choice",
        "prompt": "Call remember(category=\"decision\", content=\"what you decided\", rationale=\"why you decided it\", file_path=\"relevant/file\", tags=[\"relevant\", \"tags\"]). Save the memory_id for later outcome tracking."
      },
      {
        "title": "Complete implementation",
        "scenario": "Finished implementing and testing",
        "prompt": "Call record_outcome(memory_id=<id from remember>, outcome=\"what actually happened\", worked=true_or_false). Failed approaches are valuable learning opportunities."
      }
    ],
    "output_examples": [
      {
        "input": "I'm starting work on the authentication feature. The Daem0nMCP tools are available.",
        "output": [
          "âœ“ Loaded 5 past decisions about authentication from previous sessions",
          "âœ“ Warning found: Previous JWT approach failed due to token expiry issues - will avoid",
          "âœ“ Pattern found: Use session-based auth with refresh tokens",
          "Ready to proceed with context-aware development"
        ]
      }
    ],
    "best_practices": [
      "Always call get_briefing() at session start before doing anything else",
      "Never skip context_check() before editing any file - warnings exist because someone failed before",
      "Always call record_outcome() after implementation - failures get boosted in future searches and are valuable"
    ],
    "anti_patterns": [
      "Skipping get_briefing() because the task seems simple - small changes compound into big problems",
      "Forgetting to call remember() for significant decisions - you will not remember later",
      "Recording successful outcomes but skipping failures - failures are the most valuable memories"
    ],
    "faq": [
      {
        "question": "What happens if I skip get_briefing()?",
        "answer": "All Daem0nMCP tools will return COMMUNION_REQUIRED block until you call get_briefing() to establish the session."
      },
      {
        "question": "Where are memories stored?",
        "answer": "Memories are stored by the Daem0nMCP server. Check your server configuration for storage location and persistence settings."
      },
      {
        "question": "Do memories persist across sessions?",
        "answer": "Yes. The protocol is designed for persistence across sessions. Decisions, patterns, warnings, and learnings are retained."
      },
      {
        "question": "Can multiple users share memories?",
        "answer": "Memory sharing depends on Daem0nMCP server configuration. Some setups support team memory, others are per-user."
      },
      {
        "question": "What is the preflight token?",
        "answer": "After context_check(), you receive a cryptographic token valid for 5 minutes proving you consulted the memory system."
      },
      {
        "question": "How is this different from regular context?",
        "answer": "This protocol enforces systematic memory discipline - checking warnings, recording decisions, tracking outcomes, and linking relationships."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
