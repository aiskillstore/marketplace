{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T13:20:22.747Z",
    "slug": "dmjgilbert-systematic-debugging",
    "source_url": "https://github.com/DMJGilbert/.config/tree/main/users/darren/config/claude/skills/systematic-debugging",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "09e38e445ef2e6cc1c3a0bfa7c1e632d47b262855f761aa874fbf84436b365a4",
    "tree_hash": "aa5e8916de09ac57d19f096a0edc4610b3b01dce7ff210ca5473885f0a5ec0d4"
  },
  "skill": {
    "name": "systematic-debugging",
    "description": "Four-phase root cause investigation before attempting fixes. Use when debugging bugs, test failures, or unexpected behavior.",
    "summary": "Four-phase root cause investigation before attempting fixes. Use when debugging bugs, test failures,...",
    "icon": "üîç",
    "version": "1.0.0",
    "author": "DMJGilbert",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "debugging",
      "methodology",
      "root-cause",
      "problem-solving",
      "tdd"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a pure prompt-based documentation skill containing only markdown instructions for systematic debugging methodology. No executable code, scripts, network calls, or file system access. The skill is purely instructional.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 78,
    "audit_model": "claude",
    "audited_at": "2026-01-10T13:20:22.747Z"
  },
  "content": {
    "user_title": "Apply systematic debugging methodology",
    "value_statement": "Debugging without a systematic approach leads to wasted time and new bugs. This skill provides a four-phase methodology to find root causes before attempting fixes, dramatically improving first-time fix success rates.",
    "seo_keywords": [
      "systematic debugging",
      "root cause analysis",
      "debugging methodology",
      "bug fixing",
      "Claude Code debugging",
      "troubleshooting",
      "TDD debugging",
      "hypothesis testing",
      "pattern analysis",
      "debugging workflow"
    ],
    "actual_capabilities": [
      "Guide through four-phase root cause investigation",
      "Provide pattern analysis framework for comparing working vs broken code",
      "Apply scientific method with hypothesis testing",
      "Implement test-driven fix verification",
      "Detect when architectural problems require refactoring over symptom fixes"
    ],
    "limitations": [
      "Does not execute code or run tests automatically",
      "Does not access external debugging tools or profilers",
      "Does not integrate with issue trackers or bug databases",
      "Requires user to manually gather diagnostic evidence"
    ],
    "use_cases": [
      {
        "target_user": "Software developers",
        "title": "Fix bugs efficiently",
        "description": "Apply root cause analysis before writing code changes to avoid introducing new bugs"
      },
      {
        "target_user": "QA engineers",
        "title": "Analyze test failures",
        "description": "Systematically investigate test failures to determine whether issues are in code or tests themselves"
      },
      {
        "target_user": "DevOps engineers",
        "title": "Debug production issues",
        "description": "Use diagnostic evidence gathering and hypothesis testing to diagnose deployment failures"
      }
    ],
    "prompt_templates": [
      {
        "title": "Debug a bug",
        "scenario": "When encountering unexpected behavior",
        "prompt": "Use systematic debugging methodology to investigate this issue. Apply the four phases: root cause investigation, pattern analysis, hypothesis testing, and implementation. Before proposing any fix, read error messages, reproduce consistently, check recent changes, and trace data flow."
      },
      {
        "title": "Analyze test failure",
        "scenario": "When tests are failing",
        "prompt": "A test is failing. Apply systematic debugging: read the full error message and stack trace, identify the exact assertion failure, compare with passing tests in the same suite, form a hypothesis about the root cause, and verify with minimal code changes."
      },
      {
        "title": "Multiple fixes failed",
        "scenario": "When previous fixes did not work",
        "prompt": "Previous debugging attempts failed. Apply systematic debugging from Phase 1: stop attempting quick fixes, question whether this is an architectural problem, gather fresh diagnostic evidence, and ask whether refactoring is needed instead of symptom patches."
      },
      {
        "title": "New bug investigation",
        "scenario": "When encountering a regression",
        "prompt": "A regression was introduced. Use systematic debugging: check git history for recent changes, backtrace data flow from the error, compare with similar working code, form a testable hypothesis, and implement a TDD fix that addresses only the root cause."
      }
    ],
    "output_examples": [
      {
        "input": "The login function throws 'undefined is not a function' when users try to reset passwords",
        "output": [
          "Phase 1 - Investigation: Read stack trace to find exact line, reproduce by calling resetPassword(), check git log for auth module changes, trace where the undefined function is called",
          "Phase 2 - Pattern Analysis: Find working authentication code, compare import statements and dependencies, list all differences",
          "Phase 3 - Hypothesis: 'The resetPassword module is missing the validateEmail import, evidenced by undefined function at line 45'",
          "Phase 4 - Implementation: Write failing test, add missing import, verify all tests pass"
        ]
      }
    ],
    "best_practices": [
      "Always trace data flow backward from errors to find where bad values originate",
      "Compare working code against broken code to identify the root cause pattern",
      "Change only one variable at a time when testing hypotheses"
    ],
    "anti_patterns": [
      "Proposing fixes without fully understanding the root cause",
      "Attempting multiple simultaneous changes during debugging",
      "Making quick patches without gathering diagnostic evidence first"
    ],
    "faq": [
      {
        "question": "Which AI tools support this skill?",
        "answer": "This skill works with Claude, Codex, and Claude Code. Use it whenever you need debugging assistance."
      },
      {
        "question": "How long does systematic debugging take?",
        "answer": "Initial investigation takes 15-30 minutes but achieves 95% first-time fix success versus hours of trial-and-error."
      },
      {
        "question": "When should I stop trying fixes?",
        "answer": "Stop after three failed fix attempts. This signals an architectural problem requiring deeper investigation."
      },
      {
        "question": "Does this skill run tests automatically?",
        "answer": "No, this skill provides methodology guidance. You must manually reproduce issues and run tests."
      },
      {
        "question": "What data does this skill access?",
        "answer": "This is a prompt-only skill with no code execution or file access. It provides guidance only."
      },
      {
        "question": "How is this different from other debugging approaches?",
        "answer": "It enforces root cause analysis before any fix attempt, preventing symptom patches and new bug introduction."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
