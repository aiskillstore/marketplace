{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-06T01:21:58.117Z",
    "slug": "metabase-clojure-review",
    "source_url": "https://github.com/metabase/metabase/tree/master/.claude/skills/clojure-review",
    "source_ref": "master",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "dd5793e7e43d209a36ab1c4ff60d8f44ac9581e65e09d0f7f4d0132333c094c4",
    "tree_hash": "c2e049a159e17d4f58cd0105d884bcb524f3ac33ff7e12be7f051cdc96b925d4"
  },
  "skill": {
    "name": "clojure-review",
    "description": "Review Clojure and ClojureScript code changes for compliance with Metabase coding standards, style violations, and code quality issues. Use when reviewing pull requests or diffs containing Clojure/ClojureScript code.",
    "summary": "Review Clojure and ClojureScript code changes for compliance with Metabase coding standards, style v...",
    "icon": "ðŸ§ª",
    "version": "1.0.0",
    "author": "metabase",
    "license": "UNLICENSED",
    "category": "coding",
    "tags": [
      "clojure",
      "code-review",
      "clojurescript",
      "static-analysis",
      "quality-assurance"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a pure prompt-based skill with no executable code. It provides review guidelines, checklists, and patterns for code review. No network access, no scripts, no file writes, no external commands executed by the skill itself.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 3,
    "total_lines": 386,
    "audit_model": "claude",
    "audited_at": "2026-01-06T01:21:58.117Z"
  },
  "content": {
    "user_title": "Review Clojure code for standards compliance",
    "value_statement": "This skill helps AI assistants review Clojure and ClojureScript code changes against Metabase coding standards. It catches style violations, naming issues, documentation gaps, and code quality problems in pull requests.",
    "seo_keywords": [
      "clojure code review",
      "clojurescript review",
      "code quality",
      "style guide",
      "linting",
      "Metabase",
      "Claude Code",
      "Codex",
      "static analysis"
    ],
    "actual_capabilities": [
      "Check naming conventions (kebab-case, noun-named pure functions, ! suffix for side effects)",
      "Verify documentation requirements (docstrings, TODO format, Markdown conventions)",
      "Validate REST API patterns (Malli schemas, kebab-case query params, singular routes)",
      "Review test organization (parallelæ ‡è®° pure tests, separate deftest forms)",
      "Scan for code organization issues (function length, private visibility, let destructuring)",
      "Flag MBQL and database anti-patterns (raw MBQL usage, model naming)"
    ],
    "limitations": [
      "Only reviews code against Metabase standards, not general Clojure best practices",
      "Does not execute code or run tests (only documents how to run them)",
      "Cannot fix issues automatically, only identifies them for human review",
      "Does not integrate with external CI/CD systems or comment on GitHub directly"
    ],
    "use_cases": [
      {
        "target_user": "Pull request reviewers",
        "title": "Review PR code changes",
        "description": "Scan Clojure diffs in pull requests for style violations and coding standards compliance."
      },
      {
        "target_user": "Quality assurance",
        "title": "Enforce code consistency",
        "description": "Apply consistent naming, documentation, and architectural patterns across all Clojure contributions."
      },
      {
        "target_user": "Development teams",
        "title": "Standardize code reviews",
        "description": "Provide automated code review guidance that matches Metabase internal conventions."
      }
    ],
    "prompt_templates": [
      {
        "title": "Quick diff review",
        "scenario": "Review a small code change",
        "prompt": "Review the changed Clojure files in this diff against Metabase coding standards. Check naming, documentation, and organization."
      },
      {
        "title": "API endpoint review",
        "scenario": "Review a new REST API endpoint",
        "prompt": "Review this new REST API endpoint implementation. Check that it has Malli schemas, uses kebab-case for query params, has no side effects in GET handlers, and includes tests."
      },
      {
        "title": "Test file review",
        "scenario": "Review test file quality",
        "prompt": "Review the test file. Check that pure tests are marked parallel, test names end with -test, and separate test cases have separate deftest forms."
      },
      {
        "title": "Comprehensive review",
        "scenario": "Full code review",
        "prompt": "Perform a comprehensive code review of these Clojure changes. Use the complete checklist: naming, documentation, visibility, function length, REST API conventions, MBQL patterns, and database patterns."
      }
    ],
    "output_examples": [
      {
        "input": "Review this Clojure function for standards compliance",
        "output": [
          "## Code Review Results",
          "",
          "### Naming Issues",
          "- [ ] Pure function `calculate-user-age` should be named as a noun: `user-age`",
          "- [ ] Side-effect function `save-data` missing `!` suffix: `save-data!`",
          "",
          "### Documentation Issues",
          "- [ ] Public function `process-data` missing docstring",
          "- [ ] TODO comment missing author/date format: `;; TODO (Name 1/1/25) -- description`",
          "",
          "### Organization Issues",
          "- [ ] Function exceeds 20 lines (42 lines) - consider breaking up",
          "- [ ] Local function `helper-fn` used only in this namespace - mark as `^:private`"
        ]
      }
    ],
    "best_practices": [
      "Run the full review checklist for comprehensive feedback rather than spot-checking specific items",
      "Apply fixes for obvious issues (linting, formatting) before requesting human review of complex items",
      "Focus on Metabase-specific conventions including REST API patterns and module structure"
    ],
    "anti_patterns": [
      "Do not post congratulatory comments for following style guidelines",
      "Do not confirm things look good without substantive review",
      "Do not flag missing parentheses - these are caught by the linter"
    ],
    "faq": [
      {
        "question": "Does this skill run linters automatically?",
        "answer": "No. The skill documents how to run linters like `./bin/mage kondo-updated` but does not execute them automatically."
      },
      {
        "question": "What Clojure versions are supported?",
        "answer": "The skill follows Metabase conventions for Clojure and ClojureScript in their codebase."
      },
      {
        "question": "Can it fix issues it finds?",
        "answer": "No. This skill identifies issues for human review. Some obvious fixes can be applied manually."
      },
      {
        "question": "Is my code data safe?",
        "answer": "Yes. This is a prompt-only skill with no network access. Code is read locally and reviewed in memory."
      },
      {
        "question": "Does it work with GitHub PR comments?",
        "answer": "No. The skill provides review feedback that you can copy and paste to your review tool."
      },
      {
        "question": "How is this different from clj-kondo?",
        "answer": "clj-kondo catches syntax and basic style issues. This skill catches conventions, documentation, architecture, and patterns that require human judgment."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
