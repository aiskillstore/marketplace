{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-08T11:20:12.194Z",
    "slug": "metabase-clojure-write",
    "source_url": "https://github.com/metabase/metabase/tree/master/.claude/skills/clojure-write",
    "source_ref": "master",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "2ab7b479a9c3b1e402ad176a42b5672b0b2b7cfed5bdb06998ec149709c6c867",
    "tree_hash": "aafdbd18ff3dda10a6fd87449cd1412b728430d0c85bd8847a13fe384d9a6f55"
  },
  "skill": {
    "name": "clojure-write",
    "description": "Guide Clojure and ClojureScript development using REPL-driven workflow, coding conventions, and best practices. Use when writing, developing, or refactoring Clojure/ClojureScript code.",
    "summary": "Guide Clojure and ClojureScript development using REPL-driven workflow, coding conventions, and best...",
    "icon": "λ",
    "version": "1.0.0",
    "author": "metabase",
    "license": "UNLICENSED",
    "category": "coding",
    "tags": [
      "clojure",
      "clojurescript",
      "repl",
      "functional-programming"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure prompt-based skill containing only markdown documentation for Clojure development guidelines. No executable code, no network calls, no file system access beyond reading its own markdown files, and no environment variable access. The skill provides development workflow guidance and references command-line tools without executing them.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 4,
    "total_lines": 287,
    "audit_model": "claude",
    "audited_at": "2026-01-08T11:20:12.194Z"
  },
  "content": {
    "user_title": "Write Clojure with REPL-driven development",
    "value_statement": "Clojure development can be challenging without understanding REPL-driven workflows and coding conventions. This skill provides step-by-step guidance for writing, testing, and refactoring Clojure and ClojureScript code following established best practices.",
    "seo_keywords": [
      "clojure development",
      "clojurescript",
      "repl-driven development",
      "functional programming",
      "metabase",
      "claude code",
      "codex",
      "claude",
      "clojure coding conventions",
      "clojure best practices"
    ],
    "actual_capabilities": [
      "Guides bottom-up REPL-driven development workflow",
      "Provides Clojure and ClojureScript coding conventions",
      "Details testing strategies with targeted test execution",
      "Lists common build and lint commands for Clojure projects",
      "Explains code readability verification techniques"
    ],
    "limitations": [
      "Does not execute Clojure code directly",
      "Does not access the filesystem beyond its own documentation",
      "Does not install or configure Clojure development environment",
      "Does not modify project files without explicit user direction"
    ],
    "use_cases": [
      {
        "target_user": "Clojure developers",
        "title": "Start REPL-driven development",
        "description": "Learn to build small functions incrementally, test them in REPL, then integrate into source code."
      },
      {
        "target_user": "Metabase contributors",
        "title": "Follow Metabase conventions",
        "description": "Apply Metabase-specific naming, documentation, and code organization standards for Clojure contributions."
      },
      {
        "target_user": "ClojureScript developers",
        "title": "Write consistent ClojureScript",
        "description": "Apply the same REPL workflow and conventions to ClojureScript frontend development."
      }
    ],
    "prompt_templates": [
      {
        "title": "Start new feature",
        "scenario": "Building a new Clojure function",
        "prompt": "Help me develop a new Clojure function using REPL-driven workflow. I need to build a function that [describe functionality]. Start by identifying the smallest testable functions I should write first."
      },
      {
        "title": "Write tests",
        "scenario": "Creating test cases",
        "prompt": "Write Clojure test cases for my function. Include typical use cases and edge cases. Use the :parallel tag where appropriate for pure functions."
      },
      {
        "title": "Apply style guide",
        "scenario": "Formatting and naming",
        "prompt": "Review my Clojure code and help me apply the Metabase style guide. Check naming conventions, docstrings, function organization, and line length limits."
      },
      {
        "title": "Refactor code",
        "scenario": "Improving existing code",
        "prompt": "Help me refactor a Clojure function that's over 20 lines. Break it into smaller, composable functions using the bottom-up approach I learned."
      }
    ],
    "output_examples": [
      {
        "input": "Help me write a function to validate email addresses in Clojure",
        "output": [
          "Start by creating small, testable functions:",
          "• Write `blank?` check for empty strings",
          "• Write `contains-at?` to verify @ symbol position",
          "• Write `valid-domain?` to check domain structure",
          "Test each in REPL before composing them into `valid-email?`",
          "Remember: pure function names should be nouns (e.g., `email-validator` not `validate-email`)"
        ]
      }
    ],
    "best_practices": [
      "Start with the smallest fundamental functions and test each one thoroughly in the REPL before building on them",
      "Keep functions small (under 20 lines), focused, and composable following functional programming principles",
      "Use clojure-mcp tools when available for direct REPL integration instead of shell commands"
    ],
    "anti_patterns": [
      "Writing large functions without breaking them into testable pieces first",
      "Skipping REPL testing and writing directly to source files without verification",
      "Forgetting to run code readability checks (-check-readable) after editing Clojure code"
    ],
    "faq": [
      {
        "question": "What tools does this skill work with?",
        "answer": "This skill works with Claude, Codex, and Claude Code. It recommends using clojure-mcp tools when available for direct REPL integration."
      },
      {
        "question": "Does this skill execute Clojure code?",
        "answer": "No. This is a guidance-only skill that provides development patterns. Code execution requires clojure-mcp tools or user-initiated ./bin/mage commands."
      },
      {
        "question": "How do I run tests for my Clojure code?",
        "answer": "Use `./bin/mage run-tests namespace/test-name` to run specific tests. Run `:parallel` tagged tests concurrently for pure functions."
      },
      {
        "question": "Is my data safe with this skill?",
        "answer": "Yes. This skill only reads its own markdown files and provides guidance. It does not access project files, network resources, or environment variables."
      },
      {
        "question": "Why should I use REPL-driven development?",
        "answer": "REPL-driven development provides immediate feedback, catches errors early, and helps you build reliable functions by testing small pieces before composing them."
      },
      {
        "question": "How is this different from other Clojure skills?",
        "answer": "This skill focuses specifically on Metabase conventions and the bottom-up REPL workflow advocated by the Metabase team for reliable Clojure development."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
