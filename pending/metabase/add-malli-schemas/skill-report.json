{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-08T11:18:19.711Z",
    "slug": "metabase-add-malli-schemas",
    "source_url": "https://github.com/metabase/metabase/tree/master/.claude/skills/add-malli-schemas",
    "source_ref": "master",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "f9c6c2d0a197708300913509a98d2e50f6b0c0cbda7c4f069b3b01de5a926062",
    "tree_hash": "bef9302c1101a7df1b110b8487ea965e976809ff7485a5a20fe55e8cacbc7d78"
  },
  "skill": {
    "name": "add-malli-schemas",
    "description": "Efficiently add Malli schemas to API endpoints in the Metabase codebase with proper patterns, validation timing, and error handling",
    "summary": "Efficiently add Malli schemas to API endpoints in the Metabase codebase with proper patterns, valida...",
    "icon": "ðŸ“‹",
    "version": "1.0.0",
    "author": "metabase",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "clojure",
      "malli",
      "api",
      "validation",
      "metabase"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a pure documentation skill containing only a markdown file (SKILL.md) with guidance on adding Malli schemas. No executable code, scripts, network calls, filesystem access beyond reading, or external command execution capabilities were detected.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 421,
    "audit_model": "claude",
    "audited_at": "2026-01-08T11:18:19.710Z"
  },
  "content": {
    "user_title": "Add Malli Schemas to API Endpoints",
    "value_statement": "Inconsistent API schemas make validation difficult and errors confusing for developers. This skill provides clear patterns and best practices for adding Malli schemas to Metabase API endpoints with proper handling of route params, query params, body params, and response validation.",
    "seo_keywords": [
      "Malli schemas",
      "Clojure validation",
      "API endpoint validation",
      "Metabase development",
      "Claude Code",
      "Claude",
      "Codex",
      "schema registry",
      "request validation",
      "response validation"
    ],
    "actual_capabilities": [
      "Add route parameter schemas to API endpoints",
      "Add query parameter schemas with optional flags and default values",
      "Add request body schemas for POST and PUT endpoints",
      "Define response schemas with named schemas for reuse",
      "Apply Malli best practices from existing Metabase endpoints",
      "Handle common pitfalls like nullable fields and validation timing"
    ],
    "limitations": [
      "This is a documentation and guidance skill, not an automated code generator",
      "Does not execute code or modify files directly",
      "Specific to Metabase codebase patterns and may not apply to other projects",
      "Does not provide runtime schema validation or enforcement"
    ],
    "use_cases": [
      {
        "target_user": "Clojure developers",
        "title": "Add schemas to new endpoints",
        "description": "Learn proper Malli schema patterns when adding validation to new Metabase API endpoints"
      },
      {
        "target_user": "Backend engineers",
        "title": "Fix validation issues",
        "description": "Understand validation timing and fix schema issues in existing API endpoints"
      },
      {
        "target_user": "Code reviewers",
        "title": "Review schema changes",
        "description": "Verify that API endpoint schemas follow Metabase conventions and best practices"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic schema help",
        "scenario": "Adding first schema",
        "prompt": "How do I add a Malli schema for a route parameter that accepts a positive integer ID?"
      },
      {
        "title": "Query params",
        "scenario": "Optional query parameters",
        "prompt": "What is the correct pattern for query parameters that are optional with default values?"
      },
      {
        "title": "Response schemas",
        "scenario": "Complex response types",
        "prompt": "How do I define a response schema for an endpoint that returns a nested map with arrays of objects?"
      },
      {
        "title": "Error messages",
        "scenario": "Custom validation messages",
        "prompt": "How do I add custom error messages to my Malli schemas for better developer experience?"
      }
    ],
    "output_examples": [
      {
        "input": "How do I add a Malli schema for a POST endpoint with a name and optional description?",
        "output": [
          "Route params: id as positive integer",
          "Query params: optional include and archived flags with defaults",
          "Body params: name as non-blank string, description as optional non-blank string",
          "Response schema: defined with mr/def for reuse"
        ]
      }
    ],
    "best_practices": [
      "Use existing schema types from the ms namespace when possible for consistency with Metabase infrastructure",
      "Separate route, query, and body parameters into distinct destructuring maps rather than combining them",
      "Define named schemas with mr/def for structures that are reused across multiple endpoints"
    ],
    "anti_patterns": [
      "Forgetting to use [:maybe X] for nullable fields, which causes validation failures on nil values",
      "Using ms/TemporalString for response schemas instead of :any, since Java Time objects are validated before JSON serialization",
      "Combining route params, query params, and body params into a single destructuring map instead of separating them"
    ],
    "faq": [
      {
        "question": "Which tools support this skill?",
        "answer": "This skill works with Claude, Codex, and Claude Code for Clojure development tasks."
      },
      {
        "question": "What is the difference between request and response schemas?",
        "answer": "Request schemas validate after JSON parsing when data is already deserialized. Response schemas validate before serialization when data is still in Clojure format."
      },
      {
        "question": "How do I use existing Metabase schema types?",
        "answer": "Import ms as an alias and use types like ms/PositiveInt, ms/NonBlankString, and ms/BooleanValue from metabase.util.malli.schema."
      },
      {
        "question": "Is my data safe when using this skill?",
        "answer": "This skill is read-only documentation. It provides guidance without executing code or accessing your codebase."
      },
      {
        "question": "Why is my response schema failing validation?",
        "answer": "Common causes include using ms/TemporalString for Java Time objects, using [:sequential] for data that is actually a set, or missing [:maybe] for nullable fields."
      },
      {
        "question": "How does this compare to Schema or clojure.spec?",
        "answer": "Malli is more lightweight and performant than Clojure Schema. Unlike clojure.spec, Malli does not require AOT compilation and offers better performance for runtime validation."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
