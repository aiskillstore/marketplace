{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T12:09:54.383Z",
    "slug": "chemiseblanc-git-commit",
    "source_url": "https://github.com/Chemiseblanc/ai/tree/main/skill/git-commit",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "006b4aea7bfd0530ceed12cb4d634db85058723b1bb3b3e9038cb92ad9affae6",
    "tree_hash": "fb19ef48b6d441047f0a2c1baefbdbb3d1427811946adab3ab9d0f59ab6988d3"
  },
  "skill": {
    "name": "git-commit",
    "description": "Guide for breaking changes into logical, atomic commits using interactive staging. Use when committing changes that span multiple concerns, when needing to stage parts of files (hunks), when asked to create well-organized commit history, or when changes should be split into multiple commits.",
    "summary": "Guide for breaking changes into logical, atomic commits using interactive staging. Use when committi...",
    "icon": "üìù",
    "version": "1.0.0",
    "author": "Chemiseblanc",
    "license": "MIT",
    "category": "devops",
    "tags": [
      "git",
      "version-control",
      "commit",
      "staging",
      "best-practices"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a documentation-only skill containing static markdown with git best practices. No executable code, network calls, or data access. Pure educational content.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 94,
    "audit_model": "claude",
    "audited_at": "2026-01-10T12:09:54.383Z"
  },
  "content": {
    "user_title": "Organize Git Commits with Interactive Staging",
    "value_statement": "Struggling with messy commits that mix unrelated changes? This skill guides you through breaking changes into logical, atomic commits using git's interactive staging features.",
    "seo_keywords": [
      "git commit",
      "interactive staging",
      "git add patch",
      "atomic commits",
      "git best practices",
      "Claude",
      "Claude Code",
      "version control",
      "git workflow",
      "commit organization"
    ],
    "actual_capabilities": [
      "Guides splitting changes into logical commits",
      "Explains interactive staging with git add -p",
      "Provides hunk staging strategies",
      "Demonstrates commit verification techniques",
      "Shows workflow for multi-commit organization"
    ],
    "limitations": [
      "Documentation only - no automated git operations",
      "Requires manual execution of git commands",
      "Does not handle merge conflicts",
      "Assumes basic git knowledge"
    ],
    "use_cases": [
      {
        "target_user": "Developers",
        "title": "Clean Up Feature Branches",
        "description": "Organize mixed changes into separate commits for features, fixes, and refactors before creating pull requests."
      },
      {
        "target_user": "Team Leads",
        "title": "Review Commit History",
        "description": "Help team members create atomic commits that are easy to review and understand."
      },
      {
        "target_user": "Open Source Contributors",
        "title": "Maintain Clean History",
        "description": "Follow best practices for commit organization in open source projects with strict contribution guidelines."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Staging",
        "scenario": "First time using interactive staging",
        "prompt": "Show me how to use git add -p to stage specific parts of my changes"
      },
      {
        "title": "Split Mixed Changes",
        "scenario": "Multiple types of changes in same files",
        "prompt": "I have bug fixes and new features mixed together. How do I separate them into different commits?"
      },
      {
        "title": "Review Before Commit",
        "scenario": "Verify what's being committed",
        "prompt": "How can I see exactly what changes will be included in my next commit?"
      },
      {
        "title": "Advanced Hunk Splitting",
        "scenario": "Complex changes within single hunks",
        "prompt": "The hunk is too large and mixes different changes. How do I split it further?"
      }
    ],
    "output_examples": [
      {
        "input": "I have changes to 3 files that include a bug fix, a new feature, and some refactoring. How should I organize these into commits?",
        "output": [
          "‚Ä¢ Use 'git status' to see all changed files",
          "‚Ä¢ Run 'git add -p' to interactively stage hunks",
          "‚Ä¢ Stage only the bug fix changes first, then commit with a descriptive message",
          "‚Ä¢ Continue staging and committing the feature and refactor changes separately",
          "‚Ä¢ Verify each commit with 'git diff --cached' before committing"
        ]
      }
    ],
    "best_practices": [
      "Review staged changes with 'git diff --cached' before each commit",
      "Use conventional commit format for clear commit messages",
      "Stage related changes together even if they're in different files",
      "Keep commits atomic - each commit should represent one logical change"
    ],
    "anti_patterns": [
      "Avoid committing multiple unrelated changes in a single commit",
      "Don't stage entire files without reviewing the changes first",
      "Never rush commits - take time to organize changes properly",
      "Avoid mixing formatting changes with functional changes"
    ],
    "faq": [
      {
        "question": "Is this skill compatible with all git versions?",
        "answer": "Yes, the git commands shown work with all modern git versions (2.x and later)."
      },
      {
        "question": "What are the limitations of hunk staging?",
        "answer": "Some complex changes cannot be automatically split. You may need to manually edit files or use multiple staging passes."
      },
      {
        "question": "Can I integrate this with my IDE?",
        "answer": "Most IDEs have built-in git staging features. Use this skill to understand the underlying git commands they execute."
      },
      {
        "question": "Is my code safe when using interactive staging?",
        "answer": "Yes, interactive staging only affects what gets committed. Your working directory remains unchanged."
      },
      {
        "question": "What if I accidentally stage the wrong hunk?",
        "answer": "Use 'git reset HEAD <file>' to unstage, or 'git reset -p' to unstage specific hunks before committing."
      },
      {
        "question": "How does this compare to git stash?",
        "answer": "Interactive staging commits changes permanently. Git stash temporarily saves changes for later use."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
