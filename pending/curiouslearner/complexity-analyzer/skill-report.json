{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T12:54:16.711Z",
    "slug": "curiouslearner-complexity-analyzer",
    "source_url": "https://github.com/CuriousLearner/devkit/tree/main/skills/complexity-analyzer",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "000c902ae1230c789b78529702ce211fb25c96dcd9987e9dc09d30f0c745c86f",
    "tree_hash": "93f8cca23dc24b4f7d15c083dcbb2a0258c225a1ece940cf216e49540b0c483d"
  },
  "skill": {
    "name": "complexity-analyzer",
    "description": "Measure and report code complexity metrics with actionable recommendations.",
    "summary": "Measure and report code complexity metrics with actionable recommendations.",
    "icon": "ðŸ“Š",
    "version": "1.0.0",
    "author": "CuriousLearner",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "code-quality",
      "metrics",
      "analysis",
      "refactoring"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a pure prompt-based skill containing only instructional content for AI-assisted code complexity analysis. No executable code, network calls, file system access, or external command execution is present. The skill provides guidelines and thresholds for measuring code quality metrics.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 187,
    "audit_model": "claude",
    "audited_at": "2026-01-10T12:54:16.711Z"
  },
  "content": {
    "user_title": "Analyze code complexity metrics",
    "value_statement": "Complex code is hard to maintain and prone to bugs. This skill measures cyclomatic complexity, cognitive complexity, and maintainability to identify refactoring opportunities.",
    "seo_keywords": [
      "code complexity analyzer",
      "cyclomatic complexity",
      "cognitive complexity",
      "code quality metrics",
      "software maintainability",
      "code refactoring",
      "Claude Code",
      "Claude",
      "Codex",
      "static analysis"
    ],
    "actual_capabilities": [
      "Calculate cyclomatic complexity for code paths",
      "Measure cognitive complexity and mental effort",
      "Analyze Halstead metrics and program vocabulary",
      "Generate maintainability index scores",
      "Provide refactoring recommendations",
      "Identify overly complex functions and files"
    ],
    "limitations": [
      "Does not execute or modify source code",
      "Analysis is performed through AI tools, not dedicated CLI tools",
      "Complexity metrics are estimates based on code structure",
      "Requires AI context window access to read code"
    ],
    "use_cases": [
      {
        "target_user": "Software Engineers",
        "title": "Identify refactoring targets",
        "description": "Find complex functions that need refactoring before adding new features or fixing bugs."
      },
      {
        "target_user": "Code Reviewers",
        "title": "Review code complexity",
        "description": "Evaluate pull requests for acceptable complexity levels before merging to main branch."
      },
      {
        "target_user": "Technical Leads",
        "title": "Track code quality trends",
        "description": "Monitor project-wide complexity metrics to identify quality degradation over time."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic analysis",
        "scenario": "Quick complexity check",
        "prompt": "Use complexity-analyzer to analyze the code in my current context. Report the top 5 most complex functions with their scores and recommendations."
      },
      {
        "title": "Detailed file analysis",
        "scenario": "In-depth file review",
        "prompt": "Use complexity-analyzer with --detailed mode on the following files. Show cyclomatic complexity, nesting depth, and parameter counts for each function."
      },
      {
        "title": "Threshold-based report",
        "scenario": "High-complexity detection",
        "prompt": "Use complexity-analyzer with --threshold 20 to find all functions exceeding this complexity level. Provide refactoring suggestions for each."
      },
      {
        "title": "Export for CI/CD",
        "scenario": "Generate exportable report",
        "prompt": "Use complexity-analyzer with --export-json on the entire src directory. Generate a maintainability index and highlight functions needing immediate attention."
      }
    ],
    "output_examples": [
      {
        "input": "Analyze complexity of UserService.js",
        "output": [
          "Top Complex Functions:",
          "â€¢ processPayment() - Cyclomatic: 28 (Refactor Required)",
          "â€¢ validateOrder() - Cyclomatic: 18 (Review Recommended)",
          "â€¢ calculateTotal() - Cyclomatic: 12 (Acceptable)",
          "",
          "Maintainability Index: 68/100",
          "Recommendation: Break processPayment() into 4 smaller functions."
        ]
      }
    ],
    "best_practices": [
      "Keep cyclomatic complexity below 10 for most functions",
      "Use early returns and guard clauses to reduce nesting",
      "Extract complex conditional logic into named functions",
      "Limit function parameters to 3 or fewer"
    ],
    "anti_patterns": [
      "Ignoring high complexity warnings and leaving functions unchanged",
      "Writing functions with more than 5 levels of nesting",
      "Combining multiple responsibilities in a single function",
      "Using complex ternary operators instead of clear if-else statements"
    ],
    "faq": [
      {
        "question": "Which programming languages are supported?",
        "answer": "JavaScript, TypeScript, Python, Java, Go, and Ruby. Each language uses appropriate linting and analysis tools."
      },
      {
        "question": "What complexity thresholds should I use?",
        "answer": "Target below 10 for cyclomatic complexity. Functions above 20 need review, and above 50 require immediate refactoring."
      },
      {
        "question": "How does this integrate with my CI pipeline?",
        "answer": "Use the --export-json flag to generate machine-readable output that can be parsed and used in build systems."
      },
      {
        "question": "Is my code data safe?",
        "answer": "Yes. This skill runs entirely within your AI context. No code is sent to external services or stored externally."
      },
      {
        "question": "Why is my maintainability score low?",
        "answer": "Low scores typically result from high complexity, long functions, deep nesting, or excessive parameters. Review the recommendations to improve."
      },
      {
        "question": "How is this different from ESLint or other linters?",
        "answer": "This skill provides AI-guided analysis with context-aware recommendations. Linters enforce rules but do not explain refactoring approaches."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
