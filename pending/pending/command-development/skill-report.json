{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2025-12-30T08:29:55.631Z",
    "slug": "command-development",
    "source_url": "https://github.com/anthropics/claude-code/tree/main/plugins/plugin-dev/skills/command-development",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "trust_level": "official"
  },
  "skill": {
    "name": "Command Development",
    "description": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a custom command\", \"define command arguments\", \"use command frontmatter\", \"organize commands\", \"create command with file references\", \"interactive command\", \"use AskUserQuestion in command\", or needs guidance on slash command structure, YAML frontmatter fields, dynamic arguments, bash execution in commands, user interaction patterns, or command development best practices for Claude Code.",
    "summary": "This skill should be used when the user asks to \"create a slash command\", \"add a command\", \"write a ...",
    "icon": "⚙️",
    "version": "0.2.0",
    "author": "Anthropic",
    "license": "Not specified",
    "category": "development",
    "tags": [
      "commands",
      "slash-commands",
      "automation",
      "workflow",
      "yaml",
      "markdown",
      "claude-code",
      "plugin-development",
      "cli"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Official Anthropic skill for command development. Contains educational content and best practices with no malicious code or security vulnerabilities.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 11,
    "total_lines": 7237,
    "audit_model": "claude",
    "audited_at": "2025-12-30T08:29:55.630Z"
  },
  "content": {
    "user_title": "Slash Command Development Guide",
    "value_statement": "Learn to create powerful, reusable slash commands for Claude Code with proper YAML frontmatter, dynamic arguments, file references, and plugin integration patterns.",
    "seo_keywords": [
      "slash commands",
      "claude code commands",
      "command frontmatter",
      "yaml configuration",
      "dynamic arguments",
      "bash execution",
      "plugin development",
      "command patterns",
      "workflow automation",
      "interactive commands",
      "AskUserQuestion",
      "command testing"
    ],
    "actual_capabilities": [
      "Teaches complete slash command file structure and format",
      "Explains all YAML frontmatter fields (description, allowed-tools, model, argument-hint, disable-model-invocation)",
      "Demonstrates dynamic argument usage ($ARGUMENTS, $1, $2, etc.)",
      "Shows file reference syntax using @ for including file contents",
      "Covers bash execution patterns with !` syntax for dynamic context",
      "Provides plugin-specific features like ${CLAUDE_PLUGIN_ROOT}",
      "Explains command organization and namespacing strategies",
      "Demonstrates integration with plugin agents, skills, and hooks",
      "Includes interactive command patterns using AskUserQuestion tool",
      "Provides validation patterns for arguments, files, and resources",
      "Offers comprehensive testing strategies and best practices",
      "Contains 20+ complete working command examples",
      "Covers advanced workflows and multi-step command sequences",
      "Explains marketplace considerations for command distribution"
    ],
    "limitations": [
      "Requires understanding of Markdown and YAML syntax",
      "Bash execution patterns require familiarity with shell commands",
      "Plugin-specific features only available in plugin context",
      "Some advanced patterns require knowledge of Claude Code architecture",
      "Interactive commands require understanding of AskUserQuestion tool API"
    ],
    "use_cases": [
      {
        "title": "Create Project-Specific Workflows",
        "description": "Build custom slash commands for common team workflows like code review, testing, deployment, or documentation generation that match your project's specific needs and standards.",
        "target_user": "Development teams wanting to standardize and automate repetitive tasks"
      },
      {
        "title": "Build Reusable Plugin Commands",
        "description": "Develop commands bundled with Claude Code plugins that leverage plugin scripts, templates, configurations, and integrate with plugin agents and skills for powerful, distributable functionality.",
        "target_user": "Plugin developers creating shareable tools and workflows"
      },
      {
        "title": "Interactive Configuration Wizards",
        "description": "Create commands that use AskUserQuestion to guide users through complex setup and configuration processes with clear options, explanations, and multi-step workflows.",
        "target_user": "Users building onboarding or setup automation"
      },
      {
        "title": "Context-Aware Code Analysis",
        "description": "Build commands that combine file references, bash execution for git status, and dynamic arguments to perform intelligent, context-aware code reviews and analysis.",
        "target_user": "Code reviewers and quality assurance teams"
      },
      {
        "title": "Multi-Step Deployment Workflows",
        "description": "Create sophisticated deployment commands that validate environments, execute scripts, coordinate with hooks, and provide step-by-step progress through complex release processes.",
        "target_user": "DevOps engineers and release managers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Create a Basic Code Review Command",
        "prompt": "Create a slash command that reviews code changes for quality and security issues. It should check git diff for changed files and analyze each one.",
        "scenario": "When you want a simple command for daily code review tasks"
      },
      {
        "title": "Build an Interactive Setup Command",
        "prompt": "Create a command that uses AskUserQuestion to interactively set up a new project by asking about language, framework, testing tools, and CI/CD preferences.",
        "scenario": "When you need to guide users through complex configuration choices"
      },
      {
        "title": "Create a Plugin Command with Scripts",
        "prompt": "Build a plugin command that uses ${CLAUDE_PLUGIN_ROOT} to execute plugin scripts for linting, testing, and building, then generates a report from a plugin template.",
        "scenario": "When developing a plugin that needs to execute bundled tools"
      },
      {
        "title": "Build a Multi-Argument Deployment Command",
        "prompt": "Create a deployment command that takes environment, version, and options as arguments, validates the environment, loads appropriate config, and executes deployment with error handling.",
        "scenario": "When you need structured, validated deployment automation"
      },
      {
        "title": "Create a Documentation Generator",
        "prompt": "Build a command that takes a source file path, reads it using @, and generates comprehensive API documentation following a specific template structure.",
        "scenario": "When you want to standardize documentation generation"
      }
    ],
    "output_examples": [
      {
        "input": "User asks: 'Create a command to review pull requests'",
        "output": "I'll create a slash command for PR review:\n\n```markdown\n---\ndescription: Review pull request for quality and security\nargument-hint: [pr-number]\nallowed-tools: Bash(gh:*), Read, Grep\n---\n\nPR #$1 Review:\n\nPR Details: !`gh pr view $1 --json title,body,files`\n\nFiles Changed: !`gh pr diff $1 --name-only`\n\nReview each file for:\n1. Code quality and style\n2. Security vulnerabilities\n3. Test coverage\n4. Documentation needs\n\nProvide specific feedback with file:line references.\n```\n\nSave this as `.claude/commands/review-pr.md` and invoke with `/review-pr 123`"
      },
      {
        "input": "User asks: 'How do I make a command that takes multiple arguments?'",
        "output": "Use positional arguments $1, $2, $3, etc:\n\n```markdown\n---\ndescription: Deploy app to environment\nargument-hint: [app-name] [environment] [version]\n---\n\nDeploy $1 to $2 environment using version $3\n\nValidate:\n- App: $1\n- Environment: $2 (dev|staging|prod)\n- Version: $3\n\nProceed with deployment...\n```\n\nInvoke: `/deploy myapp staging v1.2.3`\n$1=myapp, $2=staging, $3=v1.2.3"
      }
    ],
    "best_practices": [
      "Write commands as instructions FOR Claude, not messages TO users (use imperative/infinitive voice)",
      "Always provide 'description' in frontmatter for discoverability in /help",
      "Use 'argument-hint' to document expected arguments",
      "Restrict 'allowed-tools' to minimum needed for security",
      "Use ${CLAUDE_PLUGIN_ROOT} for all plugin-internal file paths",
      "Validate arguments and file existence before processing",
      "Provide helpful error messages with corrective guidance",
      "Keep commands focused on single responsibility",
      "Test commands with various argument combinations and edge cases",
      "Document complex logic with inline comments",
      "Use AskUserQuestion for decisions requiring explanation or multiple choices",
      "Prefer Bash command filters like 'Bash(git:*)' over 'Bash(*)'",
      "Handle missing arguments gracefully with clear usage instructions",
      "Use progressive disclosure in documentation (basic info first, details on demand)",
      "Version commands and maintain changelog for distributed commands"
    ],
    "anti_patterns": [
      "Writing commands as user-facing messages instead of Claude instructions",
      "Using relative paths instead of ${CLAUDE_PLUGIN_ROOT} in plugins",
      "Hardcoding file paths that won't work across installations",
      "Omitting 'allowed-tools' when Bash execution is needed",
      "Creating overly generic command names that conflict (like /test or /run)",
      "Skipping argument validation and error handling",
      "Using 'allowed-tools: *' without security consideration",
      "Not documenting arguments with 'argument-hint'",
      "Forgetting to test commands with missing or invalid arguments",
      "Creating commands without clear single purpose",
      "Using platform-specific commands without detection/fallback",
      "Not handling file reference failures gracefully",
      "Overusing AskUserQuestion for simple values better suited as arguments",
      "Creating commands with TODO comments in production",
      "Ignoring bash command exit codes and error handling"
    ],
    "faq": [
      {
        "question": "Where should I put my slash commands?",
        "answer": "Use `.claude/commands/` for project-specific commands shared with your team, `~/.claude/commands/` for personal commands available everywhere, or `plugin-name/commands/` for plugin-bundled commands."
      },
      {
        "question": "Do I need YAML frontmatter for every command?",
        "answer": "No, frontmatter is optional. Simple commands can be just Markdown. Add frontmatter only when you need to configure description, allowed-tools, model, or other settings."
      },
      {
        "question": "What's the difference between $ARGUMENTS and $1, $2, $3?",
        "answer": "$ARGUMENTS captures all arguments as a single string. $1, $2, $3 capture individual positional arguments separately. Use $ARGUMENTS for single-parameter commands, use positional for structured multi-argument commands."
      },
      {
        "question": "How do I execute bash commands in my command?",
        "answer": "Use the !`command` syntax and ensure 'allowed-tools' includes Bash with appropriate filter like 'Bash(git:*)'. The command output is included in the prompt Claude receives."
      },
      {
        "question": "What is ${CLAUDE_PLUGIN_ROOT} and when should I use it?",
        "answer": "${CLAUDE_PLUGIN_ROOT} is an environment variable that resolves to your plugin's absolute path. Always use it for referencing plugin files, scripts, templates, or configs to ensure portability across installations."
      },
      {
        "question": "When should I use AskUserQuestion instead of command arguments?",
        "answer": "Use AskUserQuestion for decisions requiring explanation of trade-offs, multiple complex options, multi-select scenarios, or preference gathering. Use arguments for simple known values like file paths or IDs."
      },
      {
        "question": "How do I organize commands when I have many of them?",
        "answer": "Use subdirectories for namespacing: create folders like `ci/`, `git/`, `docs/` under commands/ directory. Each subfolder creates a namespace shown in /help as '(project:namespace)'."
      },
      {
        "question": "Can commands invoke plugin agents or skills?",
        "answer": "Yes. Mention the agent name and Claude will use the Task tool to launch it. Reference skills by name to hint Claude should invoke them. Document what each component provides."
      },
      {
        "question": "How do I test my commands before distributing them?",
        "answer": "Test structure validation, frontmatter fields, manual invocation, arguments (missing, invalid, edge cases), file references, bash execution, and get user feedback. See references/testing-strategies.md for comprehensive testing approaches."
      },
      {
        "question": "What's the best model to use for my command?",
        "answer": "Use 'haiku' for fast, simple commands; 'sonnet' for standard workflows (default); 'opus' for complex analysis. Omit the 'model' field unless you have specific needs."
      }
    ],
    "technical_requirements": {
      "dependencies": [
        "Claude Code CLI",
        "Basic understanding of Markdown syntax",
        "YAML knowledge for frontmatter configuration",
        "Bash/shell familiarity for command execution patterns",
        "Understanding of file systems and paths for file references"
      ],
      "permissions": [
        "File system read access for command files",
        "Write access to create command files in .claude/commands/ or ~/.claude/commands/",
        "Execution permissions for bash commands if using !` syntax",
        "Tool permissions specified in allowed-tools frontmatter field"
      ],
      "complexity": "intermediate"
    }
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "plugin-commands.md",
          "type": "file",
          "path": "examples/plugin-commands.md"
        },
        {
          "name": "simple-commands.md",
          "type": "file",
          "path": "examples/simple-commands.md"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "advanced-workflows.md",
          "type": "file",
          "path": "references/advanced-workflows.md"
        },
        {
          "name": "documentation-patterns.md",
          "type": "file",
          "path": "references/documentation-patterns.md"
        },
        {
          "name": "frontmatter-reference.md",
          "type": "file",
          "path": "references/frontmatter-reference.md"
        },
        {
          "name": "interactive-commands.md",
          "type": "file",
          "path": "references/interactive-commands.md"
        },
        {
          "name": "marketplace-considerations.md",
          "type": "file",
          "path": "references/marketplace-considerations.md"
        },
        {
          "name": "plugin-features-reference.md",
          "type": "file",
          "path": "references/plugin-features-reference.md"
        },
        {
          "name": "testing-strategies.md",
          "type": "file",
          "path": "references/testing-strategies.md"
        }
      ]
    },
    {
      "name": "README.md",
      "type": "file",
      "path": "README.md"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}