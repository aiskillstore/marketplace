{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2025-12-30T08:31:55.033Z",
    "slug": "hook-development",
    "source_url": "https://github.com/anthropics/claude-code/tree/main/plugins/plugin-dev/skills/hook-development",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "trust_level": "official"
  },
  "skill": {
    "name": "Hook Development",
    "description": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop hook\", \"validate tool use\", \"implement prompt-based hooks\", \"use ${CLAUDE_PLUGIN_ROOT}\", \"set up event-driven automation\", \"block dangerous commands\", or mentions hook events (PreToolUse, PostToolUse, Stop, SubagentStop, SessionStart, SessionEnd, UserPromptSubmit, PreCompact, Notification). Provides comprehensive guidance for creating and implementing Claude Code plugin hooks with focus on advanced prompt-based hooks API.",
    "summary": "This skill should be used when the user asks to \"create a hook\", \"add a PreToolUse/PostToolUse/Stop ...",
    "icon": "ü™ù",
    "version": "0.1.0",
    "author": "Anthropic",
    "license": "Not specified",
    "category": "development",
    "tags": [
      "hooks",
      "automation",
      "validation",
      "plugins",
      "workflow",
      "event-driven",
      "security",
      "tooling"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Official Anthropic skill providing educational hook development utilities. All scripts are validation/testing tools with proper input sanitization and no malicious patterns detected.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [
      {
        "title": "Temporary file usage without cleanup in edge cases",
        "description": "Some example scripts create temporary files (e.g., /tmp/hook-state-$$, /tmp/hook-cache-*) that may not be cleaned up if scripts are interrupted. This is minor as they're in /tmp and use process IDs for uniqueness.",
        "locations": [
          {
            "file": "references/advanced.md",
            "line_start": 140,
            "line_end": 155
          }
        ]
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 11,
    "total_lines": 2781,
    "audit_model": "claude",
    "audited_at": "2025-12-30T08:31:55.033Z"
  },
  "content": {
    "user_title": "Hook Development for Claude Code Plugins",
    "value_statement": "Build event-driven automation for Claude Code with hooks that validate tool usage, enforce quality standards, load project context, and customize workflows through natural language prompts or bash scripts.",
    "seo_keywords": [
      "claude code hooks",
      "plugin hooks",
      "pretooluse hooks",
      "posttooluse hooks",
      "event-driven automation",
      "tool validation",
      "workflow automation",
      "prompt-based hooks",
      "command hooks",
      "plugin development"
    ],
    "actual_capabilities": [
      "Create prompt-based hooks using LLM reasoning for context-aware validation",
      "Implement command hooks for deterministic checks and external tool integration",
      "Validate tool calls before execution (PreToolUse) with approve/deny/ask decisions",
      "React to tool results after execution (PostToolUse) with feedback and logging",
      "Enforce completion standards before stopping (Stop, SubagentStop)",
      "Load project-specific context at session start (SessionStart)",
      "Persist environment variables across session",
      "Pattern match tools with exact names, wildcards, or regex",
      "Run multiple hooks in parallel for performance",
      "Test and validate hook configurations before deployment",
      "Lint hook scripts for security and best practices",
      "Integrate external security scanners and validation tools"
    ],
    "limitations": [
      "Hooks load only at session start - changes require Claude Code restart",
      "Hooks run in parallel - cannot rely on execution order",
      "Command hooks have 60s default timeout, prompt hooks 30s",
      "Cannot modify core Claude Code behavior beyond tool validation",
      "Prompt-based hooks only fully supported on Stop, SubagentStop, UserPromptSubmit, PreToolUse events",
      "Hook errors may block user workflows if not handled gracefully"
    ],
    "use_cases": [
      {
        "title": "Security Validation",
        "description": "Block dangerous file writes to system directories, credentials files, or paths with traversal attempts using prompt-based validation",
        "target_user": "Security-conscious developers and teams requiring guardrails"
      },
      {
        "title": "Test Enforcement",
        "description": "Ensure tests run after code modifications by validating transcript before stopping session",
        "target_user": "Development teams enforcing quality standards"
      },
      {
        "title": "Project Context Loading",
        "description": "Automatically detect project type (Node.js, Rust, Python, etc.) and set environment variables at session start",
        "target_user": "Developers working across multiple project types"
      },
      {
        "title": "MCP Tool Monitoring",
        "description": "Validate destructive MCP operations (deletes, drops) with confirmation prompts before execution",
        "target_user": "Users integrating external MCP tools with destructive capabilities"
      },
      {
        "title": "Code Quality Checks",
        "description": "Run linters or formatters automatically after file edits to maintain code standards",
        "target_user": "Teams with strict code quality requirements"
      },
      {
        "title": "Audit Logging",
        "description": "Log all tool usage, notifications, and decisions to external systems for compliance",
        "target_user": "Enterprise teams requiring audit trails"
      }
    ],
    "prompt_templates": [
      {
        "title": "Create File Write Validation Hook",
        "prompt": "Create a PreToolUse hook that validates Write and Edit operations. Block writes to system directories (/etc, /sys, /usr), credentials files (.env, secrets, tokens), and paths with '..' traversal. Use a prompt-based hook.",
        "scenario": "When you need to prevent accidental or malicious writes to sensitive files"
      },
      {
        "title": "Create Test Enforcement Hook",
        "prompt": "Create a Stop hook that reviews the transcript and verifies tests were run if any code was modified (Write/Edit tools used). If no tests were run, block with reason 'Tests must be run after code changes'.",
        "scenario": "When you want to enforce test-driven development practices"
      },
      {
        "title": "Create Project Context Loader",
        "prompt": "Create a SessionStart command hook that detects project type (Node.js, Python, Rust, Go, Java) by checking for package.json, pyproject.toml, Cargo.toml, go.mod, pom.xml, or build.gradle. Set PROJECT_TYPE environment variable accordingly.",
        "scenario": "When you want Claude Code to automatically understand your project type"
      },
      {
        "title": "Create Bash Command Safety Hook",
        "prompt": "Create a PreToolUse hook for Bash commands that analyzes for destructive operations (rm -rf, dd, mkfs), privilege escalation (sudo), and network operations. Use prompt-based validation to catch variations and patterns intelligently.",
        "scenario": "When you need to prevent dangerous bash commands from executing"
      },
      {
        "title": "Validate Hook Configuration",
        "prompt": "Run the validate-hook-schema.sh script on my hooks/hooks.json file to check for JSON syntax errors, valid event names, proper hook types, and correct timeout ranges.",
        "scenario": "When you've created hooks.json and want to verify it's correct before testing"
      }
    ],
    "output_examples": [
      {
        "input": "User attempts to write to /etc/hosts",
        "output": "PreToolUse hook blocks with: {\"hookSpecificOutput\": {\"permissionDecision\": \"deny\"}, \"systemMessage\": \"Cannot write to system directory: /etc/hosts\"}"
      },
      {
        "input": "User tries to stop session after editing code but without running tests",
        "output": "Stop hook blocks with: {\"decision\": \"block\", \"reason\": \"Tests must be run after code changes\", \"systemMessage\": \"No test execution detected in transcript\"}"
      },
      {
        "input": "SessionStart in Node.js project with package.json",
        "output": "Hook outputs: 'üì¶ Node.js project detected' and writes 'export PROJECT_TYPE=nodejs' to $CLAUDE_ENV_FILE"
      }
    ],
    "best_practices": [
      "Use prompt-based hooks for complex validation logic requiring context awareness",
      "Use command hooks for deterministic checks, performance-critical operations, or external tool integration",
      "Always use ${CLAUDE_PLUGIN_ROOT} for portable file paths in hook commands",
      "Quote all bash variables to prevent injection attacks",
      "Set appropriate timeouts: 5-15s for command hooks, 15-30s for prompt hooks",
      "Validate all inputs in command hooks before processing",
      "Design hooks to run independently since they execute in parallel",
      "Test hooks with scripts/test-hook.sh before deploying to Claude Code",
      "Validate hooks.json with scripts/validate-hook-schema.sh",
      "Lint hook scripts with scripts/hook-linter.sh to catch security issues",
      "Use set -euo pipefail in all bash hook scripts for safety",
      "Document hook activation mechanisms and requirements in plugin README",
      "Handle errors gracefully with clear messages to avoid blocking workflows",
      "Cache validation results for performance when appropriate",
      "Use flag files or configuration for temporarily active hooks"
    ],
    "anti_patterns": [
      "Using hardcoded absolute paths instead of ${CLAUDE_PLUGIN_ROOT}",
      "Trusting user input without validation in command hooks",
      "Creating long-running hooks that exceed timeout limits",
      "Relying on hook execution order (hooks run in parallel)",
      "Leaving unquoted bash variables (injection risk)",
      "Hot-swapping hook configuration without restarting Claude Code",
      "Using prompt-based hooks for simple deterministic checks (use command hooks)",
      "Using command hooks for complex reasoning (use prompt-based hooks)",
      "Assuming hooks run sequentially and maintaining state between them",
      "Forgetting to handle edge cases like missing fields or null values",
      "Logging sensitive information in hook output",
      "Creating hooks that modify global state unpredictably"
    ],
    "faq": [
      {
        "question": "When should I use prompt-based hooks vs command hooks?",
        "answer": "Use prompt-based hooks for context-aware validation requiring natural language reasoning (e.g., security analysis, completeness checks). Use command hooks for fast deterministic checks (e.g., file size limits, regex matching) or external tool integration. Prompt hooks are recommended for most validation use cases."
      },
      {
        "question": "How do I test hooks before deploying them?",
        "answer": "Use the provided utility scripts: (1) scripts/hook-linter.sh to check for common issues, (2) scripts/test-hook.sh to run hooks with sample input, (3) scripts/validate-hook-schema.sh to validate hooks.json structure, (4) claude --debug to see detailed hook execution logs in Claude Code."
      },
      {
        "question": "Do hook configuration changes take effect immediately?",
        "answer": "No. Hooks are loaded when Claude Code session starts. You must exit and restart Claude Code for any changes to hooks/hooks.json or hook scripts to take effect."
      },
      {
        "question": "Can hooks modify tool inputs before execution?",
        "answer": "Yes, PreToolUse hooks can return updatedInput in hookSpecificOutput to modify tool parameters before execution."
      },
      {
        "question": "What's the difference between hooks/hooks.json format and settings format?",
        "answer": "Plugin hooks.json uses wrapper format: {\"description\": \"...\", \"hooks\": {\"PreToolUse\": [...]}}. User settings use direct format: {\"PreToolUse\": [...]} with no wrapper. The hook event structure is the same inside both formats."
      },
      {
        "question": "How do I make hooks that only run conditionally?",
        "answer": "Check for a flag file or configuration at the start of your hook script. If the flag isn't present, exit 0 immediately. Users can enable/disable by creating/removing the flag file, but must restart Claude Code for changes to take effect."
      },
      {
        "question": "Can I use hooks to integrate with external security scanners?",
        "answer": "Yes, command hooks can execute external tools and use their exit codes or output to approve/deny operations. See Pattern 8 in references/patterns.md for code quality check examples."
      },
      {
        "question": "What happens if multiple hooks block the same operation?",
        "answer": "Hooks run in parallel. If any hook denies/blocks an operation, the operation is blocked regardless of other hooks' decisions."
      }
    ],
    "technical_requirements": {
      "dependencies": [
        "bash",
        "jq"
      ],
      "permissions": [
        "File system read access for hook scripts",
        "Execute permissions on hook scripts"
      ],
      "complexity": "intermediate"
    }
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "load-context.sh",
          "type": "file",
          "path": "examples/load-context.sh"
        },
        {
          "name": "validate-bash.sh",
          "type": "file",
          "path": "examples/validate-bash.sh"
        },
        {
          "name": "validate-write.sh",
          "type": "file",
          "path": "examples/validate-write.sh"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "advanced.md",
          "type": "file",
          "path": "references/advanced.md"
        },
        {
          "name": "migration.md",
          "type": "file",
          "path": "references/migration.md"
        },
        {
          "name": "patterns.md",
          "type": "file",
          "path": "references/patterns.md"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "hook-linter.sh",
          "type": "file",
          "path": "scripts/hook-linter.sh"
        },
        {
          "name": "README.md",
          "type": "file",
          "path": "scripts/README.md"
        },
        {
          "name": "test-hook.sh",
          "type": "file",
          "path": "scripts/test-hook.sh"
        },
        {
          "name": "validate-hook-schema.sh",
          "type": "file",
          "path": "scripts/validate-hook-schema.sh"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}