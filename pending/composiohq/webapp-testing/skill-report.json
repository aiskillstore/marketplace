{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-06T07:57:35.708Z",
    "slug": "composiohq-webapp-testing",
    "source_url": "https://github.com/ComposioHQ/awesome-claude-skills/tree/master/webapp-testing",
    "source_ref": "master",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "51b7349e77ec63b7744a6f63647e7566a0b4d2e301121cc10e8c2113af6556a2",
    "tree_hash": "7f6af1313a033a9628e9b0e1e4bc72090c1bd6577657d47d3c6c904c9cf48f49"
  },
  "skill": {
    "name": "webapp-testing",
    "description": "Toolkit for interacting with and testing local web applications using Playwright. Supports verifying frontend functionality, debugging UI behavior, capturing browser screenshots, and viewing browser logs.",
    "summary": "Toolkit for interacting with and testing local web applications using Playwright. Supports verifying...",
    "icon": "ðŸ§ª",
    "version": "1.0.0",
    "author": "ComposioHQ",
    "license": "Complete terms in LICENSE.txt",
    "category": "development",
    "tags": [
      "testing",
      "playwright",
      "automation",
      "browser",
      "frontend"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "external_commands",
      "filesystem",
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Legitimate webapp testing toolkit using Playwright. Contains Python scripts that manage local dev servers and perform browser automation. Capabilities align with stated purpose. Risk factors are appropriate for a testing tool.",
    "risk_factor_evidence": [
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "scripts/with_server.py",
            "line_start": 1,
            "line_end": 106
          },
          {
            "file": "examples/static_html_automation.py",
            "line_start": 1,
            "line_end": 33
          },
          {
            "file": "examples/element_discovery.py",
            "line_start": 1,
            "line_end": 40
          },
          {
            "file": "examples/console_logging.py",
            "line_start": 1,
            "line_end": 35
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "scripts/with_server.py",
            "line_start": 68,
            "line_end": 74
          },
          {
            "file": "scripts/with_server.py",
            "line_start": 88,
            "line_end": 88
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "examples/static_html_automation.py",
            "line_start": 17,
            "line_end": 17
          },
          {
            "file": "examples/static_html_automation.py",
            "line_start": 29,
            "line_end": 29
          },
          {
            "file": "examples/element_discovery.py",
            "line_start": 37,
            "line_end": 37
          },
          {
            "file": "examples/console_logging.py",
            "line_start": 31,
            "line_end": 32
          }
        ]
      },
      {
        "factor": "network",
        "evidence": [
          {
            "file": "scripts/with_server.py",
            "line_start": 23,
            "line_end": 32
          },
          {
            "file": "examples/static_html_automation.py",
            "line_start": 14,
            "line_end": 14
          },
          {
            "file": "examples/element_discovery.py",
            "line_start": 10,
            "line_end": 11
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [
      {
        "title": "Shell execution in server management script",
        "description": "The with_server.py script uses subprocess.Popen with shell=True to execute user-provided server commands (lines 69-74). While this is necessary to support commands like 'cd backend && python server.py', it allows arbitrary shell command execution. An attacker who controls the command arguments could execute malicious commands. However, this is a local testing tool where the user provides their own commands.",
        "locations": [
          {
            "file": "scripts/with_server.py",
            "line_start": 68,
            "line_end": 74
          }
        ]
      },
      {
        "title": "Filesystem writes to user directories",
        "description": "Example scripts write screenshots and logs to /mnt/user-data/outputs and /tmp directories (static_html_automation.py:17, 29; element_discovery.py:37; console_logging.py:31). This is appropriate for a testing tool storing test artifacts.",
        "locations": [
          {
            "file": "examples/static_html_automation.py",
            "line_start": 17,
            "line_end": 17
          }
        ]
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 6,
    "total_lines": 512,
    "audit_model": "claude",
    "audited_at": "2026-01-06T07:57:35.708Z"
  },
  "content": {
    "user_title": "Test local web apps with Playwright automation",
    "value_statement": "Testing local web applications requires setting up servers, navigating pages, and verifying behavior. This toolkit provides Playwright automation scripts for browser testing, screenshot capture, and server lifecycle management so you can focus on writing tests.",
    "seo_keywords": [
      "webapp testing",
      "Playwright automation",
      "browser testing",
      "Claude Code",
      "frontend testing",
      "automated testing",
      "headless browser",
      "DOM inspection",
      "screenshot capture",
      "local development"
    ],
    "actual_capabilities": [
      "Launch headless Chromium browsers for automated testing",
      "Capture full-page screenshots of web application states",
      "Discover and interact with DOM elements (buttons, links, inputs)",
      "Capture browser console logs during test execution",
      "Manage local dev server lifecycle (start, wait, stop)",
      "Test static HTML files and dynamic web applications"
    ],
    "limitations": [
      "Requires Playwright and browser binaries installed",
      "Designed for local development servers only",
      "Does not test remote or production URLs",
      "Scripts must be run directly, not imported as modules"
    ],
    "use_cases": [
      {
        "target_user": "Frontend developers",
        "title": "Test React, Vue, or Svelte apps",
        "description": "Automate user flows in your frontend framework app and capture screenshots at each step for visual regression testing."
      },
      {
        "target_user": "QA engineers",
        "title": "Verify UI functionality",
        "description": "Create automated tests that click through pages, fill forms, and verify expected console errors or warnings."
      },
      {
        "target_user": "Full-stack developers",
        "title": "Test multi-service applications",
        "description": "Start backend and frontend servers together, wait for both to be ready, then run integration tests."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic screenshot",
        "scenario": "Capture a page screenshot",
        "prompt": "Take a screenshot of http://localhost:5173 and save it to /tmp/homepage.png"
      },
      {
        "title": "Form testing",
        "scenario": "Test form submission",
        "prompt": "Fill out the contact form at http://localhost:3000/contact with test data and submit it"
      },
      {
        "title": "Console error check",
        "scenario": "Capture console logs",
        "prompt": "Navigate to http://localhost:5173, capture all console messages, and save them to /tmp/logs.txt"
      },
      {
        "title": "Multi-server test",
        "scenario": "Test with backend and frontend",
        "prompt": "Start a backend server on port 3000 and frontend on port 5173, then test the login flow"
      }
    ],
    "output_examples": [
      {
        "input": "Test the homepage of my local React app",
        "output": [
          "âœ“ Chromium browser launched in headless mode",
          "âœ“ Navigated to http://localhost:5173",
          "âœ“ Waited for network idle",
          "âœ“ Found 5 buttons, 12 links, and 3 input fields",
          "âœ“ Screenshot saved to /tmp/homepage.png",
          "âœ“ Browser closed successfully"
        ]
      }
    ],
    "best_practices": [
      "Always run scripts with --help first to understand available options",
      "Use sync_playwright() for simpler synchronous automation scripts",
      "Wait for networkidle before inspecting DOM on dynamic applications"
    ],
    "anti_patterns": [
      "Do not inspect DOM before the page has fully loaded",
      "Do not forget to close the browser after automation completes",
      "Do not use production URLs - this tool is for local testing only"
    ],
    "faq": [
      {
        "question": "What browsers does this skill support?",
        "answer": "Playwright supports Chromium, Firefox, and WebKit. The examples use Chromium in headless mode."
      },
      {
        "question": "Can I test production websites?",
        "answer": "No, this skill is designed for local development servers. Use localhost URLs only."
      },
      {
        "question": "How do I run multiple servers together?",
        "answer": "Pass multiple --server and --port pairs to with_server.py. The script waits for all servers before running your test."
      },
      {
        "question": "Is my data safe when using this skill?",
        "answer": "Yes. All automation runs locally on your machine. No data is sent to external servers."
      },
      {
        "question": "Why do I see 'context window full' warnings?",
        "answer": "The helper scripts are large. Run them directly with --help instead of reading the source code."
      },
      {
        "question": "How is this different from Selenium?",
        "answer": "Playwright is more modern, faster, and has better support for modern web apps. It handles single-page apps and dynamic content better."
      }
    ]
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "console_logging.py",
          "type": "file",
          "path": "examples/console_logging.py"
        },
        {
          "name": "element_discovery.py",
          "type": "file",
          "path": "examples/element_discovery.py"
        },
        {
          "name": "static_html_automation.py",
          "type": "file",
          "path": "examples/static_html_automation.py"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "with_server.py",
          "type": "file",
          "path": "scripts/with_server.py"
        }
      ]
    },
    {
      "name": "LICENSE.txt",
      "type": "file",
      "path": "LICENSE.txt"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
