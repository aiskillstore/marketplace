{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-02-22T08:40:55.165Z",
    "slug": "mcp-use-chatgpt-app-builder",
    "source_url": "https://github.com/mcp-use/mcp-use/tree/main/skills/chatgpt-app-builder/",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "20806b31b8e480608d04888150a7c014c44963f831228be2660f6b1e3a8f32f7",
    "tree_hash": "a6612c95c1aa40026d3b851f4a2492a47a0bb3cb29f26cf22b8c62c4c53c4102"
  },
  "skill": {
    "name": "chatgpt-app-builder",
    "description": "DEPRECATED: This skill has been replaced by `mcp-app-builder`. Check if `mcp-app-builder` is available in the skills folder. If not, install it: `npx skills install mcp-use/mcp-use --skill mcp-app-builder`. Use `mcp-app-builder` instead of this skill.\n\nBuild ChatGPT apps with interactive widgets using mcp-use and OpenAI Apps SDK. Use when creating ChatGPT apps, building MCP servers with widgets, defining React widgets, working with Apps SDK, or when user mentions ChatGPT widgets, mcp-use widgets, or Apps SDK development.",
    "summary": "Build ChatGPT apps with interactive widgets using mcp-use and OpenAI Apps SDK. DEPRECATED - use mcp-app-builder instead.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "mcp-use",
    "license": "MIT",
    "tags": [
      "chatgpt",
      "mcp",
      "widgets",
      "react",
      "openai"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [],
    "category": "coding"
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill is documentation/reference material for building ChatGPT apps with mcp-use. All static analyzer findings are false positives: (1) 'Weak cryptographic algorithm' triggers on 'sha' substring in words like 'shape' - no actual crypto usage; (2) 'Ruby/shell backtick execution' detects markdown code fences, not shell commands; (3) 'System reconnaissance' and 'Hardcoded URL' are documentation patterns; (4) The critical heuristic 'Code execution + Network + Credential access' is triggered by documentation showing code examples with URLs and environment variables - standard documentation practice, not malicious behavior. This skill contains no executable code.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [
      {
        "title": "Hardcoded URLs in Documentation",
        "description": "URLs appear in documentation files (references/setup.md, references/csp-and-metadata.md). These are legitimate API endpoint references in documentation, not security issues.",
        "locations": [
          {
            "file": "references/setup.md",
            "line_start": 37,
            "line_end": 38
          },
          {
            "file": "references/csp-and-metadata.md",
            "line_start": 22,
            "line_end": 23
          }
        ]
      },
      {
        "title": "Environment Variable Access in Code Examples",
        "description": "Documentation shows process.env usage (e.g., process.env.MCP_URL). This is standard configuration pattern in code examples, not credential exfiltration.",
        "locations": [
          {
            "file": "references/server-and-widgets.md",
            "line_start": 29,
            "line_end": 29
          }
        ]
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 18,
    "total_lines": 2127,
    "audit_model": "claude",
    "audited_at": "2026-02-22T08:40:55.165Z",
    "risk_factors": [],
    "risk_factor_evidence": []
  },
  "content": {
    "user_title": "Build ChatGPT Apps with Widgets",
    "value_statement": "This skill provides comprehensive documentation for building ChatGPT apps with interactive widgets using mcp-use and OpenAI Apps SDK. It guides developers through architecture, setup, implementation, and advanced patterns for creating rich, interactive ChatGPT experiences.",
    "seo_keywords": [
      "ChatGPT widgets",
      "mcp-use",
      "OpenAI Apps SDK",
      "Claude",
      "Codex",
      "Claude Code",
      "MCP servers",
      "React widgets",
      "interactive ChatGPT",
      "ChatGPT app development"
    ],
    "actual_capabilities": [
      "Provides architecture guidance for deciding when to use tools vs widgets in ChatGPT apps",
      "Documents server handler implementation with widget responses for mcp-use",
      "Explains widget state management and LLM context handling",
      "Covers UI guidelines for display modes, themes, and layouts",
      "Details component API including McpUseProvider, Image, ErrorBoundary, and useWidget hook",
      "Includes advanced patterns for complex widgets with tool calls and theming"
    ],
    "limitations": [
      "This skill is DEPRECATED - users should use mcp-app-builder instead",
      "Does not include executable code - only documentation and reference material",
      "Requires mcp-use library installation to function",
      "Limited to ChatGPT/Claude platform widget development"
    ],
    "use_cases": [
      {
        "title": "Building ChatGPT Apps with Interactive Widgets",
        "description": "Developer learning to create ChatGPT apps with rich interactive UI components using mcp-use framework",
        "target_user": "Full-stack developers building AI-powered applications"
      },
      {
        "title": "MCP Server Development",
        "description": "Developer creating MCP (Model Context Protocol) servers with custom React widgets for AI assistants",
        "target_user": "AI platform developers and integrations engineers"
      },
      {
        "title": "ChatGPT Plugin Architecture",
        "description": "Engineer designing widget-based interactions for ChatGPT or Claude conversations",
        "target_user": "Conversational AI architects"
      }
    ],
    "prompt_templates": [
      {
        "title": "Getting Started with Widgets",
        "prompt": "I want to build a ChatGPT app with interactive widgets using mcp-use. How do I set up the project and create my first widget?",
        "scenario": "New developer onboarding"
      },
      {
        "title": "Architecture Decision",
        "prompt": "Should I use a tool or a widget for a restaurant search feature that shows results in a list and allows users to click for details?",
        "scenario": "Design decision making"
      },
      {
        "title": "State Management",
        "prompt": "How do I persist widget state across conversations and trigger the LLM from widget interactions?",
        "scenario": "Implementing stateful widgets"
      },
      {
        "title": "Advanced Widget Pattern",
        "prompt": "Create a multi-step widget with form input, API calls, and conditional rendering based on user selection.",
        "scenario": "Complex widget implementation"
      }
    ],
    "output_examples": [
      {
        "input": "How do I create a widget that displays search results?",
        "output": [
          "Use the widget() helper in your server.tool() handler",
          "Return widget({ props: searchResults, output: text('Found X results') })",
          "Create a React component in resources/ that receives props via useWidget()"
        ]
      },
      {
        "input": "What's the difference between props and output?",
        "output": [
          "output: What the LLM sees in the conversation (text, object, markdown)",
          "props: Data sent to the widget UI (hidden from LLM)"
        ]
      }
    ],
    "best_practices": [
      "Start with tools-only, upgrade to widgets only when visual interaction is needed",
      "Keep widgets focused on a single purpose - multiple simple widgets scale better than one complex widget",
      "Use props for sensitive data the LLM should not see, output for conversational context"
    ],
    "anti_patterns": [
      "Lazy-loading data that should be returned upfront - tool calls are expensive",
      "Using tools for widget-internal state management - keep flight selection, form data in widget state",
      "Creating widgets for purely conversational features that don't need visual representation"
    ],
    "faq": [
      {
        "question": "What is mcp-use?",
        "answer": "mcp-use is a framework for building ChatGPT apps with interactive widgets using the Model Context Protocol (MCP) and OpenAI Apps SDK."
      },
      {
        "question": "Why is this skill deprecated?",
        "answer": "This skill has been replaced by mcp-app-builder, which provides the same functionality with improved implementation. Users should install mcp-app-builder instead."
      },
      {
        "question": "Do I need to install anything?",
        "answer": "Yes, you need to install the mcp-use package: npm install mcp-use. This skill provides documentation for using the library."
      },
      {
        "question": "What's the difference between a tool and a widget?",
        "answer": "A tool is a backend action with no UI. A widget is a tool with a React UI component that renders visually in the chat interface."
      },
      {
        "question": "Can I use this with Claude Code?",
        "answer": "Yes, this skill supports Claude, Codex, and Claude Code as the supported AI tools."
      },
      {
        "question": "Is this for ChatGPT only?",
        "answer": "This skill is designed for ChatGPT apps and OpenAI Apps SDK, but the concepts apply to any AI assistant that supports interactive widgets."
      }
    ]
  },
  "file_structure": [
    {
      "name": "evals",
      "type": "dir",
      "path": "evals",
      "children": [
        {
          "name": "architecture.json",
          "type": "file",
          "path": "evals/architecture.json",
          "lines": 35
        },
        {
          "name": "discover.json",
          "type": "file",
          "path": "evals/discover.json",
          "lines": 27
        },
        {
          "name": "README.md",
          "type": "file",
          "path": "evals/README.md",
          "lines": 25
        },
        {
          "name": "skill.json",
          "type": "file",
          "path": "evals/skill.json",
          "lines": 43
        },
        {
          "name": "state-and-context.json",
          "type": "file",
          "path": "evals/state-and-context.json",
          "lines": 23
        },
        {
          "name": "ui-guidelines.json",
          "type": "file",
          "path": "evals/ui-guidelines.json",
          "lines": 31
        },
        {
          "name": "widgets.json",
          "type": "file",
          "path": "evals/widgets.json",
          "lines": 27
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "architecture.md",
          "type": "file",
          "path": "references/architecture.md",
          "lines": 160
        },
        {
          "name": "components-api.md",
          "type": "file",
          "path": "references/components-api.md",
          "lines": 326
        },
        {
          "name": "csp-and-metadata.md",
          "type": "file",
          "path": "references/csp-and-metadata.md",
          "lines": 167
        },
        {
          "name": "discover.md",
          "type": "file",
          "path": "references/discover.md",
          "lines": 78
        },
        {
          "name": "server-and-widgets.md",
          "type": "file",
          "path": "references/server-and-widgets.md",
          "lines": 220
        },
        {
          "name": "setup.md",
          "type": "file",
          "path": "references/setup.md",
          "lines": 91
        },
        {
          "name": "state-and-context.md",
          "type": "file",
          "path": "references/state-and-context.md",
          "lines": 251
        },
        {
          "name": "ui-guidelines.md",
          "type": "file",
          "path": "references/ui-guidelines.md",
          "lines": 215
        },
        {
          "name": "widget-patterns.md",
          "type": "file",
          "path": "references/widget-patterns.md",
          "lines": 280
        }
      ]
    },
    {
      "name": "LICENSE.txt",
      "type": "file",
      "path": "LICENSE.txt",
      "lines": 72
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 56
    }
  ]
}
