{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T19:22:50.430Z",
    "slug": "doubleslashse-cqs-patterns",
    "source_url": "https://github.com/DoubleslashSE/claude-workflows/tree/main/Plugins/dotnet-tdd/skills/cqs-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "5802c561daa0dc873a391bc44b458d01452692cc7894dbeeca55a6ae579d407d",
    "tree_hash": "c3e565724c2e662ab9999b4ef0a89a16190c1a7716aea8b13a6a90f229c461fa"
  },
  "skill": {
    "name": "cqs-patterns",
    "description": "Command Query Separation (CQS) and CQRS patterns for .NET. Use when designing methods, handlers, and application architecture. Ensures predictable, testable code.",
    "summary": "Command Query Separation (CQS) and CQRS patterns for .NET development",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "DoubleslashSE",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "CQS",
      "CQRS",
      "dotnet",
      "architecture",
      "patterns"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All 60 static findings are false positives. The scanner misinterpreted documentation keywords (command, query), markdown code fences as backticks, and metadata fields as hardcoded URLs. The skill contains legitimate CQS/CQRS architectural documentation with C# code examples.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 1125,
    "audit_model": "claude",
    "audited_at": "2026-01-21T19:22:50.430Z"
  },
  "content": {
    "user_title": "Apply CQS and CQRS patterns",
    "value_statement": "Clean architecture requires clear separation between operations that change state and those that return data. This skill provides patterns and code examples for implementing Command Query Separation and CQRS in .NET applications.",
    "seo_keywords": [
      "CQS pattern",
      "CQRS pattern",
      "Command Query Separation",
      "dotnet architecture",
      "claude code",
      "claude",
      "codex",
      "command handler",
      "query handler",
      "clean architecture"
    ],
    "actual_capabilities": [
      "Generate CQS-compliant method designs with clear command/query separation",
      "Create CQRS command and query objects with proper marker interfaces",
      "Implement command handlers with validation, persistence, and event publishing",
      "Build query handlers optimized for read operations with DTOs",
      "Design dispatcher patterns for routing commands and queries to handlers",
      "Provide guidance on when CQRS is appropriate versus simple CRUD"
    ],
    "limitations": [
      "Does not generate complete solution structure or project files",
      "Does not integrate with specific ORMs or databases",
      "Does not provide event sourcing implementation details",
      "Does not include authentication or authorization patterns"
    ],
    "use_cases": [
      {
        "title": "Design service layer methods",
        "description": "Refactor existing service methods to follow CQS principles, separating state-changing operations from data retrieval queries.",
        "target_user": ".NET developers refactoring legacy code"
      },
      {
        "title": "Build command/query handlers",
        "description": "Create new command and query handlers following established MediatR-style patterns with proper async support.",
        "target_user": "Backend developers implementing clean architecture"
      },
      {
        "title": "Architect read/write separation",
        "description": "Apply CQRS at the architectural level, designing separate read and write models optimized for their specific concerns.",
        "target_user": "Software architects designing distributed systems"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic CQS conversion",
        "prompt": "Convert this method to follow CQS principles. Separate it into a command that changes state and a query that returns data:\n\n```csharp\npublic User CreateAndReturnUser(string email, string name)\n{\n    var user = new User { Email = email, Name = name };\n    _repository.Add(user);\n    return user;\n}\n```",
        "scenario": "Refactoring a method that violates CQS by both modifying state and returning data"
      },
      {
        "title": "Create command handler",
        "prompt": "Create a command handler for creating an order with these requirements:\n- Accept CreateOrderCommand with CustomerId and OrderItems\n- Validate customer exists\n- Create Order domain entity with items\n- Persist to repository\n- Publish OrderCreatedEvent\n- Return order ID",
        "scenario": "Implementing a new command handler with validation and domain events"
      },
      {
        "title": "Create query handler",
        "prompt": "Create a query handler for retrieving orders by customer with pagination:\n- Accept GetOrdersByCustomerQuery with CustomerId, Page, PageSize\n- Return PagedResult<OrderSummaryDto>\n- Include optimized SQL query\n- Handle total count calculation",
        "scenario": "Building a read-optimized query handler with pagination"
      },
      {
        "title": "Apply full CQRS architecture",
        "prompt": "Design a CQRS implementation for a product catalog with these requirements:\n- Separate read and write models\n- Commands: CreateProduct, UpdatePrice, DiscontinueProduct\n- Queries: GetProduct, GetProductsByCategory, SearchProducts\n- Use dispatcher pattern for routing\n- Consider when full CQRS adds value over simple CQS",
        "scenario": "Architectural design for a complete CQRS subsystem"
      }
    ],
    "output_examples": [
      {
        "input": "Convert this method to CQS:\n\n```csharp\npublic Order GetAndProcessOrder(int orderId)\n{\n    var order = _repository.GetById(orderId);\n    order.Process();\n    _repository.Update(order);\n    return order;\n}\n```",
        "output": "## CQS-Compliant Refactoring\n\n**Commands (state modification):**\n```csharp\npublic void ProcessOrder(int orderId)\n{\n    var order = _repository.GetById(orderId);\n    order.Process();\n    _repository.Update(order);\n}\n```\n\n**Queries (data retrieval):**\n```csharp\npublic Order? GetOrder(int orderId)\n{\n    return _repository.GetById(orderId);\n}\n```\n\n**Usage:**\n```csharp\nvar order = orderService.GetOrder(orderId);\norderService.ProcessOrder(orderId);\n```"
      },
      {
        "input": "Create a command for updating order status",
        "output": "## Update Order Status Command\n\n```csharp\npublic record UpdateOrderStatusCommand(\n    Guid OrderId,\n    OrderStatus NewStatus,\n    string? Reason = null\n) : ICommand;\n\npublic class UpdateOrderStatusCommandHandler \n    : ICommandHandler<UpdateOrderStatusCommand>\n{\n    private readonly IOrderRepository _repository;\n    private readonly IEventPublisher _publisher;\n\n    public async Task HandleAsync(UpdateOrderStatusCommand command, \n        CancellationToken ct)\n    {\n        var order = await _repository.GetByIdAsync(command.OrderId, ct);\n        if (order == null)\n            throw new OrderNotFoundException(command.OrderId);\n        \n        order.UpdateStatus(command.NewStatus, command.Reason);\n        await _repository.UpdateAsync(order, ct);\n        await _publisher.PublishAsync(\n            new OrderStatusUpdatedEvent(order.Id, command.NewStatus), ct);\n    }\n}\n```"
      },
      {
        "input": "When should I use CQRS?",
        "output": "## When to Use CQRS\n\n**Good fit for CQRS:**\n- Complex domains with different read/write patterns\n- High-read, low-write scenarios (reporting dashboards)\n- Systems requiring audit trails on writes\n- Event-sourced systems\n- Microservices with separate read replicas\n\n**CQRS adds complexity. Consider simpler CQS when:**\n- Simple CRUD operations dominate\n- Read and write models are similar\n- Small team or project\n- Consistency between reads and writes is critical\n\n**Start with CQS at method level, then evolve to CQRS when requirements demand it.**"
      }
    ],
    "best_practices": [
      "Keep commands focused on a single action and queries focused on returning data without side effects",
      "Use marker interfaces (ICommand, IQuery) to enable generic dispatching patterns",
      "Validate commands before touching domain models and fail fast with clear error messages",
      "Separate read models (DTOs) from write models (entities) to optimize each for its purpose"
    ],
    "anti_patterns": [
      "Returning domain entities from query handlers breaks the read/write separation",
      "Adding business logic in commands instead of domain models reduces testability",
      "Using the same model for reads and writes when optimization requirements differ",
      "Applying CQRS uniformly when simpler patterns would suffice adds unnecessary complexity"
    ],
    "faq": [
      {
        "question": "What is the difference between CQS and CQRS?",
        "answer": "CQS applies at the method level - each method either changes state or returns data. CQRS applies at the architectural level - using entirely separate models, handlers, and databases for reads and writes."
      },
      {
        "question": "Can a command return a value?",
        "answer": "Commands should return void, but returning an ID or identifier is acceptable since it identifies the created resource rather than providing query data."
      },
      {
        "question": "When is CQRS overkill?",
        "answer": "CQRS adds complexity. Use simple CQS for CRUD applications, small projects, or when read/write patterns are similar. Evolve to CQRS when you have distinct optimization needs."
      },
      {
        "question": "How do I test CQS-compliant code?",
        "answer": "Commands and queries are highly testable in isolation. Mock the repository for command tests (verify interactions) and for query tests (provide test data)."
      },
      {
        "question": "Should I use the same database for reads and writes?",
        "answer": "Start with the same database. CQRS allows but does not require separate read databases. Introduce read replicas only when performance demands it."
      },
      {
        "question": "What is the dispatcher pattern?",
        "answer": "The dispatcher uses reflection to route commands and queries to their handlers based on type. This keeps controllers thin and adds zero boilerplate per handler."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 532
    }
  ]
}
