{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-17T04:22:54.562Z",
    "slug": "dowwie-control-loop-extraction",
    "source_url": "https://github.com/Dowwie/agent_framework_study/tree/main/.claude/skills/control-loop-extraction",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "d622d37807fc6f8d5ecb6f880ee80c216212a2c06b60a67084ec13361256eb84",
    "tree_hash": "ac26cea91654f1bced965aa8ab1faf563675ef5ddac405841f0c93938a29aa80"
  },
  "skill": {
    "name": "control-loop-extraction",
    "description": "Extract and analyze agent reasoning loops, step functions, and termination conditions. Use when needing to (1) understand how an agent framework implements reasoning (ReAct, Plan-and-Solve, Reflection, etc.), (2) locate the core decision-making logic, (3) analyze loop mechanics and termination conditions, (4) document the step-by-step execution flow of an agent, or (5) compare reasoning patterns across frameworks.",
    "summary": "Extract and analyze agent reasoning loops, step functions, and termination conditions. Use when need...",
    "icon": "ðŸ”„",
    "version": "1.0.0",
    "author": "Dowwie",
    "license": "MIT",
    "category": "research",
    "tags": [
      "agent-frameworks",
      "reasoning-patterns",
      "code-analysis",
      "documentation",
      "architecture"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill is a documentation-only markdown file providing pattern signatures and analysis templates for agent reasoning loops. Static findings are false positives: the skill contains no executable code, scripts, network operations, or file system access. All flagged patterns are descriptive content (Python code examples, git hashes, documentation text) used for instructional purposes.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 22,
            "line_end": 29
          },
          {
            "file": "SKILL.md",
            "line_start": 29,
            "line_end": 32
          },
          {
            "file": "SKILL.md",
            "line_start": 32,
            "line_end": 39
          },
          {
            "file": "SKILL.md",
            "line_start": 39,
            "line_end": 42
          },
          {
            "file": "SKILL.md",
            "line_start": 42,
            "line_end": 50
          },
          {
            "file": "SKILL.md",
            "line_start": 50,
            "line_end": 53
          },
          {
            "file": "SKILL.md",
            "line_start": 53,
            "line_end": 58
          },
          {
            "file": "SKILL.md",
            "line_start": 58,
            "line_end": 71
          },
          {
            "file": "SKILL.md",
            "line_start": 71,
            "line_end": 88
          },
          {
            "file": "SKILL.md",
            "line_start": 88,
            "line_end": 96
          },
          {
            "file": "SKILL.md",
            "line_start": 96,
            "line_end": 97
          },
          {
            "file": "SKILL.md",
            "line_start": 97,
            "line_end": 98
          },
          {
            "file": "SKILL.md",
            "line_start": 98,
            "line_end": 99
          },
          {
            "file": "SKILL.md",
            "line_start": 99,
            "line_end": 100
          },
          {
            "file": "SKILL.md",
            "line_start": 100,
            "line_end": 101
          },
          {
            "file": "SKILL.md",
            "line_start": 101,
            "line_end": 105
          },
          {
            "file": "SKILL.md",
            "line_start": 105,
            "line_end": 111
          },
          {
            "file": "SKILL.md",
            "line_start": 111,
            "line_end": 115
          },
          {
            "file": "SKILL.md",
            "line_start": 115,
            "line_end": 122
          },
          {
            "file": "SKILL.md",
            "line_start": 122,
            "line_end": 126
          },
          {
            "file": "SKILL.md",
            "line_start": 126,
            "line_end": 131
          },
          {
            "file": "SKILL.md",
            "line_start": 131,
            "line_end": 147
          },
          {
            "file": "SKILL.md",
            "line_start": 147,
            "line_end": 151
          },
          {
            "file": "SKILL.md",
            "line_start": 151,
            "line_end": 152
          },
          {
            "file": "SKILL.md",
            "line_start": 152,
            "line_end": 153
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 332,
    "audit_model": "claude",
    "audited_at": "2026-01-17T04:22:54.562Z"
  },
  "content": {
    "user_title": "Extract agent reasoning loops from code",
    "value_statement": "Understanding how agent frameworks implement reasoning requires tracing complex control flows. This skill provides pattern signatures and extraction methods to identify reasoning topologies like ReAct, Plan-and-Solve, Reflection, and Tree-of-Thoughts from framework source code.",
    "seo_keywords": [
      "control loop extraction",
      "agent reasoning patterns",
      "ReAct analysis",
      "Plan-and-Solve documentation",
      "agent framework architecture",
      "step function analysis",
      "termination conditions",
      "Claude Code",
      "Claude",
      "Codex"
    ],
    "actual_capabilities": [
      "Identify reasoning patterns (ReAct, Plan-and-Solve, Reflection, Tree-of-Thoughts)",
      "Locate the main agent execution loop in source code",
      "Extract step function components (input assembly, LLM call, output parsing, dispatch)",
      "Catalog termination conditions and exit guards",
      "Document reasoning topology with code references",
      "Compare reasoning patterns across different frameworks"
    ],
    "limitations": [
      "Does not automatically read or parse source files - requires user to provide code context",
      "Does not execute or modify any code",
      "Does not provide runtime analysis of agent behavior",
      "Requires prerequisite skill (codebase-mapping) to identify agent files first"
    ],
    "use_cases": [
      {
        "target_user": "AI Researchers",
        "title": "Compare reasoning architectures",
        "description": "Analyze how different agent frameworks implement reasoning loops to inform research decisions"
      },
      {
        "target_user": "Framework Developers",
        "title": "Document control flow logic",
        "description": "Extract and document the core decision-making logic from agent implementation files"
      },
      {
        "target_user": "Security Auditors",
        "title": "Trace termination conditions",
        "description": "Identify all loop exit conditions to assess agent runaway risk and safety guarantees"
      }
    ],
    "prompt_templates": [
      {
        "title": "Identify Pattern",
        "scenario": "Find reasoning pattern in unknown framework",
        "prompt": "Use control-loop-extraction to analyze this agent code. Identify the reasoning pattern (ReAct, Plan-and-Solve, Reflection, or Tree-of-Thoughts). Locate the main loop and document the step function flow."
      },
      {
        "title": "Extract Step Function",
        "scenario": "Document atomic execution unit",
        "prompt": "Extract the step function from this agent. Document: 1) How input context is assembled, 2) The LLM invocation method, 3) Output parsing logic, 4) Action dispatch routing."
      },
      {
        "title": "Catalog Terminations",
        "scenario": "List all exit conditions",
        "prompt": "Find and catalog every termination condition in this agent loop. Include code references for step limits, token limits, explicit finish signals, timeouts, and error thresholds."
      },
      {
        "title": "Full Loop Analysis",
        "scenario": "Complete framework documentation",
        "prompt": "Perform a complete control loop analysis. Include: reasoning topology classification, loop location with line numbers, step function breakdown, termination condition catalog, and loop detection method."
      }
    ],
    "output_examples": [
      {
        "input": "Analyze the control loop in this agent framework code",
        "output": [
          "Reasoning Topology: ReAct (Thought â†’ Action â†’ Observation cycle)",
          "Loop Location: src/agent.py:45-120",
          "Step Function: Input assembly via _build_messages(), LLM call via invoke(), parsing via _parse_response(), dispatch to _execute_tool() or AgentFinish",
          "Termination Conditions: Step limit at max_steps=100, explicit finish action type, timeout after 300 seconds",
          "Loop Detection: None implemented - relies on step counter only"
        ]
      }
    ],
    "best_practices": [
      "Always combine with codebase-mapping to first locate agent files before analysis",
      "Verify termination conditions include both explicit guards (finish action) and implicit limits (step/token counters)",
      "Document the reasoning topology before attempting comparative analysis with other frameworks"
    ],
    "anti_patterns": [
      "Analyzing without first identifying which reasoning pattern the framework uses",
      "Assuming termination guards exist without verifying loop exit conditions",
      "Skipping the step function breakdown when documenting agent behavior"
    ],
    "faq": [
      {
        "question": "Which reasoning patterns does this skill identify?",
        "answer": "It identifies ReAct, Plan-and-Solve, Reflection, Tree-of-Thoughts, and hybrid combinations of these patterns."
      },
      {
        "question": "What is the step function in an agent?",
        "answer": "The step function is the atomic unit of agent execution: input assembly, LLM call, output parsing, and action dispatch."
      },
      {
        "question": "Does this skill read files automatically?",
        "answer": "No. This skill provides patterns and templates. Use codebase-mapping first to identify files, then apply these extraction methods."
      },
      {
        "question": "Is my code data safe when using this skill?",
        "answer": "Yes. This skill only provides documentation templates. It never reads, writes, or executes any code."
      },
      {
        "question": "Why does the skill require codebase-mapping first?",
        "answer": "codebase-mapping identifies agent files in the repository. control-loop-extraction then analyzes the specific loop patterns within those files."
      },
      {
        "question": "How does this differ from execution-engine-analysis?",
        "answer": "control-loop-extraction focuses on reasoning patterns and decision logic. execution-engine-analysis focuses on async patterns, concurrency, and event architecture."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 154
    }
  ]
}
