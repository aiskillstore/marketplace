{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T19:29:32.063Z",
    "slug": "dowwie-multi-agent-analysis",
    "source_url": "https://github.com/Dowwie/agent_framework_study/tree/main/.claude/skills/multi-agent-analysis",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "19879fedeb17d2677a74c9b943762edde04084fbae487ab93f67ef366dd14c37",
    "tree_hash": "18169efbf4444ddce6df38e6da26742ff1d5d8fc1ce12e6edc715e520eb028b3"
  },
  "skill": {
    "name": "multi-agent-analysis",
    "description": "Analyze coordination patterns, handoff mechanisms, and state sharing in multi-agent systems. Use when (1) understanding how agents transfer control, (2) evaluating shared vs isolated state patterns, (3) mapping communication protocols between agents, (4) assessing multi-agent orchestration approaches, or (5) comparing coordination models across frameworks.",
    "summary": "Analyze coordination patterns and state sharing in multi-agent systems",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "Dowwie",
    "license": "MIT",
    "category": "research",
    "tags": [
      "multi-agent",
      "coordination",
      "architecture",
      "analysis",
      "agent-systems"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill is purely educational documentation about multi-agent coordination patterns. All static findings are false positives: backtick-wrapped code appears in Python examples demonstrating agent architectures, not executable code. The skill contains no executable scripts, network calls, or file system operations. It is safe for publication.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 1001,
    "audit_model": "claude",
    "audited_at": "2026-01-21T19:29:32.063Z"
  },
  "content": {
    "user_title": "Analyze Multi-Agent System Coordination Patterns",
    "value_statement": "Understanding how agents coordinate is critical for building scalable multi-agent systems. This skill provides frameworks and templates to analyze coordination models, handoff mechanisms, state sharing patterns, and communication protocols in any multi-agent architecture.",
    "seo_keywords": [
      "Claude",
      "Claude Code",
      "Codex",
      "multi-agent systems",
      "agent coordination",
      "distributed systems",
      "agent architecture",
      "state sharing",
      "handoff mechanisms",
      "agent orchestration"
    ],
    "actual_capabilities": [
      "Identify coordination models in multi-agent systems including supervisor, peer-to-peer, pipeline, and market-based patterns",
      "Document handoff mechanisms and analyze how agents transfer control between each other",
      "Classify state sharing patterns as blackboard, message passing, or hybrid approaches",
      "Map communication protocols and trace data flow between agents in distributed systems",
      "Generate structured analysis reports using standardized templates for coordination patterns",
      "Compare different multi-agent frameworks and their architectural trade-offs"
    ],
    "limitations": [
      "Requires existing codebase with multi-agent implementation to analyze",
      "Does not execute or simulate agent systems, only provides analysis frameworks",
      "Analysis quality depends on code documentation and architecture clarity",
      "Cannot automatically detect all implicit coordination patterns without code inspection"
    ],
    "use_cases": [
      {
        "title": "Evaluate Framework Coordination",
        "description": "AI researchers comparing LangGraph, AutoGen, and CrewAI can use this skill to systematically analyze how each framework handles agent handoffs, state management, and loop prevention.",
        "target_user": "AI/ML Researchers"
      },
      {
        "title": "Refactor Legacy Agent Systems",
        "description": "Engineering teams migrating from monolithic to multi-agent architectures can document current coordination patterns and identify bottlenecks before redesigning with better state isolation.",
        "target_user": "Software Engineers"
      },
      {
        "title": "Design New Agent Architectures",
        "description": "System architects planning multi-agent solutions can use the pattern library to choose appropriate coordination models based on requirements for scalability, fault tolerance, and complexity.",
        "target_user": "System Architects"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Coordination Analysis",
        "prompt": "Analyze the multi-agent coordination model in this codebase. Identify if it uses supervisor, peer-to-peer, pipeline, or market-based coordination.",
        "scenario": "Initial exploration of an unfamiliar multi-agent system"
      },
      {
        "title": "Handoff Mechanism Documentation",
        "prompt": "Document all agent handoff mechanisms in the system. Show how control transfers between agents and what context is preserved during handoffs.",
        "scenario": "Understanding control flow in existing agent implementation"
      },
      {
        "title": "State Sharing Pattern Classification",
        "prompt": "Classify the state sharing pattern used in this multi-agent system. Determine if agents use blackboard, message passing, or hybrid approaches. Identify shared state and isolation levels.",
        "scenario": "Evaluating concurrency and race condition risks"
      },
      {
        "title": "Complete Coordination Report",
        "prompt": "Generate a complete multi-agent analysis report including coordination model, agent inventory, handoff mechanisms, state sharing patterns, communication protocols, and loop prevention strategies.",
        "scenario": "Comprehensive architecture documentation for stakeholders"
      }
    ],
    "output_examples": [
      {
        "input": "Analyze the coordination model in AutoGen",
        "output": "Coordination Model: Supervisor (Hierarchical)\n\nThe UserProxyAgent acts as supervisor, routing tasks to AssistantAgent workers. Handoffs are explicit through next_speaker selection. State is shared via GroupChat blackboard pattern, with all agents reading from shared message history. Communication uses direct method invocation with synchronous execution."
      },
      {
        "input": "Compare state sharing in LangGraph vs CrewAI",
        "output": "LangGraph uses hybrid state sharing: immutable shared graph state with per-node isolated working memory. CrewAI uses message passing with isolated agent memory but shared task queue. LangGraph provides stronger consistency guarantees, while CrewAI offers better agent isolation for concurrent execution."
      }
    ],
    "best_practices": [
      "Start with codebase-mapping skill to identify all agent files before running coordination analysis",
      "Use the provided output template to ensure consistent documentation across different frameworks",
      "Feed analysis results into comparative-matrix skill when evaluating multiple framework options"
    ],
    "anti_patterns": [
      "Trying to analyze coordination without first understanding individual agent capabilities",
      "Assuming coordination model from documentation without inspecting actual code implementation",
      "Ignoring loop prevention mechanisms when documenting handoff flows"
    ],
    "faq": [
      {
        "question": "What is the difference between supervisor and peer-to-peer coordination?",
        "answer": "Supervisor coordination uses a central router that decides which agent handles each task. Peer-to-peer allows agents to directly delegate to each other without central control. Supervisor is simpler but creates a single point of failure. Peer-to-peer is more resilient but harder to debug."
      },
      {
        "question": "When should I use blackboard vs message passing for state sharing?",
        "answer": "Use blackboard when agents need full visibility into shared state and coordination is simple. Use message passing when you need isolation, scalability, or concurrent agent execution. Blackboard is easier to implement but risks race conditions. Message passing is more complex but safer for distributed systems."
      },
      {
        "question": "How does this skill integrate with other analysis skills?",
        "answer": "Run codebase-mapping first to identify agent files. Use multi-agent-analysis to document coordination patterns. Feed results into comparative-matrix to compare frameworks. Use control-loop-extraction for analyzing individual agent decision loops."
      },
      {
        "question": "Can this skill analyze any multi-agent framework?",
        "answer": "Yes. The skill provides framework-agnostic patterns for analyzing coordination, handoffs, and state sharing. It works with LangGraph, AutoGen, CrewAI, custom implementations, or any system with multiple agents."
      },
      {
        "question": "Does this skill execute agent code?",
        "answer": "No. This is a documentation and analysis skill that provides frameworks for understanding multi-agent patterns. It does not run, simulate, or modify agent code. It helps Claude Code analyze existing implementations."
      },
      {
        "question": "What coordination model should I choose for my use case?",
        "answer": "Use supervisor for simple routing with centralized control. Use pipeline for sequential processing with clear stages. Use peer-to-peer for resilient systems without single points of failure. Use market-based when agents have dynamic capabilities and you need self-organizing allocation."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 353
    }
  ]
}
