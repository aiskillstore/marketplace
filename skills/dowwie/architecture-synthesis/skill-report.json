{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-17T04:14:27.579Z",
    "slug": "dowwie-architecture-synthesis",
    "source_url": "https://github.com/Dowwie/agent_framework_study/tree/main/.claude/skills/architecture-synthesis",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "4df9a834c0c3b9bf6d8bafe20d2bd4766828210b16da2cf8de36ff8e211538e0",
    "tree_hash": "3ef4736ce77ff9d707963dc57ec5fd7363e02904ab12fe72c8d0b340113a4e4b"
  },
  "skill": {
    "name": "architecture-synthesis",
    "description": "Generate a reference architecture specification from analyzed frameworks. Use when (1) designing a new agent framework based on prior art, (2) defining core primitives (Message, State, Tool types), (3) specifying interface protocols, (4) creating execution loop pseudocode, or (5) producing architecture diagrams and implementation roadmaps.",
    "summary": "Generate a reference architecture specification from analyzed frameworks. Use when (1) designing a n...",
    "icon": "üèóÔ∏è",
    "version": "1.0.0",
    "author": "Dowwie",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "agent-frameworks",
      "architecture-design",
      "software-design",
      "protocols"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing only architectural guidance and Python code examples. No executable code, scripts, network calls, filesystem access, or environment variable access detected. All static findings are false positives from misidentified patterns in documentation text.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 29,
            "line_end": 42
          },
          {
            "file": "SKILL.md",
            "line_start": 42,
            "line_end": 46
          },
          {
            "file": "SKILL.md",
            "line_start": 46,
            "line_end": 66
          },
          {
            "file": "SKILL.md",
            "line_start": 66,
            "line_end": 70
          },
          {
            "file": "SKILL.md",
            "line_start": 70,
            "line_end": 92
          },
          {
            "file": "SKILL.md",
            "line_start": 92,
            "line_end": 98
          },
          {
            "file": "SKILL.md",
            "line_start": 98,
            "line_end": 120
          },
          {
            "file": "SKILL.md",
            "line_start": 120,
            "line_end": 124
          },
          {
            "file": "SKILL.md",
            "line_start": 124,
            "line_end": 146
          },
          {
            "file": "SKILL.md",
            "line_start": 146,
            "line_end": 150
          },
          {
            "file": "SKILL.md",
            "line_start": 150,
            "line_end": 165
          },
          {
            "file": "SKILL.md",
            "line_start": 165,
            "line_end": 171
          },
          {
            "file": "SKILL.md",
            "line_start": 171,
            "line_end": 203
          },
          {
            "file": "SKILL.md",
            "line_start": 203,
            "line_end": 207
          },
          {
            "file": "SKILL.md",
            "line_start": 207,
            "line_end": 271
          },
          {
            "file": "SKILL.md",
            "line_start": 271,
            "line_end": 275
          },
          {
            "file": "SKILL.md",
            "line_start": 275,
            "line_end": 314
          },
          {
            "file": "SKILL.md",
            "line_start": 314,
            "line_end": 348
          },
          {
            "file": "SKILL.md",
            "line_start": 348,
            "line_end": 364
          },
          {
            "file": "SKILL.md",
            "line_start": 364,
            "line_end": 368
          },
          {
            "file": "SKILL.md",
            "line_start": 368,
            "line_end": 368
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 551,
    "audit_model": "claude",
    "audited_at": "2026-01-17T04:14:27.578Z"
  },
  "content": {
    "user_title": "Generate Agent Framework Architecture",
    "value_statement": "Designing an AI agent framework from scratch requires careful architecture decisions. This skill synthesizes reference architectures with core primitives, interface protocols, and implementation roadmaps based on established patterns.",
    "seo_keywords": [
      "architecture synthesis",
      "agent framework design",
      "Claude Code architecture",
      "AI agent primitives",
      "LLM protocols",
      "software architecture",
      "agent execution loop",
      "Codex agent design",
      "agent design patterns"
    ],
    "actual_capabilities": [
      "Define core data primitives (Message, State, Result, Tool types) using Python patterns",
      "Specify interface protocols for LLM, Tool, and Memory components",
      "Create execution loop pseudocode with termination conditions",
      "Generate architecture diagrams using Mermaid syntax",
      "Produce implementation roadmaps with phased deliverables"
    ],
    "limitations": [
      "Does not write code files to disk - provides guidance only",
      "Does not execute any code or run commands",
      "Does not integrate with external APIs or services",
      "Requires prerequisite analysis outputs from other skills"
    ],
    "use_cases": [
      {
        "target_user": "Framework Developers",
        "title": "Build Custom Agent Frameworks",
        "description": "Design and architect new agent frameworks with proper type safety and protocol definitions."
      },
      {
        "target_user": "AI Engineers",
        "title": "Document Architecture Decisions",
        "description": "Create reference architecture specifications for team review and implementation planning."
      },
      {
        "target_user": "Technical Architects",
        "title": "Evaluate Integration Patterns",
        "description": "Assess different protocol approaches for LLM, tool, and memory integration in agent systems."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Architecture",
        "scenario": "Generate architecture for new agent",
        "prompt": "Generate a reference architecture for a new AI agent framework. Include Message, State, and Tool types with Python examples, LLM and Tool protocols, and the execution loop pseudocode."
      },
      {
        "title": "With Prerequisites",
        "scenario": "Synthesize from prior analysis",
        "prompt": "Using the comparative matrix and anti-pattern catalog results, synthesize a reference architecture specification for our new agent framework."
      },
      {
        "title": "Complete Specification",
        "scenario": "Full architecture deliverable",
        "prompt": "Produce a complete reference architecture specification including: core primitives, interface protocols, execution loop, Mermaid diagram, and 8-week implementation roadmap."
      },
      {
        "title": "Integration Focus",
        "scenario": "Protocol specification",
        "prompt": "Create detailed interface protocols for integrating multiple LLM providers with a consistent Tool protocol. Include error handling patterns."
      }
    ],
    "output_examples": [
      {
        "input": "Generate a reference architecture for a new AI agent framework",
        "output": [
          "Core Primitives: Message (frozen dataclass), AgentState (copy-on-write), ToolResult, AgentFinish, AgentContinue",
          "LLM Protocol: generate() and stream() methods with LLMResponse containing content, tool_calls, usage, and model info",
          "Tool Protocol: name, description, schema properties and execute() method for each tool",
          "Memory Protocol: add(), get_context(), clear() for context management",
          "Execution Loop: build messages, call LLM, parse response, handle finish or continue with tool calls",
          "Architecture Diagram: Core Layer ‚Üí Protocol Layer ‚Üí Execution Layer ‚Üí Integration Layer",
          "Phase 1 (Weeks 1-2): Core types, LLM Protocol, basic Tool Protocol, minimal Agent loop",
          "Phase 2 (Weeks 3-4): Error handling, retry mechanisms, logging, callbacks, token counting"
        ]
      },
      {
        "input": "Create detailed interface protocols for integrating multiple LLM providers",
        "output": [
          "LLM Protocol abstraction with generate() and stream() methods for provider independence",
          "OpenAI integration: GPT-4 and GPT-3.5 Turbo support with standard response format",
          "Anthropic integration: Claude 2 and Claude 3 support with consistent interface",
          "Tool Protocol: name, description, JSON schema properties, execute() method signature",
          "Error handling: retry on rate limit, timeout handling, graceful degradation patterns"
        ]
      }
    ],
    "best_practices": [
      "Use immutable data structures (frozen=True dataclasses) to prevent state corruption",
      "Define clear protocol interfaces for LLM, Tool, and Memory to enable pluggable components",
      "Implement step limits and termination conditions to prevent infinite loops in agent execution"
    ],
    "anti_patterns": [
      "Mutating agent state directly instead of using copy-on-write pattern",
      "Hardcoding LLM provider instead of using protocol-based abstraction",
      "Skipping error handling and feedback loops in the execution loop"
    ],
    "faq": [
      {
        "question": "What platforms support this skill?",
        "answer": "This skill works with Claude, Codex, and Claude Code for architecture design tasks."
      },
      {
        "question": "What are the input requirements?",
        "answer": "Provide comparative matrix and anti-pattern catalog outputs for best results."
      },
      {
        "question": "Does this skill write files?",
        "answer": "No. This skill generates architectural guidance and code examples as text output."
      },
      {
        "question": "Is my data safe with this skill?",
        "answer": "Yes. No data is written, transmitted, or stored. Purely a prompt-based guidance skill."
      },
      {
        "question": "Why is my output truncated?",
        "answer": "Request specific sections (primitives, protocols, loop, diagram, roadmap) individually for detailed output."
      },
      {
        "question": "How does this compare to coding skills?",
        "answer": "This skill provides architectural guidance rather than writing executable code. Use with code generation skills for full implementation."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 371
    }
  ]
}
