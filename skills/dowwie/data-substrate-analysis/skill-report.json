{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-17T04:25:44.244Z",
    "slug": "dowwie-data-substrate-analysis",
    "source_url": "https://github.com/Dowwie/agent_framework_study/tree/main/.claude/skills/data-substrate-analysis",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "72c2583cbc8b62c34cfd55614f7c2531cab8dd3f1942898679cf457d0bc31318",
    "tree_hash": "51651a5d9f7613b1044f6ee5415b63dd384c0156c9e76ea339696d3f0f391aa9"
  },
  "skill": {
    "name": "data-substrate-analysis",
    "description": "Analyze fundamental data primitives, type systems, and state management patterns in a codebase. Use when (1) evaluating typing strategies (Pydantic vs TypedDict vs loose dicts), (2) assessing immutability and mutation patterns, (3) understanding serialization approaches, (4) documenting state shape and lifecycle, or (5) comparing data modeling approaches across frameworks.",
    "summary": "Analyze fundamental data primitives, type systems, and state management patterns in a codebase. Use ...",
    "icon": "ðŸ§¬",
    "version": "1.0.0",
    "author": "Dowwie",
    "license": "MIT",
    "category": "data",
    "tags": [
      "type-systems",
      "state-management",
      "data-modeling",
      "serialization",
      "pydantic"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure markdown documentation skill providing analysis guidance for typing strategies, mutation patterns, and serialization approaches. Contains no code execution, network access, filesystem operations, or external commands. All 42 static findings are false positives from misinterpreting documentation syntax and metadata as security risks.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 23,
            "line_end": 23
          },
          {
            "file": "SKILL.md",
            "line_start": 23,
            "line_end": 23
          },
          {
            "file": "SKILL.md",
            "line_start": 23,
            "line_end": 23
          },
          {
            "file": "SKILL.md",
            "line_start": 24,
            "line_end": 24
          },
          {
            "file": "SKILL.md",
            "line_start": 24,
            "line_end": 24
          },
          {
            "file": "SKILL.md",
            "line_start": 25,
            "line_end": 25
          },
          {
            "file": "SKILL.md",
            "line_start": 25,
            "line_end": 25
          },
          {
            "file": "SKILL.md",
            "line_start": 25,
            "line_end": 25
          },
          {
            "file": "SKILL.md",
            "line_start": 26,
            "line_end": 26
          },
          {
            "file": "SKILL.md",
            "line_start": 26,
            "line_end": 26
          },
          {
            "file": "SKILL.md",
            "line_start": 27,
            "line_end": 27
          },
          {
            "file": "SKILL.md",
            "line_start": 27,
            "line_end": 27
          },
          {
            "file": "SKILL.md",
            "line_start": 40,
            "line_end": 51
          },
          {
            "file": "SKILL.md",
            "line_start": 51,
            "line_end": 55
          },
          {
            "file": "SKILL.md",
            "line_start": 55,
            "line_end": 68
          },
          {
            "file": "SKILL.md",
            "line_start": 68,
            "line_end": 76
          },
          {
            "file": "SKILL.md",
            "line_start": 76,
            "line_end": 77
          },
          {
            "file": "SKILL.md",
            "line_start": 77,
            "line_end": 78
          },
          {
            "file": "SKILL.md",
            "line_start": 78,
            "line_end": 79
          },
          {
            "file": "SKILL.md",
            "line_start": 79,
            "line_end": 79
          },
          {
            "file": "SKILL.md",
            "line_start": 79,
            "line_end": 80
          },
          {
            "file": "SKILL.md",
            "line_start": 80,
            "line_end": 81
          },
          {
            "file": "SKILL.md",
            "line_start": 81,
            "line_end": 92
          },
          {
            "file": "SKILL.md",
            "line_start": 92,
            "line_end": 118
          },
          {
            "file": "SKILL.md",
            "line_start": 118,
            "line_end": 122
          },
          {
            "file": "SKILL.md",
            "line_start": 122,
            "line_end": 123
          },
          {
            "file": "SKILL.md",
            "line_start": 123,
            "line_end": 124
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 305,
    "audit_model": "claude",
    "audited_at": "2026-01-17T04:25:44.244Z"
  },
  "content": {
    "user_title": "Analyze data primitives and type systems",
    "value_statement": "Understanding data modeling patterns is critical for building maintainable AI agent frameworks. This skill provides structured analysis of typing strategies, mutation patterns, and serialization approaches to make informed architectural decisions.",
    "seo_keywords": [
      "data primitives analysis",
      "type systems",
      "state management",
      "Pydantic",
      "TypedDict",
      "serialization",
      "immutability patterns",
      "Claude Code",
      "agent framework",
      "data modeling"
    ],
    "actual_capabilities": [
      "Locates and identifies type definition files (types.py, schema.py, models.py, state.py)",
      "Classifies typing strategies as strict (Pydantic), structural (TypedDict), or loose (dict)",
      "Analyzes mutation patterns distinguishing in-place modification from copy-on-write approaches",
      "Documents serialization methods including json(), dict(), pickle, and custom implementations",
      "Evaluates validation boundaries and nesting depth in data structures"
    ],
    "limitations": [
      "Does not execute or modify code - only analyzes existing patterns",
      "Does not access external APIs or network resources",
      "Does not install dependencies or run build commands",
      "Requires codebase to contain identifiable type definition files"
    ],
    "use_cases": [
      {
        "target_user": "Framework Developers",
        "title": "Compare typing approaches",
        "description": "Evaluate Pydantic vs TypedDict vs dataclasses for your agent framework architecture decisions."
      },
      {
        "target_user": "Code Reviewers",
        "title": "Audit state management",
        "description": "Identify mutation risks and immutability violations in existing codebase state handling."
      },
      {
        "target_user": "Technical Architects",
        "title": "Document serialization strategy",
        "description": "Analyze serialization patterns and document round-trip safety across your data models."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Type Analysis",
        "scenario": "Analyze typing in a new codebase",
        "prompt": "Use data-substrate-analysis to examine the type definitions in this codebase. Identify the typing strategy (Pydantic, Dataclass, TypedDict, or loose dicts) and list the key data primitives with their locations."
      },
      {
        "title": "Mutation Pattern Review",
        "scenario": "Review state mutation safety",
        "prompt": "Apply data-substrate-analysis to audit the mutation patterns. Report whether state updates use in-place modification or copy-on-write. Flag any risky mutable patterns found."
      },
      {
        "title": "Serialization Assessment",
        "scenario": "Evaluate serialization safety",
        "prompt": "Use data-substrate-analysis to document the serialization approach. Check for pickle usage (security risk), validate implicit vs explicit serialization, and verify round-trip safety."
      },
      {
        "title": "Comparative Framework Analysis",
        "scenario": "Compare multiple frameworks",
        "prompt": "Run data-substrate-analysis on Framework A and Framework B. Generate a comparative matrix showing typing strategy, mutation patterns, serialization method, and validation boundaries for each."
      }
    ],
    "output_examples": [
      {
        "input": "Analyze the type system in this agent framework codebase",
        "output": [
          "Typing Strategy: Pydantic BaseModel with V2 migration",
          "Key Files: models.py (L15-45), schema.py (L8-32)",
          "Nesting Depth: Medium (2-3 levels)",
          "Mutation: Mixed - uses model_copy() for updates but list.append() for message history",
          "Serialization: model_dump_json() for API, model_dump() for internal",
          "Risk: Message history mutable via .append() - consider copy-on-write"
        ]
      },
      {
        "input": "Review the mutation patterns in this Python service",
        "output": [
          "Pattern Detected: In-place mutation via list.append()",
          "Location: state_manager.py:42-48",
          "Risk Level: Medium - shared state mutation",
          "Recommendation: Use model_copy() or dataclasses.replace() for thread safety"
        ]
      },
      {
        "input": "Check serialization methods used in this project",
        "output": [
          "Serialization: Pydantic model_dump() with custom encoder",
          "Round-trip Safety: Tested with model_validate()",
          "Unsafe Patterns: None detected",
          "Note: pickle is not used - security best practice"
        ]
      }
    ],
    "best_practices": [
      "Use Pydantic BaseModel for type-safe data with automatic validation at boundaries",
      "Prefer copy-on-write (model_copy, dataclasses.replace) over in-place mutation",
      "Avoid pickle for serialization due to security vulnerabilities"
    ],
    "anti_patterns": [
      "Using loose Dict[str, Any] without type boundaries at API ingress/egress",
      "Mixing mutable and immutable patterns inconsistently within the same data structure",
      "Implicit serialization without explicit to_dict() or from_dict() methods"
    ],
    "faq": [
      {
        "question": "What typing strategies does this skill detect?",
        "answer": "Pydantic BaseModel, Dataclass, TypedDict, NamedTuple, and loose dict patterns are identified."
      },
      {
        "question": "What are the safe mutation patterns?",
        "answer": "Copy-on-write using Pydantic model_copy(), dataclasses.replace(), or immutable data structures is recommended."
      },
      {
        "question": "How does this integrate with other skills?",
        "answer": "Use codebase-mapping first to find type files, then feed findings into comparative-matrix for framework decisions."
      },
      {
        "question": "Is my data safe during analysis?",
        "answer": "Yes. This is a prompt-only skill that reads code patterns without executing or transmitting data."
      },
      {
        "question": "What serialization methods are flagged as risky?",
        "answer": "Pickle is flagged as a security risk due to arbitrary code execution vulnerabilities during deserialization."
      },
      {
        "question": "How is this different from a type checker?",
        "answer": "This analyzes architectural patterns and design decisions rather than static type correctness. It focuses on mutation, serialization, and state lifecycle."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 125
    }
  ]
}
