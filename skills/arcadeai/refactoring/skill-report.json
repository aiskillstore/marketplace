{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-16T16:03:26.584Z",
    "slug": "arcadeai-refactoring",
    "source_url": "https://github.com/ArcadeAI/dexa/tree/main/.claude/skills/safeword-refactoring",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "145ed2c471f845bc6fafc9f70dafef35866807551cf841de4bb272cddb1a4963",
    "tree_hash": "c870792f98ec6eeb447b436437374f69faf03c9840f19dba59be3ccafa9298d3"
  },
  "skill": {
    "name": "refactoring",
    "description": "Systematic refactoring with small-step discipline. Use when user says 'refactor', 'clean up', 'restructure', 'extract', 'rename', 'simplify', or mentions code smells. Enforces one change â†’ test â†’ commit cycle. For structural improvements, NOT style/formatting (use /lint). NOT for adding features or fixing bugs.",
    "summary": "Systematic refactoring with small-step discipline. Use when user says 'refactor', 'clean up', 'restr...",
    "icon": "ðŸ”§",
    "version": "1.0.0",
    "author": "ArcadeAI",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "refactoring",
      "code-quality",
      "software-craftsmanship",
      "tdd",
      "clean-code"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing only guidance and code examples. No executable code, network calls, or filesystem operations. All 37 static findings are false positives: metadata URLs flagged as network reconnaissance, documentation trigger words flagged as weak crypto, and code examples flagged as command execution. The previous audit correctly identified zero risk factors.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 63,
            "line_end": 70
          },
          {
            "file": "SKILL.md",
            "line_start": 70,
            "line_end": 86
          },
          {
            "file": "SKILL.md",
            "line_start": 86,
            "line_end": 86
          },
          {
            "file": "SKILL.md",
            "line_start": 86,
            "line_end": 87
          },
          {
            "file": "SKILL.md",
            "line_start": 87,
            "line_end": 88
          },
          {
            "file": "SKILL.md",
            "line_start": 88,
            "line_end": 89
          },
          {
            "file": "SKILL.md",
            "line_start": 89,
            "line_end": 89
          },
          {
            "file": "SKILL.md",
            "line_start": 89,
            "line_end": 91
          },
          {
            "file": "SKILL.md",
            "line_start": 91,
            "line_end": 97
          },
          {
            "file": "SKILL.md",
            "line_start": 97,
            "line_end": 103
          },
          {
            "file": "SKILL.md",
            "line_start": 103,
            "line_end": 103
          },
          {
            "file": "SKILL.md",
            "line_start": 103,
            "line_end": 104
          },
          {
            "file": "SKILL.md",
            "line_start": 104,
            "line_end": 106
          },
          {
            "file": "SKILL.md",
            "line_start": 106,
            "line_end": 106
          },
          {
            "file": "SKILL.md",
            "line_start": 106,
            "line_end": 109
          },
          {
            "file": "SKILL.md",
            "line_start": 109,
            "line_end": 128
          },
          {
            "file": "SKILL.md",
            "line_start": 128,
            "line_end": 148
          },
          {
            "file": "SKILL.md",
            "line_start": 148,
            "line_end": 153
          },
          {
            "file": "SKILL.md",
            "line_start": 153,
            "line_end": 155
          },
          {
            "file": "SKILL.md",
            "line_start": 155,
            "line_end": 179
          },
          {
            "file": "SKILL.md",
            "line_start": 179,
            "line_end": 184
          },
          {
            "file": "SKILL.md",
            "line_start": 184,
            "line_end": 227
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 409,
    "audit_model": "claude",
    "audited_at": "2026-01-16T16:03:26.584Z"
  },
  "content": {
    "user_title": "Refactor code systematically with safety",
    "value_statement": "Codebases accumulate technical debt through unclear names, duplicated logic, and deep nesting. This skill provides a disciplined approach to improve code structure while preserving behavior through test-driven safety nets and incremental changes.",
    "seo_keywords": [
      "refactoring",
      "code refactoring",
      "clean code",
      "code smells",
      "extract function",
      "rename variable",
      "technical debt",
      "Claude Code",
      "Codex",
      "software craftsmanship"
    ],
    "actual_capabilities": [
      "Guides systematic refactoring through 5 phases: Assess, Protect, Refactor, Verify, Iterate",
      "Enforces one-change-at-a-time discipline with test-then-commit workflow",
      "Identifies code smells including duplicated code, long functions, magic numbers, and dead code",
      "Provides tiered refactoring catalog from safe Rename operations to complex Extract Class transformations",
      "Creates characterization tests to capture current behavior before refactoring",
      "Manages revert protocol when refactoring attempts fail"
    ],
    "limitations": [
      "Does not execute refactoring automatically; provides guidance for AI or developer to follow",
      "Does not handle feature additions or bug fixes (redirects to other skills)",
      "Does not perform code formatting or style fixes (redirects to /lint)",
      "Requires existing tests or willingness to write characterization tests first"
    ],
    "use_cases": [
      {
        "target_user": "Software Developers",
        "title": "Clean up legacy code",
        "description": "Transform unclear variable names and duplicated logic into maintainable code with safety nets"
      },
      {
        "target_user": "Code Reviewers",
        "title": "Guide refactoring reviews",
        "description": "Ensure refactoring changes follow disciplined process with proper test coverage"
      },
      {
        "target_user": "AI Coding Assistants",
        "title": "Systematic improvement",
        "description": "Apply consistent refactoring methodology when improving code structure"
      }
    ],
    "prompt_templates": [
      {
        "title": "Simple extraction",
        "scenario": "Extract a function from long code",
        "prompt": "Refactor this function by extracting a helper function for the repeated logic. Follow the systematic approach: first add characterization tests, then extract one piece at a time, run tests after each change, and commit when tests pass."
      },
      {
        "title": "Rename variables",
        "scenario": "Improve unclear naming",
        "prompt": "Rename all unclear variables and functions in this file. For each rename: identify the rename, apply the change, run tests, commit with 'refactor: rename X to Y' message."
      },
      {
        "title": "Reduce nesting",
        "scenario": "Flatten deep conditionals",
        "prompt": "Transform deeply nested conditionals into guard clauses. Apply one refactoring at a time: convert innermost branch, run tests, commit, then proceed to next level."
      },
      {
        "title": "Extract class",
        "scenario": "Split god classes",
        "prompt": "Refactor this god class by extracting cohesive methods into a new class. Do this incrementally: move one method at a time, run tests after each move, commit each successful move."
      }
    ],
    "output_examples": [
      {
        "input": "Refactor this long function with duplicated validation logic",
        "output": [
          "âœ“ Phase 1: Assess - This is refactoring (extracting and deduplicating, not adding behavior)",
          "âœ“ Phase 2: Protect - Creating characterization tests for validation behavior",
          "âœ“ Phase 3: Refactor - Starting with Extract Function for validation, then Remove Duplication",
          "â†’ First change: Extract validate() function, running tests...",
          "âœ“ Tests pass. Commit: 'refactor: extract validation function'",
          "â†’ Next: Inline duplicated validation calls...",
          "âœ“ Refactoring complete. 3 commits, all tests green."
        ]
      },
      {
        "input": "Rename all variables with unclear names in this file",
        "output": [
          "âœ“ Identifying unclear names: d, temp, data, obj, info, calc",
          "âœ“ Starting with d â†’ discountAmount (Tier 1 safe refactoring)",
          "âœ“ Tests pass. Commit: 'refactor: rename d to discountAmount'",
          "â†’ Proceeding to temp â†’ orderSubtotal...",
          "âœ“ All renames complete. 6 commits, all tests green."
        ]
      }
    ],
    "best_practices": [
      "Always run tests after each individual refactoring step before committing",
      "Write characterization tests first when test coverage is missing or partial",
      "Stop and ask the user after two failed refactoring attempts"
    ],
    "anti_patterns": [
      "Batching multiple refactorings into one change before running tests",
      "Attempting to fix a failed refactoring instead of reverting and trying smaller steps",
      "Refactoring without any test coverage or safety net"
    ],
    "faq": [
      {
        "question": "What tools does this skill support?",
        "answer": "Compatible with Claude, Codex, and Claude Code. Works with any testing framework like Jest, pytest, or Go test."
      },
      {
        "question": "What are the limits of refactoring?",
        "answer": "This skill improves structure only. It does not add features, fix bugs, or handle API migrations requiring behavior changes."
      },
      {
        "question": "How does it integrate with version control?",
        "answer": "After each green test, commit with conventional prefix 'refactor: description'. Uses git checkout to revert failed attempts."
      },
      {
        "question": "Is my code safe during refactoring?",
        "answer": "Yes. The discipline requires tests before changes, one change at a time, and immediate revert if tests fail."
      },
      {
        "question": "What if tests fail during refactoring?",
        "answer": "Immediately revert with 'git checkout -- file'. Analyze if the step was too large. Try smaller step or ask user for guidance."
      },
      {
        "question": "How is this different from a linter?",
        "answer": "Linters fix style and formatting automatically. This skill handles structural improvements requiring judgment and incremental steps."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 229
    }
  ]
}
