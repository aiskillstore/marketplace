{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-17T05:19:19.914Z",
    "slug": "dojocodinglabs-memory-management",
    "source_url": "https://github.com/DojoCodingLabs/claude-code-waypoint/tree/main/.claude/skills/memory-management",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "dde006500d4aac80ab352c001c96b58f027628d462dfd01cfb4607c93b84daa9",
    "tree_hash": "63918cb717ed153629ccb92525a2a4d69fcfc89d1930445c5f94125e01df1fc0"
  },
  "skill": {
    "name": "memory-management",
    "description": "Context tracking and decision logging patterns for intentional memory management in Claude Code Waypoint Plugin. Use when you need to remember user preferences, track decisions, capture context across sessions, learn from corrections, or maintain project-specific knowledge. Covers when to persist context, how to track decisions, context boundaries, storage mechanisms, and memory refresh strategies.",
    "summary": "Context tracking and decision logging patterns for intentional memory management in Claude Code Wayp...",
    "icon": "ðŸ§ ",
    "version": "1.0.0",
    "author": "DojoCodingLabs",
    "license": "MIT",
    "category": "productivity",
    "tags": [
      "memory",
      "context",
      "preferences",
      "tracking",
      "persistence"
    ],
    "supported_tools": [
      "claude",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill with no executable code. Provides memory management patterns without file system access, network calls, or command execution. Static findings are false positives from pattern-matching confusion between markdown formatting and shell execution, and misidentified text patterns in example JSON.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 57,
            "line_end": 57
          },
          {
            "file": "SKILL.md",
            "line_start": 59,
            "line_end": 59
          },
          {
            "file": "SKILL.md",
            "line_start": 94,
            "line_end": 94
          },
          {
            "file": "SKILL.md",
            "line_start": 97,
            "line_end": 111
          },
          {
            "file": "SKILL.md",
            "line_start": 111,
            "line_end": 121
          },
          {
            "file": "SKILL.md",
            "line_start": 121,
            "line_end": 124
          },
          {
            "file": "SKILL.md",
            "line_start": 124,
            "line_end": 144
          },
          {
            "file": "SKILL.md",
            "line_start": 144,
            "line_end": 153
          },
          {
            "file": "SKILL.md",
            "line_start": 153,
            "line_end": 156
          },
          {
            "file": "SKILL.md",
            "line_start": 156,
            "line_end": 173
          },
          {
            "file": "SKILL.md",
            "line_start": 173,
            "line_end": 183
          },
          {
            "file": "SKILL.md",
            "line_start": 183,
            "line_end": 186
          },
          {
            "file": "SKILL.md",
            "line_start": 186,
            "line_end": 201
          },
          {
            "file": "SKILL.md",
            "line_start": 201,
            "line_end": 236
          },
          {
            "file": "SKILL.md",
            "line_start": 236,
            "line_end": 247
          },
          {
            "file": "SKILL.md",
            "line_start": 247,
            "line_end": 253
          },
          {
            "file": "SKILL.md",
            "line_start": 253,
            "line_end": 262
          },
          {
            "file": "SKILL.md",
            "line_start": 262,
            "line_end": 266
          },
          {
            "file": "SKILL.md",
            "line_start": 266,
            "line_end": 276
          },
          {
            "file": "SKILL.md",
            "line_start": 276,
            "line_end": 293
          },
          {
            "file": "SKILL.md",
            "line_start": 293,
            "line_end": 317
          },
          {
            "file": "SKILL.md",
            "line_start": 317,
            "line_end": 350
          },
          {
            "file": "SKILL.md",
            "line_start": 350,
            "line_end": 361
          },
          {
            "file": "SKILL.md",
            "line_start": 361,
            "line_end": 373
          },
          {
            "file": "SKILL.md",
            "line_start": 373,
            "line_end": 386
          },
          {
            "file": "SKILL.md",
            "line_start": 386,
            "line_end": 394
          },
          {
            "file": "SKILL.md",
            "line_start": 394,
            "line_end": 423
          },
          {
            "file": "SKILL.md",
            "line_start": 423,
            "line_end": 429
          },
          {
            "file": "SKILL.md",
            "line_start": 429,
            "line_end": 439
          },
          {
            "file": "SKILL.md",
            "line_start": 439,
            "line_end": 443
          },
          {
            "file": "SKILL.md",
            "line_start": 443,
            "line_end": 474
          },
          {
            "file": "SKILL.md",
            "line_start": 474,
            "line_end": 490
          },
          {
            "file": "SKILL.md",
            "line_start": 490,
            "line_end": 521
          },
          {
            "file": "SKILL.md",
            "line_start": 521,
            "line_end": 525
          },
          {
            "file": "SKILL.md",
            "line_start": 525,
            "line_end": 528
          },
          {
            "file": "SKILL.md",
            "line_start": 528,
            "line_end": 534
          },
          {
            "file": "SKILL.md",
            "line_start": 534,
            "line_end": 537
          },
          {
            "file": "SKILL.md",
            "line_start": 537,
            "line_end": 540
          },
          {
            "file": "SKILL.md",
            "line_start": 540,
            "line_end": 543
          },
          {
            "file": "SKILL.md",
            "line_start": 543,
            "line_end": 546
          },
          {
            "file": "SKILL.md",
            "line_start": 546,
            "line_end": 592
          },
          {
            "file": "SKILL.md",
            "line_start": 592,
            "line_end": 594
          },
          {
            "file": "SKILL.md",
            "line_start": 594,
            "line_end": 594
          },
          {
            "file": "SKILL.md",
            "line_start": 594,
            "line_end": 594
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 773,
    "audit_model": "claude",
    "audited_at": "2026-01-17T05:19:19.914Z"
  },
  "content": {
    "user_title": "Track preferences and decisions across sessions",
    "value_statement": "Claude Code loses context after resets, forcing you to re-explain preferences repeatedly. This skill provides patterns for intentional memory management so Claude remembers your preferences, tracks decisions, and learns from corrections automatically.",
    "seo_keywords": [
      "claude code memory management",
      "claude memory persistence",
      "context tracking",
      "user preferences",
      "decision logging",
      "claude code skill",
      "claude memory across sessions",
      "preference learning",
      "context reset solution",
      "ai memory patterns"
    ],
    "actual_capabilities": [
      "Remember user preferences like naming conventions and import styles across sessions",
      "Track architectural decisions with rationale and alternatives considered",
      "Learn from repeated user corrections and apply patterns automatically",
      "Store project knowledge like tech stack and structure for quick reference",
      "Detect stale memory and refresh when dependencies change",
      "Provide user control to view, clear, or export stored memory"
    ],
    "limitations": [
      "Does not execute file operations; provides patterns for Claude to follow",
      "Memory storage requires separate implementation by user or integration",
      "Cannot access external systems or APIs for data collection",
      "Security-sensitive data must never be stored; user must handle exclusions"
    ],
    "use_cases": [
      {
        "target_user": "Software Developers",
        "title": "Remember code style preferences",
        "description": "Track naming conventions, import styles, and formatting preferences so Claude applies them automatically in every session."
      },
      {
        "target_user": "Project Maintainers",
        "title": "Document architectural decisions",
        "description": "Log why certain patterns or technologies were chosen so future contributors understand the reasoning behind decisions."
      },
      {
        "target_user": "AI-Assisted Teams",
        "title": "Learn from correction patterns",
        "description": "Claude learns from repeated corrections to avoid making the same mistakes across multiple work sessions."
      }
    ],
    "prompt_templates": [
      {
        "title": "Remember preference",
        "scenario": "Teaching Claude a preference",
        "prompt": "Always remember that I prefer camelCase for variable names. Never use snake_case in this project."
      },
      {
        "title": "Log decision",
        "scenario": "Recording architectural choice",
        "prompt": "Document this decision: We chose Zustand for state management because our app needs simple client-side state without Redux boilerplate."
      },
      {
        "title": "Track correction",
        "scenario": "Correcting Claude multiple times",
        "prompt": "Log this correction. I have now told you three times to use named imports. From now on, always use named imports."
      },
      {
        "title": "Review memory",
        "scenario": "Checking stored preferences",
        "prompt": "Show me all the preferences and decisions you have stored in memory for this project."
      }
    ],
    "output_examples": [
      {
        "input": "Always remember that I prefer camelCase for variable names",
        "output": [
          "Preference stored successfully",
          "Type: Naming convention (camelCase)",
          "Confidence: High (user explicitly stated)",
          "Next use: Claude will auto-apply camelCase in all new code"
        ]
      },
      {
        "input": "We chose PostgreSQL over MongoDB because we need relational data integrity",
        "output": [
          "Decision logged with full context",
          "Location: .claude/memory/project/decisions.json",
          "Rationale captured: Relational data integrity requirement",
          "Alternatives: MongoDB (rejected)"
        ]
      }
    ],
    "best_practices": [
      "Store preferences after user states them explicitly or corrects the same pattern 2+ times",
      "Always include the rationale behind decisions so future context is clear",
      "Use human-readable JSON format so users can review and edit memory directly"
    ],
    "anti_patterns": [
      "Storing everything without filtering; be selective and store only signal, not noise",
      "Persisting information that belongs in code or config files",
      "Keeping memory indefinitely without checking for staleness or relevance"
    ],
    "faq": [
      {
        "question": "What tools does this skill support?",
        "answer": "This skill works with Claude and Claude Code. It provides patterns for memory management regardless of the AI tool being used."
      },
      {
        "question": "How much memory can be stored?",
        "answer": "Memory is stored in JSON files within .claude/memory/. File size limits depend on your file system."
      },
      {
        "question": "How does this integrate with other skills?",
        "answer": "Works with context-persistence for task state and plan-approval for decision workflows."
      },
      {
        "question": "Is my stored data secure?",
        "answer": "Memory stores only non-sensitive preferences. Never store API keys, tokens, or credentials."
      },
      {
        "question": "Why is memory becoming stale?",
        "answer": "Memory detects staleness based on timestamps. Refresh with /refresh-memory or clear specific entries."
      },
      {
        "question": "How is this different from system context?",
        "answer": "System context is temporary and lost on reset. This skill enables persistent memory across sessions."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 597
    }
  ]
}
