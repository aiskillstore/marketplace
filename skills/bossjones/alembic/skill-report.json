{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T15:20:44.689Z",
    "slug": "bossjones-alembic",
    "source_url": "https://github.com/bossjones/logging-lab/tree/main/.claude/skills/alembic",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "a29b8d3b2fed7b081b5a146fc4c699796254854721d38c40bba7d5683d4ea0f5",
    "tree_hash": "58b8f12a27e2f6b15fa63d1d128292209d2a0568bdb18853144065317bd8bd90"
  },
  "skill": {
    "name": "alembic",
    "description": "Database migration management for SQLAlchemy projects using Alembic",
    "summary": "Manage SQLAlchemy database schema changes with Alembic migrations",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "bossjones",
    "license": "MIT",
    "tags": [
      "database",
      "sqlalchemy",
      "migrations",
      "postgres",
      "python"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Documentation-only skill containing Alembic migration patterns. All static findings are false positives: bash commands are documentation examples, database URL access is standard configuration, and flagged keywords appear in legitimate documentation context.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 15,
            "line_end": 21
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 1,
            "line_end": 371
          }
        ]
      },
      {
        "factor": "env_access",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 73,
            "line_end": 74
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [
      {
        "title": "Documentation contains bash command examples",
        "description": "The skill contains bash commands in documentation for educational purposes. These are static examples, not executable code, and pose no security risk.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 15,
            "line_end": 370
          }
        ]
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 1006,
    "audit_model": "claude",
    "audited_at": "2026-01-21T15:20:44.689Z",
    "risk_factors": [
      "scripts",
      "filesystem"
    ]
  },
  "content": {
    "user_title": "Manage database migrations with Alembic",
    "value_statement": "Managing database schema changes manually is error-prone and difficult to track. This skill provides comprehensive Alembic patterns for SQLAlchemy projects, enabling safe, version-controlled database migrations with async support and best practices.",
    "seo_keywords": [
      "alembic",
      "database migration",
      "sqlalchemy",
      "postgres",
      "mysql",
      "python",
      "schema management",
      "claude",
      "codex",
      "claude code"
    ],
    "actual_capabilities": [
      "Generate database migrations automatically from SQLAlchemy model changes",
      "Apply and rollback migrations with version control",
      "Configure async database connections for modern Python patterns",
      "Use batch mode for SQLite schema changes",
      "Filter and customize autogenerated migration content",
      "Create custom migration operations for complex schema changes"
    ],
    "limitations": [
      "Requires pre-existing SQLAlchemy models and Alembic configuration",
      "Does not create initial project structure or configuration files",
      "Assumes familiarity with basic Alembic commands and concepts",
      "Does not provide database connection pooling or optimization guidance"
    ],
    "use_cases": [
      {
        "title": "Add new tables and columns",
        "description": "Generate and apply migrations when adding new database tables or columns to a Python application.",
        "target_user": "Backend developers working on feature additions"
      },
      {
        "title": "Modify existing schema safely",
        "description": "Make structural changes to database tables while preserving data and enabling rollback capability.",
        "target_user": "Database administrators and backend engineers"
      },
      {
        "title": "Coordinate team migrations",
        "description": "Apply migrations across development, staging, and production environments with version tracking.",
        "target_user": "DevOps engineers and team leads"
      }
    ],
    "prompt_templates": [
      {
        "title": "Create a new migration",
        "prompt": "I need to create a migration for my SQLAlchemy project using Alembic. The migration should [describe your change, e.g., add a users table with email and password columns]. Show me the commands to generate and apply this migration.",
        "scenario": "Generating a new database migration from model changes"
      },
      {
        "title": "Configure async Alembic",
        "prompt": "Set up Alembic for async SQLAlchemy 2.0 in my project. I have a database URL and need to configure env.py to work with async connections. Provide the complete configuration.",
        "scenario": "Configuring async database connections for migrations"
      },
      {
        "title": "Handle SQLite migrations",
        "prompt": "My project uses SQLite and I need to make schema changes. Alembic complains about unsupported operations. Show me how to use batch mode and write migrations that work with SQLite.",
        "scenario": "Managing SQLite-specific migration challenges"
      },
      {
        "title": "Customize autogenerated migrations",
        "prompt": "I want to customize how Alembic generates migrations. Specifically, I want to [skip certain tables / add custom logic / filter columns]. Show me how to use include_object or process_revision_directives.",
        "scenario": "Fine-tuning migration generation behavior"
      }
    ],
    "output_examples": [
      {
        "input": "Generate a migration to add a users table with name and email columns",
        "output": "```bash\n# Generate the migration\nuv run alembic revision --autogenerate -m \"Add users table\"\n\n# Apply the migration\nuv run alembic upgrade head\n```\n\nThis creates a migration file in alembic/versions/ with the schema change. The autogenerate feature compares your SQLAlchemy models against the current database state and generates the appropriate upgrade/downgrade operations."
      },
      {
        "input": "How do I downgrade my database by one revision?",
        "output": "```bash\n# Show current revision first\nuv run alembic current\n\n# Roll back one migration\nuv run alembic downgrade -1\n\n# Verify the rollback\nuv run alembic history\n```\n\nYou can also downgrade to a specific revision by providing the revision hash: `uv run alembic downgrade ae1027a6acf`"
      },
      {
        "input": "Set up Alembic for async SQLAlchemy with PostgreSQL",
        "output": "Configure your env.py to use asyncpg:\n\n```python\nfrom sqlalchemy.ext.asyncio import async_engine_from_config\n\ndatabase_url = settings.database_url.replace(\"postgresql://\", \"postgresql+asyncpg://\")\nconfig.set_main_option(\"sqlalchemy.url\", database_url)\n\nasync def run_async_migrations():\n    connectable = async_engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n    async with connectable.connect() as connection:\n        await connection.run_sync(do_run_migrations)\n```"
      }
    ],
    "best_practices": [
      "Always run autogenerate with --dry-run first to review changes before applying migrations",
      "Test migrations in a staging environment before deploying to production",
      "Include meaningful migration messages that describe the business purpose of the change",
      "Keep downgrade operations functional to enable safe rollback of failed deployments"
    ],
    "anti_patterns": [
      "Manually editing migration files after they have been applied to shared databases",
      "Skipping the review step for autogenerated migrations without understanding the changes",
      "Applying migrations without checking if the database is already up to date",
      "Using non-deterministic operations like NOW() or RANDOM() in migration files"
    ],
    "faq": [
      {
        "question": "How do I check if my database is up to date with migrations?",
        "answer": "Run `uv run alembic current` to see the current revision. Then compare with `uv run alembic heads` to see if pending migrations exist. You can also use the programmatic approach shown in the skill to check database state in code."
      },
      {
        "question": "Can I use Alembic with SQLite?",
        "answer": "Yes, but SQLite requires special handling. Use `render_as_batch=True` in your env.py configuration for all operations. Some ALTER TABLE operations need to be rewritten as COPY + DROP + CREATE in batch mode."
      },
      {
        "question": "How do I skip certain tables from autogeneration?",
        "answer": "Define an `include_object` function that returns False for tables or columns you want to skip. This is useful for temporary tables or system-managed columns that should not be version-controlled."
      },
      {
        "question": "What is the difference between upgrade and downgrade?",
        "answer": "Upgrade applies migrations forward (adds tables, columns, changes). Downgrade reverses them (removes what upgrade added). Always write both operations so migrations are reversible."
      },
      {
        "question": "How do I create a branch migration for parallel development?",
        "answer": "Use `uv run alembic revision -m \"message\" --head=base --branch-label=feature_name` to create a branch. Merge branches with `uv run alembic merge -m \"merge message\" feature@head main@head`."
      },
      {
        "question": "Can I run migrations programmatically from Python code?",
        "answer": "Yes, use the alembic.command module. Create a Config object and call command.upgrade() or command.revision() directly. This is useful for deployment scripts and application initialization."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 371
    }
  ]
}
