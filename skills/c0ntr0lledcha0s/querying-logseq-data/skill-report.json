{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T15:59:20.533Z",
    "slug": "c0ntr0lledcha0s-querying-logseq-data",
    "source_url": "https://github.com/C0ntr0lledCha0s/claude-code-plugin-automations/tree/main/logseq-expert/skills/querying-logseq-data",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "9c1f0f7bae441654d7c442c33c90f69d744160a8e62e004e70726aaa0fd0d72f",
    "tree_hash": "6974217ef7a5bbe92c7b15ad8b7e6762736231e334ae6d282f06a02472fd428c"
  },
  "skill": {
    "name": "querying-logseq-data",
    "description": "Expert in building Datalog queries for Logseq DB graphs. Provides query syntax guidance, optimization techniques, and advanced patterns for Datascript database queries.",
    "summary": "Expert knowledge for writing and optimizing Datalog queries in Logseq database graphs",
    "icon": "ğŸ”",
    "version": "1.0.0",
    "author": "C0ntr0lledCha0s",
    "license": "MIT",
    "category": "productivity",
    "tags": [
      "logseq",
      "datalog",
      "database-queries",
      "datascript",
      "knowledge-graph",
      "Claude",
      "Claude Code"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill contains only documentation and reference material for Logseq Datalog queries. All 113 static findings are false positives from pattern matching against Clojure syntax in code examples. No executable code, network requests, file operations, or security risks detected.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 3,
    "total_lines": 1684,
    "audit_model": "claude",
    "audited_at": "2026-01-21T15:59:20.533Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Build Advanced Datalog Queries for Logseq",
    "value_statement": "Logseq users struggle with complex database queries and Datalog syntax. This skill provides comprehensive query patterns, syntax examples, and optimization techniques for building powerful Datascript queries in Logseq.",
    "seo_keywords": [
      "Logseq queries",
      "Datalog syntax",
      "Datascript",
      "knowledge graph queries",
      "Logseq database",
      "query optimization",
      "Claude",
      "Claude Code",
      "Codex",
      "pull syntax"
    ],
    "actual_capabilities": [
      "Explain Datalog query structure including find, where, and in clauses",
      "Generate query patterns for filtering blocks by tags, properties, and dates",
      "Demonstrate pull syntax for selective attribute retrieval and nested data",
      "Provide aggregation query examples for counting, summing, and statistical operations",
      "Create recursive query patterns for hierarchical data relationships",
      "Optimize query performance with proper variable binding and clause ordering"
    ],
    "limitations": [
      "Does not execute queries or connect to actual Logseq databases",
      "Cannot debug runtime errors in user-specific graph structures",
      "Query examples may need adaptation for custom property schemas",
      "Performance characteristics depend on individual graph size and structure"
    ],
    "use_cases": [
      {
        "title": "Find Overdue Tasks",
        "description": "Query all tasks with deadlines before today and filter by priority level using date comparison predicates and property matching.",
        "target_user": "Knowledge workers managing task lists in Logseq"
      },
      {
        "title": "Analyze Reading List Statistics",
        "description": "Aggregate book ratings and count items by author using grouping functions and property-based queries for content analysis.",
        "target_user": "Researchers tracking bibliography and reading notes"
      },
      {
        "title": "Navigate Block Hierarchies",
        "description": "Build recursive queries to find all child blocks under a specific parent for exploring nested note structures and relationships.",
        "target_user": "Logseq power users organizing complex hierarchical information"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Tag Query",
        "prompt": "Show me how to find all blocks tagged with 'Project' in Logseq",
        "scenario": "Starting with simple tag-based filtering"
      },
      {
        "title": "Property Filtering",
        "prompt": "Create a query to find all items where status is 'In Progress' and priority is 'High'",
        "scenario": "Combining multiple property conditions"
      },
      {
        "title": "Date-Based Search",
        "prompt": "Write a query to find all tasks with deadlines in the next 7 days",
        "scenario": "Working with date comparisons and inputs"
      },
      {
        "title": "Advanced Aggregation",
        "prompt": "Build a query that counts books by author and shows average ratings for each author",
        "scenario": "Using aggregation functions with grouping"
      }
    ],
    "output_examples": [
      {
        "input": "How do I find all blocks with a specific tag in Logseq?",
        "output": "Here's a Datalog query to find blocks tagged with 'Book':\n\nThe query uses the :find clause with pull syntax to retrieve all block attributes. The :where clause filters for blocks that have the specified tag through the :block/tags relationship. You can replace 'Book' with any tag name in your graph."
      },
      {
        "input": "Show me how to count items grouped by a property",
        "output": "This aggregation query groups blocks by the 'author' property and counts them:\n\nThe (count ?b) aggregate function tallies blocks for each unique author value. Results return as tuples of author name and count. This pattern works for any property that has multiple blocks sharing the same value."
      },
      {
        "input": "How do I query blocks without a certain property?",
        "output": "Use the negation pattern with (not ...) to find blocks missing a property:\n\nThe underscore _ is a wildcard that matches any value. The (not ...) clause excludes blocks where the property exists. This is useful for finding incomplete items in your workflow."
      }
    ],
    "best_practices": [
      "Start with simple queries and add complexity incrementally to verify each clause works correctly",
      "Use pull syntax to retrieve only needed attributes rather than pulling all fields with [*]",
      "Place most restrictive where clauses first to reduce intermediate result sets and improve performance"
    ],
    "anti_patterns": [
      "Avoid pulling all attributes [*] on large result sets as this creates performance overhead",
      "Do not use multiple separate queries when rules can encapsulate reusable query logic",
      "Never forget to bind input variables in the :in clause when passing parameters to queries"
    ],
    "faq": [
      {
        "question": "What is the difference between :find and :find with pull?",
        "answer": "The :find clause without pull returns scalar values or tuples, while (pull ?e [attrs]) retrieves entity data as maps with specified attributes. Use pull when you need structured entity information rather than individual field values."
      },
      {
        "question": "How do I pass parameters to a Logseq query?",
        "answer": "Use the :in clause to declare input variables after the database $. For example :in $ ?tag-name allows passing a tag name parameter. Reference inputs in :where clauses or use :today for current date parameter."
      },
      {
        "question": "Can I use regular expressions in Datalog queries?",
        "answer": "Datascript supports predicate functions for pattern matching. Use predicates like (re-find pattern ?string) in where clauses to filter results by regular expression matches on string attributes."
      },
      {
        "question": "What is the purpose of rules in Datalog queries?",
        "answer": "Rules define reusable query patterns that can be invoked by name in where clauses. They reduce duplication, improve readability, and enable recursive queries for traversing hierarchical relationships like block parent-child structures."
      },
      {
        "question": "How do I query blocks modified within a date range?",
        "answer": "Use comparison predicates with timestamps: [(>= ?updated ?start)] and [(<= ?updated ?end)] in where clauses. Bind the :block/updated-at attribute to a variable and pass start and end dates as input parameters."
      },
      {
        "question": "Why is my query returning duplicate results?",
        "answer": "Duplicates occur when multiple where clauses create different binding paths to the same entity. Use :find with collection syntax [?e ...] to deduplicate, or review where clauses to ensure proper join conditions between variables."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "query-patterns.md",
          "type": "file",
          "path": "references/query-patterns.md",
          "lines": 176
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 357
    }
  ]
}
