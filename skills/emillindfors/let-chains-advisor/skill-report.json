{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:14:00.019Z",
    "slug": "emillindfors-let-chains-advisor",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-modern-patterns/skills/let-chains-advisor",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "a90ed2c24278af63bd5774fb8dbe2038f9d0c2f0c7c575a1c744e31dcb8892d3",
    "tree_hash": "e1d9d25f41c477a933e2af34d2aaa3648268ca3ca3b765a9fda00d9cd20e672b"
  },
  "skill": {
    "name": "let-chains-advisor",
    "description": "Identifies deeply nested if-let expressions and suggests let chains for cleaner control flow. Activates when users write nested conditionals with pattern matching.",
    "summary": "Identifies deeply nested if-let expressions and suggests let chains for cleaner control flow",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "rust",
      "refactoring",
      "pattern-matching",
      "code-quality"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a documentation-only skill containing Rust code examples. All static findings are false positives: Markdown code block delimiters were misidentified as shell backticks, and YAML frontmatter was misclassified as cryptographic code. No executable code, network calls, or file system access exists.",
    "files_scanned": 1,
    "total_lines": 157,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:14:00.019Z",
    "risk_factors": [],
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": []
  },
  "content": {
    "user_title": "Refactor nested if-let with let chains",
    "value_statement": "Developers writing deeply nested Rust control flow struggle with readability and maintainability. This skill proactively identifies nested if-let patterns (3+ levels) and suggests let chain refactorings for cleaner, more readable Rust 2024 code.",
    "seo_keywords": [
      "Claude",
      "Codex",
      "Claude Code",
      "Rust let chains",
      "Rust refactoring",
      "pattern matching",
      "Rust 2024",
      "control flow",
      "code quality",
      "Rust patterns"
    ],
    "actual_capabilities": [
      "Detects nested if-let expressions at 3+ levels of nesting",
      "Suggests let chain refactoring for cleaner control flow",
      "Identifies multiple Option and Result unwrapping patterns",
      "Recognizes pattern matching with guard conditions",
      "Provides before/after code examples for refactoring",
      "Verifies Rust version compatibility for let chains"
    ],
    "limitations": [
      "Only activates for Rust code, not other languages",
      "Does not auto-apply refactorings, only suggests them",
      "Requires Rust 1.88+ or Rust 2024 edition for let chains",
      "Does not analyze runtime performance impact of refactoring"
    ],
    "use_cases": [
      {
        "title": "Refactor deeply nested Option handling",
        "description": "A developer has multiple levels of if-let Some() checks for Option types. The skill suggests consolidating them into a single let chain for improved readability.",
        "target_user": "Rust developers working with optional values"
      },
      {
        "title": "Simplify Result error handling",
        "description": "When chaining Result checks with if let Ok(), the skill recommends let chain syntax to flatten nested error handling logic.",
        "target_user": "Backend Rust developers"
      },
      {
        "title": "Clean up complex guard clauses",
        "description": "Developers writing pattern matches with multiple conditions receive suggestions to use let chains with && conditions for better structure.",
        "target_user": "Experienced Rust developers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic nested pattern detection",
        "prompt": "I have this Rust code with nested if-let statements. Can you suggest a let chain refactoring for it?",
        "scenario": "User shows nested if-let code and wants refactoring help"
      },
      {
        "title": "Option chaining refactoring",
        "prompt": "How can I rewrite this deeply nested Option unwrapping using let chains in Rust 2024?",
        "scenario": "User specifically asks about let chain syntax for Options"
      },
      {
        "title": "Result and Option mix",
        "prompt": "I need to handle both Option and Result types in my control flow. Show me how let chains can simplify this nested structure.",
        "scenario": "User has mixed error types and wants cleaner syntax"
      },
      {
        "title": "While loop let chains",
        "prompt": "Can I use let chains inside a while let loop? Show me how to refactor this pattern.",
        "scenario": "User wants to apply let chains in iterator processing"
      }
    ],
    "output_examples": [
      {
        "input": "if let Some(user) = database.find_user(id) { if let Some(profile) = user.profile { if let Some(email) = profile.email { send_email(email); } } }",
        "output": "Suggested refactoring:\n\nif let Some(user) = database.find_user(id)\n    && let Some(profile) = user.profile\n    && let Some(email) = profile.email\n{\n    send_email(email);\n}\n\nThis uses let chains (Rust 2024) to flatten the nested structure into a single readable condition."
      },
      {
        "input": "if let Ok(path) = get_config_path() { if let Ok(content) = std::fs::read_to_string(path) { if let Ok(config) = toml::from_str(&content) { return Ok(config); } } }",
        "output": "Let chain refactoring:\n\nif let Ok(path) = get_config_path()\n    && let Ok(content) = std::fs::read_to_string(path)\n    && let Ok(config) = toml::from_str(&content)\n{\n    Ok(config)\n} else {\n    Err(Error::ConfigNotFound)\n}"
      }
    ],
    "best_practices": [
      "Activate the skill when you see 3+ levels of nested if-let statements",
      "Suggest let chains when all branches follow the same return/continue pattern",
      "Verify the Rust version is 1.88+ or edition 2024 before recommending let chains",
      "Provide both the original nested code and the refactored let chain version"
    ],
    "anti_patterns": [
      "Leaving deeply nested if-let patterns without suggesting refactoring",
      "Applying let chains when branches have different logic (use match instead)",
      "Forgetting that let chains require Rust 1.88 or later",
      "Using let chains for just 2 levels when nested if-let is equally readable"
    ],
    "faq": [
      {
        "question": "What are let chains in Rust?",
        "answer": "Let chains combine multiple pattern matches and conditions using && in a single if let statement. They were stabilized in Rust 1.88 and are the preferred way to handle deeply nested pattern matching."
      },
      {
        "question": "When should I suggest let chains?",
        "answer": "Suggest let chains when you see 3+ levels of nested if-let patterns that all follow the same return or continue pattern. They improve readability and reduce indentation."
      },
      {
        "question": "What Rust version is required for let chains?",
        "answer": "Let chains require Rust 1.88 or later, or the Rust 2024 edition. Check the project Cargo.toml for edition = 2024 or rust-version = 1.88."
      },
      {
        "question": "Can let chains mix Options and Results?",
        "answer": "Yes, let chains can combine if let Some() and if let Ok() patterns, as well as add boolean conditions with && operators. This makes handling mixed error types cleaner."
      },
      {
        "question": "When should I NOT use let chains?",
        "answer": "Avoid let chains when branches contain different logic. In those cases, a match expression or early return pattern is clearer. Also, for just 2 levels of nesting, the benefit is minimal."
      },
      {
        "question": "Do let chains affect runtime performance?",
        "answer": "No, let chains compile to the same code as nested if-let statements. The benefit is purely in code readability and maintainability during development."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 157
    }
  ]
}
