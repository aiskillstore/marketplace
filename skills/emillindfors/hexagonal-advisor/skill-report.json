{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:10:12.468Z",
    "slug": "emillindfors-hexagonal-advisor",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-hexagonal/skills/hexagonal-advisor",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "69eea2ecd1ad4d807903e7cb6f65946ae5a2d403c141ce1eb92d46b0d01b7525",
    "tree_hash": "2d4c781d73d6f6c5d78f392d07d23477cbb240b7140715bdee85301ab061dfc0"
  },
  "skill": {
    "name": "hexagonal-advisor",
    "description": "Reviews code architecture for hexagonal patterns, checks dependency directions, and suggests improvements for ports and adapters separation. Activates when users work with services, repositories, or architectural patterns.",
    "summary": "Code architecture reviewer for hexagonal patterns in Rust",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "tags": [
      "rust",
      "hexagonal-architecture",
      "ports-and-adapters",
      "software-architecture"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Static analysis detected pattern matches in example Rust code that appear as false positives. All 40+ findings are confirmed false positives: sqlx::query! macros flagged as external commands, axum server binding flagged as network access, and Rust bracket patterns triggering obfuscation heuristics. This is an architecture advice skill containing educational code examples with no execution capabilities.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 31,
            "line_end": 46
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "sqlx::query! macros are Rust database query DSL, not shell backtick execution. The ! suffix indicates Rust macro syntax for compile-time code generation."
      },
      {
        "factor": "network",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 436,
            "line_end": 436
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.98,
        "confidence_reasoning": "axum::Server::bind example shows infrastructure setup pattern, not network exfiltration. No data transmission to external endpoints."
      },
      {
        "factor": "env_access",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 402,
            "line_end": 402
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.98,
        "confidence_reasoning": "config.database_url is a configuration reference, not direct process.env access. This is standard infrastructure setup code."
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 538,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:10:12.468Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Review Hexagonal Architecture",
    "value_statement": "Code architecture degrades over time as teams rush to deliver features. This skill proactively identifies architectural violations in Rust codebases and suggests improvements for clean ports and adapters separation.",
    "seo_keywords": [
      "hexagonal architecture",
      "ports and adapters",
      "Rust architecture",
      "software design patterns",
      "clean architecture",
      "dependency injection",
      "domain-driven design",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Detects when domain code depends directly on infrastructure (databases, HTTP clients, frameworks)",
      "Analyzes trait abstractions and port definitions for proper separation",
      "Reviews domain model purity and identifies framework coupling",
      "Evaluates adapter implementations for correct port adherence",
      "Examines composition root patterns for proper dependency wiring",
      "Suggests refactoring steps with complete code examples"
    ],
    "limitations": [
      "Does not execute code or modify files",
      "Does not access external services or databases",
      "Limited to pattern recognition in visible code",
      "Cannot validate architecture without seeing the full codebase structure"
    ],
    "use_cases": [
      {
        "title": "Refactoring Legacy Rust Code",
        "description": "Senior developers modernizing Monolithic Rust services identify architectural violations and receive specific refactoring guidance with trait-based abstractions.",
        "target_user": "Senior developers, architects"
      },
      {
        "title": "Learning Clean Architecture",
        "description": "Intermediate Rust developers learn hexagonal patterns through real code examples showing both anti-patterns and correct implementations.",
        "target_user": "Intermediate developers"
      },
      {
        "title": "Code Review Assistance",
        "description": "Teams establish consistent architecture by having this skill review pull requests for dependency direction and separation of concerns.",
        "target_user": "Development teams"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Architecture Check",
        "prompt": "Review this Rust service code for hexagonal architecture compliance. Check if domain logic depends on infrastructure and suggest improvements.",
        "scenario": "When you see Rust code with service or repository patterns"
      },
      {
        "title": "Dependency Analysis",
        "prompt": "Analyze the dependency direction in this codebase. Are there any places where domain types depend on framework or database types? Show me how to fix them.",
        "scenario": "When analyzing architecture violations"
      },
      {
        "title": "Port Definition Review",
        "prompt": "Review these trait definitions. Are they proper ports (domain interfaces) or do they leak infrastructure details? Rewrite them as proper hexagonal ports.",
        "scenario": "When examining trait abstractions"
      },
      {
        "title": "Testing Strategy",
        "prompt": "How would I test this domain logic with mock dependencies? Show me the mock implementation pattern for the repository port.",
        "scenario": "When discussing testability improvements"
      }
    ],
    "output_examples": [
      {
        "input": "I have a UserService that directly uses sqlx::query to save users to PostgreSQL. How can I improve this?",
        "output": [
          "Your domain logic depends directly on infrastructure. Create a port trait instead:",
          "",
          "```rust",
          "#[async_trait]",
          "pub trait UserRepository: Send + Sync {",
          "    async fn save(&self, user: &User) -> Result<(), DomainError>;",
          "    async fn find(&self, id: &UserId) -> Result<User, DomainError>;",
          "}",
          "",
          "pub struct UserService<R: UserRepository> {",
          "    repo: R,",
          "}",
          "",
          "impl<R: UserRepository> UserService<R> {",
          "    pub fn new(repo: R) -> Self { Self { repo } }",
          "",
          "    pub async fn create_user(&self, email: &str) -> Result<User, DomainError> {",
          "        let user = User::new(email)?;",
          "        self.repo.save(&user).await?;",
          "        Ok(user)",
          "    }",
          "}",
          "```",
          "",
          "This allows you to test with mock implementations and swap databases without changing domain code."
        ]
      },
      {
        "input": "My User struct derives sqlx::FromRow and serde::Serialize. Is this a problem?",
        "output": [
          "Yes, this couples your domain model to infrastructure concerns. Framework types like sqlx::FromRow and serde make your domain depend on external libraries.",
          "",
          "Better approach:",
          "",
          "```rust",
          "// Domain layer - no framework dependencies",
          "pub struct User {",
          "    id: UserId,",
          "    email: Email,",
          "}",
          "",
          "// Adapter layer handles infrastructure",
          "#[derive(sqlx::FromRow)]",
          "struct UserRow { id: i64, email: String }",
          "",
          "impl From<UserRow> for User {",
          "    fn from(row: UserRow) -> Self {",
          "        // Convert database representation to domain",
          "    }",
          "}",
          "```",
          "",
          "Your domain stays pure and testable. Infrastructure details live in adapters."
        ]
      },
      {
        "input": "How should I structure my main function for hexagonal architecture?",
        "output": [
          "Use a composition root that wires all dependencies:",
          "",
          "```rust",
          "pub struct Application {",
          "    user_service: Arc<UserService<PostgresUserRepository>>,",
          "}",
          "",
          "impl Application {",
          "    pub async fn new(config: &Config) -> Result<Self, Error> {",
          "        // 1. Setup infrastructure",
          "        let pool = create_pool(&config).await?;",
          "",
          "        // 2. Create adapters",
          "        let user_repo = PostgresUserRepository::new(pool);",
          "",
          "        // 3. Create services with dependencies",
          "        let user_service = Arc::new(UserService::new(user_repo));",
          "",
          "        Ok(Self { user_service })",
          "    }",
          "}",
          "```",
          "",
          "All dependency construction happens in one place. The domain never knows about infrastructure."
        ]
      }
    ],
    "best_practices": [
      "Define port traits in the domain layer that describe what the domain needs (driven ports) and what it exposes (driving ports)",
      "Keep domain models pure by avoiding framework types like sqlx::FromRow or serde in domain structs",
      "Implement all ports in the adapter layer with infrastructure-specific code, converting between domain and infrastructure types"
    ],
    "anti_patterns": [
      "Anemic domain with structs that only hold data and no behavior - validation and business logic should live in domain types",
      "Leaky abstractions where ports use database types like i64 or sqlx::Error instead of domain types",
      "Skipping the composition root and scattering dependency construction throughout handlers or services"
    ],
    "faq": [
      {
        "question": "What is hexagonal architecture?",
        "answer": "Hexagonal architecture (ports and adapters) separates core business logic from infrastructure concerns. The domain defines ports (interfaces), and adapters implement those ports for databases, HTTP, or external services. Dependencies always point inward toward the domain."
      },
      {
        "question": "When should I use this skill?",
        "answer": "Activate this skill when you see service or repository trait definitions, domain logic mixed with infrastructure code, or questions about testing architecture. It proactively analyzes and suggests improvements."
      },
      {
        "question": "Does this skill modify my code?",
        "answer": "No. This skill provides architectural guidance and code suggestions. It only analyzes code and recommends patterns. You apply the changes yourself."
      },
      {
        "question": "What tools does this skill use?",
        "answer": "The skill activates with Read, Grep, and Glob tools to examine your codebase. It analyzes patterns and provides textual recommendations."
      },
      {
        "question": "Can this skill help with testing?",
        "answer": "Yes. It demonstrates how to create mock implementations of ports for unit testing, enabling fast tests without real database or HTTP dependencies."
      },
      {
        "question": "What languages does this skill support?",
        "answer": "This skill focuses on Rust and the sqlx, async-trait, and axum ecosystems commonly used with hexagonal architecture in Rust."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 538
    }
  ]
}
