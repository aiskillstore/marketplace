{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T01:55:15.257Z",
    "slug": "emillindfors-async-sync-advisor",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-lambda/skills/async-sync-advisor",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "c78e20b1775ff8df3d0bff48abf93adad0a3a6656cae96cb32781490174ca3aa",
    "tree_hash": "7654357b82c52a49a4149432e3967b61b8b73ed69ee62a5dc0f7a9baacee90c3"
  },
  "skill": {
    "name": "async-sync-advisor",
    "description": "Guides users on choosing between async and sync patterns for Lambda functions, including when to use tokio, rayon, and spawn_blocking. Activates when users write Lambda handlers with mixed workloads.",
    "summary": "Guides users on choosing between async and sync patterns for Lambda functions, including when to use...",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "rust",
      "aws-lambda",
      "async",
      "concurrency",
      "tokio"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings are false positives. The skill is a documentation-only skill providing guidance on Rust Lambda concurrency patterns. The detected patterns are markdown code block syntax and mentions of encryption in explanatory text, not actual executable code.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 183,
    "audit_model": "claude",
    "audited_at": "2026-01-23T01:55:15.257Z"
  },
  "content": {
    "user_title": "Choose async or sync patterns for Rust Lambda",
    "value_statement": "Rust Lambda functions often mix I/O and CPU workloads. This skill helps you choose the right concurrency pattern using tokio, rayon, or spawn_blocking for optimal performance.",
    "seo_keywords": [
      "Rust Lambda async sync",
      "AWS Lambda Rust concurrency",
      "tokio spawn_blocking",
      "Rayon parallel CPU Lambda",
      "Rust Lambda performance",
      "async Rust AWS",
      "Claude Code skill",
      "Claude Codex skill",
      "Claude skill"
    ],
    "actual_capabilities": [
      "Identify if a Lambda workload is I/O-bound or CPU-bound",
      "Suggest tokio::try_join for concurrent async I/O operations",
      "Recommend spawn_blocking for CPU-intensive synchronous work",
      "Guide combining async I/O with rayon parallel CPU processing",
      "Show patterns for mixed workloads in Lambda handlers"
    ],
    "limitations": [
      "Does not execute code or modify Lambda configurations",
      "Does not provide runtime performance benchmarks",
      "Does not troubleshoot specific runtime errors",
      "Focused on Rust Lambda patterns only"
    ],
    "use_cases": [
      {
        "title": "Optimizing mixed I/O and CPU workloads",
        "description": "When a Lambda function needs to download data from S3, process it with CPU-intensive computation, then upload results. The skill shows how to use spawn_blocking with rayon for the compute phase while keeping I/O async.",
        "target_user": "Rust developers building AWS Lambda functions"
      },
      {
        "title": "Migrating sync code to async Lambda",
        "description": "When converting a synchronous Rust application to run on Lambda. The skill identifies where to use async patterns versus where to keep code synchronous with spawn_blocking.",
        "target_user": "Developers migrating to serverless Rust"
      },
      {
        "title": "Improving Lambda cold start times",
        "description": "When evaluating whether to use async or sync patterns that affect initialization. The skill explains trade-offs between runtime overhead and CPU efficiency for different workload types.",
        "target_user": "Performance engineers optimizing Lambda"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic pattern question",
        "prompt": "I have a Rust Lambda handler that makes multiple database queries. Should I use async or sync patterns?",
        "scenario": "User asking about I/O-bound workload patterns"
      },
      {
        "title": "Mixed workload optimization",
        "prompt": "My Lambda downloads data from S3, processes it with CPU-intensive work, then uploads results. What concurrency pattern should I use?",
        "scenario": "User with mixed I/O and compute workloads"
      },
      {
        "title": "Converting existing code",
        "prompt": "I have a sync function that does image processing. How do I integrate this into an async Lambda handler?",
        "scenario": "User integrating CPU-intensive sync code into async Lambda"
      },
      {
        "title": "Performance tuning",
        "prompt": "My Lambda is using async for CPU-bound work and I want to improve performance. What patterns should I use instead?",
        "scenario": "User optimizing existing Lambda for better performance"
      }
    ],
    "output_examples": [
      {
        "input": "Should I use async or spawn_blocking for a Lambda that calls an external API and does some data processing?",
        "output": "For this mixed workload:\n\n1. Keep async for the external API call - I/O operations benefit from async\n2. Use spawn_blocking for data processing - CPU-bound work blocks the async runtime\n\n```rust\nasync fn handler(event: LambdaEvent<Request>) -> Result<Response, Error> {\n    // Phase 1: Async I/O\n    let api_data = fetch_from_api(&event.payload.url).await?;\n\n    // Phase 2: CPU sync work\n    let processed = tokio::task::spawn_blocking(move || {\n        process_data(&api_data)\n    }).await??;\n\n    Ok(Response { processed })\n}\n```"
      },
      {
        "input": "How do I handle many independent operations in parallel in my Lambda?",
        "output": "For independent I/O operations, use tokio::try_join:\n\n```rust\nasync fn handler(event: LambdaEvent<Request>) -> Result<Response, Error> {\n    let (user, orders, recommendations) = tokio::try_join!(\n        fetch_user(event.payload.user_id),\n        fetch_orders(event.payload.user_id),\n        fetch_recommendations(event.payload.user_id),\n    )?;\n\n    Ok(Response { user, orders, recommendations })\n}\n```\n\nThis runs all three fetches concurrently instead of sequentially."
      }
    ],
    "best_practices": [
      "Use async for I/O-bound operations (HTTP, database, S3) to avoid blocking the runtime",
      "Use spawn_blocking for CPU-bound work to prevent blocking the async executor",
      "Combine tokio::try_join for concurrent I/O with spawn_blocking for parallel CPU work"
    ],
    "anti_patterns": [
      "Using async for CPU-intensive work that blocks the runtime and adds unnecessary overhead",
      "Running I/O operations sequentially when they could run concurrently with try_join",
      "Mixing async and sync code without using spawn_blocking, causing the async runtime to stall"
    ],
    "faq": [
      {
        "question": "What is the difference between async and spawn_blocking?",
        "answer": "Async allows the runtime to handle other tasks while waiting for I/O. spawn_blocking moves synchronous CPU work to a separate thread pool so it does not block the async runtime. Use async for I/O and spawn_blocking for CPU work."
      },
      {
        "question": "When should I use rayon instead of spawn_blocking?",
        "answer": "Use rayon when you have parallel CPU work on collections that can be split across threads. Combine rayon with spawn_blocking to run parallel CPU work without blocking the async runtime."
      },
      {
        "question": "Does using spawn_blocking add latency to my Lambda?",
        "answer": "spawn_blocking uses a thread pool, so it has some overhead. However, this is usually much better than blocking the async runtime, which would prevent handling other requests concurrently."
      },
      {
        "question": "Can I use async for CPU-bound work?",
        "answer": "You can, but it is not recommended. CPU-bound work in an async task blocks the entire async runtime. Use spawn_blocking instead to move CPU work to a dedicated thread pool."
      },
      {
        "question": "How do I handle errors in spawn_blocking?",
        "answer": "The ? operator works differently inside spawn_blocking. Use the double ? (??) when awaiting the spawned task to propagate errors from both the spawn and the blocking work."
      },
      {
        "question": "Does this skill modify my Lambda code?",
        "answer": "No. This skill provides guidance and pattern suggestions. It reads your Lambda handlers and explains which patterns to use, but does not execute or modify any code."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 183
    }
  ]
}
