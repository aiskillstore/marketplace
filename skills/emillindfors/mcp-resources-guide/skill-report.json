{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:18:02.243Z",
    "slug": "emillindfors-mcp-resources-guide",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-mcp-server/skills/mcp-resources-guide",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "0c2de64efe61dfb2e4913844af09b6416b7c88961e15f29a0514ede3751a758f",
    "tree_hash": "dc93141546b27296142611b70ee3fbd954a82b98ec193742234b3fa098170561"
  },
  "skill": {
    "name": "MCP Resources Guide",
    "description": "Guide developers on implementing MCP resources with URI patterns, caching strategies, and streaming for AI assistants",
    "summary": "Implement MCP resources that provide data and files to AI assistants",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "tags": [
      "MCP",
      "resources",
      "URI",
      "caching",
      "streaming"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill is a documentation guide for implementing MCP resources. Static analysis flagged patterns in code examples within the markdown documentation, but all findings are false positives. The flagged 'external_commands' are Rust format strings, not shell execution. The 'env_access' patterns are legitimate API key handling examples. The 'weak cryptographic algorithm' and 'system reconnaissance' flags are misidentifications of documentation text and standard URI parsing code. No executable malicious code is present.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 41,
            "line_end": 55
          },
          {
            "file": "SKILL.md",
            "line_start": 55,
            "line_end": 59
          },
          {
            "file": "SKILL.md",
            "line_start": 59,
            "line_end": 67
          },
          {
            "file": "SKILL.md",
            "line_start": 67,
            "line_end": 73
          },
          {
            "file": "SKILL.md",
            "line_start": 73,
            "line_end": 150
          },
          {
            "file": "SKILL.md",
            "line_start": 150,
            "line_end": 154
          },
          {
            "file": "SKILL.md",
            "line_start": 154,
            "line_end": 191
          },
          {
            "file": "SKILL.md",
            "line_start": 191,
            "line_end": 197
          },
          {
            "file": "SKILL.md",
            "line_start": 197,
            "line_end": 230
          },
          {
            "file": "SKILL.md",
            "line_start": 230,
            "line_end": 234
          },
          {
            "file": "SKILL.md",
            "line_start": 234,
            "line_end": 273
          },
          {
            "file": "SKILL.md",
            "line_start": 273,
            "line_end": 277
          },
          {
            "file": "SKILL.md",
            "line_start": 277,
            "line_end": 318
          },
          {
            "file": "SKILL.md",
            "line_start": 318,
            "line_end": 322
          },
          {
            "file": "SKILL.md",
            "line_start": 322,
            "line_end": 360
          },
          {
            "file": "SKILL.md",
            "line_start": 360,
            "line_end": 366
          },
          {
            "file": "SKILL.md",
            "line_start": 366,
            "line_end": 409
          },
          {
            "file": "SKILL.md",
            "line_start": 409,
            "line_end": 413
          },
          {
            "file": "SKILL.md",
            "line_start": 413,
            "line_end": 435
          },
          {
            "file": "SKILL.md",
            "line_start": 435,
            "line_end": 441
          },
          {
            "file": "SKILL.md",
            "line_start": 441,
            "line_end": 460
          },
          {
            "file": "SKILL.md",
            "line_start": 460,
            "line_end": 466
          },
          {
            "file": "SKILL.md",
            "line_start": 466,
            "line_end": 482
          },
          {
            "file": "SKILL.md",
            "line_start": 482,
            "line_end": 488
          },
          {
            "file": "SKILL.md",
            "line_start": 488,
            "line_end": 516
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 495,
            "line_end": 495
          },
          {
            "file": "SKILL.md",
            "line_start": 502,
            "line_end": 502
          },
          {
            "file": "SKILL.md",
            "line_start": 511,
            "line_end": 511
          }
        ]
      },
      {
        "factor": "env_access",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 284,
            "line_end": 284
          },
          {
            "file": "SKILL.md",
            "line_start": 297,
            "line_end": 297
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [
      {
        "title": "External Commands Pattern in Documentation",
        "description": "Static analysis detected backtick patterns and command-like syntax in code examples. Evaluation shows these are Rust format strings (format! macro) for URI construction, not shell command execution. The backticks in Rust strings are used for string interpolation in format! macros, not backtick shell execution.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 41,
            "line_end": 55
          }
        ],
        "confidence": 0.15,
        "confidence_reasoning": "The scanner misidentifies Rust format string syntax as shell backtick execution. Actual code uses format! macro for URI construction, which is safe string formatting with no command execution."
      },
      {
        "title": "API Key Access Pattern in Examples",
        "description": "Static analysis detected API key handling in code examples. Evaluation shows these are legitimate documentation examples showing proper API key usage in resource implementations.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 284,
            "line_end": 297
          }
        ],
        "confidence": 0.1,
        "confidence_reasoning": "Code examples demonstrate proper API key handling with Bearer token authentication. These are educational examples for implementing secure API integration, not actual secret access."
      },
      {
        "title": "Weak Cryptographic Algorithm Misidentification",
        "description": "Static analysis flagged lines as weak cryptographic algorithms. Evaluation shows these are false positives - the lines contain YAML frontmatter, documentation text, and standard Rust code structures, not cryptographic code.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 2,
            "line_end": 2
          },
          {
            "file": "SKILL.md",
            "line_start": 5,
            "line_end": 5
          }
        ],
        "confidence": 0.05,
        "confidence_reasoning": "Scanner misidentifies YAML frontmatter and documentation text as cryptographic algorithms. No cryptographic code or algorithms are present in this documentation file."
      },
      {
        "title": "System Reconnaissance Misidentification",
        "description": "Static analysis flagged path parsing and metric collection as system reconnaissance. These are legitimate MCP resource patterns for URI parsing and metrics retrieval.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 176,
            "line_end": 177
          }
        ],
        "confidence": 0.1,
        "confidence_reasoning": "Code demonstrates standard URI parsing for resource identification. The metric collection pattern is legitimate resource implementation, not system reconnaissance."
      }
    ],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 560,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:18:02.243Z",
    "risk_factors": [
      "scripts",
      "filesystem",
      "external_commands"
    ]
  },
  "content": {
    "user_title": "Implement MCP resources for AI assistants",
    "value_statement": "MCP servers need resources to provide data and files to AI assistants. This skill guides developers through implementing URI-addressable resources with caching, streaming, and proper MIME type handling for production-ready integrations.",
    "seo_keywords": [
      "MCP resources",
      "Claude",
      "Codex",
      "Claude Code",
      "URI patterns",
      "resource implementation",
      "MCP server",
      "caching strategies",
      "streaming resources",
      "MIME types"
    ],
    "actual_capabilities": [
      "Guide resource design and URI pattern selection for MCP servers",
      "Implement resource listing and discovery with metadata",
      "Create resource fetching with proper MIME type handling",
      "Add caching strategies for performance optimization",
      "Implement streaming for large resource handling",
      "Build resource subscriptions for real-time updates"
    ],
    "limitations": [
      "This is a guidance skill - it does not execute code or modify files",
      "Does not provide pre-built MCP server implementations",
      "Cannot test or validate user's existing resource implementations"
    ],
    "use_cases": [
      {
        "title": "Design resource URIs for a new MCP server",
        "description": "A developer building an MCP server needs to design resource URIs for their data sources. The skill provides patterns for hierarchical paths, query-style URIs, and template-based approaches.",
        "target_user": "MCP server developers"
      },
      {
        "title": "Add caching to expensive resource fetches",
        "description": "A developer wants to optimize resource performance. The skill shows in-memory caching with TTL, lazy loading patterns, and cache invalidation strategies.",
        "target_user": "Performance-focused developers"
      },
      {
        "title": "Handle large binary resources efficiently",
        "description": "A developer needs to serve large files through MCP resources. The skill demonstrates chunked streaming, binary data handling, and memory-efficient content delivery.",
        "target_user": "Backend developers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic resource implementation",
        "prompt": "Help me implement MCP resources for my server. I need to expose files from a directory as resources with URIs like file:///path/to/file. Show me how to list resources and fetch their content with proper MIME types.",
        "scenario": "Getting started with MCP resources"
      },
      {
        "title": "Database-backed resources",
        "prompt": "I want to expose database records as MCP resources. Show me how to implement a resource that takes a URI like db://table_name/id, queries the database, and returns the result as JSON with the correct content type.",
        "scenario": "Creating database resource handlers"
      },
      {
        "title": "API integration resources",
        "prompt": "My MCP server needs to fetch data from external APIs and expose them as resources. Show me how to implement an API resource with authentication, proper error handling, and content-type detection.",
        "scenario": "Building API integration resources"
      },
      {
        "title": "Production caching strategy",
        "prompt": "My resources are fetching from slow data sources. Show me how to implement in-memory caching with TTL expiration, thread-safe access, and proper cache invalidation for a production MCP server.",
        "scenario": "Optimizing resource performance"
      }
    ],
    "output_examples": [
      {
        "input": "How do I implement a resource that serves markdown documentation files?",
        "output": "Here is a pattern for implementing a documentation resource:\n\n1. Create a struct that holds the docs directory path\n2. Implement list_resources() to walk the directory and create ResourceInfo for each .md file\n3. Implement fetch_resource() to read the file and return it with text/markdown MIME type\n4. Use uri format: docs://relative/path/file.md\n\nThe resource will automatically handle MIME type detection and provide clear URIs for AI assistants to reference."
      },
      {
        "input": "What is the difference between tools and resources in MCP?",
        "output": "Tools and resources serve different purposes:\n\n**Tools** perform actions that modify state or perform computations. They are invoked with parameters and return results.\n\n**Resources** provide data that gives context to AI assistants. They are read-only data sources like files, database records, or API responses. Resources are identified by URIs and can be listed, discovered, and fetched as needed."
      },
      {
        "input": "How do I prevent path traversal attacks in my file resources?",
        "output": "To prevent path traversal:\n\n1. Validate the URI format before processing\n2. Use strip_prefix() to remove the base path, never user input directly\n3. Reject URIs with parent directory references (../)\n4. Use canonicalize() to resolve paths and verify they are within allowed directory\n5. Return clear errors for invalid paths rather than exposing file system details"
      }
    ],
    "best_practices": [
      "Use hierarchical, descriptive URI schemes that clearly indicate resource type and location",
      "Always set accurate MIME types so AI assistants know how to process resource content",
      "Implement caching for expensive operations and streaming for large files to manage memory efficiently"
    ],
    "anti_patterns": [
      "Returning raw file paths in URIs without proper encoding or validation",
      "Loading entire large files into memory before returning them",
      "Not handling missing resources with clear error messages"
    ],
    "faq": [
      {
        "question": "What are MCP resources?",
        "answer": "MCP resources are data sources that MCP servers expose to AI assistants. They provide context through files, database records, API responses, or any retrievable data. Each resource has a unique URI, a MIME type, and content that can be fetched."
      },
      {
        "question": "How do resources differ from tools?",
        "answer": "Tools perform actions that modify state. Resources provide read-only data for context. Tools are invoked with parameters and return results. Resources are identified by URIs and fetched when needed."
      },
      {
        "question": "What URI patterns should I use?",
        "answer": "Use hierarchical paths like file:///project/src/main.rs, query-style like data://records?type=user, or template-based like user://{user_id}. Choose patterns that clearly indicate resource type and organization."
      },
      {
        "question": "How do I handle caching?",
        "answer": "Implement in-memory caching with a TTL (time-to-live). Use RwLock for thread-safe access. Check cache before fetching, update cache after fetch, and invalidate cache when data changes."
      },
      {
        "question": "Can resources return binary data?",
        "answer": "Yes. Set blob field to Some(binary_data) and mime_type to appropriate type like image/png or application/pdf. Use streaming for large binary files to avoid memory issues."
      },
      {
        "question": "How do I test my resource implementations?",
        "answer": "Test valid URIs return correct content, invalid URIs return errors, edge cases like empty directories are handled, and performance is acceptable for expected load sizes."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 560
    }
  ]
}
