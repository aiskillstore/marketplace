{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:29:28.789Z",
    "slug": "emillindfors-port-adapter-designer",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-hexagonal/skills/port-adapter-designer",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "0d25b13fc2955607c96349064190526212c0e30fda4f948db5e875d0a6135b45",
    "tree_hash": "24f652f9c6133237f17c592b953a445f7abd7532a02d83b9ac5a495e50c0ff15"
  },
  "skill": {
    "name": "port-adapter-designer",
    "description": "Helps design port traits and adapter implementations for external dependencies. Activates when users need to abstract away databases, APIs, or other external systems.",
    "summary": "Designs port abstractions and adapter implementations for hexagonal architecture in Rust. Proactively identifies external dependencies and suggests clean architecture patterns.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "tags": [
      "rust",
      "hexagonal-architecture",
      "ports-and-adapters",
      "dependency-inversion",
      "clean-architecture"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings are false positives. The skill contains documentation and code examples for hexagonal architecture patterns. The 'external_commands' detections are Rust syntax (not shell backticks), 'network' and 'env_access' patterns are example code (not actual execution), and all 'blocker' and 'obfuscation' alerts are scanner misinterpretations of legitimate Rust code constructs.",
    "files_scanned": 1,
    "total_lines": 211,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:29:28.789Z",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [
      {
        "title": "Ruby/shell backtick execution patterns",
        "description": "Static scanner detected 'Ruby/shell backtick execution' patterns at multiple lines. Upon evaluation, these are legitimate Rust generic type declarations (e.g., Arc<Mutex<HashMap<...>>>) that the scanner incorrectly identified as shell backticks. No shell or Ruby code exists in this skill file.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 24,
            "line_end": 33
          },
          {
            "file": "SKILL.md",
            "line_start": 33,
            "line_end": 37
          },
          {
            "file": "SKILL.md",
            "line_start": 37,
            "line_end": 44
          },
          {
            "file": "SKILL.md",
            "line_start": 44,
            "line_end": 48
          },
          {
            "file": "SKILL.md",
            "line_start": 48,
            "line_end": 54
          },
          {
            "file": "SKILL.md",
            "line_start": 54,
            "line_end": 60
          },
          {
            "file": "SKILL.md",
            "line_start": 60,
            "line_end": 104
          },
          {
            "file": "SKILL.md",
            "line_start": 104,
            "line_end": 108
          },
          {
            "file": "SKILL.md",
            "line_start": 108,
            "line_end": 149
          },
          {
            "file": "SKILL.md",
            "line_start": 149,
            "line_end": 153
          },
          {
            "file": "SKILL.md",
            "line_start": 153,
            "line_end": 192
          }
        ],
        "confidence": 0.95,
        "confidence_reasoning": "Rust generic type syntax like 'Arc<Mutex<HashMap>>' contains angle brackets that the scanner misidentified as shell backticks. Code inspection confirms these are legitimate Rust code examples."
      },
      {
        "title": "Hardcoded URL detection",
        "description": "Static scanner detected a hardcoded URL at line 126. This is 'https://api.stripe.com/v1/charges' within a Stripe adapter code example. The skill is documentation-only; no actual network requests are made.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 126,
            "line_end": 126
          }
        ],
        "confidence": 0.95,
        "confidence_reasoning": "The URL appears in a code example showing how to implement an HTTP adapter. The skill itself contains no network access code and never makes external requests."
      },
      {
        "title": "API/secret key access patterns",
        "description": "Static scanner detected 'env_access' patterns for API keys at lines 111 and 127. These are struct field declarations (api_key: String) in a Stripe adapter example, not environment variable access.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 111,
            "line_end": 111
          },
          {
            "file": "SKILL.md",
            "line_start": 127,
            "line_end": 127
          }
        ],
        "confidence": 0.95,
        "confidence_reasoning": "The skill shows struct field definitions in example code. No process.env, environment variable access, or credential handling exists in the skill itself."
      },
      {
        "title": "Weak cryptographic algorithm alerts",
        "description": "Static scanner flagged 'weak cryptographic algorithms' at various document lines. No cryptographic code exists in this skill file. The scanner appears to be detecting keywords in documentation text that resemble cryptographic terms.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 2,
            "line_end": 3
          },
          {
            "file": "SKILL.md",
            "line_start": 3,
            "line_end": 3
          },
          {
            "file": "SKILL.md",
            "line_start": 8,
            "line_end": 8
          },
          {
            "file": "SKILL.md",
            "line_start": 10,
            "line_end": 10
          },
          {
            "file": "SKILL.md",
            "line_start": 20,
            "line_end": 20
          },
          {
            "file": "SKILL.md",
            "line_start": 194,
            "line_end": 206
          },
          {
            "file": "SKILL.md",
            "line_start": 206,
            "line_end": 206
          }
        ],
        "confidence": 0.95,
        "confidence_reasoning": "The skill is about port/adapter architecture patterns and contains no cryptographic code. Scanner appears to be flagging documentation keywords incorrectly."
      },
      {
        "title": "System reconnaissance patterns",
        "description": "Static scanner flagged 'system reconnaissance' at line 76. This line is within a find_by_id method in an in-memory repository. No reconnaissance or system scanning code exists.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 76,
            "line_end": 76
          }
        ],
        "confidence": 0.95,
        "confidence_reasoning": "Line 76 is within a standard Rust mutex lock operation in a HashMap lookup. This is a legitimate concurrent programming pattern, not system reconnaissance."
      },
      {
        "title": "Obfuscation pattern (bracket chains)",
        "description": "Static scanner detected 'multiple bracket chains' as JSFuck/obfuscation at line 1. This is the YAML frontmatter header containing standard YAML brackets. No obfuscation exists.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 1,
            "line_end": 1
          }
        ],
        "confidence": 0.95,
        "confidence_reasoning": "The file begins with YAML frontmatter '---' which contains standard YAML syntax. Code inspection confirms no obfuscation or malicious patterns."
      },
      {
        "title": "Dangerous combination heuristic",
        "description": "Static scanner raised a 'DANGEROUS COMBINATION' heuristic alert claiming code execution + network + credential access. This is a false positive from misinterpreting code examples. The skill is purely documentation.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 1,
            "line_end": 211
          }
        ],
        "confidence": 0.9,
        "confidence_reasoning": "Scanner detected patterns across different code examples in the file but missed that the skill itself contains no execution paths. All patterns are static documentation examples only."
      }
    ]
  },
  "content": {
    "user_title": "Design Port and Adapter Patterns",
    "value_statement": "Writing code that directly couples to databases, HTTP clients, or file systems creates testing challenges and limits flexibility. This skill helps design port abstractions and adapter implementations for hexagonal architecture, enabling clean separation between business logic and external dependencies.",
    "seo_keywords": [
      "hexagonal architecture",
      "ports and adapters",
      "Rust architecture",
      "dependency injection Rust",
      "clean architecture",
      "domain driven design",
      "adapter pattern",
      "trait abstraction",
      "mock testing",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Identifies when external dependencies (databases, HTTP clients, file systems) are being used directly",
      "Designs port traits with domain types that abstract away infrastructure concerns",
      "Creates adapter implementations that conform to port interfaces",
      "Suggests in-memory test adapters for unit testing without real dependencies",
      "Proactively recommends port/adapter patterns when coupling is detected"
    ],
    "limitations": [
      "Does not generate production-ready adapter code with full error handling",
      "Does not integrate with specific frameworks or ORMs automatically",
      "Does not verify that adapters compile or follow all Rust best practices",
      "Does not execute any code or modify project files directly"
    ],
    "use_cases": [
      {
        "title": "Refactor database-coupled code",
        "description": "A developer has direct sqlx or diesel queries scattered throughout their application and wants to make the code testable. The skill helps design repository ports and create mock implementations for unit testing.",
        "target_user": "Rust developers working on legacy codebases"
      },
      {
        "title": "Design external service integrations",
        "description": "A team needs to integrate with payment gateways, email services, or third-party APIs. The skill designs service ports that hide implementation details behind clean async interfaces.",
        "target_user": "Backend engineers building integrations"
      },
      {
        "title": "Learn hexagonal architecture patterns",
        "description": "A developer is new to port/adapter architecture and wants to understand how to structure Rust code for clean separation between domain logic and infrastructure.",
        "target_user": "Rust developers learning clean architecture"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic port design request",
        "prompt": "I need a port trait for a UserRepository that supports find_by_id, find_by_email, save, delete, and list operations. The domain types are User, UserId, Email, and RepositoryError.",
        "scenario": "When a user explicitly requests help designing a port interface"
      },
      {
        "title": "Adapter implementation request",
        "prompt": "Show me how to implement the UserRepository port using sqlx with a PostgreSQL pool. Include proper error conversion from sqlx errors to domain RepositoryError.",
        "scenario": "When a user needs an adapter implementation example"
      },
      {
        "title": "Testing adapter request",
        "prompt": "Create an in-memory implementation of UserRepository for testing. Use Arc<Mutex<HashMap>> for thread-safe storage.",
        "scenario": "When a user needs a test double or mock implementation"
      },
      {
        "title": "Proactive refactoring suggestion",
        "prompt": "[The skill activates proactively] I noticed you're using sqlx::query directly in your handlers. Would you like me to design a port abstraction for your repository pattern and show you how to implement it with an adapter? This would make your code testable with mock implementations.",
        "scenario": "When the skill detects direct database usage and suggests architectural improvements"
      }
    ],
    "output_examples": [
      {
        "input": "Design a port for sending email notifications",
        "output": "```rust\n#[async_trait]\npub trait EmailPort: Send + Sync {\n    async fn send(&self, to: &Email, subject: &str, body: &str) -> Result<(), NotificationError>;\n}\n\n// Domain error type\n#[derive(Debug)]\npub enum NotificationError {\n    InvalidAddress(String),\n    SmtpFailed(String),\n    RateLimited,\n}\n```"
      },
      {
        "input": "Show me an HTTP adapter for Stripe payments",
        "output": "```rust\npub struct StripeAdapter {\n    client: reqwest::Client,\n    api_key: String,\n}\n\n#[async_trait]\nimpl PaymentPort for StripeAdapter {\n    async fn charge(&self, amount: Money, card: &Card) -> Result<PaymentId, PaymentError> {\n        // Implementation with proper error mapping\n    }\n}\n```"
      }
    ],
    "best_practices": [
      "Define ports using domain types, not infrastructure types. Pass domain objects in and out of port methods.",
      "Convert infrastructure errors to domain errors at the adapter boundary. Never leak sqlx, reqwest, or other library errors into domain code.",
      "Make ports Send + Sync for compatibility with async runtimes like Tokio. Use Arc<Mutex<T>> or RwLock when interior mutability is needed."
    ],
    "anti_patterns": [
      "Passing repository structs directly to use cases instead of defining port traits that can be mocked.",
      "Returning infrastructure errors (sqlx::Error, reqwest::Error) directly from application services instead of converting to domain errors.",
      "Designing ports that mirror database schemas rather than representing domain concepts and operations."
    ],
    "faq": [
      {
        "question": "What is the difference between a port and an adapter?",
        "answer": "A port is a trait (interface) that defines what operations the domain needs. An adapter is a concrete implementation that handles the technical details of talking to external systems like databases or APIs."
      },
      {
        "question": "How do ports make testing easier?",
        "answer": "Since ports are traits, you can create in-memory test adapters that implement the same interface. Your unit tests use the test adapter instead of real databases, making tests fast and isolated."
      },
      {
        "question": "When should I create a port?",
        "answer": "Create a port whenever your code needs to interact with something external: databases, file systems, HTTP APIs, email services, or any system that could vary independently from your business logic."
      },
      {
        "question": "Can one port have multiple adapters?",
        "answer": "Yes. A UserRepository port could have a PostgresAdapter, a MongoAdapter, and an InMemoryAdapter for testing. The domain code depends only on the port, so adapters can be swapped without changes."
      },
      {
        "question": "Does this skill modify my code?",
        "answer": "No. This skill provides guidance, code examples, and architectural suggestions. It does not write files or execute code. You copy the patterns into your project manually."
      },
      {
        "question": "What Rust crates work well with this pattern?",
        "answer": "async-trait for defining async trait methods, sqlx for database access, reqwest for HTTP clients, and tokio for async runtime. These integrate well with port/adapter architecture."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 211
    }
  ]
}
