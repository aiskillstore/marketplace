{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:31:27.595Z",
    "slug": "emillindfors-property-testing-guide",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-testing/skills/property-testing-guide",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "30ecfbc48f2fe50a1dc0ab424d3c3d0712f7fe684e502bc38c71f5fe916bd4cc",
    "tree_hash": "a2da8d1f51283630fd004bf35c0c76a4e752080cec6c2545ab8b8a6f2d177312"
  },
  "skill": {
    "name": "property-testing-guide",
    "description": "Introduces property-based testing with proptest, helping users find edge cases automatically by testing invariants and properties. Activates when users test algorithms or data structures.",
    "summary": "Learn property-based testing in Rust using proptest to automatically discover edge cases.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "rust",
      "testing",
      "proptest",
      "property-based-testing",
      "edge-cases"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill is purely educational documentation about property-based testing in Rust. All 36 static findings are false positives: the 'Ruby backtick execution' detections are markdown code fences, the 'weak cryptographic algorithm' matches are proptest framework references, and 'system reconnaissance' flags are email regex patterns in test examples. The skill is restricted to Read and Grep tools only.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [
      {
        "title": "Static Scanner False Positives - Markdown Code Blocks",
        "description": "The static scanner flagged 27 instances of 'Ruby/shell backtick execution' which are actually markdown triple-backtick code fences (```rust) used to display Rust code examples. These are documentation syntax, not executable code.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 29,
            "line_end": 36
          }
        ]
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 295,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:31:27.595Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Master Property-Based Testing in Rust",
    "value_statement": "Traditional unit tests check specific inputs, but miss edge cases. This skill teaches you property-based testing with proptest to automatically generate test inputs and discover hidden bugs.",
    "seo_keywords": [
      "Claude",
      "Codex",
      "Claude Code",
      "property-based testing",
      "proptest",
      "Rust testing",
      "edge case detection",
      "test automation",
      "invariant testing",
      "fuzz testing"
    ],
    "actual_capabilities": [
      "Teaches property-based testing concepts and patterns for Rust using proptest",
      "Provides ready-to-use code templates for roundtrip, idempotence, and invariant testing",
      "Shows how to create custom strategies for domain-specific types",
      "Demonstrates testing patterns for parsers, data structures, and serialization",
      "Explains automatic test case shrinking to find minimal failing examples",
      "Activates proactively when detecting algorithm or data structure implementations"
    ],
    "limitations": [
      "Only covers Rust and the proptest library, not other languages or frameworks",
      "Provides guidance and templates, but does not execute or run tests directly",
      "Requires users to have proptest dependency installed in their project",
      "Does not cover advanced proptest configuration or custom test runners"
    ],
    "use_cases": [
      {
        "title": "Testing Serialization Code",
        "description": "When implementing serialize and deserialize functions, use roundtrip property tests to verify that data survives encoding and decoding without corruption.",
        "target_user": "Backend developers working with data formats"
      },
      {
        "title": "Validating Sorting Algorithms",
        "description": "When implementing custom sorting or ordering algorithms, use invariant property tests to ensure output is sorted, length is preserved, and elements are unchanged.",
        "target_user": "Developers implementing custom algorithms"
      },
      {
        "title": "Parser Robustness Testing",
        "description": "When building parsers, use property tests to ensure the parser never panics on arbitrary input and correctly handles all valid input formats.",
        "target_user": "Developers building parsers or input processors"
      }
    ],
    "prompt_templates": [
      {
        "title": "Add Property Tests",
        "prompt": "Add property-based tests for this function using proptest.",
        "scenario": "You have a function and want to add comprehensive property tests."
      },
      {
        "title": "Test Serialization Roundtrip",
        "prompt": "Create a property test that verifies serialization and deserialization roundtrip for this type.",
        "scenario": "You have a type with serialize/deserialize and want to verify data integrity."
      },
      {
        "title": "Create Custom Strategy",
        "prompt": "Create a proptest strategy for generating valid instances of this domain type.",
        "scenario": "You have a complex domain type and need to generate valid test inputs."
      },
      {
        "title": "Test Data Structure Invariants",
        "prompt": "Write property tests that verify the invariants of this data structure are maintained after any sequence of operations.",
        "scenario": "You have a custom data structure and want to test that invariants hold."
      }
    ],
    "output_examples": [
      {
        "input": "Add property tests for this encode/decode function pair",
        "output": "I will create a roundtrip property test that generates random input strings, encodes them, decodes the result, and asserts the decoded value equals the original input. This tests the fundamental property that encoding followed by decoding should preserve data."
      },
      {
        "input": "Test my custom sort function with proptest",
        "output": "I will create property tests for three invariants: the output length equals input length, the output is in sorted order where each element is less than or equal to the next, and all original elements are present in the output. These properties should hold for any input vector."
      }
    ],
    "best_practices": [
      "Start with simple properties like roundtrip and idempotence before testing complex invariants",
      "Use custom strategies to generate only valid domain objects, avoiding wasted test iterations on invalid inputs",
      "Compare your implementation against a known-correct oracle when optimizing algorithms"
    ],
    "anti_patterns": [
      "Testing only specific known inputs instead of properties that should hold for all inputs",
      "Writing property tests that are too strict and fail on valid edge cases you did not anticipate",
      "Ignoring proptest shrinking output which provides minimal failing cases for debugging"
    ],
    "faq": [
      {
        "question": "What is property-based testing?",
        "answer": "Property-based testing generates many random inputs and checks that certain properties always hold, unlike traditional tests that check specific known inputs."
      },
      {
        "question": "How is proptest different from fuzzing?",
        "answer": "Proptest is similar to fuzzing but focuses on testing properties and invariants. It also provides automatic shrinking to find minimal failing cases."
      },
      {
        "question": "What properties should I test?",
        "answer": "Common properties include roundtrip (encode then decode gives original), idempotence (applying twice equals once), and invariants (sorted output, preserved length)."
      },
      {
        "question": "How do I add proptest to my project?",
        "answer": "Add proptest = \"1.0\" to the dev-dependencies section of your Cargo.toml file."
      },
      {
        "question": "What is shrinking in proptest?",
        "answer": "Shrinking automatically reduces a failing test case to its minimal form, making it easier to understand and debug the failure."
      },
      {
        "question": "When should I use custom strategies?",
        "answer": "Use custom strategies when you need to generate valid domain objects with specific constraints, like valid email addresses or positive money amounts."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 295
    }
  ]
}
