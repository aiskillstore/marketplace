{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:35:31.822Z",
    "slug": "emillindfors-rust-2024-migration",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-modern-patterns/skills/rust-2024-migration",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "7f4e2136843e7f284ae4467efbc9239549a4562b402e002197f7f3a67614abb4",
    "tree_hash": "a14e5e6fb56d7ff2f6b27f53fee02efb250980b9610399eb426547191f5e3274"
  },
  "skill": {
    "name": "rust-2024-migration",
    "description": "Guides users through migrating to Rust 2024 edition features including let chains, async closures, and improved match ergonomics. Activates when users work with Rust 2024 features or nested control flow.",
    "summary": "Guides users through migrating to Rust 2024 edition features including let chains, async closures, a...",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "tags": [
      "rust",
      "migration",
      "rust-2024",
      "async",
      "modern-rust"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings are false positives. The skill contains only documentation about Rust 2024 migration patterns. Backtick detections are markdown code block syntax, not shell execution. No executable code, network calls, or file operations beyond reading code examples.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 224,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:35:31.822Z"
  },
  "content": {
    "user_title": "Migrate to Rust 2024 edition features",
    "value_statement": "Rust 2024 introduces powerful new features like let chains and async closures that simplify code. This skill guides developers through identifying migration opportunities and applying modern patterns for cleaner, more idiomatic Rust code.",
    "seo_keywords": [
      "Rust 2024",
      "Rust migration",
      "let chains",
      "async closures",
      "Rust edition 2024",
      "Claude",
      "Codex",
      "Claude Code",
      "gen blocks",
      "async traits"
    ],
    "actual_capabilities": [
      "Identifies nested if-let patterns that can be simplified with let chains",
      "Suggests native async closures instead of manual clone-based patterns",
      "Recommends removing async-trait crate when native async fn in traits suffices",
      "Highlights gen blocks for replacing manual iterator implementations",
      "Provides migration templates and code examples for each Rust 2024 feature"
    ],
    "limitations": [
      "Does not automatically modify code files - only suggests improvements",
      "Cannot guarantee compatibility with all crate dependencies",
      "Requires Rust 1.85 or later for full feature support",
      "Does not handle complex macro-based code transformations"
    ],
    "use_cases": [
      {
        "title": "Legacy codebase modernization",
        "description": "Systematically upgrade a Rust 2021 edition codebase to 2024, identifying all nested control flow patterns that can benefit from let chains.",
        "target_user": "Senior developers leading codebase migrations"
      },
      {
        "title": "Learning modern Rust patterns",
        "description": "Understand when and how to use new Rust 2024 features through guided examples and comparisons between old and new patterns.",
        "target_user": "Rust developers learning 2024 edition"
      },
      {
        "title": "Code review automation",
        "description": "Automatically detect patterns in pull requests that could be improved with Rust 2024 features for more readable and idiomatic code.",
        "target_user": "Engineering teams using Claude for code review"
      }
    ],
    "prompt_templates": [
      {
        "title": "Analyze code for let chain opportunities",
        "prompt": "Review this Rust code and identify any nested if-let or match patterns that could be flattened using Rust 2024 let chains. Show the before and after versions with explanations.",
        "scenario": "When you have Rust code with nested conditional logic"
      },
      {
        "title": "Simplify async closure patterns",
        "prompt": "This Rust code uses manual async closures with cloning. Rewrite it using native Rust 2024 async closure syntax and explain the benefits.",
        "scenario": "When working with async code that clones for closure capture"
      },
      {
        "title": "Check async-trait necessity",
        "prompt": "This Rust trait uses the async-trait crate. Determine if native async fn in traits (Rust 1.75+) can be used instead, and provide the migrated code if possible.",
        "scenario": "When reviewing code that uses async-trait for trait methods"
      },
      {
        "title": "Convert iterator to gen block",
        "prompt": "This manual Iterator implementation could be replaced with a Rust 2024 gen block. Rewrite it using the gen syntax and show the simplified implementation.",
        "scenario": "When you encounter custom iterator structs in Rust code"
      }
    ],
    "output_examples": [
      {
        "input": "Three nested if-let statements checking user, profile, and email fields",
        "output": "A single if-let with && let chains that checks all conditions in one expression, making the logic easier to read and maintain"
      },
      {
        "input": "A vector of async closures that clone each item before the async move block",
        "output": "Native async closure syntax that captures items directly without manual cloning, reducing boilerplate"
      },
      {
        "input": "A trait method marked with #[async_trait] for database operations",
        "output": "The same trait method using native async fn syntax, removing the async-trait dependency for this use case"
      }
    ],
    "best_practices": [
      "Run `cargo fix --edition` to automatically handle simple migrations before manual review",
      "Test thoroughly after migration - some patterns may require adjustments for borrow checker compatibility",
      "Keep async-trait for dynamic dispatch (dyn Trait) but remove it for static dispatch scenarios"
    ],
    "anti_patterns": [
      "Manually cloning for async closure capture instead of using native async closures",
      "Using nested if-let chains when let chains would provide better readability",
      "Keeping async-trait on traits that could use native async fn in traits (Rust 1.75+)"
    ],
    "faq": [
      {
        "question": "What Rust version is required for Rust 2024 features?",
        "answer": "Rust 2024 features require Rust 1.85 or later. Set rust-version = \"1.85\" in Cargo.toml and edition = \"2024\"."
      },
      {
        "question": "Can I mix Rust 2021 and 2024 code in the same project?",
        "answer": "Yes, edition = \"2024\" allows using all 2024 features while remaining compatible with 2021 code. Rust maintains backward compatibility."
      },
      {
        "question": "When should I still use the async-trait crate?",
        "answer": "Use async-trait when you need dynamic dispatch with dyn Trait objects, since async fn in traits currently requires static dispatch."
      },
      {
        "question": "Do let chains work with match expressions?",
        "answer": "Yes, let chains work with let if and match. They allow && let patterns inside match arms for more flexible conditions."
      },
      {
        "question": "What is the performance impact of Rust 2024 features?",
        "answer": "Rust 2024 features are zero-cost abstractions. Let chains, async closures, and gen blocks compile down to equivalent efficient machine code."
      },
      {
        "question": "How do gen blocks differ from async blocks?",
        "answer": "Gen blocks yield values like iterators while async blocks await futures. Both use similar syntax but serve different asynchronous and generative purposes."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 224
    }
  ]
}
