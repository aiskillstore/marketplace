{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:01:34.459Z",
    "slug": "emillindfors-datafusion-query-advisor",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-data-engineering/skills/datafusion-query-advisor",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "752ee756cd090ae3b79240f5a74ad095fde3a692d20a9e5a5b0e1c94dec8843c",
    "tree_hash": "01cc1fa37b9ed1a34d6144b9be952102ec37fdce56de5bc227dd2abab7ceb3e1"
  },
  "skill": {
    "name": "datafusion-query-advisor",
    "description": "Reviews SQL queries and DataFrame operations for optimization opportunities including predicate pushdown, partition pruning, column projection, and join ordering. Activates when users write DataFusion queries or experience slow query performance.",
    "summary": "Optimize DataFusion SQL queries and DataFrame operations for better performance",
    "icon": "ðŸ“Š",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "category": "data",
    "tags": [
      "datafusion",
      "sql-optimization",
      "query-performance",
      "dataframe",
      "apache-arrow"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings are false positives. This is a documentation-only skill containing SQL and Rust code examples for educational purposes. The detected 'external_commands' patterns are markdown inline code formatting (backticks), not actual shell execution. No executable code exists that could pose security risks.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [
      {
        "title": "False Positive: Markdown Code Formatting Detected as External Commands",
        "description": "The static scanner detected 'Ruby/shell backtick execution' at 65 locations in SKILL.md. These are markdown inline code formatting delimiters (backticks) used to format SQL and Rust code examples, not actual shell commands or Ruby execution. No command injection risk exists in this documentation-only skill.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 15,
            "line_end": 15
          },
          {
            "file": "SKILL.md",
            "line_start": 30,
            "line_end": 33
          },
          {
            "file": "SKILL.md",
            "line_start": 33,
            "line_end": 36
          },
          {
            "file": "SKILL.md",
            "line_start": 36,
            "line_end": 41
          },
          {
            "file": "SKILL.md",
            "line_start": 41,
            "line_end": 44
          },
          {
            "file": "SKILL.md",
            "line_start": 44,
            "line_end": 54
          },
          {
            "file": "SKILL.md",
            "line_start": 54,
            "line_end": 63
          },
          {
            "file": "SKILL.md",
            "line_start": 63,
            "line_end": 67
          },
          {
            "file": "SKILL.md",
            "line_start": 67,
            "line_end": 70
          },
          {
            "file": "SKILL.md",
            "line_start": 70,
            "line_end": 74
          },
          {
            "file": "SKILL.md",
            "line_start": 74,
            "line_end": 77
          },
          {
            "file": "SKILL.md",
            "line_start": 77,
            "line_end": 86
          },
          {
            "file": "SKILL.md",
            "line_start": 86,
            "line_end": 91
          },
          {
            "file": "SKILL.md",
            "line_start": 91,
            "line_end": 95
          },
          {
            "file": "SKILL.md",
            "line_start": 95,
            "line_end": 98
          },
          {
            "file": "SKILL.md",
            "line_start": 98,
            "line_end": 101
          },
          {
            "file": "SKILL.md",
            "line_start": 101,
            "line_end": 104
          },
          {
            "file": "SKILL.md",
            "line_start": 104,
            "line_end": 107
          },
          {
            "file": "SKILL.md",
            "line_start": 107,
            "line_end": 114
          },
          {
            "file": "SKILL.md",
            "line_start": 114,
            "line_end": 124
          },
          {
            "file": "SKILL.md",
            "line_start": 124,
            "line_end": 129
          },
          {
            "file": "SKILL.md",
            "line_start": 129,
            "line_end": 137
          },
          {
            "file": "SKILL.md",
            "line_start": 137,
            "line_end": 147
          },
          {
            "file": "SKILL.md",
            "line_start": 147,
            "line_end": 157
          },
          {
            "file": "SKILL.md",
            "line_start": 157,
            "line_end": 163
          },
          {
            "file": "SKILL.md",
            "line_start": 163,
            "line_end": 166
          },
          {
            "file": "SKILL.md",
            "line_start": 166,
            "line_end": 173
          },
          {
            "file": "SKILL.md",
            "line_start": 173,
            "line_end": 182
          },
          {
            "file": "SKILL.md",
            "line_start": 182,
            "line_end": 194
          },
          {
            "file": "SKILL.md",
            "line_start": 194,
            "line_end": 197
          },
          {
            "file": "SKILL.md",
            "line_start": 197,
            "line_end": 204
          },
          {
            "file": "SKILL.md",
            "line_start": 204,
            "line_end": 212
          },
          {
            "file": "SKILL.md",
            "line_start": 212,
            "line_end": 215
          },
          {
            "file": "SKILL.md",
            "line_start": 215,
            "line_end": 225
          },
          {
            "file": "SKILL.md",
            "line_start": 225,
            "line_end": 231
          },
          {
            "file": "SKILL.md",
            "line_start": 231,
            "line_end": 235
          },
          {
            "file": "SKILL.md",
            "line_start": 235,
            "line_end": 248
          },
          {
            "file": "SKILL.md",
            "line_start": 248,
            "line_end": 257
          },
          {
            "file": "SKILL.md",
            "line_start": 257,
            "line_end": 266
          },
          {
            "file": "SKILL.md",
            "line_start": 266,
            "line_end": 273
          },
          {
            "file": "SKILL.md",
            "line_start": 273,
            "line_end": 276
          },
          {
            "file": "SKILL.md",
            "line_start": 276,
            "line_end": 279
          },
          {
            "file": "SKILL.md",
            "line_start": 279,
            "line_end": 285
          },
          {
            "file": "SKILL.md",
            "line_start": 285,
            "line_end": 290
          },
          {
            "file": "SKILL.md",
            "line_start": 290,
            "line_end": 292
          },
          {
            "file": "SKILL.md",
            "line_start": 292,
            "line_end": 295
          },
          {
            "file": "SKILL.md",
            "line_start": 295,
            "line_end": 298
          },
          {
            "file": "SKILL.md",
            "line_start": 298,
            "line_end": 303
          },
          {
            "file": "SKILL.md",
            "line_start": 303,
            "line_end": 308
          },
          {
            "file": "SKILL.md",
            "line_start": 308,
            "line_end": 311
          },
          {
            "file": "SKILL.md",
            "line_start": 311,
            "line_end": 315
          },
          {
            "file": "SKILL.md",
            "line_start": 315,
            "line_end": 320
          },
          {
            "file": "SKILL.md",
            "line_start": 320,
            "line_end": 324
          },
          {
            "file": "SKILL.md",
            "line_start": 324,
            "line_end": 327
          },
          {
            "file": "SKILL.md",
            "line_start": 327,
            "line_end": 332
          },
          {
            "file": "SKILL.md",
            "line_start": 332,
            "line_end": 337
          },
          {
            "file": "SKILL.md",
            "line_start": 337,
            "line_end": 348
          },
          {
            "file": "SKILL.md",
            "line_start": 348,
            "line_end": 362
          },
          {
            "file": "SKILL.md",
            "line_start": 362,
            "line_end": 375
          },
          {
            "file": "SKILL.md",
            "line_start": 375,
            "line_end": 379
          },
          {
            "file": "SKILL.md",
            "line_start": 379,
            "line_end": 386
          },
          {
            "file": "SKILL.md",
            "line_start": 386,
            "line_end": 390
          },
          {
            "file": "SKILL.md",
            "line_start": 390,
            "line_end": 401
          },
          {
            "file": "SKILL.md",
            "line_start": 401,
            "line_end": 405
          },
          {
            "file": "SKILL.md",
            "line_start": 405,
            "line_end": 418
          }
        ],
        "confidence": 0.98,
        "confidence_reasoning": "Backticks in markdown are standard code formatting, not shell execution. All 65 detections occur in SKILL.md which is a documentation file with SQL and Rust examples, not executable code."
      }
    ],
    "low_findings": [
      {
        "title": "False Positive: Documentation Keywords Misclassified as System Reconnaissance",
        "description": "The scanner flagged terms like 'scan', 'inspect', 'look for' as system reconnaissance at 6 locations. These are standard documentation language used in a query optimization guide to describe what patterns to identify in SQL queries.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 128,
            "line_end": 128
          },
          {
            "file": "SKILL.md",
            "line_start": 188,
            "line_end": 188
          },
          {
            "file": "SKILL.md",
            "line_start": 384,
            "line_end": 384
          },
          {
            "file": "SKILL.md",
            "line_start": 415,
            "line_end": 415
          }
        ],
        "confidence": 0.95,
        "confidence_reasoning": "Terms like 'What to Look For' are section headers in documentation explaining query patterns to identify. No actual system reconnaissance code or commands exist in the skill."
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 449,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:01:34.459Z",
    "risk_factors": [],
    "risk_factor_evidence": []
  },
  "content": {
    "user_title": "Optimize DataFusion SQL Queries",
    "value_statement": "Slow DataFusion queries waste resources and time. This skill analyzes SQL and DataFrame operations to identify performance issues and suggest concrete optimizations for predicate pushdown, partition pruning, column projection, and join ordering.",
    "seo_keywords": [
      "DataFusion query optimization",
      "SQL performance tuning",
      "predicate pushdown",
      "partition pruning",
      "column projection",
      "join optimization",
      "DataFrame operations",
      "Apache Arrow",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Analyzes SQL queries for predicate pushdown optimization opportunities",
      "Identifies missing partition pruning in Hive-style partitioned data",
      "Recommends column projection to avoid reading unnecessary columns",
      "Suggests join order improvements and broadcast join strategies",
      "Provides rewritten query examples with performance explanations",
      "Guides users through EXPLAIN plan analysis"
    ],
    "limitations": [
      "Cannot access actual query execution to measure real performance",
      "Does not have access to data schemas or statistics",
      "Cannot modify user code directly, only provides suggestions",
      "Limited to patterns described in the skill documentation"
    ],
    "use_cases": [
      {
        "title": "Improve Slow DataFusion Queries",
        "description": "When a user reports a slow DataFusion query, analyze the SQL or DataFrame code and suggest concrete optimizations like moving filters to the SQL layer for predicate pushdown, adding partition column filters, or selecting only required columns.",
        "target_user": "Data engineers and analysts using Apache DataFusion"
      },
      {
        "title": "Learn Query Optimization Patterns",
        "description": "A developer new to DataFusion wants to understand best practices for writing efficient queries. The skill provides educational examples showing good versus bad patterns with explanations of why certain approaches are faster.",
        "target_user": "Developers learning DataFusion optimization"
      },
      {
        "title": "Review Query Before Production",
        "description": "Before deploying a DataFusion query to production, have the skill review it for common anti-patterns like late filtering, missing statistics collection, or inefficient join strategies.",
        "target_user": "Data engineers preparing production workloads"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Query Review",
        "prompt": "Review this DataFusion query for optimization opportunities:\n\n```sql\n{query}\n```\n\nLook for issues with predicate pushdown, partition pruning, column projection, and join ordering. Provide specific suggestions with rewritten queries.",
        "scenario": "User shares a SQL query and wants optimization advice"
      },
      {
        "title": "DataFrame API Analysis",
        "prompt": "Analyze this DataFrame code for performance issues:\n\n```rust\n{code}\n```\n\nSuggest improvements for predicate pushdown, filtering placement, and memory-efficient operations like using execute_stream instead of collect.",
        "scenario": "User shares Rust DataFrame code using the DataFusion Rust API"
      },
      {
        "title": "EXPLAIN Plan Review",
        "prompt": "Review this EXPLAIN output and identify performance bottlenecks:\n\n{explain_output}\n\nPoint out any full table scans, missing predicate pushdown, or inefficient join strategies with specific recommendations.",
        "scenario": "User wants help interpreting an EXPLAIN plan"
      },
      {
        "title": "Pattern Comparison",
        "prompt": "Compare these two approaches for {use_case} and explain which is more efficient and why:\n\nApproach 1:\n{snippet1}\n\nApproach 2:\n{snippet2}",
        "scenario": "User wants to understand trade-offs between different query patterns"
      }
    ],
    "output_examples": [
      {
        "input": "Review this query:\n\nSELECT * FROM events WHERE date = '2024-01-01'",
        "output": "This query uses SELECT * which reads all columns even if you only need a few. For wide tables with many columns, this can cause significant I/O overhead.\n\n**Suggestion**: Select only the columns you need.\n\n```sql\nSELECT user_id, event_type, timestamp\nFROM events\nWHERE date = '2024-01-01'\n```\n\nThis can provide 10x+ speedup on tables with 50+ columns thanks to Parquet's columnar format."
      },
      {
        "input": "This query is slow:\n\nSELECT * FROM events WHERE timestamp >= '2024-01-15'",
        "output": "Your query scans all partitions because the filter is on a timestamp column, not partition columns.\n\n**Current behavior**: Reads all year/month/day partitions.\n\n**Optimization**: Add partition column filters for pruning:\n\n```sql\nSELECT * FROM events\nWHERE year = 2024 AND month = 1 AND day >= 15\n  AND timestamp >= '2024-01-15'\n```\n\nUse EXPLAIN to verify that partition pruning is working correctly."
      }
    ],
    "best_practices": [
      "Always use EXPLAIN to verify that filters are pushed down to the TableScan node and partitions are being pruned",
      "Filter early and often - apply WHERE clauses as early as possible in your query to reduce data volume",
      "Select only the columns you need using explicit column lists instead of SELECT * for better I/O performance"
    ],
    "anti_patterns": [
      "Using SELECT * on wide tables when you only need a few columns - this causes unnecessary I/O",
      "Filtering data in application code after calling collect() - move filters to SQL for predicate pushdown",
      "Joining large tables without considering broadcast joins for small dimension tables"
    ],
    "faq": [
      {
        "question": "What is predicate pushdown and why does it matter?",
        "answer": "Predicate pushdown moves filter operations from the query engine to the storage layer. This allows DataFusion to skip reading entire files or row groups that do not match the filter, significantly reducing I/O and improving query speed."
      },
      {
        "question": "How does partition pruning work in DataFusion?",
        "answer": "For Hive-style partitioned data, DataFusion can skip reading entire partitions when filters match partition column values. Include filters on partition columns (year, month, day) to enable this optimization."
      },
      {
        "question": "When should I use execute_stream instead of collect()?",
        "answer": "Use execute_stream when processing large result sets that may not fit in memory. Stream processing fetches batches incrementally while collect() loads all data into memory at once, which can cause OOM errors."
      },
      {
        "question": "What is column projection?",
        "answer": "Column projection is the optimization where DataFusion reads only the columns specified in SELECT rather than entire rows. With columnar formats like Parquet, this reduces I/O significantly for tables with many columns."
      },
      {
        "question": "How do I check if my query optimizations are working?",
        "answer": "Run EXPLAIN or EXPLAIN ANALYZE to see the query plan. Look for TableScan nodes with filters pushed down and verify that only necessary columns are being read. Partition pruning appears as skipped partitions in the plan."
      },
      {
        "question": "What is a broadcast join and when should I use it?",
        "answer": "A broadcast join loads a small table into memory and broadcasts it to all executor nodes, avoiding a shuffle operation. Use broadcast joins when joining a large table with a small dimension table (typically under 100MB) for better performance."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 449
    }
  ]
}
