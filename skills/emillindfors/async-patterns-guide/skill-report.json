{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T01:53:37.458Z",
    "slug": "emillindfors-async-patterns-guide",
    "source_url": "https://github.com/EmilLindfors/claude-marketplace/tree/main/plugins/rust-modern-patterns/skills/async-patterns-guide",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "26add4434a844a88fc4d05f43ef8de8d5abb4c428c6cfbc0f44bfb9d0403d619",
    "tree_hash": "747ee6698d158e84363d01b18afcd344928fbb7aa2ae77549aa4c183093645e3"
  },
  "skill": {
    "name": "async-patterns-guide",
    "description": "Guides users on modern async patterns including native async fn in traits, async closures, and avoiding async-trait when possible. Activates when users work with async code.",
    "summary": "Expert guidance on modern Rust async patterns including native async fn in traits and async closures.",
    "icon": "âš¡",
    "version": "1.0.0",
    "author": "EmilLindfors",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "rust",
      "async",
      "concurrency",
      "modern-rust",
      "patterns"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Static analysis detected 18 patterns but manual review confirms all are false positives. The skill contains only documentation with Rust code examples. The 'external_commands' findings are Markdown code fences misidentified as shell backticks. 'Sensitive' findings reference generic database variables, not SQLite. 'Weak cryptographic algorithm' and 'System reconnaissance' findings are unrelated pattern matches in the description text. No executable code exists in this skill.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [
      {
        "title": "Weak Cryptographic Algorithm - False Positive",
        "description": "Static analyzer flagged 'weak cryptographic algorithm' at SKILL.md:3. This is a false positive. Line 3 contains only the skill description text about async patterns. The analyzer likely triggered on the word 'async' which has no cryptographic meaning in this context.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 3,
            "line_end": 3
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "Line contains only descriptive text: 'description: Guides users on modern async patterns...' - no cryptographic algorithms present."
      },
      {
        "title": "Weak Cryptographic Algorithm - False Positive",
        "description": "Duplicate finding of 'weak cryptographic algorithm' at SKILL.md:3. Same false positive as above.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 3,
            "line_end": 3
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "Duplicate of previous finding - no cryptographic code exists in this documentation skill."
      }
    ],
    "medium_findings": [
      {
        "title": "External Commands (Ruby/Shell Backtick Execution) - False Positive",
        "description": "Static analyzer flagged 'Ruby/shell backtick execution' at 13 locations in SKILL.md. These are Markdown code fences and inline code formatting, not shell commands. The backticks (`) are used for code syntax in documentation, not command execution.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 31,
            "line_end": 31
          },
          {
            "file": "SKILL.md",
            "line_start": 52,
            "line_end": 52
          },
          {
            "file": "SKILL.md",
            "line_start": 63,
            "line_end": 63
          },
          {
            "file": "SKILL.md",
            "line_start": 80,
            "line_end": 80
          },
          {
            "file": "SKILL.md",
            "line_start": 87,
            "line_end": 87
          },
          {
            "file": "SKILL.md",
            "line_start": 101,
            "line_end": 101
          },
          {
            "file": "SKILL.md",
            "line_start": 104,
            "line_end": 104
          },
          {
            "file": "SKILL.md",
            "line_start": 115,
            "line_end": 115
          },
          {
            "file": "SKILL.md",
            "line_start": 121,
            "line_end": 121
          },
          {
            "file": "SKILL.md",
            "line_start": 137,
            "line_end": 137
          },
          {
            "file": "SKILL.md",
            "line_start": 144,
            "line_end": 144
          },
          {
            "file": "SKILL.md",
            "line_start": 150,
            "line_end": 150
          },
          {
            "file": "SKILL.md",
            "line_start": 153,
            "line_end": 153
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "All flagged locations contain Rust code examples within Markdown fences. No shell or Ruby execution code exists in this documentation file."
      },
      {
        "title": "Sensitive Data (SQLite Database File) - False Positive",
        "description": "Static analyzer flagged 'SQLite database file' at SKILL.md:40 and 44. These lines contain generic database variable references (db.query, db.insert) in example code, not SQLite file paths or sensitive data.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 40,
            "line_end": 40
          },
          {
            "file": "SKILL.md",
            "line_start": 44,
            "line_end": 44
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "Variables named 'db' are generic placeholders in example code. No file paths, credentials, or sensitive data present."
      }
    ],
    "low_findings": [
      {
        "title": "System Reconnaissance - False Positive",
        "description": "Static analyzer flagged 'system reconnaissance' at SKILL.md:10. This line contains a standard skill behavior description: 'You are an expert at modern Rust async patterns...' This is normal skill documentation, not reconnaissance activity.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 10,
            "line_end": 10
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "Standard skill description describing the AI's expertise area. No system scanning or reconnaissance code exists."
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 170,
    "audit_model": "claude",
    "audited_at": "2026-01-23T01:53:37.458Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Master Modern Rust Async Patterns",
    "value_statement": "Rust developers often use outdated async patterns that add unnecessary dependencies and performance overhead. This skill provides expert guidance on native async fn in traits, async closures, and helps migrate from async-trait to cleaner, faster code.",
    "seo_keywords": [
      "Rust async",
      "async-trait alternative",
      "Rust async patterns",
      "async fn in traits",
      "async closures Rust",
      "Rust concurrency",
      "modern Rust async",
      "Rust performance",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Identifies async-trait usage and evaluates if native async fn can replace it",
      "Explains when to use static vs dynamic dispatch for async traits",
      "Provides migration examples from async-trait to native patterns",
      "Demonstrates modern async closures (Rust 1.75+)",
      "Analyzes async code for performance bottlenecks and optimization opportunities"
    ],
    "limitations": [
      "Does not modify or write code files directly - only provides guidance and examples",
      "Does not run or test async code for correctness",
      "Does not handle platform-specific async runtimes (tokio, async-std)",
      "Cannot refactor entire codebases automatically"
    ],
    "use_cases": [
      {
        "title": "Migrate from async-trait to Native Async",
        "description": "A developer wants to simplify their codebase by removing the async-trait dependency. The skill evaluates their code and provides a migration path to native async fn in traits with zero runtime overhead.",
        "target_user": "Rust developers working on production async codebases"
      },
      {
        "title": "Learn Modern Async Patterns",
        "description": "A Rust developer learning async programming wants to understand best practices from the start. The skill explains when to use native async fn, async closures, and helps avoid common mistakes.",
        "target_user": "Rust developers new to async programming"
      },
      {
        "title": "Optimize Async Performance",
        "description": "A developer notices performance issues in async code and suspects dispatch overhead. The skill analyzes whether static or dynamic dispatch is appropriate and suggests architectural improvements.",
        "target_user": "Performance-focused Rust engineers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Pattern Check",
        "prompt": "I'm using async-trait in my Rust project. Can you review my code and suggest if I can switch to native async fn in traits?",
        "scenario": "User wants to evaluate migration from async-trait"
      },
      {
        "title": "Migration Guidance",
        "prompt": "I have this async-trait implementation: ```rust\nuse async_trait::async_trait;\n\n#[async_trait]\ntrait MyService {\n    async fn do_work(&self) -> Result<(), Error>;\n}\n```\n\nHow do I migrate this to native async fn with static dispatch?",
        "scenario": "User needs specific migration help"
      },
      {
        "title": "Async Closure Usage",
        "prompt": "How do I use async closures to process a list of items concurrently in Rust 1.85+? Show me a pattern with proper error handling.",
        "scenario": "User wants to learn async closure patterns"
      },
      {
        "title": "Performance Analysis",
        "prompt": "I have an async function that takes Box<dyn MyTrait>. The performance seems slow. Can you explain the overhead and suggest alternatives for better performance?",
        "scenario": "User wants to optimize async dispatch"
      }
    ],
    "output_examples": [
      {
        "input": "I want to understand when to use async-trait vs native async fn",
        "output": "Great question! Here's how to decide:\n\n**Use Native Async Fn (Rust 1.75+) when:**\n- You need static dispatch (generics)\n- No dyn Trait required\n- Performance is critical\n- MSRV >= 1.75\n\n**Use async-trait when:**\n- Dynamic dispatch required (dyn Trait)\n- Object safety needed\n- MSRV < 1.75\n\nThe native approach avoids boxing overhead and provides better optimization opportunities."
      },
      {
        "input": "Help me migrate this code from async-trait",
        "input_context": "```rust\n#[async_trait]\ntrait UserRepository {\n    async fn find_user(&self, id: &str) -> Result<User, Error>;\n}\n\n#[async_trait]\nimpl UserRepository for PostgresRepo {\n    async fn find_user(&self, id: &str) -> Result<User, Error> {\n        // implementation\n    }\n}\n```",
        "output": "Here's your migrated code using native async fn:\n\n```rust\ntrait UserRepository {\n    async fn find_user(&self, id: &str) -> Result<User, Error>;\n}\n\nimpl UserRepository for PostgresRepo {\n    async fn find_user(&self, id: &str) -> Result<User, Error> {\n        // implementation - no changes needed!\n    }\n}\n\n// Use with generics for static dispatch\nasync fn process_users<R: UserRepository>(repo: R) {\n    let user = repo.find_user(\"123\").await.unwrap();\n}\n```\n\nKey changes:\n1. Removed async_trait::async_trait attribute\n2. Removed async-trait from impl block\n3. Use generics for static dispatch instead of Box<dyn Trait>"
      }
    ],
    "best_practices": [
      "Prefer native async fn in traits over async-trait when using Rust 1.75+ and static dispatch is acceptable",
      "Use generics with trait bounds instead of Box<dyn Trait> to eliminate boxing overhead",
      "Reserve async-trait for cases requiring true dynamic dispatch or object safety",
      "Consider MSRV requirements before migrating from async-trait to native patterns"
    ],
    "anti_patterns": [
      "Using Box<dyn Trait> with async-trait when static dispatch would suffice",
      "Mixing async-trait patterns with generic code that forces monomorphization",
      "Ignoring the performance impact of vtable lookups in hot async paths",
      "Using async-trait without evaluating whether native async fn meets requirements"
    ],
    "faq": [
      {
        "question": "What is async-trait and why would I want to avoid it?",
        "answer": "async-trait is a crate that enables async fn in traits for Rust versions before 1.75. It uses macros and boxing under the hood, adding runtime overhead. Modern Rust (1.75+) supports native async fn in traits without these drawbacks."
      },
      {
        "question": "Does async-trait work with Rust 1.75+?",
        "answer": "Yes, async-trait still works in Rust 1.75+, but native async fn is now preferred. You can use async-trait for dynamic dispatch or when MSRV requires older Rust versions."
      },
      {
        "question": "What is the performance difference between async-trait and native async fn?",
        "answer": "async-trait uses Box<dyn Trait> for dynamic dispatch, adding vtable lookups and heap allocation. Native async fn with static dispatch eliminates these, providing zero-cost abstractions and better optimization."
      },
      {
        "question": "Can I mix async-trait and native async fn in the same project?",
        "answer": "Yes, traits using async-trait and native async fn can coexist. However, using Box<dyn Trait> for async-trait traits and generics for native async traits creates different dispatch mechanisms."
      },
      {
        "question": "What are async closures and when should I use them?",
        "answer": "Async closures (Rust 1.85+) are closures that return futures. They enable passing async logic as arguments without manually constructing future types. Useful for callbacks and higher-order async operations."
      },
      {
        "question": "How do I decide between static and dynamic dispatch for async traits?",
        "answer": "Choose static dispatch (generics) when you know all trait implementations at compile time and want best performance. Choose dynamic dispatch (dyn Trait) when implementing plugins, storing heterogenous trait objects, or when compile-time type knowledge is impossible."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 170
    }
  ]
}
