{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T13:33:29.665Z",
    "slug": "dnyoussef-cicd-intelligent-recovery",
    "source_url": "https://github.com/DNYoussef/ai-chrome-extension/tree/main/.claude/skills/cicd-intelligent-recovery",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "5dc0723f458295e17a03fb30c3004d61e034f326407da2a8d7c472e5ab2e21d7",
    "tree_hash": "f32eeee0073ae47451d7aea1f0f9a42bf2f7f828f0baacf17a1b73fa76bc3833"
  },
  "skill": {
    "name": "cicd-intelligent-recovery",
    "description": "Loop 3 of the Three-Loop Integrated Development System. CI/CD automation with intelligent failure recovery, root cause analysis, and comprehensive quality validation. Receives implementation from Loop 2, feeds failure patterns back to Loop 1. Achieves 100% test success through automated repair and theater validation. v2.0.0 with explicit agent SOPs.",
    "summary": "Loop 3 of the Three-Loop Integrated Development System. CI/CD automation with intelligent failure re...",
    "icon": "ðŸ”„",
    "version": "1.0.0",
    "author": "DNYoussef",
    "license": "MIT",
    "category": "devops",
    "tags": [
      "cicd",
      "testing",
      "automation",
      "ai-analysis",
      "quality-assurance"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "medium",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "The skill requires network access for GitHub API integration, filesystem access for code manipulation and test execution, and external command execution for various development tools. These capabilities are appropriate for a CI/CD automation tool but require user awareness of the broad access permissions.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 149,
            "line_end": 155
          },
          {
            "file": "SKILL.md",
            "line_start": 162,
            "line_end": 170
          },
          {
            "file": "SKILL.md",
            "line_start": 1334,
            "line_end": 1340
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 176,
            "line_end": 209
          },
          {
            "file": "SKILL.md",
            "line_start": 1349,
            "line_end": 1355
          },
          {
            "file": "SKILL.md",
            "line_start": 1385,
            "line_end": 1395
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 142,
            "line_end": 147
          },
          {
            "file": "SKILL.md",
            "line_start": 1647,
            "line_end": 1652
          },
          {
            "file": "SKILL.md",
            "line_start": 1950,
            "line_end": 1956
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [
      {
        "title": "GitHub API Access with Write Permissions",
        "description": "The skill requires GitHub CLI authentication and creates webhooks, pull requests, and pushes code changes. While legitimate for CI/CD automation, this grants significant repository modification capabilities.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 145,
            "line_end": 147
          },
          {
            "file": "SKILL.md",
            "line_start": 1589,
            "line_end": 1590
          },
          {
            "file": "SKILL.md",
            "line_start": 1647,
            "line_end": 1652
          }
        ]
      },
      {
        "title": "Sandbox Execution with Production-like Environment",
        "description": "The skill creates production-like sandboxes with database and Redis connections, which could potentially access sensitive data if misconfigured.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 1334,
            "line_end": 1340
          },
          {
            "file": "SKILL.md",
            "line_start": 1364,
            "line_end": 1376
          }
        ]
      }
    ],
    "low_findings": [
      {
        "title": "Extensive File System Operations",
        "description": "The skill reads, writes, and modifies numerous files including test artifacts, patches, and configuration files. This is expected behavior for a development tool but represents broad filesystem access.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 181,
            "line_end": 209
          },
          {
            "file": "SKILL.md",
            "line_start": 1085,
            "line_end": 1103
          }
        ]
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 2030,
    "audit_model": "claude",
    "audited_at": "2026-01-10T13:33:29.665Z"
  },
  "content": {
    "user_title": "Automate CI/CD Recovery with AI-Powered Fixes",
    "value_statement": "Stop debugging failed CI/CD pipelines manually. This skill automatically analyzes test failures, identifies root causes, and generates fixes with 100% success rate.",
    "seo_keywords": [
      "CI/CD automation",
      "test failure recovery",
      "GitHub Actions",
      "Claude Code",
      "AI debugging",
      "automated fixes",
      "root cause analysis",
      "quality validation",
      "Codex",
      "DevOps automation"
    ],
    "actual_capabilities": [
      "Automatically detects and downloads CI/CD failure reports from GitHub Actions",
      "Uses Gemini 2M token window for full codebase analysis with AI agents",
      "Achieves 100% test success rate through automated repair and validation",
      "Implements Byzantine consensus with 7-agent analysis for fault-tolerant decisions",
      "Provides connascence-aware fixes that handle code coupling properly"
    ],
    "limitations": [
      "Requires GitHub CLI authentication and repository write access",
      "Needs production-like sandbox environment for validation",
      "Works best with JavaScript/Node.js projects (example configurations provided)",
      "Requires existing test suite to validate fixes against"
    ],
    "use_cases": [
      {
        "target_user": "DevOps Engineers",
        "title": "Automated Pipeline Recovery",
        "description": "Automatically fix failing CI/CD pipelines without manual intervention, reducing debugging time from hours to minutes."
      },
      {
        "target_user": "Development Teams",
        "title": "Quality Gate Enforcement",
        "description": "Ensure 100% test success before deployment with intelligent failure analysis and automated repair."
      },
      {
        "target_user": "QA Teams",
        "title": "Root Cause Analysis",
        "description": "Deep dive into test failures with AI-powered analysis to identify true root causes, not just symptoms."
      }
    ],
    "prompt_templates": [
      {
        "title": "Quick Pipeline Fix",
        "scenario": "GitHub Actions workflow is failing",
        "prompt": "Run cicd-intelligent-recovery to analyze and fix the failing tests in my repository. The failures are in the latest workflow run."
      },
      {
        "title": "Deep Analysis Mode",
        "scenario": "Complex test failures need investigation",
        "prompt": "Use cicd-intelligent-recovery with Gemini large-context analysis to understand why tests are failing across multiple files and dependencies."
      },
      {
        "title": "Validation Only",
        "scenario": "Verify fixes work before deployment",
        "prompt": "Run sandbox validation for the current fixes to ensure they pass all tests in a production-like environment."
      },
      {
        "title": "Pattern Analysis",
        "scenario": "Learn from failures for future prevention",
        "prompt": "Extract failure patterns from this CI/CD run and store them for Loop 1 planning in the next iteration."
      }
    ],
    "output_examples": [
      {
        "input": "Fix the failing tests in my CI/CD pipeline",
        "output": [
          "âœ… Downloaded 15 failure reports from GitHub Actions",
          "âœ… Gemini analysis complete: identified 3 root causes",
          "âœ… Byzantine consensus achieved on failure cascade",
          "âœ… Applied 5 connascence-aware fixes",
          "âœ… Theater audit passed: no false improvements",
          "âœ… Sandbox validation: 100% test success (15/15 tests)",
          "âœ… Created PR with automated fixes",
          "ðŸ“Š Metrics: 0% â†’ 100% pass rate, 5 root causes resolved"
        ]
      }
    ],
    "best_practices": [
      "Always run theater detection audit to ensure fixes are genuine improvements, not symptom masking",
      "Use connascence-aware bundling when fixes span multiple files to maintain code consistency",
      "Store failure patterns in cross-loop memory for continuous improvement across iterations"
    ],
    "anti_patterns": [
      "Don't use this skill without first completing Loop 2 implementation phase",
      "Avoid manual code changes during automated recovery to prevent conflicts",
      "Never skip sandbox validation - production-like testing is critical for reliability"
    ],
    "faq": [
      {
        "question": "Is this compatible with my CI/CD platform?",
        "answer": "Currently optimized for GitHub Actions with GitHub CLI. Other platforms require custom webhook configuration."
      },
      {
        "question": "What if the automated fixes don't work?",
        "answer": "The skill includes self-consistency validation with dual sandbox and theater checks. Failed fixes are rejected automatically."
      },
      {
        "question": "How does this integrate with my existing workflow?",
        "answer": "It's Loop 3 of a 3-loop system. It receives from Loop 2 implementation and feeds failure patterns back to Loop 1 planning."
      },
      {
        "question": "Is my code safe during automated fixes?",
        "answer": "All changes are made in isolated branches with full rollback capability. Sandbox validation ensures fixes work before applying."
      },
      {
        "question": "What programming languages are supported?",
        "answer": "Examples show JavaScript/Node.js, but the approach works with any language that has test suites and GitHub Actions."
      },
      {
        "question": "How long does the automated recovery take?",
        "answer": "Typically 1.5-2 hours compared to 8-12 hours of manual debugging, achieving 5-7x speed improvement."
      }
    ]
  },
  "file_structure": [
    {
      "name": "cicd-intelligent-recovery-process.dot",
      "type": "file",
      "path": "cicd-intelligent-recovery-process.dot"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
