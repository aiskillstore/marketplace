{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-15T11:55:57.554Z",
    "slug": "alirezarezvani-tdd-guide",
    "source_url": "https://github.com/alirezarezvani/claude-skills/tree/main/engineering-team/tdd-guide",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "2323d2de41146cbe3be65d7d2d6f1a80a046291fcb4d49c91c95f3b9b81ef44d",
    "tree_hash": "0b07e151f11a65f862297dddb2a4d55d4d677cb9a42121a0a9b4d679acaa0a53"
  },
  "skill": {
    "name": "tdd-guide",
    "description": "Comprehensive Test Driven Development guide for engineering subagents with multi-framework support, coverage analysis, and intelligent test generation",
    "summary": "Comprehensive Test Driven Development guide for engineering subagents with multi-framework support, ...",
    "icon": "ðŸ§ª",
    "version": "1.0.0",
    "author": "alirezarezvani",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "testing",
      "tdd",
      "coverage",
      "test-generation"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "network",
      "filesystem",
      "env_access",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a legitimate TDD (Test Driven Development) guidance skill. The static analyzer produced 288 false positive findings triggered by testing-related terminology and standard code patterns. All findings were evaluated and dismissed as non-threatening: cryptographic module imports are standard Python security libraries, URL strings in documentation are test fixture examples, shell command examples are documentation formatting, and path handling is for coverage report parsing. No malicious intent or security risks were identified.",
    "risk_factor_evidence": [
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "framework_adapter.py",
            "line_start": 1,
            "line_end": 10
          },
          {
            "file": "coverage_analyzer.py",
            "line_start": 1,
            "line_end": 15
          }
        ]
      },
      {
        "factor": "network",
        "evidence": []
      },
      {
        "factor": "filesystem",
        "evidence": []
      },
      {
        "factor": "env_access",
        "evidence": []
      },
      {
        "factor": "external_commands",
        "evidence": []
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 15,
    "total_lines": 4911,
    "audit_model": "claude",
    "audited_at": "2026-01-15T11:55:57.554Z"
  },
  "content": {
    "user_title": "Generate tests with TDD guidance",
    "value_statement": "Engineering teams often struggle to write comprehensive tests consistently. This skill provides intelligent test generation, coverage analysis, and step-by-step TDD workflow guidance across multiple languages and frameworks.",
    "seo_keywords": [
      "tdd guide",
      "test driven development",
      "claude code",
      "test generation",
      "coverage analysis",
      "jest",
      "pytest",
      "junit",
      "claude",
      "vitest"
    ],
    "actual_capabilities": [
      "Generate test cases from user stories, API specs, and business requirements",
      "Parse LCOV, JSON, and XML coverage reports to identify untested code paths",
      "Guide red-green-refactor cycles with phase-by-phase validation",
      "Support Jest, Pytest, JUnit, Vitest, Mocha, and RSpec frameworks",
      "Calculate test quality metrics including isolation, assertions, and naming quality",
      "Generate test fixtures with boundary values and edge case scenarios"
    ],
    "limitations": [
      "Focuses on unit tests; integration and E2E tests require different patterns",
      "Cannot execute tests or measure actual runtime behavior",
      "Generated tests provide scaffolding that requires human review and refinement"
    ],
    "use_cases": [
      {
        "target_user": "Software developers",
        "title": "Generate unit tests",
        "description": "Create comprehensive test suites from requirements for new features"
      },
      {
        "target_user": "QA engineers",
        "title": "Analyze coverage gaps",
        "description": "Identify untested code paths and receive prioritized recommendations"
      },
      {
        "target_user": "Engineering teams",
        "title": "Adopt TDD practices",
        "description": "Follow structured red-green-refactor workflows with step-by-step guidance"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic test generation",
        "scenario": "Generate tests for existing code",
        "prompt": "Generate Jest tests for my authentication module covering happy path, error cases, and edge cases"
      },
      {
        "title": "Coverage analysis",
        "scenario": "Analyze test coverage",
        "prompt": "Analyze coverage from coverage/lcov.info and identify gaps with prioritized recommendations"
      },
      {
        "title": "TDD workflow",
        "scenario": "Practice TDD for new feature",
        "prompt": "Guide me through TDD for implementing a password validation function with requirements: min 8 chars, uppercase, lowercase, number, special char"
      },
      {
        "title": "Framework migration",
        "scenario": "Convert tests between frameworks",
        "prompt": "Convert these Jest tests to Pytest format and explain the key syntax differences"
      }
    ],
    "output_examples": [
      {
        "input": "Generate Pytest tests for a user registration function that validates email format, password strength, and duplicate accounts",
        "output": [
          "Generated 6 test cases organized by feature (email validation, password strength, duplicate prevention)",
          "Test file: test_user_registration.py created with imports, fixtures, and assertions",
          "Coverage: 100% line coverage on validation logic",
          "Each test includes descriptive docstrings explaining the scenario being tested"
        ]
      },
      {
        "input": "Analyze coverage report at coverage/coverage-final.json and suggest improvements",
        "output": [
          "Line coverage: 72% (below 80% threshold)",
          "Branch coverage: 65% - conditional logic gaps in error handling",
          "P0 priority: Add tests for null input scenarios in user_service.ts lines 45-52",
          "P1 priority: Test edge cases for timeout configuration in network_utils.ts"
        ]
      }
    ],
    "best_practices": [
      "Start with requirements: write tests from user stories before seeing implementation code",
      "Test behavior not implementation: focus on what code does, not how it does it",
      "Keep tests isolated: each test should run independently without shared state"
    ],
    "anti_patterns": [
      "Multiple assertions per test (assertion roulette makes debugging harder)",
      "Testing implementation details instead of public interfaces",
      "Skipping error handling and edge case tests to meet coverage targets"
    ],
    "faq": [
      {
        "question": "Which frameworks are supported?",
        "answer": "Jest, Vitest, Mocha for JavaScript/TypeScript. Pytest, unittest, nose2 for Python. JUnit 5, TestNG for Java."
      },
      {
        "question": "Can this skill run my tests?",
        "answer": "No. This skill generates tests and analyzes coverage reports but cannot execute code or run test suites."
      },
      {
        "question": "How does coverage analysis work?",
        "answer": "Provide a coverage report file (LCOV, JSON, or XML) and the skill parses it to identify untested lines and branches."
      },
      {
        "question": "What languages work best?",
        "answer": "TypeScript, JavaScript, Python, and Java have full support. Other languages have limited adapter support."
      },
      {
        "question": "Can I migrate tests between frameworks?",
        "answer": "Yes. Provide existing tests and specify the target framework for automated translation with pattern mapping."
      },
      {
        "question": "Does this modify my codebase?",
        "answer": "No. The skill generates test code suggestions but does not write files or modify existing code without explicit instruction."
      }
    ]
  },
  "file_structure": [
    {
      "name": "coverage_analyzer.py",
      "type": "file",
      "path": "coverage_analyzer.py",
      "lines": 435
    },
    {
      "name": "expected_output.json",
      "type": "file",
      "path": "expected_output.json",
      "lines": 78
    },
    {
      "name": "fixture_generator.py",
      "type": "file",
      "path": "fixture_generator.py",
      "lines": 441
    },
    {
      "name": "format_detector.py",
      "type": "file",
      "path": "format_detector.py",
      "lines": 385
    },
    {
      "name": "framework_adapter.py",
      "type": "file",
      "path": "framework_adapter.py",
      "lines": 429
    },
    {
      "name": "HOW_TO_USE.md",
      "type": "file",
      "path": "HOW_TO_USE.md",
      "lines": 314
    },
    {
      "name": "metrics_calculator.py",
      "type": "file",
      "path": "metrics_calculator.py",
      "lines": 457
    },
    {
      "name": "output_formatter.py",
      "type": "file",
      "path": "output_formatter.py",
      "lines": 355
    },
    {
      "name": "README.md",
      "type": "file",
      "path": "README.md",
      "lines": 681
    },
    {
      "name": "sample_coverage_report.lcov",
      "type": "file",
      "path": "sample_coverage_report.lcov",
      "lines": 57
    },
    {
      "name": "sample_input_python.json",
      "type": "file",
      "path": "sample_input_python.json",
      "lines": 40
    },
    {
      "name": "sample_input_typescript.json",
      "type": "file",
      "path": "sample_input_typescript.json",
      "lines": 37
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 288
    },
    {
      "name": "tdd_workflow.py",
      "type": "file",
      "path": "tdd_workflow.py",
      "lines": 475
    },
    {
      "name": "test_generator.py",
      "type": "file",
      "path": "test_generator.py",
      "lines": 439
    }
  ]
}
