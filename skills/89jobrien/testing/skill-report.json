{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T09:37:44.060Z",
    "slug": "89jobrien-testing",
    "source_url": "https://github.com/89jobrien/steve/tree/main/steve/skills/testing",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "1b8fe1d35f2a44322c36403cc2b2d3aa344f6b13a6085f7db3c9fa7c7b87425e",
    "tree_hash": "675207beb6ee9be913eed14175d8cad24c76d08577b299d311f48f7651894b90"
  },
  "skill": {
    "name": "testing",
    "description": "Comprehensive testing specialization covering test strategy, automation, TDD methodology, test writing, and web app testing. Use when setting up test infrastructure, writing tests, implementing TDD workflows, analyzing coverage, integrating tests into CI/CD, or testing web applications with Playwright. Framework-agnostic approach with framework-specific guidance via reference files.",
    "summary": "Comprehensive testing specialization covering test strategy, automation, TDD methodology, test writi...",
    "icon": "ðŸ§ª",
    "version": "1.0.1",
    "author": "Joseph OBrien",
    "license": "UNLICENSED",
    "category": "coding",
    "tags": [
      "tdd",
      "test-automation",
      "playwright",
      "testing",
      "coverage"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "external_commands",
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill with minimal code execution. The only executable script (with_server.py) manages local dev servers for testing. Commands are user-provided via CLI arguments, not loaded from external sources. File writes are limited to /mnt/user-data/outputs/ directory. No network exfiltration or credential access detected.",
    "risk_factor_evidence": [
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "scripts/with_server.py",
            "line_start": 1,
            "line_end": 130
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "scripts/with_server.py",
            "line_start": 90,
            "line_end": 96
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "examples/static-html-automation.py",
            "line_start": 19,
            "line_end": 31
          },
          {
            "file": "examples/console-logging.py",
            "line_start": 32,
            "line_end": 33
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [
      {
        "title": "Shell execution in with_server.py",
        "description": "The with_server.py script uses subprocess.Popen with shell=True (line 92) to execute user-provided server commands. While this is intentional for supporting shell syntax, shell=True can be risky if commands come from untrusted sources. However, commands are passed via CLI arguments by the user, not loaded from files or network. The code includes # nosec B602 comment indicating intentional use. An attacker controlling command arguments could execute arbitrary commands, but this requires the user to explicitly pass malicious commands.",
        "locations": [
          {
            "file": "scripts/with_server.py",
            "line_start": 90,
            "line_end": 96
          }
        ]
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 9,
    "total_lines": 2231,
    "audit_model": "claude",
    "audited_at": "2026-01-10T09:37:44.059Z"
  },
  "content": {
    "user_title": "Write tests with TDD methodology",
    "value_statement": "Writing tests after code leads to fragile codebases and missed bugs. This skill provides structured TDD workflows, test patterns, and Playwright automation to help you write maintainable tests before code, catch bugs early, and build confidence in your software.",
    "seo_keywords": [
      "test-driven development",
      "TDD workflow",
      "unit testing",
      "Playwright testing",
      "pytest",
      "Jest testing",
      "test automation",
      "CI/CD testing",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Design test strategies using the test pyramid (70% unit, 20% integration, 10% E2E)",
      "Follow Red-Green-Refactor TDD cycles with framework-specific workflows",
      "Write maintainable tests using AAA pattern and descriptive naming conventions",
      "Automate web application testing with Playwright scripts and element discovery",
      "Integrate tests into CI/CD pipelines with quality gates and coverage thresholds",
      "Analyze test coverage and identify gaps in critical business logic paths"
    ],
    "limitations": [
      "This skill provides guidance and patterns only. It does not execute tests directly.",
      "Framework setup requires manual installation of dependencies (pytest, Jest, etc.).",
      "Playwright browser automation requires local server or static HTML files.",
      "Coverage analysis is conceptual; actual coverage tools must be run separately."
    ],
    "use_cases": [
      {
        "target_user": "Developers new to TDD",
        "title": "Learn TDD fundamentals",
        "description": "Start writing failing tests before code. Follow Red-Green-Refactor cycle for every new feature."
      },
      {
        "target_user": "QA engineers",
        "title": "Automate web testing",
        "description": "Use Playwright to discover elements, fill forms, capture console logs, and verify page states."
      },
      {
        "target_user": "DevOps engineers",
        "title": "Set up CI/CD testing",
        "description": "Configure test stages, quality gates, and coverage thresholds for automated pipelines."
      }
    ],
    "prompt_templates": [
      {
        "title": "Set up test infrastructure",
        "scenario": "New project needs tests",
        "prompt": "Help me set up test infrastructure for my [language] project using [framework]. Show me the TDD workflow with a simple example."
      },
      {
        "title": "Write first test",
        "scenario": "Starting new feature",
        "prompt": "We are doing TDD. Write a failing test first for a [feature description] function that [expected behavior]."
      },
      {
        "title": "Debug failing test",
        "scenario": "Test is not passing",
        "prompt": "My test is failing with [error message]. Analyze whether the test or implementation needs fixing, and show the corrected code."
      },
      {
        "title": "Create E2E test",
        "scenario": "Web app needs automation",
        "prompt": "Write a Playwright script to test my web app at localhost:[port]. Discover buttons, links, and input fields. Fill a form and verify submission."
      }
    ],
    "output_examples": [
      {
        "input": "Write a failing test first for a calculator add function that returns the sum of two numbers",
        "output": [
          "RED PHASE - Write failing test first:",
          "â€¢ Create test_calculator.py with test_add_two_numbers",
          "â€¢ Test calls add(2, 3) expecting result == 5",
          "â€¢ Run test - it fails with NameError (add not defined)",
          "GREEN PHASE - Minimal implementation:",
          "â€¢ Create calculator.py with def add(a, b): return 5",
          "â€¢ Test passes immediately",
          "REFACTOR PHASE:",
          "â€¢ Change to def add(a, b): return a + b",
          "â€¢ All tests still pass"
        ]
      }
    ],
    "best_practices": [
      "Write one failing test at a time. Resist the urge to write multiple tests or implementation code.",
      "Keep tests independent. Each test should set up its own data and not depend on other tests.",
      "Test behavior, not implementation. Verify public API outcomes rather than internal state."
    ],
    "anti_patterns": [
      "Writing tests after implementation (this defeats the purpose of TDD design discipline)",
      "Testing implementation details like private attributes or internal counters",
      "Mocking everything including the code under test (over-mocking removes meaning from tests)"
    ],
    "faq": [
      {
        "question": "Which testing frameworks does this skill support?",
        "answer": "Python (pytest, unittest), JavaScript/TypeScript (Jest, Vitest), Java (JUnit), Go (testing package), Rust (built-in), and Playwright for E2E."
      },
      {
        "question": "What coverage thresholds should I aim for?",
        "answer": "Recommended: 80% lines, functions, branches, and statements. Critical business logic (auth, payments) should aim for 100%."
      },
      {
        "question": "How do I integrate tests into CI/CD?",
        "answer": "Run unit tests on every commit, integration tests on pull requests, and E2E tests before merging to main. Use coverage thresholds as quality gates."
      },
      {
        "question": "Is my test data safe?",
        "answer": "Yes. This skill only provides guidance and example patterns. No test data is collected, transmitted, or stored externally."
      },
      {
        "question": "Why is my Playwright script not finding elements?",
        "answer": "Wait for networkidle before inspecting dynamic apps. Use page.wait_for_load_state('networkidle') after page.goto(). Prefer text= and role= selectors over fragile CSS selectors."
      },
      {
        "question": "How is this different from Codex or Claude Code default testing?",
        "answer": "This skill provides structured TDD methodology, framework-specific workflows, and detailed Playwright automation patterns beyond basic testing capabilities."
      }
    ]
  },
  "file_structure": [
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "console-logging.py",
          "type": "file",
          "path": "examples/console-logging.py"
        },
        {
          "name": "element-discovery.py",
          "type": "file",
          "path": "examples/element-discovery.py"
        },
        {
          "name": "static-html-automation.py",
          "type": "file",
          "path": "examples/static-html-automation.py"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "framework-workflows.md",
          "type": "file",
          "path": "references/framework-workflows.md"
        },
        {
          "name": "test-patterns.md",
          "type": "file",
          "path": "references/test-patterns.md"
        },
        {
          "name": "testing-report.template.md",
          "type": "file",
          "path": "references/testing-report.template.md"
        },
        {
          "name": "webapp-testing.md",
          "type": "file",
          "path": "references/webapp-testing.md"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "with-server.py",
          "type": "file",
          "path": "scripts/with-server.py"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
