{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-02-03T08:04:27.411Z",
    "slug": "gavin-ali-java-unit-test",
    "source_url": "https://github.com/gavin-ali/java-unit-test-skills/tree/main/.trae/skills/java-unit-test",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "77524e757938c1177d67f6e65924d39f04661f566df27bcabd2698fa311e12d6",
    "tree_hash": "e1507583e77316278d606f538ff59f60a4ed786b88caff32bc2a0899fd1becf3"
  },
  "skill": {
    "name": "java-unit-test",
    "description": "ä¸º Java é¡¹ç›®ç”Ÿæˆè‡ªåŠ¨åŒ–å•å…ƒæµ‹è¯•ï¼ˆJUnit 5 + Mockitoï¼‰ã€‚å½“ç”¨æˆ·è¦æ±‚ç¼–å†™å•å…ƒæµ‹è¯•ã€ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹æˆ–æå‡æµ‹è¯•è¦†ç›–çŽ‡æ—¶ä½¿ç”¨ã€‚",
    "summary": "ä½¿ç”¨ JUnit 5 å’Œ Mockito ä¸º Java é¡¹ç›®ç”Ÿæˆè‡ªåŠ¨åŒ–å•å…ƒæµ‹è¯•ï¼Œè¦†ç›–å…³é”®ä¸šåŠ¡é€»è¾‘å’Œè¾¹ç•Œæ¡ä»¶",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "gavin-ali",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "java",
      "testing",
      "junit",
      "mockito",
      "code-quality"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static analysis findings are false positives. The detected patterns are documentation text and comments, not actual code. This is a legitimate Java unit testing skill with no security concerns.",
    "risk_factor_evidence": [
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 57,
            "line_end": 57
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 177,
    "audit_model": "claude",
    "audited_at": "2026-02-03T08:04:27.411Z"
  },
  "content": {
    "user_title": "Generate Java Unit Tests with JUnit 5 and Mockito",
    "value_statement": "Automatically generate comprehensive unit tests for Java projects using JUnit 5 and Mockito. This skill helps you write test cases that cover happy paths, edge cases, and error scenarios while maintaining best practices.",
    "seo_keywords": [
      "java testing",
      "junit 5",
      "mockito",
      "unit testing",
      "test coverage",
      "code quality",
      "Claude Code",
      "Claude Codex",
      "automated testing",
      "integration testing"
    ],
    "actual_capabilities": [
      "Generate JUnit 5 test classes with proper structure and naming conventions",
      "Configure Mockito mocks and spies according to dependency injection patterns",
      "Create test cases covering happy paths, edge cases, and exception scenarios",
      "Apply AAA pattern (Arrange-Act-Assert) for clear test organization",
      "Implement parameterized tests for multiple input combinations",
      "Add assertions that verify both return values and side effects"
    ],
    "limitations": [
      "Cannot execute tests or verify test coverage in CI/CD pipelines",
      "Requires user to manually run tests and adjust coverage thresholds",
      "Cannot handle complex integration testing scenarios without project context",
      "Relies on user-provided code structure - may not adapt to unfamiliar patterns",
      "Cannot generate tests for code with complex external dependencies without mocking setup",
      "Does not refactor existing test suites or fix broken tests"
    ],
    "use_cases": [
      {
        "title": "New Java Developer",
        "description": "Generate unit tests for new classes following best practices and project conventions",
        "target_user": "New Java Developer"
      },
      {
        "title": "Legacy Codebase Improvement",
        "description": "Add tests to existing classes to improve coverage and prevent regressions",
        "target_user": "Legacy Codebase Improvement"
      },
      {
        "title": "Test Generation During Code Review",
        "description": "Quickly generate tests for code changes during pull request reviews",
        "target_user": "Test Generation During Code Review"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Unit Test Generation",
        "scenario": "Generate a basic JUnit 5 test class for a new service class",
        "prompt": "Generate a JUnit 5 test class for the UserService class. Include @ExtendWith(MockitoExtension.class), mock dependencies, and test the createUser method with valid input. Use @Test annotation and proper assertions."
      },
      {
        "title": "Edge Case and Boundary Testing",
        "scenario": "Test boundary conditions and error handling",
        "prompt": "Generate comprehensive test cases for the calculateInterest method. Test happy path, boundary conditions (zero, negative numbers), and exception handling for invalid inputs."
      },
      {
        "title": "Parameterized Testing",
        "scenario": "Test multiple input combinations efficiently",
        "prompt": "Create parameterized tests for the filterProducts method with different category and price range combinations. Use @ParameterizedTest and @ValueSource or @MethodSource."
      },
      {
        "title": "Mockito Configuration and Verification",
        "scenario": "Configure mocks and verify interactions",
        "prompt": "Generate test class with @InjectMocks, @Mock annotations. Configure mock behavior using when().thenReturn(), and add verify() calls to check that dependencies are called with correct parameters."
      }
    ],
    "output_examples": [
      {
        "input": "Generate a test class for a BankAccount class with deposit, withdraw, and checkBalance methods",
        "output": [
          "@ExtendWith(MockitoExtension.class)\nclass BankAccountTest {\n\n    @InjectMocks\n    private BankAccount bankAccount;\n\n    @Test\n    void shouldDepositAmountSuccessfully() {\n        // Arrange\n        double amount = 1000.0;\n        \n        // Act\n        bankAccount.deposit(amount);\n        \n        // Assert\n        assertEquals(1000.0, bankAccount.getBalance());\n    }\n\n    @Test\n    void shouldWithdrawAmountSuccessfully() {\n        // Arrange\n        bankAccount.deposit(1000.0);\n        double amount = 500.0;\n        \n        // Act\n        bankAccount.withdraw(amount);\n        \n        // Assert\n        assertEquals(500.0, bankAccount.getBalance());\n    }\n}"
        ]
      },
      {
        "input": "Test an email service with happy path and exception handling",
        "output": [
          "@ExtendWith(MockitoExtension.class)\nclass EmailServiceTest {\n\n    @InjectMocks\n    private EmailService emailService;\n\n    @Mock\n    private EmailClient emailClient;\n\n    @Test\n    void shouldSendEmailSuccessfully() {\n        // Arrange\n        Email email = new Email(\"test@example.com\", \"Hello\", \"Test body\");\n        when(emailClient.send(any())).thenReturn(true);\n        \n        // Act\n        boolean result = emailService.send(email);\n        \n        // Assert\n        assertTrue(result);\n        verify(emailClient, times(1)).send(any());\n    }\n\n    @Test\n    void shouldThrowExceptionWhenEmailIsNull() {\n        // Act & Assert\n        assertThrows(IllegalArgumentException.class, () -> emailService.send(null));\n    }\n}"
        ]
      }
    ],
    "best_practices": [
      "Use Arrange-Act-Assert pattern for clear test structure",
      "Name tests with clear method name + scenario + expected result",
      "Keep tests independent and repeatable without execution order dependencies",
      "Avoid deep stubs and focus on testing observable behavior",
      "Mock only external dependencies, not helper methods",
      "Use specific assertions rather than generic ones like assertNotNull"
    ],
    "anti_patterns": [
      "Testing private methods directly - test through public interfaces instead",
      "Writing slow tests that include sleep, real network calls, or file I/O",
      "Over-mocking leading to brittle tests that break on minor implementation changes",
      "Testing implementation details instead of business behavior",
      "Having tests that depend on execution order or randomness",
      "Leaving unused imports and imports in wrong order"
    ],
    "faq": [
      {
        "question": "Which testing framework does this skill use?",
        "answer": "This skill primarily uses JUnit 5 with Mockito. It can adapt to JUnit 4 or other frameworks if you specify them in your request."
      },
      {
        "question": "Can it generate integration tests?",
        "answer": "This skill focuses on unit tests. For integration tests, you need to provide more context about your testing framework and configuration."
      },
      {
        "question": "How does it handle external dependencies?",
        "answer": "The skill uses Mockito to mock external dependencies like databases, APIs, and other services. You can provide additional context about your dependencies for better mock configuration."
      },
      {
        "question": "What coverage percentage can it achieve?",
        "answer": "The skill generates tests covering happy paths, edge cases, and error scenarios. Actual coverage depends on the code structure and your specific requirements."
      },
      {
        "question": "Can it refactor existing tests?",
        "answer": "This skill primarily generates new tests. For refactoring existing test suites, please provide the current test files and specific improvement areas."
      },
      {
        "question": "Does it support Spring Boot testing?",
        "answer": "Yes, the skill can generate tests compatible with Spring Boot test configuration including @SpringBootTest and @MockBean annotations."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 177
    }
  ]
}
