{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-17T07:46:40.305Z",
    "slug": "obra-systematic-debugging",
    "source_url": "https://github.com/obra/superpowers/tree/main/skills/systematic-debugging",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "1a6bb97f9541f57f12c7edb48a9ca62288e84190fbf6713f405dc16e96786af9",
    "tree_hash": "18cfe9b8e10f27db9bca07e1d1e569591df8505fa8ba5e0cc847b9f15256913d"
  },
  "skill": {
    "name": "systematic-debugging",
    "description": "Use when encountering any bug, test failure, or unexpected behavior, before proposing fixes",
    "summary": "Use when encountering any bug, test failure, or unexpected behavior, before proposing fixes",
    "icon": "üîç",
    "version": "1.0.0",
    "author": "obra",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "debugging",
      "root-cause-analysis",
      "testing",
      "troubleshooting",
      "development"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "external_commands",
      "filesystem",
      "env_access",
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill is a methodology guide for systematic debugging practices. All 139 static findings are false positives. The 'backtick execution' findings are markdown code block syntax in documentation files. The 'weak cryptographic algorithm' findings are text references containing 'md5' or 'sha' substrings in documentation. The 'keychain access' finding shows example bash commands for debugging macOS code signing issues. No executable code performs malicious actions.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 18,
            "line_end": 20
          },
          {
            "file": "SKILL.md",
            "line_start": 77,
            "line_end": 87
          },
          {
            "file": "SKILL.md",
            "line_start": 90,
            "line_end": 106
          },
          {
            "file": "condition-based-waiting.md",
            "line_start": 11,
            "line_end": 36
          },
          {
            "file": "condition-based-waiting.md",
            "line_start": 46,
            "line_end": 61
          },
          {
            "file": "root-cause-tracing.md",
            "line_start": 11,
            "line_end": 24
          },
          {
            "file": "root-cause-tracing.md",
            "line_start": 35,
            "line_end": 51
          },
          {
            "file": "defense-in-depth.md",
            "line_start": 25,
            "line_end": 43
          },
          {
            "file": "defense-in-depth.md",
            "line_start": 85,
            "line_end": 98
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "condition-based-waiting.md",
            "line_start": 55,
            "line_end": 55
          },
          {
            "file": "CREATION-LOG.md",
            "line_start": 7,
            "line_end": 7
          },
          {
            "file": "find-polluter.sh",
            "line_start": 42,
            "line_end": 42
          }
        ]
      },
      {
        "factor": "env_access",
        "evidence": [
          {
            "file": "defense-in-depth.md",
            "line_start": 58,
            "line_end": 58
          },
          {
            "file": "root-cause-tracing.md",
            "line_start": 77,
            "line_end": 77
          }
        ]
      },
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 12,
    "total_lines": 2042,
    "audit_model": "claude",
    "audited_at": "2026-01-17T07:46:40.305Z"
  },
  "content": {
    "user_title": "Debug systematically to find root causes, not symptoms",
    "value_statement": "Random fixes waste hours and create new bugs. This skill teaches a four-phase process that finds root causes before attempting fixes. It prevents rework by ensuring you understand the problem before proposing solutions.",
    "seo_keywords": [
      "debugging",
      "root cause analysis",
      "Claude",
      "Claude Code",
      "Codex",
      "troubleshooting",
      "bug fixing",
      "systematic debugging",
      "test failures",
      "software development"
    ],
    "actual_capabilities": [
      "Guides through four-phase debugging methodology: Root Cause Investigation, Pattern Analysis, Hypothesis Testing, Implementation",
      "Provides condition-based waiting utilities to replace arbitrary timeouts in flaky tests",
      "Includes root cause tracing techniques to trace bugs backward through call stacks",
      "Offers defense-in-depth validation patterns for adding checks at multiple layers",
      "Contains pressure-test scenarios to practice resisting quick-fix temptations",
      "Provides a bisection script to identify which test creates unwanted state pollution"
    ],
    "limitations": [
      "Requires discipline to follow process even when quick fixes seem obvious",
      "May feel slower than guessing on simple bugs (though actually faster overall)",
      "Effectiveness depends on team adoption and willingness to trace root causes",
      "Some techniques assume familiarity with debugging tools and stack trace analysis"
    ],
    "use_cases": [
      {
        "target_user": "Developer debugging test failures",
        "title": "Fix flaky tests permanently",
        "description": "Replace arbitrary timeouts with condition-based waiting. Trace test pollution to its source using the included bisection script."
      },
      {
        "target_user": "Engineer under time pressure",
        "title": "Resist the quick-fix temptation",
        "description": "Follow structured phases to find root causes even when shortcuts seem faster. Avoid hours of symptom whack-a-mole."
      },
      {
        "target_user": "Team lead reviewing debugging approaches",
        "title": "Establish debugging standards",
        "description": "Use the four-phase framework and anti-pattern list to guide team debugging practices and improve code review quality."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Debug Request",
        "scenario": "Starting to investigate a bug",
        "prompt": "I have a test failure. Help me follow the systematic debugging process to find the root cause before attempting any fixes."
      },
      {
        "title": "Flaky Test Fix",
        "scenario": "Test passes sometimes, fails other times",
        "prompt": "This test is flaky. Help me replace arbitrary timeouts with condition-based waiting using the techniques from systematic-debugging."
      },
      {
        "title": "Root Cause Tracing",
        "scenario": "Bug appears deep in call stack",
        "prompt": "An error happens deep in execution. Help me trace backward through the call chain to find where the invalid data originates."
      },
      {
        "title": "Failed Fixes Recovery",
        "scenario": "Multiple fix attempts have failed",
        "prompt": "I have tried 3 fixes and none worked. Help me stop and question whether this is an architectural problem rather than continuing to fix symptoms."
      }
    ],
    "output_examples": [
      {
        "input": "Help me debug why git init is running in my source directory instead of temp folder",
        "output": [
          "Phase 1: Trace the data flow backward",
          "git init receives empty cwd parameter",
          "Empty string resolves to process.cwd() which is source directory",
          "setupCoreTest returns empty tempDir before beforeEach runs",
          "Root cause: Top-level variable accessed before initialization",
          "Fix: Make tempDir a getter that throws if accessed early"
        ]
      },
      {
        "input": "My test fails randomly, sometimes passes",
        "output": [
          "Current approach uses arbitrary setTimeout delays",
          "Replace with condition-based waiting that polls for actual state",
          "waitForEvent polls every 10ms with configurable timeout",
          "Result: Test pass rate improved from 60% to 100%",
          "Execution became 40% faster by not over-waiting"
        ]
      }
    ],
    "best_practices": [
      "Complete Phase 1 root cause investigation before proposing any fixes",
      "Make one change at a time and verify each hypothesis before moving on",
      "Add defense-in-depth validation at multiple layers after finding root cause"
    ],
    "anti_patterns": [
      "Proposing fixes without reading error messages and tracing data flow",
      "Adding multiple fixes at once when one does not work",
      "Skipping the test case step and manually verifying fixes"
    ],
    "faq": [
      {
        "question": "When should I skip the systematic process?",
        "answer": "Almost never. Simple bugs have root causes too. The process is fast for simple issues and prevents new bugs from quick fixes."
      },
      {
        "question": "What if I am under time pressure?",
        "answer": "Systematic debugging is faster than guess-and-check thrashing. Following the process saves time by avoiding multiple failed fix attempts."
      },
      {
        "question": "How do I know if my fix addresses root cause?",
        "answer": "You traced the bug backward to its origin. Your fix prevents the invalid state from ever occurring, not just handling it downstream."
      },
      {
        "question": "What if my hypothesis is wrong?",
        "answer": "Form a new hypothesis and test again. Do not add more fixes on top. Return to Phase 1 with new information from failed test."
      },
      {
        "question": "How many fix attempts before questioning architecture?",
        "answer": "After 3 failed fixes, stop and question fundamentals. This pattern indicates architectural problems, not bugs to fix."
      },
      {
        "question": "Can I use this for production bugs?",
        "answer": "Yes. The process applies to test failures, production bugs, performance problems, build failures, and integration issues."
      }
    ]
  },
  "file_structure": [
    {
      "name": "condition-based-waiting-example.ts",
      "type": "file",
      "path": "condition-based-waiting-example.ts",
      "lines": 159
    },
    {
      "name": "condition-based-waiting.md",
      "type": "file",
      "path": "condition-based-waiting.md",
      "lines": 116
    },
    {
      "name": "CREATION-LOG.md",
      "type": "file",
      "path": "CREATION-LOG.md",
      "lines": 120
    },
    {
      "name": "defense-in-depth.md",
      "type": "file",
      "path": "defense-in-depth.md",
      "lines": 123
    },
    {
      "name": "find-polluter.sh",
      "type": "file",
      "path": "find-polluter.sh",
      "lines": 64
    },
    {
      "name": "root-cause-tracing.md",
      "type": "file",
      "path": "root-cause-tracing.md",
      "lines": 170
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 297
    },
    {
      "name": "test-academic.md",
      "type": "file",
      "path": "test-academic.md",
      "lines": 15
    },
    {
      "name": "test-pressure-1.md",
      "type": "file",
      "path": "test-pressure-1.md",
      "lines": 59
    },
    {
      "name": "test-pressure-2.md",
      "type": "file",
      "path": "test-pressure-2.md",
      "lines": 69
    },
    {
      "name": "test-pressure-3.md",
      "type": "file",
      "path": "test-pressure-3.md",
      "lines": 70
    }
  ]
}
