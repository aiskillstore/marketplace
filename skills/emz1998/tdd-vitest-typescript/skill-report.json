{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:33:42.648Z",
    "slug": "emz1998-tdd-vitest-typescript",
    "source_url": "https://github.com/Emz1998/nexly-notes/tree/main/archive/tdd",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "27ea948d996074fe105e1fce18b056a06426888f9dfc15332ee1d291bb12d602",
    "tree_hash": "759781b10612d8aa91de7319f350ee0af611671c0f10133463e3fa4151a7b408"
  },
  "skill": {
    "name": "tdd-vitest-typescript",
    "description": "Test-Driven Development (TDD) using Vitest and TypeScript. Use when the user requests help with TDD, writing tests before code, test-first development, Vitest test setup, TypeScript testing patterns, unit testing, integration testing, or following the Red-Green-Refactor cycle with Vitest.",
    "summary": "Guide for Test-Driven Development workflows using Vitest and TypeScript. Helps write failing tests first, implement minimal code to pass, and refactor with confidence.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "Emz1998",
    "license": "MIT",
    "tags": [
      "TDD",
      "Vitest",
      "TypeScript",
      "testing",
      "unit-testing"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Legitimate TDD educational skill. Static analyzer flagged benign code patterns: TypeScript template literals misidentified as shell backticks, regex validation patterns misidentified as weak crypto, and project scaffolding fs operations. No malicious intent detected.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [
      {
        "title": "TypeScript Template Literals Misidentified",
        "description": "Static analyzer flagged TypeScript template literals (backticks) as shell command execution. These are standard code examples using backticks for multiline strings in test documentation.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 20,
            "line_end": 39
          },
          {
            "file": "SKILL.md",
            "line_start": 45,
            "line_end": 47
          },
          {
            "file": "SKILL.md",
            "line_start": 322,
            "line_end": 332
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "Backticks are standard TypeScript syntax for template literals. No shell command execution exists in documentation."
      },
      {
        "title": "Regex Patterns Misidentified as Crypto",
        "description": "Email validation and pattern matching regex expressions flagged as weak cryptographic algorithms. These are standard input validation patterns in test code.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 64,
            "line_end": 66
          },
          {
            "file": "SKILL.md",
            "line_start": 138,
            "line_end": 142
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "Regex patterns like ^.+@.+\\..+$ are for email validation, not cryptographic operations. No crypto code present."
      },
      {
        "title": "Project Scaffolding Filesystem Operations",
        "description": "Setup script creates project files and directories using fs module. Operations are controlled for local project initialization only.",
        "locations": [
          {
            "file": "scripts/setup-vitest.js",
            "line_start": 9,
            "line_end": 9
          },
          {
            "file": "scripts/setup-vitest.js",
            "line_start": 22,
            "line_end": 22
          }
        ],
        "verdict": "TRUE_POSITIVE",
        "confidence": 0.9,
        "confidence_reasoning": "Script creates local project files for TDD setup. No external or dangerous filesystem operations. Controlled by hardcoded paths."
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 4,
    "total_lines": 1930,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:33:42.648Z",
    "risk_factors": [
      "filesystem",
      "external_commands"
    ],
    "risk_factor_evidence": [
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "scripts/setup-vitest.js",
            "line_start": 9,
            "line_end": 9
          },
          {
            "file": "scripts/setup-vitest.js",
            "line_start": 22,
            "line_end": 22
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "scripts/setup-vitest.js",
            "line_start": 8,
            "line_end": 8
          },
          {
            "file": "scripts/setup-vitest.js",
            "line_start": 17,
            "line_end": 17
          }
        ]
      }
    ]
  },
  "content": {
    "user_title": "Set up TDD with Vitest and TypeScript",
    "value_statement": "Writing tests before code ensures reliable, maintainable software. This skill guides you through the Red-Green-Refactor cycle with Vitest, covering test patterns, mocking strategies, and TDD best practices.",
    "seo_keywords": [
      "TDD",
      "Test-Driven Development",
      "Vitest",
      "TypeScript testing",
      "unit testing",
      "Claude",
      "Codex",
      "Claude Code",
      "Red-Green-Refactor",
      "test patterns"
    ],
    "actual_capabilities": [
      "Guide Red-Green-Refactor TDD workflow with Vitest",
      "Set up Vitest configuration for TypeScript projects",
      "Write unit tests, integration tests, and async tests",
      "Implement mocking and spying with Vitest test utilities",
      "Identify and avoid common testing anti-patterns",
      "Apply advanced testing patterns for complex scenarios"
    ],
    "limitations": [
      "Does not execute tests directly in user environment",
      "Does not integrate with CI/CD pipelines",
      "Does not provide pre-configured testing frameworks beyond Vitest",
      "Focus is on testing methodology, not specific application domains"
    ],
    "use_cases": [
      {
        "title": "Starting a New Feature with TDD",
        "description": "A developer wants to build a new feature using Test-Driven Development. The skill guides them through writing failing tests first, implementing minimal code, and refactoring while keeping tests green.",
        "target_user": "Software developers adopting TDD practices"
      },
      {
        "title": "Learning TypeScript Testing Patterns",
        "description": "A developer new to TypeScript testing wants to learn patterns for type-safe test data, generic function testing, and proper mocking strategies with Vitest.",
        "target_user": "Developers learning TypeScript testing"
      },
      {
        "title": "Improving Test Quality",
        "description": "A team wants to improve their test suite. The skill helps identify anti-patterns like testing implementation details, complex setup, and vague test names.",
        "target_user": "Teams improving test maintainability"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic TDD Setup",
        "prompt": "Help me set up Test-Driven Development using Vitest and TypeScript. I want to follow the Red-Green-Refactor cycle for building a new feature.",
        "scenario": "Initial TDD project setup"
      },
      {
        "title": "Writing Failing Tests",
        "prompt": "Write a failing test first for a Calculator class with add, subtract, multiply, and divide methods. Then show me the minimal implementation to make the tests pass.",
        "scenario": "Writing failing tests before implementation"
      },
      {
        "title": "Mocking Dependencies",
        "prompt": "How do I mock an external API dependency in Vitest? I need to test a service that calls a remote API without making actual network requests.",
        "scenario": "Mocking external dependencies in tests"
      },
      {
        "title": "Avoiding Testing Anti-Patterns",
        "prompt": "Review my test code and identify any anti-patterns. My tests are brittle and break when I refactor even though the behavior is unchanged.",
        "scenario": "Improving test maintainability"
      }
    ],
    "output_examples": [
      {
        "input": "Help me write a test for a user registration feature using TDD",
        "output": "## TDD Approach: User Registration\n\n### 1. Red - Write Failing Test\n\n```typescript\ndescribe('User Registration', () => {\n  it('creates new user account with valid email', async () => {\n    const result = await registerUser({\n      email: 'new@example.com',\n      password: 'secure123',\n    });\n    \n    expect(result.success).toBe(true);\n    expect(result.user.email).toBe('new@example.com');\n  });\n\n  it('rejects registration with existing email', async () => {\n    // ... test for duplicate email handling\n  });\n\n  it('rejects weak passwords', async () => {\n    // ... test for password validation\n  });\n});\n```\n\n### 2. Green - Minimal Implementation\n\nWrite just enough code to pass the tests.\n\n### 3. Refactor\n\nImprove the implementation while keeping tests green."
      },
      {
        "input": "How do I set up Vitest with TypeScript?",
        "output": "## Vitest + TypeScript Setup\n\n### Install Dependencies\n```bash\nnpm install -D vitest @vitest/ui @vitest/coverage-v8 typescript @types/node\n```\n\n### Create vitest.config.ts\n```typescript\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    coverage: {\n      provider: 'v8',\n      reporter: ['text', 'json', 'html'],\n    },\n  },\n});\n```\n\n### Configure tsconfig.json\n```json\n{\n  \"compilerOptions\": {\n    \"types\": [\"vitest/globals\", \"node\"],\n    \"esModuleInterop\": true,\n    \"strict\": true\n  }\n}\n```"
      }
    ],
    "best_practices": [
      "Write failing tests first before any implementation code to define behavior clearly",
      "Keep tests focused with single assertions per test concern for easier debugging",
      "Test public behavior and outcomes rather than private implementation details"
    ],
    "anti_patterns": [
      "Testing implementation details like private methods that may change during refactoring",
      "Using arbitrary sleep or timeout delays in tests instead of waiting for actual conditions",
      "Creating massive test setup with dozens of lines of boilerplate instead of reusable helpers"
    ],
    "faq": [
      {
        "question": "What is the TDD cycle?",
        "answer": "TDD follows three phases: Red (write a failing test), Green (write minimal code to pass), and Refactor (improve code while keeping tests green). This cycle ensures tests define behavior before implementation."
      },
      {
        "question": "How do I run Vitest in watch mode?",
        "answer": "Run 'vitest' without arguments to start watch mode. Tests automatically re-run when files change, enabling rapid TDD iterations."
      },
      {
        "question": "What test file naming convention does Vitest use?",
        "answer": "Vitest recognizes files named *.test.ts or *.spec.ts. Place tests adjacent to source files or in __tests__ directories."
      },
      {
        "question": "How do I mock a module in Vitest?",
        "answer": "Use vi.mock() before imports: 'vi.mock(\"./api\");'. Then use vi.mocked() to type mock returns or vi.fn() for spy functions."
      },
      {
        "question": "What coverage target should I aim for?",
        "answer": "Aim for 80%+ coverage on business logic and 100% on critical paths like authentication. Avoid obsessing over 100% coverage everywhere."
      },
      {
        "question": "How do I test async code with Vitest?",
        "answer": "Use async/await with expect(result).rejects.toThrow() for rejected promises, or use .resolves for fulfilled promises."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "advanced-patterns.md",
          "type": "file",
          "path": "references/advanced-patterns.md",
          "lines": 602
        },
        {
          "name": "anti-patterns.md",
          "type": "file",
          "path": "references/anti-patterns.md",
          "lines": 502
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "setup-vitest.js",
          "type": "file",
          "path": "scripts/setup-vitest.js",
          "lines": 260
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 566
    }
  ]
}
