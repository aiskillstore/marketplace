{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:42:36.304Z",
    "slug": "emz1998-writing-types",
    "source_url": "https://github.com/Emz1998/nexly-notes/tree/main/archive/skills/code-style/types",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "206be79b8ef13311ce218c6767b47a144fcabafbb85ba739dc7590b11e5de49e",
    "tree_hash": "f3865af41d702e5b0c4a0f42c9393e6674e4f8f6924af1c277b5604d34cefe73"
  },
  "skill": {
    "name": "writing-types",
    "description": "Use this skill when you need to write types and interfaces in `srs/types` for the Next.js app",
    "summary": "Write TypeScript types and interfaces for the Next.js app with modular, maintainable patterns",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "Emz1998",
    "license": "MIT",
    "tags": [
      "typescript",
      "types",
      "interfaces",
      "type-safety"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings are false positives. The SKILL.md file contains only markdown documentation with inline code formatting. Backticks are used for path references, not shell execution. No cryptographic algorithms, network calls, or dangerous code patterns present.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [
      {
        "title": "False Positive: Backtick Pattern Misclassified",
        "description": "Markdown inline code formatting (backticks) was misidentified as Ruby/shell backtick execution. Lines 3 and 8 use backticks for code path references, not command execution.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 3,
            "line_end": 3
          },
          {
            "file": "SKILL.md",
            "line_start": 8,
            "line_end": 8
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "Backticks are standard markdown syntax for inline code formatting. No shell or Ruby execution context exists in this file."
      },
      {
        "title": "False Positive: Cryptographic Pattern Error",
        "description": "Static scanner incorrectly flagged 'Weak cryptographic algorithm' at line 3. No cryptographic code exists in this file.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 3,
            "line_end": 3
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "Line 3 contains only YAML frontmatter with a description field. No cryptographic algorithms, encryption, or hashing code present."
      }
    ],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 15,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:42:36.304Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Write TypeScript Types for Next.js",
    "value_statement": "Writing TypeScript types manually can be error-prone and lead to inconsistent patterns across a codebase. This skill provides guidelines for creating modular, maintainable type definitions that improve code quality and type safety.",
    "seo_keywords": [
      "TypeScript types",
      "interfaces",
      "type definitions",
      "type safety",
      "Next.js types",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Generate TypeScript type definitions for Next.js applications",
      "Create modular type files with clear separation of concerns",
      "Enforce maximum 50 lines per file for maintainability",
      "Write interfaces for complex data structures"
    ],
    "limitations": [
      "Does not infer types from existing code or runtime values",
      "Does not validate types against actual data usage",
      "Does not generate test cases for type definitions",
      "Requires manual review for complex generic types"
    ],
    "use_cases": [
      {
        "title": "New Data Model Types",
        "description": "When adding new data models to the Next.js app, use this skill to generate clean, modular type definitions that follow project conventions.",
        "target_user": "TypeScript developers building Next.js applications"
      },
      {
        "title": "API Response Types",
        "description": "Create type definitions for API responses by describing the expected data structure. The skill helps organize types into manageable files.",
        "target_user": "Backend and full-stack developers"
      },
      {
        "title": "Refactoring Legacy Types",
        "description": "When breaking down large type files, use this skill to restructure types into smaller, focused modules while maintaining type safety.",
        "target_user": "Codebase maintainers and refactoring specialists"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Type Request",
        "prompt": "Write TypeScript types for a user object with the following properties: id, name, email, createdAt. Keep it modular and follow the writing-types skill guidelines.",
        "scenario": "Simple type generation for a data model"
      },
      {
        "title": "API Response Types",
        "prompt": "Create type definitions for a paginated API response that includes items array, total count, page number, and hasMore flag. Use separate files if the types exceed 50 lines.",
        "scenario": "Generating types for API response structures"
      },
      {
        "title": "Complex Object with Relations",
        "prompt": "Write types for a blog post that includes an author reference, tags array, and nested comments. Separate the types into modular files following the skill rules.",
        "scenario": "Creating types for complex nested objects"
      },
      {
        "title": "Module Organization Request",
        "prompt": "Generate all TypeScript types needed for a todo list feature including Todo, TodoList, and UserTodoPreferences. Organize them into modular files under the types directory.",
        "scenario": "Creating a complete type module for a feature"
      }
    ],
    "output_examples": [
      {
        "input": "Write types for a product with id, name, price, description, and category",
        "output": [
          "```typescript",
          "// types/product.ts",
          "export type ProductId = string;",
          "",
          "export interface Product {",
          "  id: ProductId;",
          "  name: string;",
          "  price: number;",
          "  description: string;",
          "  category: string;",
          "}",
          "```"
        ]
      },
      {
        "input": "Create types for a user profile with optional avatar and required email",
        "output": [
          "```typescript",
          "// types/user.ts",
          "export interface UserProfile {",
          "  id: string;",
          "  email: string;",
          "  displayName: string;",
          "  avatarUrl?: string;",
          "  createdAt: Date;",
          "}",
          "```"
        ]
      }
    ],
    "best_practices": [
      "Use descriptive type names and separate concerns into modular files",
      "Keep each type file under 50 lines for better maintainability",
      "Export types from index files for easy importing"
    ],
    "anti_patterns": [
      "Putting all types in a single monolithic types.ts file",
      "Using overly generic types like 'any' or 'object'",
      "Defining complex nested types without breaking them into smaller pieces"
    ],
    "faq": [
      {
        "question": "What is the maximum file size recommendation for type files?",
        "answer": "The skill recommends keeping each type file under 50 lines of code for better maintainability and code review."
      },
      {
        "question": "Should I use interfaces or types for my definitions?",
        "answer": "Both interfaces and types are valid. Use interfaces for object shapes that may be extended, and types for unions, primitives, or complex combinations."
      },
      {
        "question": "How should I organize related types?",
        "answer": "Group related types in the same file or directory. Use an index.ts file to re-export types for convenient importing."
      },
      {
        "question": "Does this skill generate generic types?",
        "answer": "The skill can generate generic types when you specify the type parameters in your request. Be specific about the generic constraints you need."
      },
      {
        "question": "Can I use this skill for React component props?",
        "answer": "Yes, you can request prop types for React components. Describe the component's props and any event handlers it accepts."
      },
      {
        "question": "How do I handle circular type references?",
        "answer": "For circular references, use interface extensions or type aliases with forward declarations. The skill can help structure these patterns correctly."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 15
    }
  ]
}
