{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-23T02:39:50.912Z",
    "slug": "emz1998-writing-lib-functions",
    "source_url": "https://github.com/Emz1998/nexly-notes/tree/main/archive/skills/code-style/lib",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "e9d11ddcc41fbc34dad7fa4f83c08212332cdbec53d44ddb4167d0e0d606b7ad",
    "tree_hash": "6a18540e764087b784984f0e57a63273526719b8712cfbed8638e461d6457358"
  },
  "skill": {
    "name": "writing-lib-functions",
    "description": "Use this skill when you need to write lib functions in `srs/lib` for the Next.js app",
    "summary": "Write modular library functions for the Next.js application in the srs/lib directory",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "Emz1998",
    "license": "MIT",
    "tags": [
      "nextjs",
      "library-functions",
      "modular-code",
      "code-organization"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Static analysis flagged backticks in markdown and YAML as shell execution patterns. This is a false positive. The skill contains only documentation with inline code formatting. No executable code, network access, or sensitive operations. Safe for publication.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 15,
    "audit_model": "claude",
    "audited_at": "2026-01-23T02:39:50.912Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Write modular lib functions for Next.js",
    "value_statement": "Developers working on Next.js applications need consistent, maintainable library functions. This skill provides clear guidelines for writing modular, well-organized code in the srs/lib directory.",
    "seo_keywords": [
      "Claude",
      "Codex",
      "Claude Code",
      "Next.js library functions",
      "modular JavaScript",
      "code organization",
      "srs/lib",
      "Next.js development",
      "TypeScript utilities"
    ],
    "actual_capabilities": [
      "Writes library functions in the srs/lib directory for Next.js applications",
      "Enforces modular code structure with file size limits",
      "Separates concerns into multiple focused files",
      "Follows project conventions for code organization"
    ],
    "limitations": [
      "Does not generate tests or documentation for the functions",
      "Does not validate function logic or edge cases",
      "Does not integrate with external APIs or databases",
      "Does not provide code examples or templates"
    ],
    "use_cases": [
      {
        "title": "Create utility functions",
        "description": "Add new helper functions to handle common tasks like data formatting, validation, or string manipulation in the Next.js application.",
        "target_user": "Frontend developers building Next.js applications"
      },
      {
        "title": "Refactor existing code",
        "description": "Split large utility files into smaller, focused modules following the 50-line limit per file guideline.",
        "target_user": "Maintenance developers improving code maintainability"
      },
      {
        "title": "Add data layer functions",
        "description": "Create new functions for database operations, API integrations, or data transformation logic within the srs/lib directory.",
        "target_user": "Full-stack developers extending application functionality"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic function request",
        "prompt": "Write a lib function in srs/lib that formats dates to a human-readable format.",
        "scenario": "When you need to add a simple utility function"
      },
      {
        "title": "Validation function",
        "prompt": "Create a validation function in srs/lib that checks if an email address is valid.",
        "scenario": "When you need form validation logic"
      },
      {
        "title": "Data transformation",
        "prompt": "Write a function in srs/lib that transforms API response data into the format needed by the frontend components.",
        "scenario": "When working with external API data"
      },
      {
        "title": "Complex utility with refactoring",
        "prompt": "I need to add a new utility for parsing and validating user input. Write it as a modular function in srs/lib. Keep each file under 50 lines and separate concerns into multiple files if needed.",
        "scenario": "When creating a complex utility that needs to be well-organized"
      }
    ],
    "output_examples": [
      {
        "input": "Write a lib function in srs/lib that converts a date to ISO format",
        "output": "Created utils/date-formatters.ts with toIsoDate() function that converts JavaScript Date objects to ISO 8601 string format."
      },
      {
        "input": "Create a lib function for validating URLs",
        "output": "Added validators/url.ts with isValidUrl() function using the URL constructor for robust URL validation."
      },
      {
        "input": "Write a function that formats currency amounts",
        "output": "Created formatters/currency.ts with formatCurrency() supporting multiple currency codes and locale-aware formatting."
      }
    ],
    "best_practices": [
      "Keep each file under 50 lines of code to improve readability and maintainability",
      "Separate related functions into their own files by responsibility",
      "Use descriptive file names that indicate the purpose of the contained functions",
      "Group related utilities in subdirectories when the lib grows large"
    ],
    "anti_patterns": [
      "Putting unrelated utility functions in a single catch-all file like utils.ts",
      "Creating files with hundreds of lines of code that mix different concerns",
      "Duplicating similar logic across multiple files instead of extracting shared helpers",
      "Adding business logic or component-specific code to the lib directory"
    ],
    "faq": [
      {
        "question": "Where should I place new library functions?",
        "answer": "Create new files in srs/lib or its subdirectories. Use descriptive names like formatters/, validators/, or helpers/ to organize by purpose."
      },
      {
        "question": "What is the recommended file size limit?",
        "answer": "Keep each file under 50 lines of code. If a file grows larger, refactor it into smaller, focused modules."
      },
      {
        "question": "Can I create subdirectories in srs/lib?",
        "answer": "Yes. Create subdirectories like srs/lib/utils/, srs/lib/validators/, or srs/lib/formatters/ to group related functions."
      },
      {
        "question": "Should I add TypeScript types in lib files?",
        "answer": "Yes. Include proper TypeScript interfaces and type definitions within each file to maintain type safety."
      },
      {
        "question": "How should I name library function files?",
        "answer": "Use kebab-case for file names. Group similar functions together. For example, use date-formatters.ts instead of dateFormatter.ts."
      },
      {
        "question": "What goes in srs/lib versus other directories?",
        "answer": "srs/lib should contain pure utility functions, formatters, validators, and helpers. Keep business logic, components, and hooks in their respective directories."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 15
    }
  ]
}
