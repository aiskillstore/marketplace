{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T17:05:53.631Z",
    "slug": "wshobson-postgresql-table-design",
    "source_url": "https://github.com/wshobson/agents/tree/main/plugins/database-design/skills/postgresql",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "b2761ed21c1a29940787c0f72356dbae5e1eca0062c00c46259e4a6b188de1a4",
    "tree_hash": "6979108ba169f7cb71af3f86519d98b051960280a9964d02a1e8c5c3a5773486"
  },
  "skill": {
    "name": "postgresql-table-design",
    "description": "Design a PostgreSQL-specific schema. Covers best-practices, data types, indexing, constraints, performance patterns, and advanced features",
    "summary": "PostgreSQL schema design expert covering data types, indexing, constraints, and performance",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "wshobson",
    "license": "MIT",
    "category": "data",
    "tags": [
      "postgresql",
      "database",
      "schema-design",
      "sql",
      "data-modeling"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill is a documentation-only resource providing PostgreSQL schema design guidance. All 237 static findings are false positives triggered by SQL examples and technical terminology in markdown code blocks. The skill contains no executable code, network calls, or file system access. Safe for publication.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 2539,
    "audit_model": "claude",
    "audited_at": "2026-01-21T17:05:53.631Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Design PostgreSQL schemas with expert guidance",
    "value_statement": "PostgreSQL schema design requires knowledge of data types, indexing strategies, constraints, and performance patterns. This skill provides comprehensive guidance on PostgreSQL-specific best practices, advanced features, and common pitfalls to help you build efficient, maintainable database schemas.",
    "seo_keywords": [
      "Claude",
      "Codex",
      "Claude Code",
      "PostgreSQL",
      "database design",
      "schema design",
      "SQL",
      "indexing",
      "data modeling",
      "performance optimization"
    ],
    "actual_capabilities": [
      "Provides guidance on PostgreSQL data types including BIGINT, TEXT, TIMESTAMPTZ, NUMERIC, JSONB, arrays, ranges, and composite types",
      "Explains indexing strategies for B-tree, GIN, GiST, BRIN indexes including partial, covering, and expression indexes",
      "Covers constraint types including primary keys, foreign keys, unique constraints, check constraints, and exclusion constraints",
      "Offers patterns for partitioning, update-heavy tables, insert-heavy workloads, and upsert operations",
      "Details PostgreSQL-specific features like MVCC, TOAST storage, row-level security, and generated columns",
      "Recommends extensions including TimescaleDB, PostGIS, pgvector, and pg_trgm"
    ],
    "limitations": [
      "Does not execute SQL commands or create actual database schemas",
      "Does not analyze existing databases or provide migration scripts",
      "Focuses on PostgreSQL-specific patterns and may not apply to other database systems",
      "Does not provide application-level code or ORM configurations"
    ],
    "use_cases": [
      {
        "title": "Design a new database schema",
        "description": "Get guidance on table structure, data types, constraints, and indexing strategies when designing a new PostgreSQL database for an application.",
        "target_user": "Backend developers and database architects"
      },
      {
        "title": "Optimize existing schema performance",
        "description": "Learn about indexing strategies, partitioning options, and performance patterns to improve query performance and reduce database bloat.",
        "target_user": "Database administrators and performance engineers"
      },
      {
        "title": "Review schema design decisions",
        "description": "Validate data type choices, constraint usage, and normalization decisions against PostgreSQL best practices before implementation.",
        "target_user": "Technical leads and code reviewers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic table design",
        "prompt": "I need to create a users table with email, name, and timestamps. What is the recommended PostgreSQL schema?",
        "scenario": "Beginner: Creating a simple reference table"
      },
      {
        "title": "Choose appropriate data types",
        "prompt": "I am storing product prices, IP addresses, and user preferences. What PostgreSQL data types should I use?",
        "scenario": "Intermediate: Selecting specialized data types"
      },
      {
        "title": "Design indexing strategy",
        "prompt": "My orders table has queries filtering by user_id, status, and created_at. What indexes should I create?",
        "scenario": "Intermediate: Optimizing query performance"
      },
      {
        "title": "Handle high-volume time-series data",
        "prompt": "I need to store millions of sensor readings per day with queries filtering by device and time range. How should I design the schema and partitioning?",
        "scenario": "Advanced: Designing for high-volume workloads"
      }
    ],
    "output_examples": [
      {
        "input": "How should I store monetary values in PostgreSQL?",
        "output": "Use NUMERIC(p,s) for monetary values, never float types. For example: amount NUMERIC(10,2) for currency with two decimal places. This provides exact decimal arithmetic without floating-point precision issues. Avoid the deprecated money type."
      },
      {
        "input": "What is the difference between BIGINT GENERATED ALWAYS AS IDENTITY and UUID for primary keys?",
        "output": [
          "BIGINT GENERATED ALWAYS AS IDENTITY: Sequential integer IDs. Preferred for most use cases. Benefits: smaller storage, faster indexing, better locality. Use when global uniqueness across systems is not required.",
          "UUID: Globally unique identifiers. Use when: merging data from multiple databases, federating systems, or requiring opaque non-sequential IDs. Generate with uuidv7() on PostgreSQL 18+ or gen_random_uuid() on older versions."
        ]
      },
      {
        "input": "Should I add indexes on foreign key columns?",
        "output": "Yes, always add explicit indexes on foreign key columns. PostgreSQL does not auto-index FK columns unlike some databases. This speeds up joins and prevents locking issues during parent table deletes or updates. Example: CREATE INDEX ON orders (user_id) for user_id foreign key."
      }
    ],
    "best_practices": [
      "Start with normalized schemas to third normal form and only denormalize when you have measured performance problems with specific high-value queries",
      "Use TIMESTAMPTZ for all timestamp columns, TEXT for strings, NUMERIC for money, and BIGINT GENERATED ALWAYS AS IDENTITY for primary keys unless you need UUIDs",
      "Create indexes for columns used in WHERE clauses, JOIN conditions, and ORDER BY clauses, and always add explicit indexes on foreign key columns"
    ],
    "anti_patterns": [
      "Do not use VARCHAR(n) or CHAR(n) data types; use TEXT with CHECK constraints for length limits if needed",
      "Do not use TIMESTAMP without time zone, the money type, or SERIAL; use TIMESTAMPTZ, NUMERIC, and GENERATED ALWAYS AS IDENTITY instead",
      "Do not denormalize data prematurely before measuring actual performance issues; premature denormalization creates maintenance burden without proven benefits"
    ],
    "faq": [
      {
        "question": "When should I use UUID instead of BIGINT for primary keys?",
        "answer": "Use UUID when you need global uniqueness across distributed systems, when merging databases, or when you want opaque non-sequential identifiers. Use BIGINT GENERATED ALWAYS AS IDENTITY for most other cases as it provides better performance and smaller storage."
      },
      {
        "question": "Does PostgreSQL automatically create indexes on foreign key columns?",
        "answer": "No, PostgreSQL does not automatically index foreign key columns. You must manually create indexes on FK columns to improve join performance and prevent locking issues during parent table modifications."
      },
      {
        "question": "What is the difference between JSONB and JSON data types?",
        "answer": "JSONB is preferred over JSON. JSONB stores data in binary format for faster processing and supports indexing with GIN indexes. Use JSON only if you must preserve the original ordering and formatting of JSON content."
      },
      {
        "question": "When should I partition a table?",
        "answer": "Partition tables larger than 100 million rows when queries consistently filter on a partition key like timestamp or region. Partitioning is also useful when you need to prune or bulk replace data periodically. Use declarative partitioning or TimescaleDB for automated management."
      },
      {
        "question": "Why do I see gaps in my IDENTITY column sequence?",
        "answer": "Gaps in sequences are normal and expected behavior in PostgreSQL. Rollbacks, crashes, and concurrent transactions create gaps. Do not try to make IDs consecutive as this is standard database behavior and does not indicate a problem."
      },
      {
        "question": "How do I make text comparisons case-insensitive?",
        "answer": "For simple ASCII case-insensitivity, create an expression index on LOWER(column) and query with WHERE LOWER(email) = LOWER(input). For locale-aware comparisons, use non-deterministic collations. Use CITEXT type only if you need case-insensitive constraints like UNIQUE or PRIMARY KEY."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 205
    }
  ]
}
