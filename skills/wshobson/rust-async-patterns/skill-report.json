{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-17T09:49:17.388Z",
    "slug": "wshobson-rust-async-patterns",
    "source_url": "https://github.com/wshobson/agents/tree/main/plugins/systems-programming/skills/rust-async-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "9cffd8a20391db673d0048eab929f9e532396b50a71958c096903bcb9da9a035",
    "tree_hash": "a5ec22d302887f158ac97352b73784c0002bdbfd61cde1ccecfc6fb1f382461d"
  },
  "skill": {
    "name": "rust-async-patterns",
    "description": "Master Rust async programming with Tokio, async traits, error handling, and concurrent patterns. Use when building async Rust applications, implementing concurrent systems, or debugging async code.",
    "summary": "Master Rust async programming with Tokio, async traits, error handling, and concurrent patterns. Use...",
    "icon": "âš¡",
    "version": "1.0.0",
    "author": "wshobson",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "rust",
      "async",
      "tokio",
      "concurrency",
      "debugging"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure educational documentation containing Rust async programming examples. All static findings are false positives: 'process spawn' refers to tokio::spawn for async task management (not command execution), 'backtick execution' refers to markdown code formatting, and 'weak cryptographic algorithm' refers to keywords in documentation fields. The skill contains no tool definitions, file access, network calls, or command execution capabilities.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          },
          {
            "file": "SKILL.md",
            "line_start": 211,
            "line_end": 211
          },
          {
            "file": "SKILL.md",
            "line_start": 62,
            "line_end": 62
          },
          {
            "file": "SKILL.md",
            "line_start": 515,
            "line_end": 515
          },
          {
            "file": "SKILL.md",
            "line_start": 516,
            "line_end": 516
          },
          {
            "file": "SKILL.md",
            "line_start": 517,
            "line_end": 517
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 88,
            "line_end": 88
          },
          {
            "file": "SKILL.md",
            "line_start": 138,
            "line_end": 138
          },
          {
            "file": "SKILL.md",
            "line_start": 166,
            "line_end": 166
          },
          {
            "file": "SKILL.md",
            "line_start": 177,
            "line_end": 177
          },
          {
            "file": "SKILL.md",
            "line_start": 258,
            "line_end": 258
          },
          {
            "file": "SKILL.md",
            "line_start": 288,
            "line_end": 288
          },
          {
            "file": "SKILL.md",
            "line_start": 465,
            "line_end": 465
          },
          {
            "file": "SKILL.md",
            "line_start": 492,
            "line_end": 492
          },
          {
            "file": "SKILL.md",
            "line_start": 23,
            "line_end": 27
          },
          {
            "file": "SKILL.md",
            "line_start": 27,
            "line_end": 33
          },
          {
            "file": "SKILL.md",
            "line_start": 33,
            "line_end": 34
          },
          {
            "file": "SKILL.md",
            "line_start": 34,
            "line_end": 35
          },
          {
            "file": "SKILL.md",
            "line_start": 35,
            "line_end": 36
          },
          {
            "file": "SKILL.md",
            "line_start": 36,
            "line_end": 37
          },
          {
            "file": "SKILL.md",
            "line_start": 37,
            "line_end": 41
          },
          {
            "file": "SKILL.md",
            "line_start": 41,
            "line_end": 50
          },
          {
            "file": "SKILL.md",
            "line_start": 50,
            "line_end": 52
          },
          {
            "file": "SKILL.md",
            "line_start": 52,
            "line_end": 73
          },
          {
            "file": "SKILL.md",
            "line_start": 73,
            "line_end": 79
          },
          {
            "file": "SKILL.md",
            "line_start": 79,
            "line_end": 125
          },
          {
            "file": "SKILL.md",
            "line_start": 125,
            "line_end": 129
          },
          {
            "file": "SKILL.md",
            "line_start": 129,
            "line_end": 187
          },
          {
            "file": "SKILL.md",
            "line_start": 187,
            "line_end": 191
          },
          {
            "file": "SKILL.md",
            "line_start": 191,
            "line_end": 243
          },
          {
            "file": "SKILL.md",
            "line_start": 243,
            "line_end": 247
          },
          {
            "file": "SKILL.md",
            "line_start": 247,
            "line_end": 302
          },
          {
            "file": "SKILL.md",
            "line_start": 302,
            "line_end": 306
          },
          {
            "file": "SKILL.md",
            "line_start": 306,
            "line_end": 355
          },
          {
            "file": "SKILL.md",
            "line_start": 355,
            "line_end": 359
          },
          {
            "file": "SKILL.md",
            "line_start": 359,
            "line_end": 411
          },
          {
            "file": "SKILL.md",
            "line_start": 411,
            "line_end": 415
          },
          {
            "file": "SKILL.md",
            "line_start": 415,
            "line_end": 471
          },
          {
            "file": "SKILL.md",
            "line_start": 471,
            "line_end": 475
          },
          {
            "file": "SKILL.md",
            "line_start": 475,
            "line_end": 495
          },
          {
            "file": "SKILL.md",
            "line_start": 495,
            "line_end": 500
          },
          {
            "file": "SKILL.md",
            "line_start": 500,
            "line_end": 502
          },
          {
            "file": "SKILL.md",
            "line_start": 502,
            "line_end": 504
          },
          {
            "file": "SKILL.md",
            "line_start": 504,
            "line_end": 507
          },
          {
            "file": "SKILL.md",
            "line_start": 507,
            "line_end": 510
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 694,
    "audit_model": "claude",
    "audited_at": "2026-01-17T09:49:17.388Z"
  },
  "content": {
    "user_title": "Learn async Rust patterns fast",
    "value_statement": "Async Rust can be hard to structure and debug. This skill gives clear patterns for Tokio tasks, channels, streams, and errors.",
    "seo_keywords": [
      "Rust async",
      "Tokio patterns",
      "async traits",
      "concurrency Rust",
      "Rust streams",
      "Claude",
      "Codex",
      "Claude Code",
      "async error handling",
      "Tokio shutdown"
    ],
    "actual_capabilities": [
      "Explain Tokio task spawning with JoinSet and concurrency limits",
      "Show mpsc, broadcast, oneshot, and watch channel usage",
      "Outline async error handling with anyhow, thiserror, and timeouts",
      "Describe graceful shutdown with CancellationToken and broadcast",
      "Demonstrate async traits with async-trait and trait objects",
      "Cover stream creation and processing with StreamExt"
    ],
    "limitations": [
      "Does not generate complete runnable projects",
      "Assumes Tokio runtime and common async crates",
      "Does not provide benchmarking or performance tuning tools"
    ],
    "use_cases": [
      {
        "target_user": "Backend engineer",
        "title": "Build concurrent services",
        "description": "Apply structured patterns for task orchestration, error handling, and shutdown in async Rust services."
      },
      {
        "target_user": "Systems developer",
        "title": "Debug async deadlocks",
        "description": "Use tracing guidance and common pitfalls to diagnose stuck tasks and lock misuse."
      },
      {
        "target_user": "Rust learner",
        "title": "Study async concepts",
        "description": "Learn futures, await, streams, and channels with short, focused examples."
      }
    ],
    "prompt_templates": [
      {
        "title": "Async quick start",
        "scenario": "Set up a basic Tokio app",
        "prompt": "Give a short Tokio async main example with tracing and a simulated async call. Explain each step in one sentence."
      },
      {
        "title": "Concurrency limit",
        "scenario": "Process many URLs safely",
        "prompt": "Show a pattern for limiting concurrent async tasks for a list of URLs using Tokio or futures streams."
      },
      {
        "title": "Graceful shutdown",
        "scenario": "Stop a service cleanly",
        "prompt": "Explain a graceful shutdown approach using CancellationToken and a shutdown broadcast channel."
      },
      {
        "title": "Async trait design",
        "scenario": "Define repository interfaces",
        "prompt": "Provide an async trait design for a repository with get, save, and delete, and note trait object usage."
      }
    ],
    "output_examples": [
      {
        "input": "Explain how to limit concurrency for async HTTP requests in Tokio.",
        "output": [
          "Use a stream over URLs and apply buffer_unordered with a limit",
          "Collect results and handle errors per request",
          "Avoid unbounded spawning to protect memory and sockets"
        ]
      },
      {
        "input": "Show me how to coordinate between async tasks using channels.",
        "output": [
          "Use mpsc::channel for one-to-one communication between producer and consumer",
          "Use broadcast::channel when multiple consumers need the same message",
          "Use oneshot::channel when you need a single response from a spawned task"
        ]
      },
      {
        "input": "How do I handle errors in async Rust code properly?",
        "output": [
          "Use anyhow for application-level errors with context chaining",
          "Use thiserror for library code to create custom error types",
          "Wrap operations with timeout to prevent indefinite hanging"
        ]
      }
    ],
    "best_practices": [
      "Use tokio::select! to race futures safely",
      "Prefer channels for coordination over shared mutable state",
      "Instrument async tasks with tracing for observability"
    ],
    "anti_patterns": [
      "Calling blocking functions like std::thread::sleep in async code",
      "Holding mutex or rwlock guards across await points",
      "Spawning unlimited tasks without a concurrency limit"
    ],
    "faq": [
      {
        "question": "Is this compatible with current Tokio versions?",
        "answer": "Yes, the patterns target Tokio 1.x and standard Rust async syntax."
      },
      {
        "question": "Does it generate full application code?",
        "answer": "No, it provides focused patterns and examples rather than full projects."
      },
      {
        "question": "Can I use it in an existing repository?",
        "answer": "Yes, apply the patterns to your current async modules and services."
      },
      {
        "question": "Does it access or store my data?",
        "answer": "No, it is static guidance and does not read files or send data."
      },
      {
        "question": "What if my async code still hangs?",
        "answer": "Use tracing, check for locked awaits, and add cancellation paths."
      },
      {
        "question": "How is this different from general async guides?",
        "answer": "It focuses on practical Tokio patterns, tasks, channels, and shutdown flows."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 518
    }
  ]
}
