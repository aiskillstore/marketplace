{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-05T17:07:20.120Z",
    "slug": "wshobson-projection-patterns",
    "source_url": "https://github.com/wshobson/agents/tree/main/plugins/backend-development/skills/projection-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "135da8d35a92b0dadba8d4af9bc96edfeec25198e21dc104eaf497ef9996ab93",
    "tree_hash": "d15e6561779e52a38b5fbc0d3470c337c65a4c32acf66af08f24d0cef7889c25"
  },
  "skill": {
    "name": "projection-patterns",
    "description": "Build read models and projections from event streams. Use when implementing CQRS read sides, building materialized views, or optimizing query performance in event-sourced systems.",
    "summary": "Build read models and projections from event streams. Use when implementing CQRS read sides, buildin...",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "wshobson",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "cqrs",
      "event-sourcing",
      "projections",
      "read-models"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Documentation-only skill containing architectural guidance and Python code templates. No executable code, file access, network calls, or system modifications. Pure prompt-based skill for CQRS projection patterns.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 4,
    "total_lines": 607,
    "audit_model": "claude",
    "audited_at": "2026-01-05T17:07:20.120Z"
  },
  "content": {
    "user_title": "Implement CQRS Projections",
    "value_statement": "Event-sourced systems need efficient read models. This skill provides production-ready templates and patterns for building projections, read models, and materialized views from event streams.",
    "seo_keywords": [
      "cqrs projections",
      "event sourcing",
      "read models",
      "materialized views",
      "claude code",
      "claude ai",
      "codex ai",
      "event stream processing",
      "cqrs read side",
      "projection patterns"
    ],
    "actual_capabilities": [
      "Design projection architectures with checkpoint-based processing",
      "Build basic projector classes with event handling logic",
      "Create aggregated projections for reporting dashboards",
      "Implement search indexes using Elasticsearch projections",
      "Develop multi-table projections for customer activity tracking"
    ],
    "limitations": [
      "Requires existing event store infrastructure to function",
      "Database drivers must be installed separately for templates",
      "Templates serve as starting points, not production-ready solutions"
    ],
    "use_cases": [
      {
        "target_user": "Backend Developers",
        "title": "Build Read Models",
        "description": "Transform event streams into optimized read models for your CQRS architecture."
      },
      {
        "target_user": "Data Engineers",
        "title": "Create Dashboards",
        "description": "Build real-time aggregated views for analytics dashboards and reporting systems."
      },
      {
        "target_user": "System Architects",
        "title": "Design Event Systems",
        "description": "Plan and implement projection strategies for event-sourced microservices."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Projection",
        "scenario": "Create a simple event projector",
        "prompt": "Create a basic projection class that handles OrderCreated and OrderCompleted events from an event stream and updates a PostgreSQL read model."
      },
      {
        "title": "Multi-Table Projection",
        "scenario": "Update multiple related tables",
        "prompt": "Write a projection that updates both a customer summary table and order history table when an OrderCompleted event occurs, using a single database transaction."
      },
      {
        "title": "Search Index Projection",
        "scenario": "Sync events to search index",
        "prompt": "Create an Elasticsearch projection that indexes product events for full-text search, handling create, update, and delete operations."
      },
      {
        "title": "Aggregated Metrics",
        "scenario": "Build daily aggregations",
        "prompt": "Write a projection that aggregates sales data by day, handling both completed orders and refunds with upsert logic."
      }
    ],
    "output_examples": [
      {
        "input": "Create a basic order summary projection",
        "output": [
          "Event handler for OrderCreated: Insert new order summary record",
          "Event handler for OrderItemAdded: Update total_amount and item_count",
          "Event handler for OrderShipped: Set status to shipped and record shipped_at timestamp",
          "Checkpoint tracking: Store global_position after each processed event",
          "Idempotent design: Safe to replay events on system restart"
        ]
      }
    ],
    "best_practices": [
      "Make projections idempotent so they can safely replay events after failures",
      "Use database transactions when a single event updates multiple tables",
      "Store checkpoints to enable resumption from the last processed position"
    ],
    "anti_patterns": [
      "Coupling projections together creates cascade failures and ordering dependencies",
      "Skipping error handling causes silent failures and data inconsistency",
      "Over-normalizing read models defeats the purpose of projections"
    ],
    "faq": [
      {
        "question": "Which databases work with these projections?",
        "answer": "Templates use asyncpg for PostgreSQL but patterns apply to any async database driver like SQLAlchemy or databases supporting async connections."
      },
      {
        "question": "How do projections handle high event volumes?",
        "answer": "Implement batch processing with configurable batch_size and checkpointing to manage memory and enable restart capability."
      },
      {
        "question": "Can I use these patterns with Kafka?",
        "answer": "Yes, the projector pattern works with any event source. Replace the event_store.read_all() call with your Kafka consumer logic."
      },
      {
        "question": "Is my data safe with these projections?",
        "answer": "These are architectural templates. Actual data safety depends on your database permissions, connection security, and access controls."
      },
      {
        "question": "Why is my projection falling behind?",
        "answer": "Check event batch size, database query performance, and ensure proper indexing on your read model tables for event data access patterns."
      },
      {
        "question": "How is this different from ETL pipelines?",
        "answer": "Projections process events in order as they occur, maintaining state. ETL typically runs batch jobs on historical data without real-time updates."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
