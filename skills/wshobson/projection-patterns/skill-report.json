{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-17T09:15:42.879Z",
    "slug": "wshobson-projection-patterns",
    "source_url": "https://github.com/wshobson/agents/tree/main/plugins/backend-development/skills/projection-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "135da8d35a92b0dadba8d4af9bc96edfeec25198e21dc104eaf497ef9996ab93",
    "tree_hash": "42330a9e94c501ef355dcfe594418c53debfbf00794278d019bda81948ed6900"
  },
  "skill": {
    "name": "projection-patterns",
    "description": "Build read models and projections from event streams. Use when implementing CQRS read sides, building materialized views, or optimizing query performance in event-sourced systems.",
    "summary": "Build read models and projections from event streams. Use when implementing CQRS read sides, buildin...",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "wshobson",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "cqrs",
      "event-sourcing",
      "projections",
      "read-models",
      "event-streaming"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill is documentation-only containing Python code templates for CQRS projection patterns. Static scanner flagged 42 patterns, but all are false positives triggered by documentation formatting and terminology. No executable code, network calls, or system modifications exist. The skill only provides architectural guidance via markdown templates.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          },
          {
            "file": "SKILL.md",
            "line_start": 487,
            "line_end": 487
          },
          {
            "file": "SKILL.md",
            "line_start": 488,
            "line_end": 488
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 23,
            "line_end": 32
          },
          {
            "file": "SKILL.md",
            "line_start": 32,
            "line_end": 47
          },
          {
            "file": "SKILL.md",
            "line_start": 47,
            "line_end": 120
          },
          {
            "file": "SKILL.md",
            "line_start": 120,
            "line_end": 124
          },
          {
            "file": "SKILL.md",
            "line_start": 124,
            "line_end": 246
          },
          {
            "file": "SKILL.md",
            "line_start": 246,
            "line_end": 250
          },
          {
            "file": "SKILL.md",
            "line_start": 250,
            "line_end": 315
          },
          {
            "file": "SKILL.md",
            "line_start": 315,
            "line_end": 319
          },
          {
            "file": "SKILL.md",
            "line_start": 319,
            "line_end": 372
          },
          {
            "file": "SKILL.md",
            "line_start": 372,
            "line_end": 376
          },
          {
            "file": "SKILL.md",
            "line_start": 376,
            "line_end": 468
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 664,
    "audit_model": "claude",
    "audited_at": "2026-01-17T09:15:42.879Z"
  },
  "content": {
    "user_title": "Implement CQRS Projection Patterns",
    "value_statement": "Event-sourced systems need efficient read models for high-performance queries. This skill provides production-ready templates and patterns for building projections, read models, and materialized views from event streams using Python.",
    "seo_keywords": [
      "cqrs projections",
      "event sourcing",
      "read models",
      "materialized views",
      "claude code",
      "claude ai",
      "codex ai",
      "event stream processing",
      "cqrs read side",
      "projection patterns"
    ],
    "actual_capabilities": [
      "Design projection architectures with checkpoint-based event processing",
      "Build basic projector classes with event handling and read model updates",
      "Create aggregated projections for analytics dashboards and reporting",
      "Implement search indexes using Elasticsearch for full-text event search",
      "Develop multi-table projections with transactional consistency"
    ],
    "limitations": [
      "Requires an existing event store or message broker to function",
      "Database drivers must be installed separately for the templates",
      "Templates are architectural starting points, not production-ready solutions"
    ],
    "use_cases": [
      {
        "target_user": "Backend Developers",
        "title": "Build Read Models",
        "description": "Transform event streams into optimized read models for your CQRS architecture."
      },
      {
        "target_user": "Data Engineers",
        "title": "Create Analytics Views",
        "description": "Build real-time aggregated views for dashboards and reporting systems."
      },
      {
        "target_user": "System Architects",
        "title": "Design Event Systems",
        "description": "Plan and implement projection strategies for event-sourced microservices."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Projection",
        "scenario": "Create a simple event projector",
        "prompt": "Create a basic projection class that handles OrderCreated and OrderCompleted events from an event stream and updates a PostgreSQL read model."
      },
      {
        "title": "Multi-Table Update",
        "scenario": "Update multiple related tables",
        "prompt": "Write a projection that updates both a customer summary table and order history table when an OrderCompleted event occurs, using a single database transaction."
      },
      {
        "title": "Search Index Sync",
        "scenario": "Sync events to search index",
        "prompt": "Create an Elasticsearch projection that indexes product events for full-text search, handling create, update, and delete operations."
      },
      {
        "title": "Daily Metrics",
        "scenario": "Build daily aggregations",
        "prompt": "Write a projection that aggregates sales data by day, handling both completed orders and refunds with upsert logic."
      }
    ],
    "output_examples": [
      {
        "input": "Create a basic order summary projection",
        "output": [
          "Event handler for OrderCreated: Insert new order summary record with customer data",
          "Event handler for OrderItemAdded: Update total_amount and increment item_count",
          "Event handler for OrderShipped: Set status to shipped and record shipped_at timestamp",
          "Checkpoint tracking: Store global_position after each processed event",
          "Idempotent design: Safe to replay events on system restart"
        ]
      },
      {
        "input": "Build a customer activity tracker projection",
        "output": [
          "CustomerCreated handler: Insert customer record and initialize activity summary",
          "OrderCompleted handler: Update total_orders and total_spent in summary table",
          "OrderCompleted handler: Insert into order history table for audit trail",
          "ReviewSubmitted handler: Increment review count and record last review date",
          "CustomerTierChanged handler: Update tier and tier change timestamp"
        ]
      },
      {
        "input": "Implement a real-time sales dashboard projection",
        "output": [
          "OrderCompleted handler: Upsert daily sales record with new order totals",
          "OrderRefunded handler: Decrement revenue and increment refund totals",
          "Date extraction: Parse completion date to group sales by day",
          "Atomic updates: Use database ON CONFLICT for race condition safety",
          "Metric calculations: Track total orders, revenue, items, and refunds per day"
        ]
      }
    ],
    "best_practices": [
      "Make projections idempotent so they can safely replay events after failures or restarts",
      "Use database transactions when a single event updates multiple related tables",
      "Store checkpoints to enable resumption from the last processed event position"
    ],
    "anti_patterns": [
      "Coupling projections together creates cascade failures and tight ordering dependencies",
      "Skipping error handling causes silent failures and data inconsistency in read models",
      "Over-normalizing read models defeats the purpose of projections by adding join complexity"
    ],
    "faq": [
      {
        "question": "Which databases work with these projections?",
        "answer": "Templates use asyncpg for PostgreSQL but the patterns apply to any async database driver like SQLAlchemy or databases with async support."
      },
      {
        "question": "How do projections handle high event volumes?",
        "answer": "Implement batch processing with configurable batch_size and checkpointing to manage memory and enable restart capability."
      },
      {
        "question": "Can I use these patterns with Kafka?",
        "answer": "Yes, the projector pattern works with any event source. Replace the event_store.read_all() call with your Kafka consumer logic."
      },
      {
        "question": "Is my data safe with these projections?",
        "answer": "These are architectural templates. Actual data safety depends on your database permissions, connection security, and access controls."
      },
      {
        "question": "Why is my projection falling behind the event stream?",
        "answer": "Check event batch size, database query performance, and ensure proper indexing on read model tables for event data patterns."
      },
      {
        "question": "How is this different from ETL pipelines?",
        "answer": "Projections process events in order as they occur, maintaining state. ETL typically runs batch jobs on historical data without real-time updates."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 489
    }
  ]
}
