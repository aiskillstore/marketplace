{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T19:28:41.575Z",
    "slug": "wshobson-microservices-patterns",
    "source_url": "https://github.com/wshobson/agents/tree/main/plugins/backend-development/skills/microservices-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "fa4bfd6c9de32d3efbb2de99d46ac37d8c79da9acd10940ba4d5930f4c7b07de",
    "tree_hash": "5bb10b0f5ce18ae6b9cdcbc0f75eae074fe0a7c6ae03623b0b5bdf40328a439b"
  },
  "skill": {
    "name": "microservices-patterns",
    "description": "Design microservices architectures with service boundaries, event-driven communication, and resilience patterns. Use when building distributed systems, decomposing monoliths, or implementing microservices.",
    "summary": "Design and implement microservices architectures with service decomposition, inter-service communication, and resilience patterns.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "wshobson",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "microservices",
      "distributed-systems",
      "architecture",
      "event-driven",
      "resilience"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Static analysis detected 36 patterns across 2 files. All findings evaluated as false positives or safe educational content. The 18 weak crypto alerts match on words like design and description in documentation. The 11 external command alerts are markdown code fences for syntax highlighting. Network patterns are legitimate example URLs for teaching microservices communication. No actual security risks identified.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          },
          {
            "file": "SKILL.md",
            "line_start": 172,
            "line_end": 172
          },
          {
            "file": "SKILL.md",
            "line_start": 161,
            "line_end": 161
          },
          {
            "file": "SKILL.md",
            "line_start": 164,
            "line_end": 164
          },
          {
            "file": "SKILL.md",
            "line_start": 165,
            "line_end": 165
          },
          {
            "file": "SKILL.md",
            "line_start": 166,
            "line_end": 166
          },
          {
            "file": "SKILL.md",
            "line_start": 253,
            "line_end": 253
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 81,
            "line_end": 149
          },
          {
            "file": "SKILL.md",
            "line_start": 149,
            "line_end": 153
          },
          {
            "file": "SKILL.md",
            "line_start": 153,
            "line_end": 215
          },
          {
            "file": "SKILL.md",
            "line_start": 215,
            "line_end": 221
          },
          {
            "file": "SKILL.md",
            "line_start": 221,
            "line_end": 255
          },
          {
            "file": "SKILL.md",
            "line_start": 255,
            "line_end": 259
          },
          {
            "file": "SKILL.md",
            "line_start": 259,
            "line_end": 340
          },
          {
            "file": "SKILL.md",
            "line_start": 340,
            "line_end": 344
          },
          {
            "file": "SKILL.md",
            "line_start": 344,
            "line_end": 465
          },
          {
            "file": "SKILL.md",
            "line_start": 465,
            "line_end": 471
          },
          {
            "file": "SKILL.md",
            "line_start": 471,
            "line_end": 554
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 1025,
    "audit_model": "claude",
    "audited_at": "2026-01-21T19:28:41.575Z"
  },
  "content": {
    "user_title": "Design Microservices Architectures with Proven Patterns",
    "value_statement": "Building distributed systems with microservices introduces complexity in service boundaries, inter-service communication, and fault tolerance. This skill provides battle-tested patterns for service decomposition, event-driven architecture, saga coordination, and circuit breaker implementation to help you build resilient, scalable systems.",
    "seo_keywords": [
      "microservices architecture",
      "distributed systems design",
      "service decomposition",
      "event-driven architecture",
      "circuit breaker pattern",
      "saga pattern",
      "API gateway",
      "microservices patterns",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Design service boundaries using business capability and subdomain decomposition",
      "Implement synchronous REST and gRPC communication between services",
      "Build event-driven architectures with Apache Kafka message streaming",
      "Implement saga pattern for distributed transactions with compensating actions",
      "Apply circuit breaker pattern to prevent cascade failures in service calls",
      "Create API gateways for request routing and aggregate responses from multiple services"
    ],
    "limitations": [
      "Does not generate complete production-ready microservices applications",
      "Does not provide infrastructure-as-code templates for deployment",
      "Does not include service mesh configuration examples (Istio, Linkerd)",
      "Does not cover database migration strategies between services"
    ],
    "use_cases": [
      {
        "title": "Migrate a Monolith to Microservices",
        "description": "Apply the Strangler Fig pattern to gradually extract functionality from a legacy monolith into independently deployable services while maintaining system stability.",
        "target_user": "Backend engineers modernizing legacy applications"
      },
      {
        "title": "Build Event-Driven Order Processing",
        "description": "Design an order management system where Order, Payment, and Inventory services communicate asynchronously through Kafka events with saga-based compensation for failed transactions.",
        "target_user": "System architects designing new distributed platforms"
      },
      {
        "title": "Add Resilience to Service Calls",
        "description": "Implement circuit breakers and retry with exponential backoff to protect services from cascade failures and improve overall system reliability under partial outages.",
        "target_user": "DevOps engineers improving system reliability"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Service Decomposition",
        "prompt": "Help me decompose my {application_type} application into microservices. The application has these main functions: {list_functions}. How should I define service boundaries and what decomposition strategy should I use?",
        "scenario": "When starting a new microservices project or migrating from monolith"
      },
      {
        "title": "API Gateway Design",
        "prompt": "Design an API gateway pattern for my microservices architecture. I have these services: {list_services}. How should the gateway handle authentication, rate limiting, and request aggregation?",
        "scenario": "When clients need a unified entry point to multiple backend services"
      },
      {
        "title": "Saga Pattern Implementation",
        "prompt": "Help me implement a saga pattern for a {business_process} that involves these steps: {list_steps}. What compensating actions should I define for each step and how should I handle partial failures?",
        "scenario": "When implementing distributed transactions across multiple services"
      },
      {
        "title": "Circuit Breaker Configuration",
        "prompt": "I have a {service_name} service that occasionally experiences latency spikes. How should I configure the circuit breaker parameters (failure_threshold, recovery_timeout, success_threshold) and integrate it with my existing HTTP client?",
        "scenario": "When protecting services from cascade failures during outages"
      }
    ],
    "output_examples": [
      {
        "input": "How should I decompose an e-commerce platform into microservices?",
        "output": [
          "For an e-commerce platform, I recommend organizing services around business capabilities:",
          "",
          "1. **Order Service** - Manages order lifecycle, cart, and order history",
          "2. **Payment Service** - Handles payment processing, refunds, and payment methods",
          "3. **Inventory Service** - Tracks product stock, reservations, and warehouse locations",
          "4. **Catalog Service** - Product listings, search, and category management",
          "5. **User Service** - Authentication, profiles, and preferences",
          "6. **Shipping Service** - Delivery tracking, label generation, and carrier integration",
          "",
          "Each service owns its own database and communicates through well-defined APIs or events. The Order Service publishes OrderCreated events that Payment and Inventory services consume to process their respective operations asynchronously."
        ]
      },
      {
        "input": "How do I handle a payment failure in my order fulfillment saga?",
        "output": [
          "When the payment step fails in the OrderFulfillmentSaga, the saga orchestrator triggers compensating actions in reverse order:",
          "",
          "1. Payment failed - no compensation needed for payment",
          "2. Compensate inventory: Release the reservation by calling InventoryService.release(reservation_id)",
          "3. Compensate order: Cancel the order by calling OrderService.cancel(order_id)",
          "4. Return a failed result with error details to the client",
          "",
          "The key is designing each compensation action to be idempotent and handling cases where the compensation itself might partially fail. Log all compensation actions and alert operators for manual intervention when needed."
        ]
      },
      {
        "input": "Why is my circuit breaker opening immediately and how should I tune it?",
        "output": [
          "A circuit breaker opens when failures exceed the failure_threshold within a sliding window. Common causes and solutions:",
          "",
          "**If it opens too easily:**",
          "- Increase failure_threshold (try 10 instead of 5)",
          "- Increase recovery_timeout (try 60 seconds instead of 30)",
          "- Add a success_threshold to require multiple successes before closing",
          "",
          "**If it stays open too long:**",
          "- Decrease recovery_timeout for faster testing",
          "- Use adaptive thresholds based on traffic volume",
          "",
          "**Best practices:**",
          "- Set failure_threshold based on your service's normal error rate",
          "- Set recovery_timeout longer than your typical outage duration",
          "- Monitor circuit state changes to tune parameters"
        ]
      }
    ],
    "best_practices": [
      "Define clear service boundaries aligned with business capabilities rather than technical layers to ensure loose coupling and high cohesion",
      "Use asynchronous event-driven communication for operations that can tolerate eventual consistency to improve system resilience and reduce blocking dependencies",
      "Always implement circuit breakers on inter-service calls and configure timeouts that are shorter than the client-imposed timeout budget"
    ],
    "anti_patterns": [
      "Distributed Monolith - Creating microservices that are tightly coupled through shared databases or synchronous chains of dependencies, losing the benefits of independent deployment",
      "Chatty Services - Designing services that require dozens of back-and-forth calls to complete a single user request, increasing latency and failure points",
      "Synchronous Everything - Using request-response communication for all inter-service communication, creating tight coupling and preventing independent scaling and failure isolation"
    ],
    "faq": [
      {
        "question": "When should I choose microservices over a monolith?",
        "answer": "Consider microservices when your team needs independent deployment cycles, different services require different technology stacks, or you need horizontal scaling for specific components. Start with a monolith if your application is simple or your team is small, then decompose as complexity grows."
      },
      {
        "question": "How do I maintain data consistency across microservices without distributed transactions?",
        "answer": "Use the Saga pattern with compensating transactions. Each service performs its operation and publishes an event. If a later step fails, previous steps execute compensating actions to undo their work. Accept eventual consistency instead of strong consistency for most use cases."
      },
      {
        "question": "What is the difference between choreography and orchestration for sagas?",
        "answer": "Choreography uses events where each service reacts to events from other services without a central coordinator. Orchestration uses a central saga orchestrator that directs the flow by calling each service step. Orchestration provides better observability and debugging while choreography reduces coupling."
      },
      {
        "question": "How do I handle authentication across multiple microservices?",
        "answer": "Use API gateway pattern where the gateway handles authentication and passes user context to backend services. Services validate tokens issued by a central identity provider. Consider JWT tokens that can be validated independently by each service without calling the auth service."
      },
      {
        "question": "What timeout values should I use for inter-service calls?",
        "answer": "Follow the timeout budgeting pattern: set total client timeout, then allocate portions to each service call. Use aggressive timeouts (1-5 seconds) for critical paths and longer timeouts (10-30 seconds) for operations that legitimately take longer. Always use read timeouts, not just connection timeouts."
      },
      {
        "question": "How do I test microservices that depend on each other?",
        "answer": "Use the testing pyramid: unit tests for individual services with mocked dependencies, contract tests to verify API compatibility between services, integration tests with real dependencies in containers, and end-to-end tests for critical user journeys. Consider tools like Pact for contract testing."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 586
    }
  ]
}
