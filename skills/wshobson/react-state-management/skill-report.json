{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T17:09:26.081Z",
    "slug": "wshobson-react-state-management",
    "source_url": "https://github.com/wshobson/agents/tree/main/plugins/frontend-mobile-development/skills/react-state-management",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "83d867232cf464c30f053993a86d3e08fc80fa6c4bafc8123fe66f62afef350e",
    "tree_hash": "1e87c558e7acb4691e1c64e675227ff944cd2d1ab377ae880dc79ca5209e7dba"
  },
  "skill": {
    "name": "react-state-management",
    "description": "Master modern React state management with Redux Toolkit, Zustand, Jotai, and React Query. Use when setting up global state, managing server state, or choosing between state management solutions.",
    "summary": "Master modern React state management patterns including Redux Toolkit, Zustand, Jotai, and React Query for global state, server state, and caching.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "wshobson",
    "license": "MIT",
    "tags": [
      "react",
      "redux",
      "zustand",
      "jotai",
      "react-query",
      "state-management",
      "frontend"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All 44 static findings are false positives. The scanner incorrectly flagged markdown code blocks as shell commands, standard documentation URLs as hardcoded secrets, and React/Redux patterns (state, slices, selectors) as cryptographic or reconnaissance patterns. This is legitimate documentation for React state management libraries.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 915,
    "audit_model": "claude",
    "audited_at": "2026-01-21T17:09:26.081Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Implement React State Management",
    "value_statement": "Managing state across React components can lead to complex code and inconsistent data. This skill provides comprehensive patterns for Redux Toolkit, Zustand, Jotai, and React Query to handle local, global, and server state efficiently.",
    "seo_keywords": [
      "React state management",
      "Redux Toolkit tutorial",
      "Zustand state manager",
      "Jotai atoms",
      "React Query caching",
      "React global state",
      "Claude Code",
      "Codex",
      "Claude Code state management",
      "React hooks state"
    ],
    "actual_capabilities": [
      "Explain Redux Toolkit patterns including slices, thunks, and typed hooks",
      "Show Zustand store creation with persistence and devtools middleware",
      "Demonstrate Jotai atomic state with derived atoms and storage sync",
      "Implement React Query for server state with caching and optimistic updates",
      "Compare state management solutions and recommend based on app complexity",
      "Combine multiple state approaches (client + server state) in one app"
    ],
    "limitations": [
      "Does not write code directly - provides guidance and patterns for implementation",
      "Does not set up projects or install dependencies",
      "Does not debug existing state issues or performance problems",
      "Does not integrate with specific backend frameworks or databases"
    ],
    "use_cases": [
      {
        "title": "Choosing a State Solution for a New Project",
        "description": "A development team starting a new React application needs to select the right state management approach based on app size and requirements.",
        "target_user": "Development teams starting new React projects"
      },
      {
        "title": "Implementing Server Data Caching",
        "description": "A frontend developer wants to add caching, background refetching, and optimistic updates for API data in a React application.",
        "target_user": "Frontend developers building data-driven applications"
      },
      {
        "title": "Migrating Legacy Redux to Modern Patterns",
        "description": "A developer needs to update verbose Redux boilerplate code to Redux Toolkit with Immer for immutable updates.",
        "target_user": "Developers maintaining legacy React Redux codebases"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic: Redux Toolkit Setup",
        "prompt": "How do I set up Redux Toolkit with TypeScript in a React app? Show how to create a store with slices and typed useDispatch and useSelector hooks.",
        "scenario": "Setting up Redux Toolkit for the first time"
      },
      {
        "title": "Intermediate: Zustand with Persistence",
        "prompt": "Show me how to create a Zustand store that persists to localStorage with devtools support. Include how to access the store in components and handle typed state updates.",
        "scenario": "Creating a persistent client-side store"
      },
      {
        "title": "Advanced: React Query with Optimistic Updates",
        "prompt": "Write a React Query mutation that performs optimistic updates. Include onMutate for snapshotting previous state, onError for rollback, and onSettled for refetching.",
        "scenario": "Implementing data mutations with rollback support"
      },
      {
        "title": "Expert: Combining Multiple State Approaches",
        "prompt": "How do I combine React Query for server state with Zustand for client-only state in the same application? Show the separation of concerns and how components consume both.",
        "scenario": "Architecting hybrid state architecture"
      }
    ],
    "output_examples": [
      {
        "input": "What state management library should I use for a small app with simple global state needs?",
        "output": "For small applications with simple global state, Zustand or Jotai are excellent choices:\n\n**Zustand** offers the simplest API with minimal boilerplate:\n- Create stores with a single hook-like function\n- Built-in devtools and persistence middleware\n- No providers required\n- Selective subscriptions prevent unnecessary re-renders\n\n**Jotai** excels when you want atomic, granular updates:\n- Each piece of state is an independent atom\n- Derived atoms compute from other atoms automatically\n- Perfect for fine-grained reactivity\n\nChoose Zustand if you prefer a unified store model. Choose Jotai if you want atomic updates without a global store wrapper."
      },
      {
        "input": "How do I handle server state with React Query vs client state with Redux Toolkit?",
        "output": "Keep server state and client state separate for clarity and maintainability:\n\n**React Query handles server state:**\n- Server data, caching, and synchronization\n- Automatic refetching and background updates\n- Stale-while-revalidate caching strategy\n- Optimistic mutations with rollback\n\n**Redux Toolkit handles client state:**\n- User interface state (modals, sidebar open/close)\n- Authentication state (when not in cookies)\n- Application preferences and settings\n- Complex client-side derived state\n\nThis separation prevents mixing concerns and makes debugging easier since each tool has a clear purpose."
      }
    ],
    "best_practices": [
      "Colocate state as close to where it is used as possible - avoid putting everything in global state",
      "Use selectors to select only the needed data from stores to prevent unnecessary component re-renders",
      "Separate server state (React Query) from client state (Zustand/Redux) - each has different update patterns and lifetimes"
    ],
    "anti_patterns": [
      "Putting every piece of state in global state just because it is accessed by multiple components - local state is often sufficient",
      "Mutating state directly instead of using immutable update patterns or libraries like Immer",
      "Duplicating server state in both React Query and client stores - let React Query be the single source of truth for server data"
    ],
    "faq": [
      {
        "question": "What is the difference between Redux Toolkit, Zustand, and Jotai?",
        "answer": "Redux Toolkit is the modern Redux with Immer for immutable updates, best for large apps needing Redux DevTools and TypeScript support. Zustand is minimal and unopinionated, great for simple to medium apps. Jotai uses atomic state where each piece is independent, ideal for fine-grained reactivity and small bundles."
      },
      {
        "question": "When should I use React Query over Redux for data?",
        "answer": "Use React Query for server data that comes from an API. It handles caching, background refetching, deduping requests, and optimistic updates automatically. Use Redux only for client state that React Query cannot manage, such as UI state or authentication tokens."
      },
      {
        "question": "How do I persist state in Zustand?",
        "answer": "Import the persist middleware from zustand/middleware and add it to your store configuration. The middleware accepts a name for localStorage and optional filters to exclude certain state from persistence. Zustand handles reading and writing to localStorage automatically."
      },
      {
        "question": "Can I use multiple state management libraries together?",
        "answer": "Yes, combining libraries is common and recommended. Use React Query for server state, Zustand or Redux for client state, and Jotai for atomic state. Each serves a different purpose and they work well together without conflicts."
      },
      {
        "question": "How do I debug state with Redux DevTools?",
        "answer": "Redux Toolkit includes devtools by default when using the configureStore function. The devtools browser extension shows action history, state changes, and time-travel debugging. Zustand also supports devtools through the devtools middleware."
      },
      {
        "question": "What is the recommended state structure for large apps?",
        "answer": "Normalize state similar to a database with entities keyed by ID. Use separate slices or stores for different domains (user, products, cart). Keep state flat and avoid nesting to make updates easier and prevent deep comparisons."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 430
    }
  ]
}
