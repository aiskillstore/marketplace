{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-04T17:08:12.891Z",
    "slug": "wshobson-distributed-tracing",
    "source_url": "https://github.com/wshobson/agents/tree/main/plugins/observability-monitoring/skills/distributed-tracing",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "f027ee2b349b310b0dd01a45f5e23a2e4f01aaa8395ced10cdeb6fbd8c9a3c56",
    "tree_hash": "5f9fab7e1492574c3319e06fcb8f92ec30b79d42819a0df5377780ba6c8a372e"
  },
  "skill": {
    "name": "distributed-tracing",
    "description": "Implement distributed tracing with Jaeger and Tempo to track requests across microservices and identify performance bottlenecks. Use when debugging microservices, analyzing request flows, or implementing observability for distributed systems.",
    "summary": "Implement distributed tracing with Jaeger and Tempo to track requests across microservices and ident...",
    "icon": "ðŸ§­",
    "version": "1.0.0",
    "author": "wshobson",
    "license": "MIT",
    "category": "devops",
    "tags": [
      "observability",
      "tracing",
      "microservices",
      "opentelemetry",
      "jaeger"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Documentation-only skill with no executable code. Contains only markdown guidance, code examples, and configuration templates for users to copy into their own applications. Zero attack surface - no data access, no network calls, no file operations, no command execution.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 4,
    "total_lines": 657,
    "audit_model": "claude",
    "audited_at": "2026-01-04T17:08:12.891Z"
  },
  "content": {
    "user_title": "Implement distributed tracing for microservices",
    "value_statement": "You need to understand request flows and latency across your services. This skill provides clear guidance on Jaeger, Tempo, and OpenTelemetry setup for distributed tracing implementation.",
    "seo_keywords": [
      "distributed tracing",
      "Jaeger",
      "Tempo",
      "OpenTelemetry",
      "microservices observability",
      "trace context propagation",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Explain trace, span, and context concepts with visual examples",
      "Provide Jaeger deployment configurations for Kubernetes and Docker Compose",
      "Show OpenTelemetry instrumentation patterns in Python, Node.js, and Go",
      "Describe trace context propagation headers and client implementations",
      "Outline sampling strategies for production cost control",
      "Guide troubleshooting missing traces and latency overhead issues"
    ],
    "limitations": [
      "Does not execute deployments or run any infrastructure commands",
      "Does not cover tracing vendors beyond Jaeger and Tempo",
      "Does not include production security hardening procedures",
      "Does not generate, validate, or modify user code automatically"
    ],
    "use_cases": [
      {
        "target_user": "Platform engineer",
        "title": "Cluster tracing rollout",
        "description": "Plan Jaeger or Tempo setup and sampling configuration for a Kubernetes environment."
      },
      {
        "target_user": "Backend developer",
        "title": "Service instrumentation",
        "description": "Add OpenTelemetry tracing to Python, Node.js, or Go microservices."
      },
      {
        "target_user": "SRE",
        "title": "Latency investigation",
        "description": "Analyze trace paths to identify slow spans and trace error propagation patterns."
      }
    ],
    "prompt_templates": [
      {
        "title": "Start tracing basics",
        "scenario": "New to distributed tracing",
        "prompt": "Explain trace, span, and context with a simple microservices example showing how requests flow between services."
      },
      {
        "title": "Jaeger quick setup",
        "scenario": "Need local dev stack",
        "prompt": "Give me a Docker Compose configuration for Jaeger and list the main ports I should expose for local development."
      },
      {
        "title": "Instrument a service",
        "scenario": "Add tracing to an API",
        "prompt": "Show how to instrument a Flask service with OpenTelemetry and configure it to send traces to a Jaeger collector."
      },
      {
        "title": "Sampling strategy",
        "scenario": "Control tracing cost",
        "prompt": "Recommend a sampling strategy for production environments and explain the tradeoffs between visibility and cost."
      }
    ],
    "output_examples": [
      {
        "input": "How do I troubleshoot missing traces in Jaeger?",
        "output": [
          "Check collector endpoint and port configuration in your exporter",
          "Verify network connectivity between your app and the collector",
          "Confirm sampling rate is not set to zero in your configuration",
          "Review application logs for exporter errors or connection failures"
        ]
      }
    ],
    "best_practices": [
      "Use consistent span naming and service identifiers across all services",
      "Propagate trace context across every service boundary using standard headers",
      "Tune sampling rates to balance observability cost and production visibility"
    ],
    "anti_patterns": [
      "Sampling 100% of traces in production without reviewing storage costs",
      "Omitting error logging and exception recording inside spans",
      "Using inconsistent service names across different services in the same trace"
    ],
    "faq": [
      {
        "question": "Is this skill compatible with Claude, Codex, and Claude Code?",
        "answer": "Yes. It provides vendor-neutral observability guidance that works in all three AI platforms."
      },
      {
        "question": "What are the limits of this skill?",
        "answer": "It is documentation-only content and does not execute commands or deploy infrastructure automatically."
      },
      {
        "question": "Can it integrate with my existing observability stack?",
        "answer": "Yes. It describes OpenTelemetry concepts that can be adapted to most observability platforms."
      },
      {
        "question": "Does it access or send my data?",
        "answer": "No. The skill contains only documentation and example code. It has no data access or network actions."
      },
      {
        "question": "What should I check if traces do not appear?",
        "answer": "Verify collector endpoints, check network connectivity, confirm sampling settings, and review application logs."
      },
      {
        "question": "How does it compare to vendor APM guides?",
        "answer": "It provides concise open-source focused guidance without requiring vendor-specific tooling or platforms."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
