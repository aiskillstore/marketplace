{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T19:21:15.170Z",
    "slug": "wshobson-error-handling-patterns",
    "source_url": "https://github.com/wshobson/agents/tree/main/plugins/developer-essentials/skills/error-handling-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "ae26a5ea7420910eab04ae2075df87695ab8a0781b0accfa0134bcf3177f0e45",
    "tree_hash": "8800c0576539ad69e98812d056c4e1b8d95f87816f6f80baa54212a2632955aa"
  },
  "skill": {
    "name": "error-handling-patterns",
    "description": "Master error handling patterns across languages including exceptions, Result types, error propagation, and graceful degradation to build resilient applications. Use when implementing error handling, designing APIs, or improving application reliability.",
    "summary": "Master error handling patterns across languages including exceptions, Result types, error propagatio...",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "wshobson",
    "license": "MIT",
    "tags": [
      "error-handling",
      "resilience",
      "exceptions",
      "debugging",
      "reliability"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings are false positives. The skill is legitimate educational documentation about error handling patterns across Python, TypeScript, Rust, and Go. Static scanner misidentified 'error' keywords as cryptographic issues and Markdown code fences as shell backticks. No actual network calls, command execution, or malicious patterns exist in the skill content.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 1236,
    "audit_model": "claude",
    "audited_at": "2026-01-21T19:21:15.170Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Implement robust error handling patterns",
    "value_statement": "Applications often fail unexpectedly due to poor error handling. This skill provides battle-tested patterns for exceptions, Result types, circuit breakers, and graceful degradation across Python, TypeScript, Rust, and Go.",
    "seo_keywords": [
      "error handling",
      "exception handling",
      "circuit breaker pattern",
      "error recovery",
      "graceful degradation",
      "Result types",
      "Claude error handling",
      "Codex error patterns",
      "Claude Code debugging",
      "resilient applications"
    ],
    "actual_capabilities": [
      "Generate custom exception hierarchies in Python, TypeScript, Rust, and Go",
      "Implement Result type patterns for explicit error handling",
      "Create circuit breakers to prevent cascading failures",
      "Build retry logic with exponential backoff for network operations",
      "Design error aggregation for collecting multiple validation errors",
      "Implement graceful degradation with fallback strategies"
    ],
    "limitations": [
      "Does not execute code or interact with live systems",
      "Does not provide runtime error monitoring or alerting",
      "Does not integrate with specific error tracking services",
      "Focuses on patterns rather than language-specific framework implementations"
    ],
    "use_cases": [
      {
        "title": "Build production-grade API error handling",
        "description": "Design error handling for a new REST API that returns consistent error responses with proper HTTP status codes, error codes, and helpful messages for API consumers.",
        "target_user": "Backend developers building APIs"
      },
      {
        "title": "Add resilience to distributed systems",
        "description": "Implement circuit breaker and retry patterns to prevent cascading failures when external services become unavailable, ensuring the system degrades gracefully.",
        "target_user": "Platform engineers and architects"
      },
      {
        "title": "Improve code review feedback on error handling",
        "description": "Provide specific, actionable feedback on error handling in pull requests, identifying anti-patterns like empty catch blocks or overly broad exception handling.",
        "target_user": "Senior developers and tech leads"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic error handling implementation",
        "prompt": "I need error handling for a {language} function that calls an external API. The function should retry on network failures with exponential backoff, include proper error types, and provide clear error messages for debugging.",
        "scenario": "Adding error handling to API calls"
      },
      {
        "title": "Custom exception hierarchy design",
        "prompt": "Design a custom exception hierarchy for a {application_type} application. Include base exception class, specific error types for validation, not found, and external service failures. Each exception should include error code, timestamp, and relevant context.",
        "scenario": "Designing application-wide error taxonomy"
      },
      {
        "title": "Circuit breaker integration",
        "prompt": "Implement a circuit breaker pattern for a service that makes calls to an unreliable third-party API. Include configuration for failure threshold, timeout duration, and half-open state for recovery testing.",
        "scenario": "Adding fault tolerance to external service calls"
      },
      {
        "title": "Multi-error validation aggregation",
        "prompt": "Create a validation system that collects all validation errors rather than failing on the first one. Show how to aggregate errors from multiple fields and return them as a structured response.",
        "scenario": "Building user-friendly form validation"
      }
    ],
    "output_examples": [
      {
        "input": "Add error handling to a function that reads a file and parses JSON content.",
        "output": "Here is a pattern for robust file handling with proper error hierarchy:\n\n**Python Example:**\n```python\nclass FileReadError(ApplicationError):\n    \"\"\"Raised when file read operations fail.\"\"\"\n    pass\n\nclass ParseError(ApplicationError):\n    \"\"\"Raised when JSON parsing fails.\"\"\"\n    pass\n\ndef read_json_file(path: str) -> dict:\n    try:\n        with open(path, 'r') as f:\n            content = f.read()\n        return json.loads(content)\n    except FileNotFoundError as e:\n        raise FileReadError(f\"File not found: {path}\", details={\"path\": path}) from e\n    except json.JSONDecodeError as e:\n        raise ParseError(f\"Invalid JSON in file: {path}\", details={\"path\": path, \"error\": str(e)}) from e\n```\n\n**Key practices:**\n- Use specific exception types for different error scenarios\n- Include contextual information in exceptions\n- Chain exceptions to preserve original stack trace\n- Use context managers for automatic resource cleanup"
      },
      {
        "input": "How should I handle errors in an async function that calls multiple services in parallel?",
        "output": "For parallel service calls, consider these strategies:\n\n**Option 1: Aggregate Errors**\nCollect all errors and report them together rather than failing on the first error.\n\n```typescript\nasync function fetchUserData(userId: string): Promise<UserData> {\n    const errors: Error[] = [];\n    let user: User | null = null;\n    let orders: Order[] = [];\n    \n    try { user = await userService.getUser(userId); }\n    catch (e) { errors.push(e); }\n    \n    try { orders = await orderService.getOrders(userId); }\n    catch (e) { errors.push(e); }\n    \n    if (errors.length > 0) {\n        throw new AggregateError(errors, `${errors.length} operations failed`);\n    }\n    \n    return { user, orders };\n}\n```\n\n**Option 2: Result Types**\nUse explicit success/failure types for each operation.\n\n```typescript\nasync function fetchUserData(userId: string): Promise<Result<UserData>> {\n    const [userResult, ordersResult] = await Promise.all([\n        safePromise(userService.getUser(userId)),\n        safePromise(orderService.getOrders(userId))\n    ]);\n    \n    if (!userResult.ok) return Err(userResult.error);\n    if (!ordersResult.ok) return Err(ordersResult.error);\n    \n    return Ok({ user: userResult.value, orders: ordersResult.value });\n}\n```"
      },
      {
        "input": "What are the worst error handling anti-patterns to avoid?",
        "output": "Here are the most dangerous anti-patterns and their fixes:\n\n**Anti-Pattern 1: Empty Catch Blocks**\n```python\ntry:\n    do_something()\nexcept:\n    pass  # Silent failure - bugs hide forever\n```\n**Fix:** Always log or re-raise exceptions.\n\n**Anti-Pattern 2: Catching Too Broadly**\n```python\ntry:\n    do_something()\nexcept Exception:\n    # Hides bugs including typos and logic errors\n    pass\n```\n**Fix:** Catch specific exception types only.\n\n**Anti-Pattern 3: Swallowing After Logging**\n```python\ntry:\n    do_something()\nexcept Exception as e:\n    logger.error(e)\n    # Error logged but not handled - caller doesn't know it failed\n```\n**Fix:** Re-raise or return error result.\n\n**Anti-Pattern 4: Overly Generic Errors**\n```python\nraise Exception(\"Error occurred\")  # No context, no code, useless for debugging\n```\n**Fix:** Include what happened, what was being processed, and error codes."
      }
    ],
    "best_practices": [
      "Create specific exception types with contextual information including error codes, timestamps, and relevant metadata for debugging",
      "Use Result types or explicit error returns for expected failures to make error handling forced and visible at compile time where possible",
      "Implement circuit breakers for external dependencies to prevent cascading failures and allow graceful degradation",
      "Log errors with appropriate severity - error-level for actual problems, warning for expected failures, never for normal flow"
    ],
    "anti_patterns": [
      "Empty catch blocks that silently swallow errors, hiding bugs and making debugging impossible",
      "Overly broad exception handlers like `except Exception` that mask programming errors alongside expected failures",
      "Logging exceptions without re-raising them, creating duplicate log entries and confusing control flow",
      "Returning generic error codes instead of typed exceptions, making error handling verbose and error-prone"
    ],
    "faq": [
      {
        "question": "When should I use exceptions versus Result types?",
        "answer": "Use exceptions for unexpected, exceptional conditions like network failures, file not found, or programming bugs. Use Result types for expected failures like validation errors, rate limiting, or business rule violations. Exceptions disrupt control flow while Result types make error handling explicit and forced."
      },
      {
        "question": "How do I design a good error hierarchy?",
        "answer": "Start with a base ApplicationError that captures common fields like timestamp, error code, and context. Create specific subclasses for each error domain: ValidationError, NotFoundError, ExternalServiceError, AuthenticationError. Avoid deep inheritance hierarchies - 2-3 levels is typically sufficient."
      },
      {
        "question": "What is a circuit breaker and when should I use one?",
        "answer": "A circuit breaker prevents cascading failures by stopping requests to a failing service. It has three states: closed (normal operation), open (requests fail fast), and half-open (testing recovery). Use it for any external service call where repeated failures could exhaust resources or affect user experience."
      },
      {
        "question": "How should I handle errors in async code?",
        "answer": "In async/await code, use try/catch around await statements. For Promise chains, always add .catch() handlers. Be careful with unhandled promise rejections - they can crash Node.js processes. Consider Result types for async operations to make failures explicit."
      },
      {
        "question": "What information should I include in error messages?",
        "answer": "Include what operation was attempted, what the input or resource was, why it failed, and what the user or developer can do about it. Avoid exposing sensitive data. Use structured formats with error codes for programmatic handling."
      },
      {
        "question": "How do I test error handling effectively?",
        "answer": "Test each error path explicitly using mocking to trigger specific failures. Verify that errors contain expected context and codes. Test retry logic by simulating transient failures. Ensure circuit breakers transition between states correctly under failure conditions."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 637
    }
  ]
}
