{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T19:01:03.551Z",
    "slug": "wshobson-debugging-strategies",
    "source_url": "https://github.com/wshobson/agents/tree/main/plugins/developer-essentials/skills/debugging-strategies",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "921b1570df8c9e8e941b6dd979e11a21ecad32b5e73e727fc71b2f2c80e16adc",
    "tree_hash": "5429a5227b2e8d44c81e7d923394b0d036251bf04da401a33fd74f86d899ba0a"
  },
  "skill": {
    "name": "debugging-strategies",
    "description": "Master systematic debugging techniques, profiling tools, and root cause analysis to efficiently track down bugs across any codebase or technology stack. Use when investigating bugs, performance issues, or unexpected behavior.",
    "summary": "Master systematic debugging techniques, profiling tools, and root cause analysis to efficiently trac...",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "wshobson",
    "license": "MIT",
    "tags": [
      "debugging",
      "troubleshooting",
      "performance",
      "code-analysis",
      "developer-tools"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Static analysis detected 54 potential issues, all confirmed as false positives. The 'scripts' patterns are Go import statements in code examples. 'External_commands' are markdown backticks used for code formatting. 'Weak cryptographic algorithm' flags are triggered by Go standard library package names (crypto/pprof). 'Network' URLs are GitHub source URLs and localhost debugging endpoints. All findings are legitimate documentation content with no security concerns.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 1137,
    "audit_model": "claude",
    "audited_at": "2026-01-21T19:01:03.551Z"
  },
  "content": {
    "user_title": "Apply Systematic Debugging Strategies",
    "value_statement": "Debugging complex software issues often feels random and frustrating. This skill provides systematic debugging techniques, profiling tools, and root cause analysis methods that transform troubleshooting into a methodical process.",
    "seo_keywords": [
      "debugging",
      "troubleshooting",
      "bug fixing",
      "error debugging",
      "debugging techniques",
      "performance profiling",
      "Claude",
      "Codex",
      "Claude Code",
      "root cause analysis"
    ],
    "actual_capabilities": [
      "Apply systematic debugging methodology using the scientific method",
      "Debug JavaScript, TypeScript, Python, and Go code with language-specific tools",
      "Use profiling tools to identify performance bottlenecks",
      "Implement advanced techniques like binary search debugging and git bisect",
      "Detect and resolve memory leaks and race conditions",
      "Debug production issues safely using logging and monitoring"
    ],
    "limitations": [
      "Cannot directly access or modify external codebases",
      "Cannot execute debugging commands on user systems",
      "Cannot install or configure debugging tools",
      "Provides guidance and strategies only, not automated fixes"
    ],
    "use_cases": [
      {
        "title": "Fix elusive production bugs",
        "description": "Apply systematic debugging techniques to track down hard-to-reproduce issues in production environments using logging, stack trace analysis, and differential debugging.",
        "target_user": "Software engineers debugging production incidents"
      },
      {
        "title": "Optimize slow application performance",
        "description": "Use profiling tools and techniques to identify performance bottlenecks, memory leaks, and inefficient code patterns across JavaScript, Python, and Go applications.",
        "target_user": "Developers optimizing application performance"
      },
      {
        "title": "Learn structured debugging approaches",
        "description": "Master the scientific method for debugging, rubber duck debugging, and systematic problem isolation to become more effective at troubleshooting any code issue.",
        "target_user": "Junior developers learning debugging skills"
      }
    ],
    "prompt_templates": [
      {
        "title": "Debug a specific error",
        "prompt": "I'm seeing this error in my application: [insert error message and stack trace]. Apply systematic debugging techniques to help me identify the root cause. Walk through the scientific method: observe, hypothesize, experiment, analyze.",
        "scenario": "When you encounter an error message or exception you do not understand"
      },
      {
        "title": "Profile performance bottleneck",
        "description": "My [application type] application is running slowly. Help me use profiling tools to identify the bottleneck. Include step-by-step instructions for using [Chrome DevTools / cProfile / pprof] to find where the time is being spent.",
        "prompt": "My [application type] application is running slowly. Help me use profiling tools to identify the bottleneck. Include step-by-step instructions for using [Chrome DevTools / cProfile / pprof] to find where the time is being spent."
      },
      {
        "title": "Debug race condition",
        "description": "I have an intermittent bug that only happens sometimes and seems related to async operations. Guide me through debugging race conditions using trace logging and timing analysis.",
        "prompt": "I have an intermittent bug that only happens sometimes and seems related to async operations. Guide me through debugging race conditions using trace logging and timing analysis."
      },
      {
        "title": "Use git bisect for regression",
        "description": "A bug appeared between working version [version A] and current version [version B]. Guide me through using git bisect to find the exact commit that introduced the regression.",
        "prompt": "A bug appeared between working version [version A] and current version [version B]. Guide me through using git bisect to find the exact commit that introduced the regression."
      }
    ],
    "output_examples": [
      {
        "input": "My Node.js API returns 500 errors intermittently. The error says 'Cannot read property of undefined' but I cannot find where this happens.",
        "output": "Let me apply systematic debugging to find this undefined property issue.\n\n## Step 1: Reproduce and Observe\n- When does the error occur? Always or randomly?\n- Which API endpoint triggers it?\n- What request parameters are sent?\n\n## Step 2: Gather Information\n1. Add strategic logging before the likely crash point:\n```javascript\nconsole.log('Order data:', JSON.stringify(order, null, 2));\n```\n2. Check which property might be undefined:\n```javascript\nconsole.log('Items:', order?.items);\nconsole.log('User:', order?.user?.name);\n```\n\n## Step 3: Hypothesis\nHypothesis: The error likely occurs when:\n- order.items is undefined for certain request types\n- order.user is null for guest users\n\n## Step 4: Test and Verify\nAdd null checks and verify with sample requests:\n```javascript\nconst items = order?.items ?? [];\nconst userName = order?.user?.name ?? 'Guest';\n```\n\nWould you like me to help you implement this fix?"
      },
      {
        "input": "Help me debug a memory leak in my React application.",
        "output": "Let me guide you through debugging a React memory leak systematically.\n\n## Reproduction Phase\n1. Open Chrome DevTools > Memory tab\n2. Take a heap snapshot (before)\n3. Perform the suspected leaky action 10-20 times\n4. Take another snapshot (after)\n5. Compare snapshots to identify retained objects\n\n## Common React Memory Leak Patterns\n1. Unsubscribed event listeners\n2. Timers (setInterval) not cleared in useEffect cleanup\n3. Closures holding references to component scope\n4. Global caches growing unbounded\n\n## Quick Debugging Steps\n```javascript\nuseEffect(() => {\n  const timer = setInterval(() => {\n    // ...\n  }, 1000);\n  \n  // Cleanup function - CRITICAL for preventing leaks\n  return () => {\n    clearInterval(timer);\n    // Remove any subscriptions\n  };\n}, []);\n```\n\nWhat symptoms are you seeing? High memory in DevTools or actual crashes?"
      }
    ],
    "best_practices": [
      "Reproduce the bug consistently before attempting fixes. Without consistent reproduction, you cannot verify your solution.",
      "Isolate the problem by removing unrelated code. Create a minimal reproduction case that demonstrates the issue.",
      "Use the debugger, not just console.log statements. Breakpoints let you inspect program state at any point."
    ],
    "anti_patterns": [
      "Making multiple changes at once. Change one thing at a time to understand what actually fixes the issue.",
      "Ignoring error messages or not reading the full stack trace. The error message and stack trace contain valuable clues.",
      "Assuming the bug is in someone else's code. Most bugs are in your own recent changes, not third-party libraries."
    ],
    "faq": [
      {
        "question": "What is the scientific method for debugging?",
        "answer": "The scientific method for debugging involves: (1) Observe the actual behavior and error, (2) Form a hypothesis about what causes it, (3) Design and run an experiment to test the hypothesis, (4) Analyze whether the results prove or disprove your theory, (5) Repeat with a new hypothesis until you find the root cause."
      },
      {
        "question": "How do I debug production issues safely?",
        "answer": "Never modify production code directly. Instead: (1) Add logging to capture more information, (2) Use feature flags to test fixes, (3) Deploy to staging first to verify, (4) Use error tracking tools like Sentry, (5) Work with anonymized production data locally."
      },
      {
        "question": "What is binary search debugging?",
        "answer": "Binary search debugging narrows down the problematic code by repeatedly halving the search space. Comment out half the code to see if the bug still occurs. Continue narrowing until you identify the exact line or section causing the issue."
      },
      {
        "question": "How do I debug intermittent bugs?",
        "answer": "Intermittent bugs require extensive logging and state capture. Add detailed logs showing timing, input data, and state transitions. Look for patterns in when the bug occurs. Check for race conditions in async code and timing dependencies."
      },
      {
        "question": "What is rubber duck debugging?",
        "answer": "Rubber duck debugging is explaining your code and problem out loud, line by line, to a rubber duck or colleague. The act of articulating the problem often reveals the issue. It forces you to slow down and think through each step."
      },
      {
        "question": "How do I use git bisect to find when a bug was introduced?",
        "answer": "Git bisect automates searching for the commit that introduced a bug. Run 'git bisect start', mark a known good commit with 'git bisect good <commit>', mark a known bad commit with 'git bisect bad <commit>'. Git will checkout commits in the middle for you to test. Mark each as 'good' or 'bad' until it identifies the exact commit."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 528
    }
  ]
}
