{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-17T08:31:55.273Z",
    "slug": "wshobson-typescript-advanced-types",
    "source_url": "https://github.com/wshobson/agents/tree/main/plugins/javascript-typescript/skills/typescript-advanced-types",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "dcb35d436f28e1914b8f2f95befc2ff11ab55531097703cbcaa23d4b7dd7b077",
    "tree_hash": "9fbce01754d98309c0b35f7428cf01d27ccdaa698bc4a84fc2ca8fa71dc30ba4"
  },
  "skill": {
    "name": "typescript-advanced-types",
    "description": "Master TypeScript's advanced type system including generics, conditional types, mapped types, template literals, and utility types for building type-safe applications. Use when implementing complex type logic, creating reusable type utilities, or ensuring compile-time type safety in TypeScript projects.",
    "summary": "Master TypeScript's advanced type system including generics, conditional types, mapped types, templa...",
    "icon": "ðŸ§©",
    "version": "1.0.0",
    "author": "wshobson",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "typescript",
      "types",
      "generics",
      "type-safety",
      "advanced"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a documentation-only skill containing educational TypeScript content. No executable code, network calls, or filesystem operations exist. All static findings are false positives caused by the analyzer misinterpreting TypeScript syntax as security-relevant patterns.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          },
          {
            "file": "SKILL.md",
            "line_start": 336,
            "line_end": 336
          },
          {
            "file": "SKILL.md",
            "line_start": 339,
            "line_end": 339
          },
          {
            "file": "SKILL.md",
            "line_start": 344,
            "line_end": 344
          },
          {
            "file": "SKILL.md",
            "line_start": 714,
            "line_end": 714
          },
          {
            "file": "SKILL.md",
            "line_start": 715,
            "line_end": 715
          },
          {
            "file": "SKILL.md",
            "line_start": 716,
            "line_end": 716
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 28,
            "line_end": 36
          },
          {
            "file": "SKILL.md",
            "line_start": 36,
            "line_end": 39
          },
          {
            "file": "SKILL.md",
            "line_start": 39,
            "line_end": 53
          },
          {
            "file": "SKILL.md",
            "line_start": 53,
            "line_end": 56
          },
          {
            "file": "SKILL.md",
            "line_start": 56,
            "line_end": 66
          },
          {
            "file": "SKILL.md",
            "line_start": 66,
            "line_end": 73
          },
          {
            "file": "SKILL.md",
            "line_start": 73,
            "line_end": 78
          },
          {
            "file": "SKILL.md",
            "line_start": 78,
            "line_end": 81
          },
          {
            "file": "SKILL.md",
            "line_start": 81,
            "line_end": 90
          },
          {
            "file": "SKILL.md",
            "line_start": 90,
            "line_end": 93
          },
          {
            "file": "SKILL.md",
            "line_start": 93,
            "line_end": 98
          },
          {
            "file": "SKILL.md",
            "line_start": 98,
            "line_end": 101
          },
          {
            "file": "SKILL.md",
            "line_start": 101,
            "line_end": 112
          },
          {
            "file": "SKILL.md",
            "line_start": 112,
            "line_end": 119
          },
          {
            "file": "SKILL.md",
            "line_start": 119,
            "line_end": 131
          },
          {
            "file": "SKILL.md",
            "line_start": 131,
            "line_end": 134
          },
          {
            "file": "SKILL.md",
            "line_start": 134,
            "line_end": 141
          },
          {
            "file": "SKILL.md",
            "line_start": 141,
            "line_end": 144
          },
          {
            "file": "SKILL.md",
            "line_start": 144,
            "line_end": 146
          },
          {
            "file": "SKILL.md",
            "line_start": 146,
            "line_end": 156
          },
          {
            "file": "SKILL.md",
            "line_start": 156,
            "line_end": 159
          },
          {
            "file": "SKILL.md",
            "line_start": 159,
            "line_end": 173
          },
          {
            "file": "SKILL.md",
            "line_start": 173,
            "line_end": 180
          },
          {
            "file": "SKILL.md",
            "line_start": 180,
            "line_end": 182
          },
          {
            "file": "SKILL.md",
            "line_start": 182,
            "line_end": 184
          },
          {
            "file": "SKILL.md",
            "line_start": 184,
            "line_end": 187
          },
          {
            "file": "SKILL.md",
            "line_start": 187,
            "line_end": 192
          },
          {
            "file": "SKILL.md",
            "line_start": 192,
            "line_end": 195
          },
          {
            "file": "SKILL.md",
            "line_start": 195,
            "line_end": 198
          },
          {
            "file": "SKILL.md",
            "line_start": 198,
            "line_end": 198
          },
          {
            "file": "SKILL.md",
            "line_start": 198,
            "line_end": 215
          },
          {
            "file": "SKILL.md",
            "line_start": 215,
            "line_end": 221
          },
          {
            "file": "SKILL.md",
            "line_start": 221,
            "line_end": 248
          },
          {
            "file": "SKILL.md",
            "line_start": 248,
            "line_end": 254
          },
          {
            "file": "SKILL.md",
            "line_start": 254,
            "line_end": 289
          },
          {
            "file": "SKILL.md",
            "line_start": 289,
            "line_end": 293
          },
          {
            "file": "SKILL.md",
            "line_start": 293,
            "line_end": 348
          },
          {
            "file": "SKILL.md",
            "line_start": 348,
            "line_end": 352
          },
          {
            "file": "SKILL.md",
            "line_start": 352,
            "line_end": 408
          },
          {
            "file": "SKILL.md",
            "line_start": 408,
            "line_end": 412
          },
          {
            "file": "SKILL.md",
            "line_start": 412,
            "line_end": 452
          },
          {
            "file": "SKILL.md",
            "line_start": 452,
            "line_end": 456
          },
          {
            "file": "SKILL.md",
            "line_start": 456,
            "line_end": 530
          },
          {
            "file": "SKILL.md",
            "line_start": 530,
            "line_end": 534
          },
          {
            "file": "SKILL.md",
            "line_start": 534,
            "line_end": 597
          },
          {
            "file": "SKILL.md",
            "line_start": 597,
            "line_end": 603
          },
          {
            "file": "SKILL.md",
            "line_start": 603,
            "line_end": 620
          },
          {
            "file": "SKILL.md",
            "line_start": 620,
            "line_end": 624
          },
          {
            "file": "SKILL.md",
            "line_start": 624,
            "line_end": 641
          },
          {
            "file": "SKILL.md",
            "line_start": 641,
            "line_end": 645
          },
          {
            "file": "SKILL.md",
            "line_start": 645,
            "line_end": 657
          },
          {
            "file": "SKILL.md",
            "line_start": 657,
            "line_end": 661
          },
          {
            "file": "SKILL.md",
            "line_start": 661,
            "line_end": 661
          },
          {
            "file": "SKILL.md",
            "line_start": 661,
            "line_end": 662
          },
          {
            "file": "SKILL.md",
            "line_start": 662,
            "line_end": 663
          },
          {
            "file": "SKILL.md",
            "line_start": 663,
            "line_end": 674
          },
          {
            "file": "SKILL.md",
            "line_start": 674,
            "line_end": 692
          },
          {
            "file": "SKILL.md",
            "line_start": 692,
            "line_end": 696
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 894,
    "audit_model": "claude",
    "audited_at": "2026-01-17T08:31:55.273Z"
  },
  "content": {
    "user_title": "Master advanced TypeScript types",
    "value_statement": "Complex type logic can be hard to design and maintain. This skill provides patterns and examples to build reusable and safe TypeScript types for your projects.",
    "seo_keywords": [
      "TypeScript advanced types",
      "generics",
      "conditional types",
      "mapped types",
      "template literal types",
      "type utilities",
      "type safety",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Explain generics with constraints and multiple type parameters",
      "Show conditional and distributive conditional type patterns",
      "Demonstrate mapped types with key remapping and filtering",
      "Provide template literal type techniques for string patterns",
      "Outline advanced patterns like typed event emitters and API clients"
    ],
    "limitations": [
      "Does not run or type-check code in your project",
      "Does not infer types from your codebase automatically",
      "Does not replace TypeScript compiler diagnostics",
      "Does not cover runtime validation libraries"
    ],
    "use_cases": [
      {
        "target_user": "Library authors",
        "title": "Design reusable types",
        "description": "Build ergonomic generic APIs and utility types for public packages."
      },
      {
        "target_user": "Frontend engineers",
        "title": "Type-safe UI models",
        "description": "Model events, forms, and state with strict compile-time safety."
      },
      {
        "target_user": "Backend developers",
        "title": "Typed API clients",
        "description": "Create strongly typed request and response contracts."
      }
    ],
    "prompt_templates": [
      {
        "title": "Learn a concept",
        "scenario": "I need to understand a type feature",
        "prompt": "Explain TypeScript conditional types with a simple example and a common use case."
      },
      {
        "title": "Build a utility type",
        "scenario": "I want a reusable helper type",
        "prompt": "Create a mapped type that picks properties by value type and explain how it works."
      },
      {
        "title": "Design a pattern",
        "scenario": "I need a type-safe pattern",
        "prompt": "Design a type-safe event emitter API with an example event map and usage."
      },
      {
        "title": "Advanced inference",
        "scenario": "I need complex inference logic",
        "prompt": "Show how to infer parameter and return types from a generic function and apply them in an API client."
      }
    ],
    "output_examples": [
      {
        "input": "Show a type-safe builder pattern for a User object",
        "output": [
          "Defines required and optional keys",
          "Tracks build state across set calls",
          "Prevents build until required fields are set",
          "Includes a short usage example"
        ]
      },
      {
        "input": "How do I create a discriminated union for async state?",
        "output": [
          "Defines success, error, and loading states",
          "Uses status field for type narrowing",
          "Provides type-safe switch handling",
          "Shows state machine reducer pattern"
        ]
      },
      {
        "input": "What is key remapping in mapped types?",
        "output": [
          "Transforms property keys using template literals",
          "Filters properties with conditional types",
          "Creates getter methods from property names",
          "Demonstrates with Capitalize utility"
        ]
      }
    ],
    "best_practices": [
      "Use unknown instead of any for safer type narrowing",
      "Prefer inference and helper types to reduce duplication",
      "Enable strict compiler options for stronger guarantees"
    ],
    "anti_patterns": [
      "Overusing any to bypass type checking",
      "Creating overly complex conditional types without need",
      "Ignoring strict null checks in data models"
    ],
    "faq": [
      {
        "question": "What TypeScript versions are supported?",
        "answer": "The concepts are based on modern TypeScript and work with current stable releases."
      },
      {
        "question": "Are there limits on type complexity?",
        "answer": "Very deep conditional or recursive types can slow down compilation."
      },
      {
        "question": "Can this integrate with my existing codebase?",
        "answer": "Yes, you can adapt the patterns to your interfaces and utility types."
      },
      {
        "question": "Does it access my data or files?",
        "answer": "No, it provides guidance only and does not access local data."
      },
      {
        "question": "How do I troubleshoot type errors?",
        "answer": "Start with strict mode, simplify types, and add small helper types."
      },
      {
        "question": "How does this compare to general TypeScript help?",
        "answer": "It focuses on advanced patterns like conditional, mapped, and template literal types."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 718
    }
  ]
}
