{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T18:52:04.568Z",
    "slug": "wshobson-architecture-patterns",
    "source_url": "https://github.com/wshobson/agents/tree/main/plugins/backend-development/skills/architecture-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "b7a511cef10caa98a3d6afad0c2405b952d3c48c58e1daec405b443ade6cabf9",
    "tree_hash": "1d15c17d5da447a5a6fa27cc711bce198e5e16fa2778ca776458ef49e7d3e372"
  },
  "skill": {
    "name": "architecture-patterns",
    "description": "Implement proven backend architecture patterns including Clean Architecture, Hexagonal Architecture, and Domain-Driven Design. Use when architecting complex backend systems or refactoring existing applications for better maintainability.",
    "summary": "Master proven backend architecture patterns for building maintainable, testable, and scalable systems.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "wshobson",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "architecture",
      "backend",
      "clean-architecture",
      "ddd",
      "design-patterns"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All 43 static analysis findings are false positives from educational code examples in documentation. The skill teaches software architecture patterns through Python examples showing Clean Architecture, Hexagonal Architecture, and Domain-Driven Design. No executable code, network access, or security vulnerabilities present.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 909,
    "audit_model": "claude",
    "audited_at": "2026-01-21T18:52:04.568Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Implement Backend Architecture Patterns",
    "value_statement": "Building maintainable backend systems requires proven architecture patterns. This skill helps you implement Clean Architecture, Hexagonal Architecture, and Domain-Driven Design to create testable, scalable applications with proper separation of concerns.",
    "seo_keywords": [
      "Claude",
      "Codex",
      "Claude Code",
      "architecture patterns",
      "clean architecture",
      "hexagonal architecture",
      "domain-driven design",
      "backend development",
      "software design",
      "DDD"
    ],
    "actual_capabilities": [
      "Generate Clean Architecture project structures with proper layer separation and dependency rules",
      "Implement Hexagonal Architecture with ports and adapters for database, API, and external service integrations",
      "Create Domain-Driven Design tactical patterns including entities, value objects, aggregates, and repositories",
      "Design use cases that orchestrate business logic without framework dependencies",
      "Refactor tightly coupled code into loosely coupled architectures with proper abstractions",
      "Provide architecture pattern examples in Python with FastAPI, AsyncPG, and common backend libraries"
    ],
    "limitations": [
      "Focuses on Python backend implementations, not other languages or frontend architectures",
      "Provides structural guidance but cannot automatically refactor large existing codebases",
      "Does not include infrastructure-as-code or deployment configurations",
      "Architectural patterns may be over-engineering for simple CRUD applications"
    ],
    "use_cases": [
      {
        "title": "Design New Backend Service Architecture",
        "description": "Plan and implement a new microservice using Clean Architecture principles with proper layer separation, dependency injection, and testable business logic.",
        "target_user": "Backend engineers starting new projects"
      },
      {
        "title": "Refactor Monolithic Application",
        "description": "Transform a tightly coupled monolithic application into a well-structured hexagonal architecture with ports and adapters for easier testing and maintenance.",
        "target_user": "Senior developers maintaining legacy systems"
      },
      {
        "title": "Implement Domain-Driven Design Patterns",
        "description": "Model complex business domains using DDD tactical patterns including aggregates, entities, value objects, and domain events for better domain alignment.",
        "target_user": "Architects designing enterprise applications"
      }
    ],
    "prompt_templates": [
      {
        "title": "Generate Clean Architecture Structure",
        "prompt": "Create a Clean Architecture folder structure for an e-commerce order management system with domain entities, use cases, and adapters.",
        "scenario": "Starting a new backend project and need proper architectural foundation"
      },
      {
        "title": "Implement Repository Port and Adapter",
        "prompt": "Implement a user repository port interface and PostgreSQL adapter following hexagonal architecture principles with async database access.",
        "scenario": "Adding database layer with testable abstractions"
      },
      {
        "title": "Create Domain Entities with Business Logic",
        "prompt": "Design an Order aggregate with domain entities, value objects, and business rules for adding items, calculating totals, and state transitions.",
        "scenario": "Modeling complex business domain with DDD patterns"
      },
      {
        "title": "Refactor Controller to Use Case Pattern",
        "prompt": "Refactor this FastAPI endpoint that has business logic in the controller into a proper use case with dependency injection and separation of concerns.",
        "scenario": "Improving existing code to follow Clean Architecture principles"
      }
    ],
    "output_examples": [
      {
        "input": "Create a Clean Architecture structure for a user management system",
        "output": "The skill generates a complete directory structure with domain/entities containing User entity, domain/interfaces with IUserRepository port, use_cases containing CreateUserUseCase and UpdateUserUseCase, adapters/repositories with PostgresUserRepository implementation, and adapters/controllers with UserController for HTTP handling. Each component demonstrates proper dependency flow and separation of concerns."
      },
      {
        "input": "Implement a payment gateway adapter using hexagonal architecture",
        "output": "The skill creates a PaymentGatewayPort interface defining the charge method contract, then implements both StripePaymentAdapter for production and MockPaymentAdapter for testing. Both adapters implement the same port interface, allowing easy swapping without changing business logic. The example includes error handling and proper async/await patterns."
      },
      {
        "input": "Design an Order aggregate with DDD patterns",
        "output": "The skill designs an Order entity as aggregate root with add_item, calculate_total, and submit methods encapsulating business rules. It includes OrderItem entity, Money value object for currency handling, OrderStatus enum for state management, and domain events like OrderSubmittedEvent. The aggregate enforces invariants and maintains consistency boundaries."
      }
    ],
    "best_practices": [
      "Always point dependencies inward from outer layers to inner layers, never let domain layer depend on infrastructure",
      "Use interfaces and ports to define contracts in the domain layer, implement adapters in outer layers for testability",
      "Keep business logic in domain entities and use cases, controllers should only handle HTTP concerns and delegate to use cases"
    ],
    "anti_patterns": [
      "Placing business logic in controllers or API handlers instead of use cases and domain entities",
      "Creating anemic domain models with only data properties and no behavior, putting all logic in services",
      "Tightly coupling domain layer to specific frameworks, databases, or external APIs without abstraction interfaces"
    ],
    "faq": [
      {
        "question": "When should I use Clean Architecture versus simpler patterns?",
        "answer": "Use Clean Architecture for complex business logic with multiple integrations and long-term maintenance needs. Simple CRUD applications with basic workflows may not benefit from the additional abstraction layers. Consider the trade-off between maintainability and simplicity based on your project complexity."
      },
      {
        "question": "How does hexagonal architecture differ from Clean Architecture?",
        "answer": "Both enforce dependency inversion and separation of concerns. Clean Architecture emphasizes concentric layers with strict dependency rules flowing inward. Hexagonal Architecture focuses on ports and adapters where the domain core is surrounded by interchangeable adapters. They are complementary approaches often used together."
      },
      {
        "question": "What is the difference between entities and value objects in DDD?",
        "answer": "Entities have unique identity and lifecycle, two entities with same attributes are still different if IDs differ. Value objects are defined by their attributes and are immutable, two value objects with same attributes are considered equal. Use entities for things that change over time, value objects for descriptive characteristics."
      },
      {
        "question": "How do I test use cases that depend on repositories and external services?",
        "answer": "Use dependency injection to provide mock implementations of repository and service interfaces. Create test doubles that implement the same port interfaces but return controlled data instead of accessing real databases or APIs. This allows testing business logic in isolation without infrastructure dependencies."
      },
      {
        "question": "Can I apply these patterns to existing codebases or only new projects?",
        "answer": "You can incrementally refactor existing code toward these patterns. Start with one module or feature, extract business logic into use cases, create repository interfaces, and implement adapters. Gradual migration is safer than full rewrites. Focus on high-change areas first for maximum benefit."
      },
      {
        "question": "Does this skill work with frameworks other than FastAPI and PostgreSQL?",
        "answer": "The principles apply to any framework or database. Examples use FastAPI and PostgreSQL for demonstration, but the same patterns work with Django, Flask, Express, MongoDB, MySQL, or other technologies. The key is keeping framework-specific code in outer adapter layers separate from business logic."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 488
    }
  ]
}
