{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-02-15T08:42:06.726Z",
    "slug": "wshobson-python-design-patterns",
    "source_url": "https://github.com/wshobson/agents/tree/main/plugins/python-development/skills/python-design-patterns/",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "7a72c3de6184ca9948bcce55cde3e13f406a40ecdc85e39665ced05f07d2171f",
    "tree_hash": "dcf44e74baff60e674cefb235b85434883b7ec20472b7ffc807b9415df87b8d9"
  },
  "skill": {
    "name": "python-design-patterns",
    "description": "Python design patterns including KISS, Separation of Concerns, Single Responsibility, and composition over inheritance. Use when making architecture decisions, refactoring code structure, or evaluating when abstractions are appropriate.",
    "summary": "Guide to Python design patterns including KISS, Single Responsibility, Composition over Inheritance, and Separation of Concerns for building maintainable code.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "wshobson",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "python",
      "design-patterns",
      "software-architecture",
      "best-practices",
      "refactoring"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All 35 static findings are false positives. The skill is a documentation file containing Python code examples for educational purposes. Python dictionary syntax was misidentified as shell backticks, email examples as network calls, and code examples as cryptographic algorithms or reconnaissance. No actual security risks present.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 412,
    "audit_model": "claude",
    "audited_at": "2026-02-15T08:42:06.726Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Apply Python Design Patterns",
    "value_statement": "Write maintainable Python code using proven design patterns like KISS, Single Responsibility, and Composition over Inheritance to build systems that are easy to understand, test, and modify.",
    "seo_keywords": [
      "python design patterns",
      "KISS principle python",
      "single responsibility principle",
      "composition over inheritance python",
      "separation of concerns",
      "software architecture",
      "clean code python",
      "refactoring patterns",
      "Claude Code",
      "Codex"
    ],
    "actual_capabilities": [
      "Apply KISS principle to choose simplest solutions that work",
      "Implement Single Responsibility to keep classes focused on one purpose",
      "Use Composition over Inheritance for flexible, testable code",
      "Apply Separation of Concerns to organize code into distinct layers",
      "Use Rule of Three to avoid premature abstractions",
      "Implement Dependency Injection for testable components"
    ],
    "limitations": [
      "Does not provide executable code or runtime environment",
      "Does not generate code automatically - guides decision-making",
      "Does not include specific framework implementations",
      "Does not cover all 23 GoF design patterns"
    ],
    "use_cases": [
      {
        "title": "Architecting new Python services",
        "description": "When starting a new service, use these patterns to create a clean, maintainable architecture from the beginning.",
        "target_user": "Backend developers building new Python services"
      },
      {
        "title": "Refactoring tangled code",
        "description": "When faced with complex, coupled code, apply SRP and Separation of Concerns to untangle dependencies.",
        "target_user": "Developers working on legacy codebases"
      },
      {
        "title": "Evaluating abstraction decisions",
        "description": "When deciding whether to create an abstraction, use the Rule of Three to avoid premature generalization.",
        "target_user": "Software architects making design decisions"
      }
    ],
    "prompt_templates": [
      {
        "title": "Apply KISS to a problem",
        "prompt": "I need to solve [describe problem]. What is the simplest solution that works? Show me an example."
      },
      {
        "title": "Refactor using SRP",
        "prompt": "Here is my class [paste code] that does multiple things. How can I split it into classes with single responsibilities?"
      },
      {
        "title": "Composition vs Inheritance",
        "prompt": "I have a base class with shared behavior and want to extend it. How can I use composition instead of inheritance? Show an example."
      },
      {
        "title": "Apply layered architecture",
        "prompt": "How should I organize [describe your application] into layers? Show me the separation of concerns with example code."
      }
    ],
    "output_examples": [
      {
        "input": "Show me how to refactor a class that handles user registration, sends emails, logs activity, and saves to database",
        "output": "A refactored example splitting into UserService (business logic), UserRepository (data access), EmailNotifier (notifications), and ActivityLogger (logging) - each with single responsibility."
      },
      {
        "input": "I need to add payment processing to my order system. Should I inherit from a base Order class or use composition?",
        "output": "Explanation of why composition is preferred - you can swap payment providers, test with fakes, and avoid inheritance hierarchies. Example showing PaymentProcessor injected into OrderService."
      },
      {
        "input": "I have three similar functions that process data slightly differently. Should I create an abstraction?",
        "output": "Apply Rule of Three - wait until you see a clear pattern emerge. Show example of when duplication is better than wrong abstraction, and when to abstract."
      }
    ],
    "best_practices": [
      "Start with the simplest solution and add complexity only when justified by concrete requirements",
      "Keep functions focused to 20-50 lines with a single purpose",
      "Separate I/O operations from business logic into different layers",
      "Inject dependencies through constructors for testability"
    ],
    "anti_patterns": [
      "Creating abstractions too early before understanding the domain",
      "Using inheritance for code reuse instead of composition",
      "Mixing concerns like HTTP handling, validation, and database access in one class",
      "Making code clever instead of readable"
    ],
    "faq": [
      {
        "question": "What is the Rule of Three in Python?",
        "answer": "Wait until you have three similar instances before creating an abstraction. Two similar pieces of code may not actually share a pattern - wait for the third to confirm."
      },
      {
        "question": "When should I use composition over inheritance?",
        "answer": "Always prefer composition unless you need true polymorphism. Inheritance creates tight coupling and makes testing harder."
      },
      {
        "question": "How big should a function be?",
        "answer": "Keep functions to 20-50 lines depending on complexity. Extract when it serves multiple purposes or has deeply nested logic (3+ levels)."
      },
      {
        "question": "What is Separation of Concerns?",
        "answer": "Organize code into distinct layers (API, Service, Repository) where each layer has a clear responsibility and only depends on layers below it."
      },
      {
        "question": "What is Dependency Injection?",
        "answer": "Pass dependencies through constructors rather than creating them inside the class. This makes code testable by allowing fake implementations."
      },
      {
        "question": "When should I apply the KISS principle?",
        "answer": "Always start with the simplest solution that works. Only add complexity when concrete requirements justify it. Simple code is easier to maintain."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 412
    }
  ]
}
