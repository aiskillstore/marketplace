{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-16T20:39:43.841Z",
    "slug": "cjharmath-py-alembic-patterns",
    "source_url": "https://github.com/CJHarmath/claude-agents-skills/tree/main/skills/py-alembic-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "e9af20862076147b8d3fd595c9e9e7e44cbb0e2e91f6c3eae368c3b89bd35602",
    "tree_hash": "a93d0ef570a31c28a9d8ac2f758b1208704ff921ba880ce7aa411c10f1d4eea5"
  },
  "skill": {
    "name": "py-alembic-patterns",
    "description": "Alembic migration patterns for PostgreSQL. Use when creating migrations, reviewing autogenerated migrations, or handling schema changes safely.",
    "summary": "Alembic migration patterns for PostgreSQL. Use when creating migrations, reviewing autogenerated mig...",
    "icon": "üóÑÔ∏è",
    "version": "1.0.0",
    "author": "CJHarmath",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "database",
      "postgresql",
      "alembic",
      "migration",
      "sqlalchemy"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a pure documentation skill containing only markdown content with educational code examples. All 39 static findings are false positives caused by pattern matching on example code in markdown blocks and metadata fields. No executable code, scripts, network operations, or file system access exists in this skill.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 16,
            "line_end": 37
          },
          {
            "file": "SKILL.md",
            "line_start": 37,
            "line_end": 62
          },
          {
            "file": "SKILL.md",
            "line_start": 62,
            "line_end": 74
          },
          {
            "file": "SKILL.md",
            "line_start": 74,
            "line_end": 80
          },
          {
            "file": "SKILL.md",
            "line_start": 80,
            "line_end": 132
          },
          {
            "file": "SKILL.md",
            "line_start": 132,
            "line_end": 140
          },
          {
            "file": "SKILL.md",
            "line_start": 140,
            "line_end": 158
          },
          {
            "file": "SKILL.md",
            "line_start": 158,
            "line_end": 166
          },
          {
            "file": "SKILL.md",
            "line_start": 166,
            "line_end": 194
          },
          {
            "file": "SKILL.md",
            "line_start": 194,
            "line_end": 202
          },
          {
            "file": "SKILL.md",
            "line_start": 202,
            "line_end": 222
          },
          {
            "file": "SKILL.md",
            "line_start": 222,
            "line_end": 230
          },
          {
            "file": "SKILL.md",
            "line_start": 230,
            "line_end": 263
          },
          {
            "file": "SKILL.md",
            "line_start": 263,
            "line_end": 271
          },
          {
            "file": "SKILL.md",
            "line_start": 271,
            "line_end": 280
          },
          {
            "file": "SKILL.md",
            "line_start": 280,
            "line_end": 286
          },
          {
            "file": "SKILL.md",
            "line_start": 286,
            "line_end": 312
          },
          {
            "file": "SKILL.md",
            "line_start": 312,
            "line_end": 320
          },
          {
            "file": "SKILL.md",
            "line_start": 320,
            "line_end": 321
          },
          {
            "file": "SKILL.md",
            "line_start": 321,
            "line_end": 334
          },
          {
            "file": "SKILL.md",
            "line_start": 334,
            "line_end": 342
          },
          {
            "file": "SKILL.md",
            "line_start": 342,
            "line_end": 344
          },
          {
            "file": "SKILL.md",
            "line_start": 344,
            "line_end": 353
          },
          {
            "file": "SKILL.md",
            "line_start": 353,
            "line_end": 361
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 548,
    "audit_model": "claude",
    "audited_at": "2026-01-16T20:39:43.841Z"
  },
  "content": {
    "user_title": "Write safe Alembic migrations for PostgreSQL",
    "value_statement": "Database migrations can cause data loss or downtime when done incorrectly. This skill provides tested patterns for creating, reviewing, and safely applying Alembic migrations.",
    "seo_keywords": [
      "Alembic migration patterns",
      "PostgreSQL migrations",
      "SQLAlchemy migrations",
      "database schema changes",
      "Claude Code database",
      "Codex migration tool",
      "safe database migrations",
      "migration review checklist",
      "Alembic best practices"
    ],
    "actual_capabilities": [
      "Generate Alembic migration files with proper upgrade and downgrade functions",
      "Review autogenerated migrations for dangerous patterns like drop-then-add",
      "Implement safe patterns for adding non-nullable columns to existing tables",
      "Create concurrent index operations to avoid table locks on large tables",
      "Handle PostgreSQL enum type creation and modification",
      "Resolve multi-head migration conflicts in team environments"
    ],
    "limitations": [
      "Does not execute migrations or connect to databases directly",
      "Does not generate migrations automatically from model definitions",
      "Patterns are PostgreSQL-focused and may not apply to other databases",
      "Does not replace human review of migration impact on production data"
    ],
    "use_cases": [
      {
        "target_user": "Backend developers",
        "title": "Write production-safe migrations",
        "description": "Create migrations with proper downgrade paths that handle data correctly and avoid table locks in production environments."
      },
      {
        "target_user": "DevOps engineers",
        "title": "Review migrations before deployment",
        "description": "Verify migrations follow safety patterns and will not cause downtime or data loss during production deployments."
      },
      {
        "target_user": "Database administrators",
        "title": "Audit team migration practices",
        "description": "Ensure development teams follow PostgreSQL best practices for naming, index creation, and constraint management."
      }
    ],
    "prompt_templates": [
      {
        "title": "Create a new migration",
        "scenario": "Need to add a table or column",
        "prompt": "Help me create an Alembic migration to add a user_preferences table with id, user_id, and theme columns. Include proper upgrade and downgrade functions."
      },
      {
        "title": "Review autogenerated code",
        "scenario": "Checking migration safety",
        "prompt": "Review this autogenerated Alembic migration for dangerous patterns. Check for data loss risks and missing downgrade logic: [paste migration]"
      },
      {
        "title": "Handle large table changes",
        "scenario": "Adding index to million-row table",
        "prompt": "I need to add an index on the events table which has 50 million rows. Show me how to do this without locking the table in production."
      },
      {
        "title": "Data migration with backfill",
        "scenario": "Transform existing data",
        "prompt": "I am adding a status column that must be backfilled based on other columns. Show me how to implement this as a data migration with batch processing."
      }
    ],
    "output_examples": [
      {
        "input": "Create a migration to rename the name column to full_name in the users table",
        "output": [
          "WARNING: Autogenerate will create drop+add which loses data",
          "CORRECT approach: Use op.alter_column with new_column_name parameter",
          "Example: op.alter_column('users', 'name', new_column_name='full_name')",
          "Always implement matching downgrade to reverse the rename"
        ]
      },
      {
        "input": "Add a required role column to the users table that already has data",
        "output": [
          "Three-step process for non-nullable columns on existing tables:",
          "Step 1: Add column as nullable",
          "Step 2: Backfill existing rows with default value",
          "Step 3: Alter column to add NOT NULL constraint",
          "This prevents failures on tables with existing data"
        ]
      }
    ],
    "best_practices": [
      "Always implement downgrade functions that fully reverse the upgrade operation",
      "Review every autogenerated migration for drop+add patterns that cause data loss",
      "Use CONCURRENTLY for index creation on large tables to prevent production locks"
    ],
    "anti_patterns": [
      "Relying on autogenerated migrations without manual review for column renames",
      "Adding NOT NULL columns without backfilling existing rows first",
      "Leaving downgrade functions empty with just pass, making rollback impossible"
    ],
    "faq": [
      {
        "question": "Does this skill execute migrations against my database?",
        "answer": "No. This skill provides patterns and examples. You run migrations yourself using Alembic commands in your project."
      },
      {
        "question": "What changes does Alembic autogenerate handle correctly?",
        "answer": "Table creation, column addition and removal, type changes, and foreign keys work reliably. Always verify the generated output."
      },
      {
        "question": "How do I migrate tables with millions of rows safely?",
        "answer": "Use CONCURRENTLY for indexes, batch data updates in chunks, and add nullable columns before constraints."
      },
      {
        "question": "Will these patterns prevent all data loss?",
        "answer": "They address common pitfalls but always backup production databases before migrations and test downgrade paths."
      },
      {
        "question": "Can I use these patterns with MySQL or other databases?",
        "answer": "Some patterns like CONCURRENTLY are PostgreSQL-specific. General structure and review practices apply broadly."
      },
      {
        "question": "Why should I implement downgrade functions I may never use?",
        "answer": "Downgrades are essential for rollback when issues are found after deployment. The one time you need it justifies the effort."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 366
    }
  ]
}
