{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-16T21:19:47.685Z",
    "slug": "cjharmath-rn-async-patterns",
    "source_url": "https://github.com/CJHarmath/claude-agents-skills/tree/main/skills/rn-async-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "1053d9c90658ae80db186a532b086cf1a311c98abdfd433efee3670cbd76894c",
    "tree_hash": "83194b5f614e8e912893ae77b72e987909ce3d5263f2e22695b27ea85d7dabeb"
  },
  "skill": {
    "name": "rn-async-patterns",
    "description": "Async/await correctness in React Native with Zustand. Use when debugging race conditions, missing awaits, floating promises, or async timing issues in Expo/React Native apps.",
    "summary": "Async/await correctness in React Native with Zustand. Use when debugging race conditions, missing aw...",
    "icon": "âš¡",
    "version": "1.0.0",
    "author": "CJHarmath",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "react-native",
      "async",
      "zustand",
      "debugging",
      "expo"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a pure documentation skill containing only markdown guidance for debugging async patterns in React Native. All 53 static findings are false positives: the scanner misidentified 'async' keywords as cryptographic algorithms, 'Object.keys()' as certificate files, and grep command examples as shell execution. No executable code, network calls, file system access, or command execution capabilities exist.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 153,
            "line_end": 153
          },
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 10,
            "line_end": 10
          },
          {
            "file": "SKILL.md",
            "line_start": 16,
            "line_end": 16
          },
          {
            "file": "SKILL.md",
            "line_start": 20,
            "line_end": 28
          },
          {
            "file": "SKILL.md",
            "line_start": 28,
            "line_end": 30
          },
          {
            "file": "SKILL.md",
            "line_start": 30,
            "line_end": 34
          },
          {
            "file": "SKILL.md",
            "line_start": 34,
            "line_end": 38
          },
          {
            "file": "SKILL.md",
            "line_start": 38,
            "line_end": 42
          },
          {
            "file": "SKILL.md",
            "line_start": 42,
            "line_end": 43
          },
          {
            "file": "SKILL.md",
            "line_start": 43,
            "line_end": 43
          },
          {
            "file": "SKILL.md",
            "line_start": 43,
            "line_end": 53
          },
          {
            "file": "SKILL.md",
            "line_start": 53,
            "line_end": 63
          },
          {
            "file": "SKILL.md",
            "line_start": 63,
            "line_end": 66
          },
          {
            "file": "SKILL.md",
            "line_start": 66,
            "line_end": 78
          },
          {
            "file": "SKILL.md",
            "line_start": 78,
            "line_end": 82
          },
          {
            "file": "SKILL.md",
            "line_start": 82,
            "line_end": 84
          },
          {
            "file": "SKILL.md",
            "line_start": 84,
            "line_end": 90
          },
          {
            "file": "SKILL.md",
            "line_start": 90,
            "line_end": 94
          },
          {
            "file": "SKILL.md",
            "line_start": 94,
            "line_end": 118
          },
          {
            "file": "SKILL.md",
            "line_start": 118,
            "line_end": 122
          },
          {
            "file": "SKILL.md",
            "line_start": 122,
            "line_end": 128
          },
          {
            "file": "SKILL.md",
            "line_start": 128,
            "line_end": 136
          },
          {
            "file": "SKILL.md",
            "line_start": 136,
            "line_end": 154
          },
          {
            "file": "SKILL.md",
            "line_start": 154,
            "line_end": 160
          },
          {
            "file": "SKILL.md",
            "line_start": 160,
            "line_end": 161
          },
          {
            "file": "SKILL.md",
            "line_start": 161,
            "line_end": 168
          },
          {
            "file": "SKILL.md",
            "line_start": 168,
            "line_end": 170
          },
          {
            "file": "SKILL.md",
            "line_start": 170,
            "line_end": 202
          },
          {
            "file": "SKILL.md",
            "line_start": 202,
            "line_end": 208
          },
          {
            "file": "SKILL.md",
            "line_start": 208,
            "line_end": 210
          },
          {
            "file": "SKILL.md",
            "line_start": 210,
            "line_end": 219
          },
          {
            "file": "SKILL.md",
            "line_start": 219,
            "line_end": 221
          },
          {
            "file": "SKILL.md",
            "line_start": 221,
            "line_end": 229
          },
          {
            "file": "SKILL.md",
            "line_start": 229,
            "line_end": 229
          },
          {
            "file": "SKILL.md",
            "line_start": 229,
            "line_end": 230
          },
          {
            "file": "SKILL.md",
            "line_start": 230,
            "line_end": 232
          },
          {
            "file": "SKILL.md",
            "line_start": 232,
            "line_end": 242
          },
          {
            "file": "SKILL.md",
            "line_start": 242,
            "line_end": 244
          },
          {
            "file": "SKILL.md",
            "line_start": 244,
            "line_end": 246
          },
          {
            "file": "SKILL.md",
            "line_start": 246,
            "line_end": 247
          },
          {
            "file": "SKILL.md",
            "line_start": 247,
            "line_end": 249
          },
          {
            "file": "SKILL.md",
            "line_start": 249,
            "line_end": 250
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 433,
    "audit_model": "claude",
    "audited_at": "2026-01-16T21:19:47.685Z"
  },
  "content": {
    "user_title": "Debug React Native async issues",
    "value_statement": "Async bugs in React Native apps often work in development but fail under load. This skill provides patterns to detect and fix race conditions, floating promises, and async timing issues in Zustand-based state management.",
    "seo_keywords": [
      "React Native async debugging",
      "Zustand async patterns",
      "race condition fix",
      "floating promises TypeScript",
      "async await React Native",
      "Expo async debugging",
      "Claude async code help",
      "Codex React patterns",
      "ClauCode async debugging"
    ],
    "actual_capabilities": [
      "Detect floating promises (async calls without await)",
      "Identify hidden async functions in Zustand stores",
      "Apply post-condition validation after async operations",
      "Choose between sequential and parallel async execution",
      "Fix async useEffect patterns with proper cleanup",
      "Configure ESLint rules for async code safety"
    ],
    "limitations": [
      "Does not execute code or modify your project files",
      "Does not provide real-time debugging or breakpoints",
      "Does not connect to running React Native applications",
      "Requires manual application of suggested fixes to your codebase"
    ],
    "use_cases": [
      {
        "target_user": "React Native developers",
        "title": "Debug production async bugs",
        "description": "Identify why async code works in development but fails under load or on slower devices"
      },
      {
        "target_user": "Zustand users",
        "title": "Fix Zustand async patterns",
        "description": "Detect hidden async in Zustand actions and properly await state updates"
      },
      {
        "target_user": "Code reviewers",
        "title": "Review async code quality",
        "description": "Apply checklist for catching race conditions and missing awaits in pull requests"
      }
    ],
    "prompt_templates": [
      {
        "title": "Find floating promises",
        "scenario": "Detect async calls without await",
        "prompt": "Help me find floating promises in my React Native code. Show me how to identify async function calls that are not awaited and explain the race condition risks."
      },
      {
        "title": "Fix Zustand async",
        "scenario": "Debug Zustand state issues",
        "prompt": "My Zustand store has async actions that seem to run out of order. Show me how to properly structure async Zustand actions and validate post-conditions."
      },
      {
        "title": "Parallel vs sequential",
        "scenario": "Choose execution strategy",
        "prompt": "I have multiple async operations that might depend on each other. Help me decide when to use Promise.all() versus sequential await statements."
      },
      {
        "title": "Add ESLint rules",
        "scenario": "Automate async detection",
        "prompt": "What ESLint rules should I add to my project to automatically catch floating promises, missing awaits, and other async anti-patterns in TypeScript?"
      }
    ],
    "output_examples": [
      {
        "input": "Help me fix this async race condition in my Zustand store",
        "output": [
          "Detected issue: enableSkillAreaRetake is async but called without await",
          "Risk: clearSkillAreaAnswers runs before state update completes",
          "Fix: Add await before enableSkillAreaRetake call",
          "Prevention: Enable @typescript-eslint/no-floating-promises rule in ESLint",
          "Validation: Add post-condition check to verify retakeAreas contains the new area"
        ]
      },
      {
        "input": "How should I structure async operations that depend on each other",
        "output": [
          "Check if operations share state: if yes, use sequential await",
          "Check if order matters: if yes, use sequential await",
          "If independent, use Promise.all() for parallel execution",
          "Example: await Promise.all([fetchUser(id), fetchSettings(id)]) when no dependencies"
        ]
      },
      {
        "input": "Why does my useEffect async code cause warnings",
        "output": [
          "useEffect cannot be async directly - it must return cleanup or nothing",
          "Use inner async function pattern: useEffect(() => { async function load() {...}; load(); }, [])",
          "Add cancellation flag to prevent state updates on unmounted component",
          "This prevents race conditions between async operations and component lifecycle"
        ]
      }
    ],
    "best_practices": [
      "Always await async functions or explicitly mark them as fire-and-forget with a comment",
      "Validate post-conditions after async operations that subsequent code depends on",
      "Use the inner async function pattern in useEffect with cleanup for race conditions"
    ],
    "anti_patterns": [
      "Calling async functions without await assuming they complete immediately",
      "Using Promise.all() when operations depend on shared state or must run in order",
      "Making useEffect callbacks async directly without cleanup handling"
    ],
    "faq": [
      {
        "question": "Which React Native versions are supported?",
        "answer": "Works with all React Native versions using TypeScript. Compatible with Expo and bare React Native projects."
      },
      {
        "question": "What are the limits of pattern detection?",
        "answer": "The skill provides guidance patterns. You must manually apply fixes to your codebase. No automated code scanning included."
      },
      {
        "question": "How do I integrate with my existing codebase?",
        "answer": "Review the ESLint configuration section and apply the recommended rules. Use the code review checklist during pull requests."
      },
      {
        "question": "Is my code sent anywhere?",
        "answer": "No. This is a documentation-only skill. Code snippets you share stay in your conversation and are not transmitted externally."
      },
      {
        "question": "Why do async bugs only appear in production?",
        "answer": "Development environments are fast and predictable. Production has network latency, slower devices, and concurrent operations that expose race conditions."
      },
      {
        "question": "How does this compare to unit testing async code?",
        "answer": "This skill helps write cleaner async code. Unit tests validate behavior. Use both together for comprehensive async reliability."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 256
    }
  ]
}
