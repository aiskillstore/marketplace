{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T14:45:26.718Z",
    "slug": "cjharmath-rn-state-flows",
    "source_url": "https://github.com/CJHarmath/claude-agents-skills/tree/main/skills/rn-state-flows",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "823a1a6b8e0f6def10153dd3302c239c4f8ad2fd43495ed2d3b3df394f4f303f",
    "tree_hash": "081adfd9c1edf33dd1b5fd4811d094efa069eec43a8501053bd033135a24684b"
  },
  "skill": {
    "name": "rn-state-flows",
    "description": "Complex multi-step operations in React Native. Use when implementing flows with multiple async steps, state machine patterns, or debugging flow ordering issues.",
    "summary": "Patterns for implementing complex multi-step operations with proper state management in React Native applications.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "CJHarmath",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "react-native",
      "state-management",
      "state-machine",
      "async-flows",
      "debugging"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings are false positives. Hash values in JSON triggered C2/crypto alerts. Markdown code block delimiters were misidentified as shell backtick execution. This is a documentation skill with TypeScript examples for React Native state management patterns.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 927,
    "audit_model": "claude",
    "audited_at": "2026-01-21T14:45:26.718Z"
  },
  "content": {
    "user_title": "Design Complex State Flows in React Native",
    "value_statement": "Complex multi-step operations in React Native are prone to ordering bugs and untested edge cases. This skill provides patterns for modeling state transitions, implementing validated flow steps, and surfacing flow state to the UI.",
    "seo_keywords": [
      "React Native state management",
      "state machine patterns",
      "async flow debugging",
      "multi-step operations",
      "TypeScript state flows",
      "React Native best practices",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Design state machine diagrams for complex multi-step operations",
      "Implement validated flow steps with preconditions and postconditions",
      "Create flow objects to structure long async sequences",
      "Track and surface flow state to React Native UI components",
      "Write integration tests for complete flow execution"
    ],
    "limitations": [
      "Does not replace dedicated state machine libraries like XState",
      "Does not provide runtime visualization or debugging tools",
      "Focuses on patterns rather than copy-paste solutions",
      "Requires manual implementation following documented patterns"
    ],
    "use_cases": [
      {
        "title": "Implement multi-step form flows",
        "description": "Design and implement wizards, onboarding flows, or checkout processes with proper state tracking and validation between steps.",
        "target_user": "React Native mobile developers"
      },
      {
        "title": "Debug complex async sequences",
        "description": "Diagnose ordering bugs and race conditions in existing flows by documenting state transitions and identifying missing validations.",
        "target_user": "Code reviewers and debugging engineers"
      },
      {
        "title": "Test flow-level scenarios",
        "description": "Create integration tests that verify complete flow execution including error handling at each step.",
        "target_user": "QA engineers and test automation specialists"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic flow description",
        "prompt": "I need to implement a flow in React Native where users [describe the overall process]. What states should I model and how should I structure the step validation?",
        "scenario": "Getting started with a new multi-step feature"
      },
      {
        "title": "Debugging existing flows",
        "prompt": "My current flow has a bug where [describe the issue]. The current implementation [describe current approach]. Help me identify the missing state or validation and design a fix.",
        "scenario": "Diagnosing bugs in existing flow code"
      },
      {
        "title": "Adding error handling",
        "prompt": "I have a flow with steps that can fail at various points: [list failure scenarios]. How should I structure error states and retry logic?",
        "scenario": "Adding robust error handling to existing flows"
      },
      {
        "title": "Testing strategy",
        "prompt": "I want to write integration tests for my [describe flow]. What scenarios should I cover and how do I structure the test setup?",
        "scenario": "Creating comprehensive test coverage for flows"
      }
    ],
    "output_examples": [
      {
        "input": "Design a user registration flow with email verification, profile creation, and account activation steps.",
        "output": "State Machine:\nIDLE â†’ VERIFYING_EMAIL â†’ CREATING_PROFILE â†’ ACTIVATING â†’ COMPLETE\n         â†“                              â†“\n      ERROR                         ERROR\n\nEach transition requires:\n- Precondition validation before executing\n- Postcondition check after completion\n- Error state with step context for UI feedback"
      },
      {
        "input": "Help me refactor this implicit flow into an explicit one with validation.",
        "output": "Refactored pattern:\n1. Create a FlowStep interface with execute and validate functions\n2. Define each step with pre/postcondition checks\n3. Execute flow in sequence with try-catch around each step\n4. Log flow ID for debugging across steps\n5. Surface status to UI for loading/error states"
      },
      {
        "input": "Write tests for a checkout flow with payment, inventory, and confirmation steps.",
        "output": "Test scenarios:\n- Happy path: complete flow with all steps succeeding\n- Payment failure: error caught and surfaced at payment step\n- Inventory failure: error after payment succeeds\n- Network recovery: retry logic at specific steps"
      }
    ],
    "best_practices": [
      "Model all states including error states before implementation, even with simple diagrams",
      "Validate preconditions before each step and postconditions after each step completes",
      "Log flow IDs and state transitions to enable debugging of multi-step issues"
    ],
    "anti_patterns": [
      "Implicit flow logic scattered across multiple functions without clear ordering",
      "Missing error handling at individual steps, causing silent failures",
      "No UI feedback during long async operations, leaving users uncertain of progress"
    ],
    "faq": [
      {
        "question": "When should I use this skill vs XState?",
        "answer": "Use this skill for flows with fewer than 6 states and straightforward transitions. Consider XState when you need visualization tools, complex parallel states, or shared state machine definitions across teams."
      },
      {
        "question": "Can these patterns work with Zustand or Redux?",
        "answer": "Yes, the patterns are library-agnostic. Examples use Zustand-style stores but the concepts apply to Redux, Context, or any state management solution."
      },
      {
        "question": "How do I handle concurrent flows?",
        "answer": "Each concurrent flow needs a unique flow ID and separate state tracking. Consider using a flow manager that coordinates multiple active flows and handles priority."
      },
      {
        "question": "What logging should I include for debugging flows?",
        "answer": "Log flow start, each step execution, step completion with validation results, errors with step context, and flow completion. Use a consistent flow ID across all logs."
      },
      {
        "question": "How do I test flow-level bugs that only appear in production?",
        "answer": "Add comprehensive logging with flow IDs, capture flow state snapshots on errors, and write integration tests that simulate the specific sequence that failed."
      },
      {
        "question": "Can these patterns be used for background sync flows?",
        "answer": "Yes, the same patterns apply. Model states like IDLE, SYNCING, COMPLETE, ERROR. Include retry logic and persistence of in-progress state for app restarts."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 377
    }
  ]
}
