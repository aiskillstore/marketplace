{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T16:53:27.695Z",
    "slug": "cjharmath-py-pydantic-patterns",
    "source_url": "https://github.com/CJHarmath/claude-agents-skills/tree/main/skills/py-pydantic-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "53089afa53bbff546da1774d16741636a6f5e5d7b1460eaeed4ac7319a2729a8",
    "tree_hash": "f6390e72e825a5fce73489f99f2ab4524361896789f7b2c71b476f1e46040edf"
  },
  "skill": {
    "name": "py-pydantic-patterns",
    "description": "Pydantic v2 patterns for validation and serialization. Use when creating schemas, validating data, or working with request/response models.",
    "summary": "Pydantic v2 patterns for data validation, serialization, and schema design",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "CJHarmath",
    "license": "MIT",
    "tags": [
      "pydantic",
      "python",
      "validation",
      "serialization",
      "data-schemas"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Documentation-only skill providing Pydantic v2 patterns. Static scanner flagged 14 false positives: Pydantic field constraints (gt, le, ge) misidentified as cryptographic algorithms; grep command examples misidentified as shell execution; valid strings misidentified as reconnaissance. All findings are benign documentation content.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 1011,
    "audit_model": "claude",
    "audited_at": "2026-01-21T16:53:27.695Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Apply Pydantic v2 Validation Patterns",
    "value_statement": "Pydantic v2 has significant API changes from v1. This skill provides proven patterns for validation, serialization, and schema design to help you migrate and build robust data models.",
    "seo_keywords": [
      "Pydantic v2",
      "Python validation",
      "data validation",
      "Pydantic patterns",
      "serialization",
      "schema design",
      "field validation",
      "model validation",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Migrate Pydantic v1 code to v2 with correct decorators and methods",
      "Implement field validators with single-field and cross-field validation",
      "Configure models with ConfigDict for ORM integration and behavior control",
      "Create discriminated unions for polymorphic data structures",
      "Build custom types with BeforeValidator and AfterValidator",
      "Control serialization output with field_serializer and computed_field"
    ],
    "limitations": [
      "Does not include runtime performance benchmarks or optimization",
      "Does not provide database integration code beyond ORM compatibility",
      "Does not cover Pydantic v1 legacy support in detail",
      "Does not include migration scripts or automated conversion tools"
    ],
    "use_cases": [
      {
        "title": "Build validated API request schemas",
        "description": "Create Pydantic models that validate incoming API data, ensuring type safety and business rules are enforced before processing.",
        "target_user": "Backend developers building REST or GraphQL APIs"
      },
      {
        "title": "Migrate from Pydantic v1 to v2",
        "description": "Identify and replace deprecated v1 patterns with v2 equivalents using the migration patterns and detection commands.",
        "target_user": "Python developers maintaining legacy codebases"
      },
      {
        "title": "Design database ORM models",
        "description": "Configure Pydantic models that work with SQLAlchemy or SQLModel, enabling seamless conversion between ORM objects and API schemas.",
        "target_user": "Full-stack developers working with databases"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic validation model",
        "prompt": "Create a Pydantic v2 model for a user registration form with fields: email, password, and confirm_password. Add validation to ensure email format is valid, password meets minimum length, and password matches confirm_password.",
        "scenario": "You need to validate user input for a registration endpoint"
      },
      {
        "title": "ORM integration",
        "prompt": "Write a Pydantic v2 model that can validate data from a SQLAlchemy ORM object. Include configuration for from_attributes and handle fields like UUID, datetime, and relationships.",
        "scenario": "You need to convert ORM objects to JSON-serializable responses"
      },
      {
        "title": "Complex validation with custom types",
        "prompt": "Create a Pydantic model with custom types for phone number, email, and UUID. Use BeforeValidator and AfterValidator to normalize and validate input data before the model is created.",
        "scenario": "You need reusable validated types with normalization logic"
      },
      {
        "title": "Polymorphic API responses",
        "prompt": "Design a discriminated union pattern for an API that returns different question types (text, multiple_choice, rating). Show how Pydantic automatically selects the correct model based on a discriminator field.",
        "scenario": "You need to handle polymorphic response data in an API"
      }
    ],
    "output_examples": [
      {
        "input": "Create a Pydantic model for a product with name, price, and quantity. Price must be positive. Quantity must be non-negative.",
        "output": "```python\nfrom pydantic import BaseModel, Field\n\nclass Product(BaseModel):\n    name: str = Field(min_length=1, max_length=200)\n    price: float = Field(gt=0, description=\"Product price in USD\")\n    quantity: int = Field(ge=0, description=\"Available inventory\")\n```"
      },
      {
        "input": "Write a Pydantic v2 model validator that checks end_date is after start_date.",
        "output": "```python\nfrom datetime import datetime\nfrom pydantic import BaseModel, model_validator\n\nclass Event(BaseModel):\n    name: str\n    start_date: datetime\n    end_date: datetime\n    \n    @model_validator(mode=\"after\")\n    def validate_date_range(self):\n        if self.end_date < self.start_date:\n            raise ValueError(\"end_date must be after start_date\")\n        return self\n```"
      }
    ],
    "best_practices": [
      "Use field_validator with @classmethod decorator instead of the deprecated @validator from v1",
      "Configure model_config with from_attributes=True when working with ORM objects",
      "Use Field descriptions to generate OpenAPI documentation automatically",
      "Prefer model_validator over field_validator when validation requires multiple fields"
    ],
    "anti_patterns": [
      "Using .dict() and .json() methods - these are v1 APIs; use .model_dump() and .model_dump_json() instead",
      "Defining validators inside class Config - v2 uses decorators and model_config dictionary",
      "Mixing v1 and v2 patterns which causes validation to fail silently",
      "Forgetting @classmethod on field_validator which causes runtime errors"
    ],
    "faq": [
      {
        "question": "How do I migrate from Pydantic v1 to v2?",
        "answer": "Replace @validator with @field_validator, change class Config to model_config dict, use .model_dump() instead of .dict(), and use from_attributes=True instead of orm_mode. The Detection Commands section shows grep patterns to find v1 code."
      },
      {
        "question": "What is the difference between field_validator and model_validator?",
        "answer": "field_validator validates individual fields and can access other fields through ValidationInfo. model_validator validates the entire model before or after validation, ideal for cross-field validation like date ranges."
      },
      {
        "question": "How do I configure Pydantic to work with SQLAlchemy?",
        "answer": "Set model_config = ConfigDict(from_attributes=True) on your model. This allows Pydantic to read attributes from ORM objects. Use model_validate(orm_object) to create a model instance from the ORM object."
      },
      {
        "question": "Can I use Pydantic for API documentation?",
        "answer": "Yes. Field descriptions, examples, and aliases generate OpenAPI documentation automatically. Use Field(description=\"...\", examples=[...]) to add metadata that appears in Swagger/OpenAPI docs."
      },
      {
        "question": "How do I create reusable validated types?",
        "answer": "Use Annotated types with BeforeValidator or AfterValidator. Define a validation function, annotate it, and reuse the type across multiple models. This keeps validation logic DRY and consistent."
      },
      {
        "question": "How do I exclude None values or sensitive data from serialization?",
        "answer": "Use model_dump(exclude_none=True) to skip None fields. Use exclude={\"password\"} to skip specific fields. Use field_serializer to transform values before output, such as masking sensitive data."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 359
    }
  ]
}
