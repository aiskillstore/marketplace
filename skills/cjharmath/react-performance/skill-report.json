{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T16:58:13.782Z",
    "slug": "cjharmath-react-performance",
    "source_url": "https://github.com/CJHarmath/claude-agents-skills/tree/main/skills/react-performance",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "6113ae86e2af8a2badf0ec6e566171fe4cdfc2f6ff3759da6b09b13b414fb3f8",
    "tree_hash": "520e089c9531a1f6e750855d5ed30c680bff6739c55f25fbced45426c1f91120"
  },
  "skill": {
    "name": "react-performance",
    "description": "Performance optimization for React web applications. Use when optimizing renders, implementing virtualization, memoizing components, or debugging performance issues.",
    "summary": "Expert guidance for React performance optimization including memoization, virtualization, and code splitting techniques.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "CJHarmath",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "react",
      "performance",
      "optimization",
      "memoization",
      "virtualization"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings are false positives from educational code examples. The skill contains legitimate React performance optimization patterns including lazy loading, Web Workers, and memoization techniques. No security concerns detected.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 1074,
    "audit_model": "claude",
    "audited_at": "2026-01-21T16:58:13.782Z"
  },
  "content": {
    "user_title": "Optimize React Application Performance",
    "value_statement": "React applications often suffer from unnecessary re-renders and slow list rendering causing poor user experience. This skill provides expert patterns for memoization, virtualization, code splitting, and performance profiling to build fast, responsive React applications.",
    "seo_keywords": [
      "React performance",
      "Claude Code",
      "memoization",
      "virtualization",
      "React optimization",
      "useMemo",
      "useCallback",
      "code splitting",
      "Claude",
      "Codex"
    ],
    "actual_capabilities": [
      "Implement memoization patterns using useMemo, useCallback, and React.memo",
      "Apply list virtualization with react-window for rendering large datasets",
      "Optimize Zustand store selectors to prevent unnecessary re-renders",
      "Configure code splitting and lazy loading for route-based performance",
      "Debug performance issues using React DevTools Profiler and why-did-you-render",
      "Implement Web Workers for offloading heavy computations from main thread"
    ],
    "limitations": [
      "Focuses on React web applications, not React Native mobile performance",
      "Assumes familiarity with React hooks and functional component patterns",
      "Does not cover server-side rendering or Next.js specific optimizations beyond basics",
      "Performance recommendations are general guidelines that may need adjustment based on specific use cases"
    ],
    "use_cases": [
      {
        "title": "Optimize Large Data Tables",
        "description": "Improve rendering performance for tables with thousands of rows by implementing virtualization and memoized row components.",
        "target_user": "Frontend developers building data-intensive dashboards"
      },
      {
        "title": "Fix Re-render Performance Issues",
        "description": "Identify and eliminate unnecessary component re-renders using profiling tools and proper memoization techniques.",
        "target_user": "React developers troubleshooting slow application interactions"
      },
      {
        "title": "Reduce Initial Bundle Size",
        "description": "Implement route-based code splitting and lazy loading to decrease initial load times and improve time-to-interactive metrics.",
        "target_user": "Web performance engineers optimizing core web vitals"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Re-render Analysis",
        "prompt": "Review this React component and identify any unnecessary re-renders. Suggest specific memoization improvements.",
        "scenario": "You have a component that seems to render more often than expected"
      },
      {
        "title": "List Performance Optimization",
        "prompt": "I have a list rendering 500 items that scrolls slowly. Help me implement virtualization with react-window and optimize the item components.",
        "scenario": "Your application displays long lists with performance lag"
      },
      {
        "title": "Zustand Selector Optimization",
        "prompt": "Analyze my Zustand store usage and convert whole-store selectors to specific selectors to reduce re-renders.",
        "scenario": "Components re-render on unrelated state changes in global store"
      },
      {
        "title": "Advanced Performance Audit",
        "prompt": "Perform a complete performance audit of my React application. Check for memoization opportunities, bundle size issues, and suggest code splitting strategies. Include profiler analysis recommendations.",
        "scenario": "You need a comprehensive performance review before production launch"
      }
    ],
    "output_examples": [
      {
        "input": "This component re-renders when I type in an unrelated input field. How do I fix it?",
        "output": "The component is re-rendering because it receives a new inline object prop on every parent render. Wrap the object in useMemo or define it outside the component. Also ensure any callback props use useCallback. I can help refactor the parent component to create stable references."
      },
      {
        "input": "Help me virtualize this list of 1000 products",
        "output": "I will implement react-window FixedSizeList for your product list. First, I will wrap each product item with React.memo to prevent unnecessary re-renders. Then I will configure the virtual list container with appropriate height and item size. The visible items will render instantly while maintaining smooth scrolling."
      },
      {
        "input": "My app bundle is 2MB and loads slowly. What should I do?",
        "output": "I will analyze your imports and implement route-based code splitting using React.lazy. Large libraries will be moved to separate chunks loaded on demand. I will also check for duplicate dependencies and suggest dynamic imports for heavy components like charts and editors that are not immediately visible."
      }
    ],
    "best_practices": [
      "Always profile before optimizing. Use React DevTools Profiler to identify actual bottlenecks rather than premature optimization.",
      "Memoize components and values strategically. Only apply useMemo and useCallback when profiling shows measurable benefit, as they add overhead.",
      "Use specific Zustand selectors instead of selecting entire store. Components should only subscribe to the exact state slices they need."
    ],
    "anti_patterns": [
      "Wrapping every component with React.memo without profiling. This adds unnecessary comparison overhead for components that render infrequently or with changing props.",
      "Memoizing simple primitive operations like string concatenation or basic arithmetic. The memoization overhead exceeds the computation cost.",
      "Using inline objects or functions as props to memoized children. This defeats memoization because new references are created on every render."
    ],
    "faq": [
      {
        "question": "When should I use useMemo versus useCallback?",
        "answer": "Use useMemo for memoizing computed values like filtered arrays or complex calculations. Use useCallback for memoizing function references that are passed as props to memoized children or used in dependency arrays. Both prevent unnecessary re-renders by maintaining stable references."
      },
      {
        "question": "How do I know if my list needs virtualization?",
        "answer": "Virtualize lists with 100 or more items, especially if items are complex components. If you notice scroll lag or slow initial render with large datasets, virtualization will help by only rendering visible items in the viewport."
      },
      {
        "question": "Does React.memo work with all components?",
        "answer": "React.memo works with functional components and performs shallow comparison of props by default. For deep comparison or complex props, provide a custom comparison function as the second argument. It is most effective for components with stable props."
      },
      {
        "question": "Why is my Zustand component still re-rendering?",
        "answer": "You are likely selecting the entire store or multiple values without shallow comparison. Use specific selectors like useStore(s => s.items) or wrap multiple selections with useShallow to only trigger re-renders when selected values actually change."
      },
      {
        "question": "How do I debug what caused a component to re-render?",
        "answer": "Use React DevTools Profiler to record interactions and see which components rendered. Install why-did-you-render library in development to get console logs explaining why memoized components re-rendered. Check for new object references in props and dependency arrays."
      },
      {
        "question": "Should I code split every route in my application?",
        "answer": "Code split routes that are not immediately needed on initial load. Keep critical landing pages in the main bundle for fast initial render. Split heavy features like admin panels, settings pages, and large data visualization routes to reduce initial bundle size."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 463
    }
  ]
}
