{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T11:26:19.567Z",
    "slug": "bikach-backend-architect",
    "source_url": "https://github.com/Bikach/skills-claude-code/tree/main/backend-architect",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "d8dfe30d5860f08ea78a5aec6b15d2a67205432b87106950b6f6464685ab403e",
    "tree_hash": "0b3e6a09989fe286d4fcaed65ddf83651398abbbded03a110a393880c8ee8b9f"
  },
  "skill": {
    "name": "backend-architect",
    "description": "Expert senior en architecture backend pour accompagner le d√©veloppement (conception, impl√©mentation, review, refactoring). Architecture hexagonale, DDD, SOLID, clean code, tests. Utiliser pour concevoir de nouvelles features, d√©velopper du code, reviewer, refactorer, ou r√©soudre des probl√®mes architecturaux.",
    "summary": "Expert senior en architecture backend pour accompagner le d√©veloppement (conception, impl√©mentation,...",
    "icon": "üèóÔ∏è",
    "version": "1.0.0",
    "author": "Bikach",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "backend",
      "architecture",
      "ddd",
      "solid"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a pure documentation-based skill containing only markdown files and a SKILL.md prompt. No executable code, network calls, filesystem operations, or code execution paths exist. All content is educational architectural guidance.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 21,
    "total_lines": 4191,
    "audit_model": "claude",
    "audited_at": "2026-01-10T11:26:19.567Z"
  },
  "content": {
    "user_title": "Design and review backend architecture",
    "value_statement": "Complex backend systems need strong architectural foundations. This skill provides expert guidance on hexagonal architecture, domain-driven design, SOLID principles, and code quality to help you build maintainable and scalable applications.",
    "seo_keywords": [
      "backend architecture",
      "hexagonal architecture",
      "domain driven design",
      "DDD",
      "SOLID principles",
      "clean code",
      "code review",
      "refactoring",
      "Claude",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Guide implementation of hexagonal and clean architecture patterns",
      "Analyze code for SOLID principle violations",
      "Detect and refactor common code smells",
      "Provide DDD patterns and bounded context guidance",
      "Review test coverage and quality",
      "Checklist-based performance analysis"
    ],
    "limitations": [
      "Does not generate code directly - provides architectural guidance",
      "Does not execute or test user code",
      "Does not access external systems or APIs",
      "Limited to text-based architectural advice"
    ],
    "use_cases": [
      {
        "target_user": "Software Architects",
        "title": "Design New Systems",
        "description": "Plan hexagonal architecture and bounded contexts for new backend projects"
      },
      {
        "target_user": "Lead Developers",
        "title": "Code Review Guide",
        "description": "Review team code for architecture violations and code smells"
      },
      {
        "target_user": "Backend Developers",
        "title": "Refactoring Support",
        "description": "Identify and fix SOLID violations, God Classes, and other architectural issues"
      }
    ],
    "prompt_templates": [
      {
        "title": "Analyze Architecture",
        "scenario": "Review existing code",
        "prompt": "Analyze this codebase for architecture violations. Check if the code follows hexagonal architecture principles and identify any SOLID principle violations."
      },
      {
        "title": "Refactor Guidance",
        "scenario": "Fix code smells",
        "prompt": "Help me refactor this God Class. What responsibilities should be extracted and how should I structure the new classes?"
      },
      {
        "title": "Design Pattern",
        "scenario": "New feature design",
        "prompt": "Design the bounded contexts and ports/adapters for a new user management feature using DDD and hexagonal architecture."
      },
      {
        "title": "Checklist Review",
        "scenario": "Quality assessment",
        "prompt": "Use the clean code and testing checklists to review this code. List all issues found with file locations and severity levels."
      }
    ],
    "output_examples": [
      {
        "input": "Review this UserService class for architecture issues",
        "output": [
          "P0 - God Class detected: UserService has 15+ methods handling CRUD, email sending, and reporting",
          "Violation: Single Responsibility Principle - split into separate use cases",
          "Recommendation: Extract CreateUserUseCase, UserReportService, and move email logic to EmailGateway adapter"
        ]
      }
    ],
    "best_practices": [
      "Start with bounded context definitions before implementing features",
      "Keep domain logic independent of infrastructure concerns",
      "Use ports and adapters to decouple business rules from frameworks",
      "Apply SOLID principles incrementally during code reviews"
    ],
    "anti_patterns": [
      "Putting business logic in controllers or adapters",
      "Using concrete database classes directly in use cases",
      "Creating large classes with multiple unrelated responsibilities",
      "Skipping test coverage for domain layer logic"
    ],
    "faq": [
      {
        "question": "Which programming languages support hexagonal architecture?",
        "answer": "Hexagonal architecture is language-agnostic. It works with Java, TypeScript, Python, Go, and any OO or FP language that supports interfaces and dependency injection."
      },
      {
        "question": "How large should a bounded context be?",
        "answer": "A bounded context should align with a single business capability. It can range from a few files to many modules depending on the subdomain complexity."
      },
      {
        "question": "Can this skill integrate with my existing code review tools?",
        "answer": "This skill provides guidance that you can apply manually or through CI/CD pipelines. It does not directly integrate with external tools."
      },
      {
        "question": "Is my code data sent to external servers?",
        "answer": "No. This skill operates entirely within your AI conversation. No code or data is transmitted externally."
      },
      {
        "question": "What if my codebase does not use DDD patterns?",
        "answer": "The skill adapts to your context. It can provide guidance using simpler layered architecture or help you migrate toward DDD incrementally."
      },
      {
        "question": "How does this compare to static analysis tools?",
        "answer": "This skill provides human-readable architectural guidance and context-aware suggestions. Static analysis tools find syntax issues and can complement this skill for comprehensive reviews."
      }
    ]
  },
  "file_structure": [
    {
      "name": "architecture",
      "type": "dir",
      "path": "architecture",
      "children": [
        {
          "name": "ddd-patterns.md",
          "type": "file",
          "path": "architecture/ddd-patterns.md"
        },
        {
          "name": "dependency-injection.md",
          "type": "file",
          "path": "architecture/dependency-injection.md"
        },
        {
          "name": "hexagonal.md",
          "type": "file",
          "path": "architecture/hexagonal.md"
        }
      ]
    },
    {
      "name": "checklists",
      "type": "dir",
      "path": "checklists",
      "children": [
        {
          "name": "clean-code-checklist.md",
          "type": "file",
          "path": "checklists/clean-code-checklist.md"
        },
        {
          "name": "performance-checklist.md",
          "type": "file",
          "path": "checklists/performance-checklist.md"
        },
        {
          "name": "testing-checklist.md",
          "type": "file",
          "path": "checklists/testing-checklist.md"
        }
      ]
    },
    {
      "name": "code-smells",
      "type": "dir",
      "path": "code-smells",
      "children": [
        {
          "name": "data-clumps.md",
          "type": "file",
          "path": "code-smells/data-clumps.md"
        },
        {
          "name": "feature-envy.md",
          "type": "file",
          "path": "code-smells/feature-envy.md"
        },
        {
          "name": "god-class.md",
          "type": "file",
          "path": "code-smells/god-class.md"
        },
        {
          "name": "long-method.md",
          "type": "file",
          "path": "code-smells/long-method.md"
        },
        {
          "name": "primitive-obsession.md",
          "type": "file",
          "path": "code-smells/primitive-obsession.md"
        },
        {
          "name": "shotgun-surgery.md",
          "type": "file",
          "path": "code-smells/shotgun-surgery.md"
        }
      ]
    },
    {
      "name": "examples",
      "type": "dir",
      "path": "examples",
      "children": [
        {
          "name": "bad-vs-good-refactoring.md",
          "type": "file",
          "path": "examples/bad-vs-good-refactoring.md"
        },
        {
          "name": "good-hexagonal-structure.md",
          "type": "file",
          "path": "examples/good-hexagonal-structure.md"
        }
      ]
    },
    {
      "name": "solid-principles",
      "type": "dir",
      "path": "solid-principles",
      "children": [
        {
          "name": "dependency-inversion.md",
          "type": "file",
          "path": "solid-principles/dependency-inversion.md"
        },
        {
          "name": "interface-segregation.md",
          "type": "file",
          "path": "solid-principles/interface-segregation.md"
        },
        {
          "name": "liskov-substitution.md",
          "type": "file",
          "path": "solid-principles/liskov-substitution.md"
        },
        {
          "name": "open-closed.md",
          "type": "file",
          "path": "solid-principles/open-closed.md"
        },
        {
          "name": "single-responsibility.md",
          "type": "file",
          "path": "solid-principles/single-responsibility.md"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
