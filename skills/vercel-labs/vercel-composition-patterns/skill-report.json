{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-28T04:23:06.875Z",
    "slug": "vercel-labs-vercel-composition-patterns",
    "source_url": "https://github.com/vercel-labs/agent-skills/tree/main/skills/composition-patterns/",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "b6d80568d60fe50b1680880ee1da0a83dc3caab8f8f9bcfd2d935feebf1db8ef",
    "tree_hash": "c0eb819690f581991072d92f6e0dd38ec2783e12170404478309b3a3250a2a96"
  },
  "skill": {
    "name": "vercel-composition-patterns",
    "description": "React composition patterns that scale. Use when refactoring components with boolean prop proliferation, building flexible component libraries, or designing reusable APIs. Triggers on tasks involving compound components, render props, context providers, or component architecture.",
    "summary": "React composition patterns that scale. Use when refactoring components with boolean prop proliferation, building flexible component libraries, or designing reusable APIs.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "vercel-labs",
    "license": "MIT",
    "tags": [
      "react",
      "component-architecture",
      "composition",
      "patterns",
      "frontend"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Documentation-only skill containing React composition pattern guidelines. All static scanner findings are false positives: detected 'backtick execution' patterns are markdown code examples in documentation, not actual shell commands. Network URLs are legitimate React.dev documentation links. No executable code present.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 13,
    "total_lines": 1940,
    "audit_model": "claude",
    "audited_at": "2026-01-28T04:23:06.875Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Apply React composition patterns",
    "value_statement": "Building React components with boolean props leads to unmaintainable code. This skill provides AI-ready guidelines for using compound components, lifting state, and composing internals to create scalable component architectures.",
    "seo_keywords": [
      "React composition patterns",
      "Claude",
      "Codex",
      "Claude Code",
      "component architecture",
      "compound components",
      "React component patterns",
      "boolean props refactor",
      "React context patterns",
      "children over render props"
    ],
    "actual_capabilities": [
      "Guidance on avoiding boolean prop proliferation in React components",
      "Patterns for implementing compound components with shared context",
      "State management patterns that decouple implementation from interface",
      "Techniques for lifting state into provider components",
      "Recommendations for using children over render props",
      "Creating explicit component variants instead of conditional modes"
    ],
    "limitations": [
      "Contains documentation only, does not execute or modify code directly",
      "Focuses on React patterns, may not apply to other frameworks",
      "Best practices assume TypeScript usage"
    ],
    "use_cases": [
      {
        "title": "Refactor complex component props",
        "description": "When a component has many boolean props like isThread, isEditing, isDMThread, apply composition patterns to eliminate conditional complexity.",
        "target_user": "Frontend developers refactoring legacy React codebases"
      },
      {
        "title": "Design new component libraries",
        "description": "When building a reusable component library, use compound component patterns to create flexible, composable APIs that scale.",
        "target_user": "Library authors and UI/UX engineers"
      },
      {
        "title": "Review component architecture",
        "description": "When reviewing React code, check for composition patterns that enable easier maintenance and AI-assisted refactoring.",
        "target_user": "Code reviewers and architects"
      }
    ],
    "prompt_templates": [
      {
        "title": "Simple pattern reference",
        "prompt": "How should I structure this React component to avoid boolean props? Use the vercel-composition-patterns skill.",
        "scenario": "Quick reference for a single component"
      },
      {
        "title": "State management guidance",
        "prompt": "I need to share state between sibling components. Following the vercel-composition-patterns skill, what's the recommended approach using context providers?",
        "scenario": "State sharing between components"
      },
      {
        "title": "Component API design",
        "prompt": "Review my component API design using the vercel-composition-patterns skill. How can I replace render props with children composition?",
        "scenario": "Refactoring render props to children"
      },
      {
        "title": "Architecture refactoring",
        "prompt": "Refactor this component file following vercel-composition-patterns: convert boolean props to compound components, lift shared state into providers, and ensure all states are representable.",
        "scenario": "Full component refactoring task"
      }
    ],
    "output_examples": [
      {
        "input": "Component has isThread, isEditing, isDMThread, isForwarding boolean props",
        "output": [
          "Convert to compound components: Composer.Frame, Composer.Header, Composer.Input",
          "Replace conditionals with composition: <ThreadComposer /> or <EditMessageComposer />",
          "Lift state into provider components for sibling access"
        ]
      },
      {
        "input": "State needs to be accessed by multiple sibling components",
        "output": [
          "Create a context provider that owns the state",
          "Expose state and actions through a generic interface",
          "Components access state via context, not props"
        ]
      }
    ],
    "best_practices": [
      "Avoid boolean props that multiply possible states; use composition instead to eliminate impossible states.",
      "Structure components as compound components that share context, with each variant being explicit and self-contained.",
      "Decouple state management from UI by defining generic interfaces with state, actions, and metadata for dependency injection."
    ],
    "anti_patterns": [
      "Using boolean props like isEnabled, isVisible, isActive to control component behavior creates exponential state combinations.",
      "Passing state through many prop layers instead of using context providers for sibling component access.",
      "Using render props when children composition would be simpler and more readable."
    ],
    "faq": [
      {
        "question": "When should I use compound components vs single component with props?",
        "answer": "Use compound components when you have multiple related pieces that should be composed flexibly. Single components with props work for simple cases but become unwieldy with more than 2-3 configuration options."
      },
      {
        "question": "How do compound components share state?",
        "answer": "Compound components share state through React context. A parent provider component manages state and exposes it to all child components via the context API."
      },
      {
        "question": "What is the benefit of explicit variants over boolean props?",
        "answer": "Explicit variants like ThreadComposer and EditMessageComposer make code self-documenting and eliminate impossible state combinations. Each variant is clear about what it renders and what state it uses."
      },
      {
        "question": "When should I use children instead of render props?",
        "answer": "Use children for composing static structure. Use render props when the parent needs to pass data or state callbacks to the rendered content. Children are more natural for layout composition."
      },
      {
        "question": "How does this help AI agents?",
        "answer": "Composition patterns create predictable, consistent code structures that AI agents can easily understand, modify, and extend. There are fewer hidden conditionals and impossible states to reason about."
      },
      {
        "question": "Does this work with React Server Components?",
        "answer": "Yes, the composition patterns work with RSC. State management patterns apply to client components, while architecture patterns like avoiding boolean props and using explicit variants benefit both server and client code."
      }
    ]
  },
  "file_structure": [
    {
      "name": "rules",
      "type": "dir",
      "path": "rules",
      "children": [
        {
          "name": "_sections.md",
          "type": "file",
          "path": "rules/_sections.md",
          "lines": 25
        },
        {
          "name": "_template.md",
          "type": "file",
          "path": "rules/_template.md",
          "lines": 25
        },
        {
          "name": "architecture-avoid-boolean-props.md",
          "type": "file",
          "path": "rules/architecture-avoid-boolean-props.md",
          "lines": 101
        },
        {
          "name": "architecture-compound-components.md",
          "type": "file",
          "path": "rules/architecture-compound-components.md",
          "lines": 113
        },
        {
          "name": "patterns-children-over-render-props.md",
          "type": "file",
          "path": "rules/patterns-children-over-render-props.md",
          "lines": 88
        },
        {
          "name": "patterns-explicit-variants.md",
          "type": "file",
          "path": "rules/patterns-explicit-variants.md",
          "lines": 101
        },
        {
          "name": "state-context-interface.md",
          "type": "file",
          "path": "rules/state-context-interface.md",
          "lines": 192
        },
        {
          "name": "state-decouple-implementation.md",
          "type": "file",
          "path": "rules/state-decouple-implementation.md",
          "lines": 114
        },
        {
          "name": "state-lift-state.md",
          "type": "file",
          "path": "rules/state-lift-state.md",
          "lines": 126
        }
      ]
    },
    {
      "name": "AGENTS.md",
      "type": "file",
      "path": "AGENTS.md",
      "lines": 900
    },
    {
      "name": "metadata.json",
      "type": "file",
      "path": "metadata.json",
      "lines": 12
    },
    {
      "name": "README.md",
      "type": "file",
      "path": "README.md",
      "lines": 61
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 82
    }
  ]
}
