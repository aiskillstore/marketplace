{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-16T23:11:52.603Z",
    "slug": "consiliency-treesitter-patterns",
    "source_url": "https://github.com/Consiliency/treesitter-chunker/tree/main/.ai-dev-kit/skills/treesitter-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "dfa701011e55e426d20f36d189cc7fe8dd2dba20a6b69d3deda1adddce2cd2c5",
    "tree_hash": "2189d8e11f97d4a103273ec8deb976a17bcc5bae903c956fbdc360bf0e99a1e3"
  },
  "skill": {
    "name": "treesitter-patterns",
    "description": "Universal patterns for tree-sitter code parsing. Covers AST visitors, query patterns, and language plugin development. Framework-agnostic.",
    "summary": "Universal patterns for tree-sitter code parsing. Covers AST visitors, query patterns, and language p...",
    "icon": "ðŸŒ³",
    "version": "1.0.0",
    "author": "Consiliency",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "tree-sitter",
      "AST",
      "code parsing",
      "query patterns",
      "language plugins"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill contains only markdown documentation with tree-sitter code examples. No executable code, network calls, file operations, or cryptographic operations exist. Static findings are false positives from documentation patterns being misidentified.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 48,
            "line_end": 48
          },
          {
            "file": "SKILL.md",
            "line_start": 52,
            "line_end": 52
          },
          {
            "file": "SKILL.md",
            "line_start": 56,
            "line_end": 56
          },
          {
            "file": "SKILL.md",
            "line_start": 62,
            "line_end": 76
          },
          {
            "file": "SKILL.md",
            "line_start": 76,
            "line_end": 80
          },
          {
            "file": "SKILL.md",
            "line_start": 80,
            "line_end": 99
          },
          {
            "file": "SKILL.md",
            "line_start": 99,
            "line_end": 103
          },
          {
            "file": "SKILL.md",
            "line_start": 103,
            "line_end": 124
          },
          {
            "file": "SKILL.md",
            "line_start": 124,
            "line_end": 128
          },
          {
            "file": "SKILL.md",
            "line_start": 128,
            "line_end": 140
          },
          {
            "file": "SKILL.md",
            "line_start": 140,
            "line_end": 146
          },
          {
            "file": "SKILL.md",
            "line_start": 146,
            "line_end": 146
          },
          {
            "file": "SKILL.md",
            "line_start": 146,
            "line_end": 146
          },
          {
            "file": "SKILL.md",
            "line_start": 146,
            "line_end": 147
          },
          {
            "file": "SKILL.md",
            "line_start": 147,
            "line_end": 147
          },
          {
            "file": "SKILL.md",
            "line_start": 147,
            "line_end": 147
          },
          {
            "file": "SKILL.md",
            "line_start": 147,
            "line_end": 148
          },
          {
            "file": "SKILL.md",
            "line_start": 148,
            "line_end": 148
          },
          {
            "file": "SKILL.md",
            "line_start": 148,
            "line_end": 148
          },
          {
            "file": "SKILL.md",
            "line_start": 148,
            "line_end": 149
          },
          {
            "file": "SKILL.md",
            "line_start": 149,
            "line_end": 149
          },
          {
            "file": "SKILL.md",
            "line_start": 149,
            "line_end": 149
          },
          {
            "file": "SKILL.md",
            "line_start": 149,
            "line_end": 150
          },
          {
            "file": "SKILL.md",
            "line_start": 150,
            "line_end": 150
          },
          {
            "file": "SKILL.md",
            "line_start": 150,
            "line_end": 150
          },
          {
            "file": "SKILL.md",
            "line_start": 150,
            "line_end": 154
          },
          {
            "file": "SKILL.md",
            "line_start": 154,
            "line_end": 172
          },
          {
            "file": "SKILL.md",
            "line_start": 172,
            "line_end": 176
          },
          {
            "file": "SKILL.md",
            "line_start": 176,
            "line_end": 208
          },
          {
            "file": "SKILL.md",
            "line_start": 208,
            "line_end": 212
          },
          {
            "file": "SKILL.md",
            "line_start": 212,
            "line_end": 222
          },
          {
            "file": "SKILL.md",
            "line_start": 222,
            "line_end": 233
          },
          {
            "file": "SKILL.md",
            "line_start": 233,
            "line_end": 237
          },
          {
            "file": "SKILL.md",
            "line_start": 237,
            "line_end": 251
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 436,
    "audit_model": "claude",
    "audited_at": "2026-01-16T23:11:52.603Z"
  },
  "content": {
    "user_title": "Parse code with tree-sitter patterns",
    "value_statement": "Working with tree-sitter requires understanding AST navigation, query patterns, and visitor implementations. This skill provides ready-to-use patterns for parsing any programming language.",
    "seo_keywords": [
      "tree-sitter",
      "AST parsing",
      "code analysis",
      "Claude Code",
      "Claude",
      "Codex",
      "query patterns",
      "language parser",
      "visitor pattern",
      "code extraction"
    ],
    "actual_capabilities": [
      "Parse source code into AST using tree-sitter parsers",
      "Navigate and traverse AST nodes with visitors",
      "Write tree-sitter query patterns for code extraction",
      "Handle parse errors and edge cases gracefully",
      "Build language plugins with framework-agnostic patterns",
      "Extract functions, classes, and imports from code"
    ],
    "limitations": [
      "Does not install tree-sitter language parsers automatically",
      "Requires existing tree-sitter language bindings",
      "Does not execute or evaluate parsed code",
      "Does not handle parser compilation or grammar creation"
    ],
    "use_cases": [
      {
        "target_user": "Code analysis developers",
        "title": "Extract code structures",
        "description": "Pull function definitions, class declarations, and imports from any codebase for analysis."
      },
      {
        "target_user": "Plugin developers",
        "title": "Build language tools",
        "description": "Create new language plugins using visitor patterns and query optimizations."
      },
      {
        "target_user": "Documentation engineers",
        "title": "Generate code references",
        "description": "Parse source files to auto-generate API documentation and code inventories."
      }
    ],
    "prompt_templates": [
      {
        "title": "Parse function",
        "scenario": "Extract functions from Python code",
        "prompt": "Use tree-sitter to parse this Python code and extract all function definitions with their names and parameters."
      },
      {
        "title": "Build AST visitor",
        "scenario": "Create custom AST traversal",
        "prompt": "Create an AST visitor class that walks the parse tree and collects all class definitions."
      },
      {
        "title": "Write query pattern",
        "scenario": "Match code patterns",
        "prompt": "Write a tree-sitter query to find all decorated functions with @pytest.mark decorators."
      },
      {
        "title": "Handle errors",
        "scenario": "Graceful parse handling",
        "prompt": "Parse this code with error handling. Return both the tree and any parse errors encountered."
      }
    ],
    "output_examples": [
      {
        "input": "Parse this JavaScript file and list all exported functions",
        "output": [
          "parseModule - line 12-45 - Parses module dependencies",
          "validateSchema - line 48-72 - Validates JSON schema",
          "buildAST - line 75-98 - Constructs abstract syntax tree"
        ]
      },
      {
        "input": "Find all Python class definitions with their methods",
        "output": [
          "UserAuthenticator - lines 23-67 - Methods: login, logout, reset_password",
          "DataProcessor - lines 71-134 - Methods: load, transform, export",
          "APIRouter - lines 138-189 - Methods: register, middleware, handle"
        ]
      },
      {
        "input": "Extract import statements from this TypeScript file",
        "output": [
          "react from react",
          "useState, useEffect from react",
          "axios from axios",
          "ApiError from ./errors"
        ]
      }
    ],
    "best_practices": [
      "Always implement error handling for parse errors and missing nodes",
      "Use tree-sitter queries instead of manual tree traversal when possible",
      "Test query patterns on real code samples before production use"
    ],
    "anti_patterns": [
      "Assuming all source files parse successfully without error handling",
      "Using manual child iteration instead of optimized query patterns",
      "Ignoring performance implications when parsing large codebases"
    ],
    "faq": [
      {
        "question": "What languages does tree-sitter support?",
        "answer": "Tree-sitter supports 40+ languages including Python, JavaScript, TypeScript, Go, Rust, Ruby, C, C++, and many more."
      },
      {
        "question": "How do I install language parsers?",
        "answer": "Install parsers via npm (tree-sitter-javascript), pip (tree-sitter-python), or compile from the official tree-sitter-lang repos."
      },
      {
        "question": "Can I use this with any framework?",
        "answer": "Yes. Patterns are framework-agnostic. Use with Code-Index-MCP, treesitter-chunker, or custom implementations."
      },
      {
        "question": "Is parsed code executed?",
        "answer": "No. Tree-sitter only parses source text into an AST. It never executes or evaluates the parsed code."
      },
      {
        "question": "Why are my queries returning no matches?",
        "answer": "Check node type names match the language grammar. Use (editor.tree-sitter-query-test) to verify queries against sample code."
      },
      {
        "question": "How is this different from regex?",
        "answer": "Tree-sitter understands code structure via the AST. Queries can match nested patterns that regex cannot capture."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 260
    }
  ]
}
