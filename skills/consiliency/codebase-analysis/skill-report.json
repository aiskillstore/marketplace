{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T15:59:03.411Z",
    "slug": "consiliency-codebase-analysis",
    "source_url": "https://github.com/Consiliency/treesitter-chunker/tree/main/.ai-dev-kit/skills/codebase-analysis",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "9b66950a548fb3766119458cf8e45dfafa54825569279096b668978fe2cf48c4",
    "tree_hash": "5a0acad55e14da12dc68d808e54c4bdcf04ca3bee100c96a1306a1a6079583a9"
  },
  "skill": {
    "name": "codebase-analysis",
    "description": "Patterns and techniques for analyzing brownfield codebases. Use when onboarding to unfamiliar code, preparing for refactoring, conducting architecture reviews, or identifying technical debt.",
    "summary": "Systematically analyze codebases using proven patterns for entry point discovery, dependency tracing, and technical debt identification.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "Consiliency",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "code-analysis",
      "refactoring",
      "technical-debt",
      "architecture",
      "codebase-onboarding"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Documentation-only skill providing codebase analysis patterns and techniques. All 325 static findings are false positives: detected patterns are bash command examples in markdown files showing how to analyze codebases, not executable skill code. No actual security risks identified.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 7,
    "total_lines": 4365,
    "audit_model": "claude",
    "audited_at": "2026-01-21T15:59:03.411Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Analyze unfamiliar codebases systematically",
    "value_statement": "Understanding unfamiliar codebases wastes hours of developer time. This skill provides structured patterns to quickly identify entry points, trace dependencies, detect architectural patterns, and catalog technical debt.",
    "seo_keywords": [
      "Claude",
      "Codex",
      "Claude Code",
      "codebase analysis",
      "code analysis tools",
      "refactoring patterns",
      "technical debt identification",
      "codebase onboarding",
      "dependency tracing",
      "architecture review"
    ],
    "actual_capabilities": [
      "Discover application entry points across multiple frameworks and languages",
      "Trace dependency chains and import relationships between modules",
      "Identify architectural patterns like MVC, layered architecture, or hexagonal design",
      "Catalog technical debt including code smells, outdated dependencies, and missing tests",
      "Recognize framework-specific patterns for React, Django, Rails, and more",
      "Generate structured analysis reports with dependency graphs and C4 diagrams"
    ],
    "limitations": [
      "Performs static analysis only and does not execute or modify code",
      "Cannot detect runtime behavior or dynamic imports",
      "Does not integrate with build systems or testing frameworks",
      "Requires manual interpretation of findings and prioritization decisions"
    ],
    "use_cases": [
      {
        "title": "Onboard new developers to legacy codebases",
        "description": "New team members follow structured workflows to discover entry points, trace key dependencies, and understand code organization patterns in unfamiliar projects.",
        "target_user": "Software developers joining existing projects"
      },
      {
        "title": "Plan refactoring and modernization efforts",
        "description": "Architects identify all affected code paths, dependencies, and technical debt before making changes to ensure safe refactoring with minimal risk.",
        "target_user": "Software architects and technical leads"
      },
      {
        "title": "Conduct pre-acquisition technical due diligence",
        "description": "Engineering consultants systematically evaluate codebase quality, architectural patterns, and technical debt to assess project health and risks.",
        "target_user": "Engineering consultants and CTOs"
      }
    ],
    "prompt_templates": [
      {
        "title": "Quick codebase overview",
        "prompt": "Analyze this codebase using the entry-point-discovery pattern. Identify the main entry points, their initialization sequence, and the primary framework being used.",
        "scenario": "Initial orientation when joining a new project"
      },
      {
        "title": "Trace module dependencies",
        "prompt": "Use dependency-tracing patterns to map how the authentication module connects to other parts of the system. Show all imports and what depends on it.",
        "scenario": "Understanding module relationships before refactoring"
      },
      {
        "title": "Identify architectural patterns",
        "prompt": "Apply pattern-detection techniques to identify the architectural style of this codebase. Is it MVC, layered architecture, hexagonal, or something else? Provide evidence from directory structure and code organization.",
        "scenario": "Architecture review or documentation"
      },
      {
        "title": "Comprehensive technical debt audit",
        "prompt": "Follow the debt-identification cookbook to find code debt, test debt, dependency debt, and documentation gaps. Categorize findings by severity and provide file locations with line numbers.",
        "scenario": "Planning a refactoring sprint or modernization effort"
      }
    ],
    "output_examples": [
      {
        "input": "Analyze this Python Django codebase and identify the main entry points",
        "output": "Entry Points Found:\n\n1. wsgi.py:8 - WSGI application factory for production deployment\n2. manage.py:22 - Django management command entry\n3. urls.py:5 - URL routing configuration\n\nInitialization Sequence:\n- settings.py loads environment variables and database config\n- Database connection pool established via DATABASES setting\n- Middleware stack initializes (authentication, CORS, security headers)\n- URL patterns registered from apps.urls modules\n- Static file handlers configured\n\nFramework: Django 4.x (detected from settings.py imports)"
      },
      {
        "input": "Trace dependencies for the user authentication module in this Node.js app",
        "output": "Dependency Analysis for auth/authentication.js:\n\nDirect Dependencies (imported by this module):\n- crypto (Node.js built-in) - password hashing\n- jsonwebtoken (npm) - JWT token generation\n- ../models/User.js - user data access\n- ../config/env.js - environment configuration\n\nReverse Dependencies (modules that import this):\n- routes/auth.js:12 - login/logout routes\n- routes/api.js:8 - API authentication middleware\n- middleware/requireAuth.js:5 - route protection\n- services/email.js:18 - password reset flows\n\nRisk Assessment: High coupling - changes affect 4 modules"
      },
      {
        "input": "Identify technical debt in this React TypeScript project",
        "output": "Technical Debt Inventory:\n\nCode Debt (High Priority):\n- 47 TODO/FIXME comments found across components/\n- UserProfile.tsx:156-289 - function exceeds 130 lines, needs refactoring\n- Duplicate API call logic in 6 different components (needs custom hook)\n\nTest Debt (Medium Priority):\n- 23 component files missing corresponding .test.tsx files\n- Test coverage: 42% (below 80% target)\n\nDependency Debt (High Priority):\n- react-router-dom v5.2 is 2 major versions behind (v6.x available)\n- 3 npm packages with known security vulnerabilities\n\nRecommendation: Address security vulnerabilities immediately, then tackle test coverage gaps"
      }
    ],
    "best_practices": [
      "Always start with entry point discovery before analyzing random files to understand initialization flow",
      "Trace dependency chains before making changes to identify all affected modules and prevent breaking changes",
      "Document findings as you analyze to create knowledge transfer materials for the team"
    ],
    "anti_patterns": [
      "Analyzing random files without first discovering entry points and understanding overall architecture",
      "Making architectural claims based on directory names alone without examining actual code dependencies",
      "Skipping pattern detection and jumping straight to identifying anti-patterns without establishing baseline"
    ],
    "faq": [
      {
        "question": "What programming languages does this skill support?",
        "answer": "This skill provides analysis patterns for JavaScript, TypeScript, Python, Go, Java, Rust, C, C++, Ruby, and Dart. The techniques work with any language that has clear import or include statements."
      },
      {
        "question": "Does this skill modify or execute my code?",
        "answer": "No. This skill performs read-only static analysis and does not execute code, make modifications, or run build processes. It only examines source files."
      },
      {
        "question": "How long does a typical codebase analysis take?",
        "answer": "Analysis time depends on the depth setting. Quick analysis takes about 5 minutes for basic entry points. Standard analysis takes 30 minutes for dependencies and patterns. Deep analysis with full technical debt audit takes over 1 hour."
      },
      {
        "question": "Can this skill detect security vulnerabilities?",
        "answer": "This skill can identify code patterns that might indicate security concerns, but it is not a dedicated security scanner. Use specialized tools like npm audit or Snyk for vulnerability detection."
      },
      {
        "question": "What output formats are supported?",
        "answer": "The skill generates reports in markdown format by default. It can also produce JSON output for programmatic processing and C4 diagrams for architectural visualization."
      },
      {
        "question": "How does this differ from automated code analysis tools?",
        "answer": "This skill provides structured workflows and patterns for human-guided analysis, not automated scanning. It helps you know what to look for and how to interpret findings in context."
      }
    ]
  },
  "file_structure": [
    {
      "name": "cookbook",
      "type": "dir",
      "path": "cookbook",
      "children": [
        {
          "name": "debt-identification.md",
          "type": "file",
          "path": "cookbook/debt-identification.md",
          "lines": 158
        },
        {
          "name": "dependency-tracing.md",
          "type": "file",
          "path": "cookbook/dependency-tracing.md",
          "lines": 179
        },
        {
          "name": "entry-point-discovery.md",
          "type": "file",
          "path": "cookbook/entry-point-discovery.md",
          "lines": 183
        },
        {
          "name": "pattern-detection.md",
          "type": "file",
          "path": "cookbook/pattern-detection.md",
          "lines": 169
        }
      ]
    },
    {
      "name": "reference",
      "type": "dir",
      "path": "reference",
      "children": [
        {
          "name": "framework-patterns.md",
          "type": "file",
          "path": "reference/framework-patterns.md",
          "lines": 228
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 120
    }
  ]
}
