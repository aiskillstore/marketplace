{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-02-12T08:56:54.333Z",
    "slug": "vuejs-ai-vue-options-api-best-practices",
    "source_url": "https://github.com/vuejs-ai/skills/tree/main/skills/vue-options-api-best-practices/",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "4f7cebd7599e95cb5d62699d7301a882a1772a284aa388f839673617154c0d08",
    "tree_hash": "e472e259ff0881c04a1805b2db5180d37c93d8baef797ceaaa9d5038687a7920"
  },
  "skill": {
    "name": "vue-options-api-best-practices",
    "description": "Vue.js Options API best practices, TypeScript integration, and common gotchas for Vue 2 and Vue 3.",
    "summary": "Comprehensive guide for Vue.js Options API with TypeScript examples, covering lifecycle hooks, methods, and type safety.",
    "icon": "ðŸ“¦",
    "version": "2.0.0",
    "author": "github.com/vuejs-ai",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "vue",
      "vuejs",
      "options-api",
      "typescript",
      "web-development"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Static analysis detected 258 potential security issues, all are false positives from markdown code blocks. The 'Ruby/shell backtick execution' findings are JavaScript code examples in markdown fences. 'Hardcoded URL' findings are Vue.js documentation links. 'Weak cryptographic algorithm' findings trigger on the word 'key' in event.key and YAML frontmatter. No actual security risks exist.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [
      {
        "title": "Static Analysis False Positives",
        "description": "All 258 detected security issues are false positives from markdown documentation files. The static analyzer incorrectly flagged: (1) JavaScript code examples in markdown code blocks as 'Ruby/shell backtick execution' due to backtick syntax; (2) Vue.js documentation links as 'hardcoded URLs'; (3) The word 'key' in 'event.key' and YAML 'impactDescription' as 'weak cryptographic algorithm'. These are documentation files, not executable code.",
        "locations": []
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 11,
    "total_lines": 1509,
    "audit_model": "claude",
    "audited_at": "2026-02-12T08:56:54.333Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Master Vue.js Options API Best Practices",
    "value_statement": "Developers struggle with Vue.js Options API TypeScript integration and common pitfalls. This skill provides proven patterns and solutions for type-safe Options API code in Vue 2 and Vue 3.",
    "seo_keywords": [
      "Vue.js Options API",
      "Claude",
      "Codex",
      "Claude Code",
      "Vue TypeScript",
      "Vue lifecycle hooks",
      "Vue best practices",
      "Options API methods",
      "Vue 2 Vue 3",
      "Vue component development"
    ],
    "actual_capabilities": [
      "Guide proper use of regular functions versus arrow functions in lifecycle hooks and methods to maintain correct 'this' context binding",
      "Provide TypeScript integration patterns for Options API including component type definitions and computed property return types",
      "Explain Vue provide/inject limitations with TypeScript and workarounds for type safety",
      "Document event handler type annotations for DOM events in Options API methods",
      "Show stateful method patterns and debouncing pitfalls in Vue components",
      "Cover strict mode configuration for enhanced TypeScript type inference in Options API"
    ],
    "limitations": [
      "Focuses exclusively on Options API patterns, does not cover Composition API approaches",
      "Examples assume familiarity with Vue.js basics and JavaScript fundamentals",
      "TypeScript examples require TypeScript 4.x or later for full type inference support",
      "Some patterns may differ between Vue 2 and Vue 3 - check version compatibility"
    ],
    "use_cases": [
      {
        "title": "Fix 'this' Context Issues",
        "description": "Junior Vue developer encounters undefined errors when accessing component data in lifecycle hooks. Use this skill to learn why arrow functions break 'this' binding and how to use regular functions correctly.",
        "target_user": "Vue.js developers learning Options API"
      },
      {
        "title": "Add TypeScript to Vue Components",
        "description": "Senior developer adding TypeScript to existing Vue Options API project needs guidance on typing component props, events, and injected properties. This skill provides type-safe patterns for Options API.",
        "target_user": "TypeScript developers working with Vue"
      },
      {
        "title": "Debug Vue Component Issues",
        "description": "Full-stack developer debugging mysterious component state mutations uses this skill to identify stateful method pitfalls and understand debouncing in Vue lifecycle hooks.",
        "target_user": "Full-stack web developers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Fix Lifecycle Hook Error",
        "prompt": "I'm getting 'Cannot read property of undefined' in my Vue component's mounted hook. Here's my component code:\n\n[PASTE YOUR COMPONENT CODE]\n\nWhat's wrong with my lifecycle hook?",
        "scenario": "Beginner debugging 'this' context errors"
      },
      {
        "title": "Type Component Props",
        "prompt": "Help me add TypeScript types to my Vue Options API component. I need to type these props:\n\n[LIST YOUR PROPS]\n\nShow me the correct defineComponent setup.",
        "scenario": "Adding TypeScript to existing component"
      },
      {
        "title": "Resolve Type Errors",
        "prompt": "My Vue Options API component has TypeScript errors. Here's the error:\n\n[PASTE ERROR MESSAGE]\n\nAnd here's my component:\n\n[PASTE COMPONENT CODE]\n\nWhat type annotations am I missing?",
        "scenario": "Troubleshooting TypeScript integration"
      },
      {
        "title": "Refactor to Best Practices",
        "prompt": "Review my Vue Options API component for best practices violations:\n\n[PASTE COMPONENT CODE]\n\nIdentify any issues with lifecycle hooks, method definitions, or TypeScript usage.",
        "scenario": "Code review and improvement"
      }
    ],
    "output_examples": [
      {
        "input": "I'm getting 'this is undefined' in my mounted hook using arrow function: mounted: () => { console.log(this.message) }",
        "output": "The issue is that arrow functions lexically bind 'this' from their enclosing scope, preventing Vue from setting it to the component instance. Replace the arrow function with a regular function: mounted() { console.log(this.message) }. This allows Vue to properly bind 'this' to your component."
      },
      {
        "input": "How do I type event handlers in Vue Options API with TypeScript?",
        "output": "Define event handler parameters with explicit DOM event types. For example: methods: { handleClick(event: MouseEvent) { console.log(event.clientX) }, handleKeydown(event: KeyboardEvent) { if (event.key === 'Enter') this.submit() } }. Common types include MouseEvent, KeyboardEvent, Event, and InputEvent."
      },
      {
        "input": "My computed property returns a union type and TypeScript is complaining",
        "output": "Use a type guard or ComputedRef to clarify the return type. Define the computed property with explicit return type annotation: computed: { fullName(): string { return this.firstName + ' ' + this.lastName } }. For complex types, see the computed return types reference."
      }
    ],
    "best_practices": [
      "Always use regular function syntax for lifecycle hooks and top-level methods to ensure proper 'this' context binding",
      "Leverage TypeScript's defineComponent utility to enable type inference for component options and props",
      "Use explicit type annotations for event handler parameters to improve type safety and IDE autocomplete"
    ],
    "anti_patterns": [
      "Using arrow functions for lifecycle hooks like created: () => {} or mounted: () => {} which breaks 'this' binding",
      "Defining methods with arrow functions like methods: { handleClick: () => {} } which prevents access to component instance",
      "Skipping type annotations on event handlers which loses type safety and documentation benefits"
    ],
    "faq": [
      {
        "question": "Why can't I use arrow functions in Vue lifecycle hooks?",
        "answer": "Arrow functions lexically bind 'this' from their definition scope, preventing Vue from setting it to the component instance. Always use regular functions or method shorthand for lifecycle hooks like created, mounted, and updated."
      },
      {
        "question": "Do I need defineComponent for TypeScript in Options API?",
        "answer": "Yes, defineComponent is required for full TypeScript type inference in Options API. It enables type checking for props, computed properties, methods, and lifecycle hooks. Wrap your component object: export default defineComponent({ ... })."
      },
      {
        "question": "Can I use arrow functions inside methods?",
        "answer": "Yes, arrow functions are allowed inside method bodies, especially for callbacks and array methods. They inherit 'this' from the enclosing method which is properly bound. The issue is only with arrow functions as the method or hook itself."
      },
      {
        "question": "How do I type complex prop objects in Options API?",
        "answer": "Define an interface for your prop structure and use it in the prop validation. For example: props: { user: { type: Object as PropType<User>, required: true } }. This ensures type safety while maintaining runtime validation."
      },
      {
        "question": "What's the difference between Vue 2 and Vue 3 lifecycle hooks?",
        "answer": "Vue 3 renamed some hooks: beforeDestroy becomes beforeUnmount, destroyed becomes unmounted. Vue 3 also adds new hooks like renderTracked and renderTriggered for debugging reactivity. The this-binding rules apply equally in both versions."
      },
      {
        "question": "Why are my injected properties undefined in TypeScript?",
        "answer": "The provide/inject API has limited TypeScript inference. Use an injection key symbol with explicit typing: const ThemeKey = Symbol('theme'). Then inject: { theme: { from: ThemeKey } } or use declare module augmentation for global injection types."
      }
    ]
  },
  "file_structure": [
    {
      "name": "reference",
      "type": "dir",
      "path": "reference",
      "children": [
        {
          "name": "no-arrow-functions-in-lifecycle-hooks.md",
          "type": "file",
          "path": "reference/no-arrow-functions-in-lifecycle-hooks.md",
          "lines": 96
        },
        {
          "name": "no-arrow-functions-in-methods.md",
          "type": "file",
          "path": "reference/no-arrow-functions-in-methods.md",
          "lines": 69
        },
        {
          "name": "stateful-methods-lifecycle.md",
          "type": "file",
          "path": "reference/stateful-methods-lifecycle.md",
          "lines": 62
        },
        {
          "name": "ts-options-api-arrow-functions-validators.md",
          "type": "file",
          "path": "reference/ts-options-api-arrow-functions-validators.md",
          "lines": 142
        },
        {
          "name": "ts-options-api-computed-return-types.md",
          "type": "file",
          "path": "reference/ts-options-api-computed-return-types.md",
          "lines": 193
        },
        {
          "name": "ts-options-api-proptype-complex-types.md",
          "type": "file",
          "path": "reference/ts-options-api-proptype-complex-types.md",
          "lines": 213
        },
        {
          "name": "ts-options-api-provide-inject-limitations.md",
          "type": "file",
          "path": "reference/ts-options-api-provide-inject-limitations.md",
          "lines": 136
        },
        {
          "name": "ts-options-api-type-event-handlers.md",
          "type": "file",
          "path": "reference/ts-options-api-type-event-handlers.md",
          "lines": 203
        },
        {
          "name": "ts-options-api-use-definecomponent.md",
          "type": "file",
          "path": "reference/ts-options-api-use-definecomponent.md",
          "lines": 173
        },
        {
          "name": "ts-strict-mode-options-api.md",
          "type": "file",
          "path": "reference/ts-strict-mode-options-api.md",
          "lines": 198
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 24
    }
  ]
}
