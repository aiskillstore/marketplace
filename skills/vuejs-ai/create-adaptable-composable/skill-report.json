{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-02-09T09:02:18.681Z",
    "slug": "vuejs-ai-create-adaptable-composable",
    "source_url": "https://github.com/vuejs-ai/skills/tree/main/skills/create-adaptable-composable/",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "0ec21735d31b70bdbdadbb26b562feff87258ba0af77bd0f2880b850f320fe2d",
    "tree_hash": "26acd3104b54cda6eae5c201361b92f69abca664fadfe9585bf8e3258fd4c8de"
  },
  "skill": {
    "name": "create-adaptable-composable",
    "description": "Create a library-grade Vue composable that accepts maybe-reactive inputs (MaybeRef / MaybeRefOrGetter) so callers can pass a plain value, ref, or getter. Normalize inputs with toValue()/toRef() inside reactive effects (watch/watchEffect) to keep behavior predictable and reactive. Use this skill when user asks for creating adaptable or reusable composables.",
    "summary": "Create library-grade Vue composables that accept both reactive and non-reactive inputs for flexible API design.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "vuejs-ai",
    "license": "MIT",
    "tags": [
      "vue",
      "composables",
      "reactivity",
      "vue-composition-api"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Static analyzer flagged TypeScript template literals as shell backticks and random text patterns as cryptographic algorithms. All findings are false positives. The skill contains only Vue.js documentation with TypeScript code examples for creating composables. No shell commands, cryptographic code, or security risks exist.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [
      {
        "title": "False Positive: Cryptographic Algorithm Detection",
        "description": "Static analyzer incorrectly flagged text patterns as cryptographic code. Analysis confirms this is Vue.js documentation describing composable design patterns. No MD5, SHA1, DES, or other weak cryptographic algorithms exist in this file.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 3,
            "line_end": 3
          },
          {
            "file": "SKILL.md",
            "line_start": 15,
            "line_end": 16
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "Lines 3, 15-16 contain frontmatter and prose about composable design, not cryptographic code. The analyzer misinterpreted text patterns as algorithm names."
      },
      {
        "title": "False Positive: Shell Command Detection",
        "description": "Static analyzer flagged backticks as Ruby/shell command execution. These are TypeScript template literals used throughout the code examples. No shell commands, exec(), system(), or backtick invocation exists.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 18,
            "line_end": 18
          },
          {
            "file": "SKILL.md",
            "line_start": 25,
            "line_end": 65
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "Backticks in SKILL.md delimit TypeScript template literals for code examples. No shell execution, child_process, or Ruby backtick invocation patterns exist in the file."
      }
    ],
    "medium_findings": [
      {
        "title": "False Positive: Template Literal Detection",
        "description": "TypeScript template literals flagged as potential external commands. TypeScript uses backticks for multi-line strings and template expressions in code examples.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 25,
            "line_end": 35
          },
          {
            "file": "SKILL.md",
            "line_start": 39,
            "line_end": 42
          },
          {
            "file": "SKILL.md",
            "line_start": 44,
            "line_end": 46
          },
          {
            "file": "SKILL.md",
            "line_start": 50,
            "line_end": 65
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.9,
        "confidence_reasoning": "Lines contain TypeScript code examples with backtick-delimited template literals. No exec, spawn, or command invocation patterns present."
      }
    ],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 77,
    "audit_model": "claude",
    "audited_at": "2026-02-09T09:02:18.681Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Create Adaptable Vue Composable",
    "value_statement": "Creating Vue composables with flexible input types is challenging. This skill provides a pattern for building library-grade composables that accept both reactive and non-reactive inputs using MaybeRef and MaybeRefOrGetter types.",
    "seo_keywords": [
      "Vue 3 composable",
      "MaybeRef",
      "MaybeRefOrGetter",
      "Vue reactivity",
      "Vue composable pattern",
      "Vue Composition API",
      "Vue reusable logic",
      "toRef",
      "toValue",
      "claude code",
      "claude",
      "codex"
    ],
    "actual_capabilities": [
      "Design Vue composables with flexible MaybeRef input types",
      "Create composables accepting both reactive and non-reactive values",
      "Implement proper input normalization using toRef() and toValue()",
      "Apply Vue reactivity patterns for predictable behavior",
      "Build library-grade APIs with computed-friendly inputs"
    ],
    "limitations": [
      "This skill provides guidance patterns, not executable code generation",
      "Requires Vue 3 or Nuxt 3 project context",
      "Does not create full composable implementations, only architectural patterns",
      "User must implement actual composable logic following the documented patterns"
    ],
    "use_cases": [
      {
        "title": "Building a Read-Only Title Manager",
        "description": "Create a composable that sets the document title and accepts title as MaybeRefOrGetter, allowing plain strings, refs, or getter functions.",
        "target_user": "Vue component developers needing reusable title management"
      },
      {
        "title": "Creating a Writable Counter Composable",
        "description": "Build a counter composable with MaybeRef input for the initial count, enabling two-way binding with reactive and non-reactive values.",
        "target_user": "Library authors creating reusable state management utilities"
      },
      {
        "title": "Designing a Flexible Form Input Handler",
        "description": "Design composables that accept DOM elements or computed targets as MaybeRefOrGetter for flexible input handling in various contexts.",
        "target_user": "Frontend engineers building form abstraction layers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Composable Request",
        "prompt": "Create an adaptable composable called useUserPreferences that accepts a MaybeRefOrGetter for theme configuration. The composable should watch the value and apply the theme to the document body.",
        "scenario": "User wants to create a reusable theme management composable"
      },
      {
        "title": "Two-Way Binding Request",
        "prompt": "Build a useLocalStorage composable that accepts a MaybeRef for the initial value and key. The composable should sync the ref value with localStorage and return a writable ref.",
        "scenario": "Developer needs persistent state management with localStorage"
      },
      {
        "title": "Computed Input Pattern",
        "prompt": "Create a useDebouncedValue composable where the input is MaybeRefOrGetter. Use watch() with toRef() for reactive sources and return a computed value that updates with debouncing.",
        "scenario": "Building a debounced input for search or filtering"
      },
      {
        "title": "Multi-Input Composable",
        "prompt": "Design a useFormValidator composable that accepts multiple MaybeRef inputs for form field values and a MaybeRefOrGetter for validation rules. Normalize all inputs and return validation state.",
        "scenario": "Creating a flexible form validation utility"
      }
    ],
    "output_examples": [
      {
        "input": "Create a useDocumentTitle composable that accepts a MaybeRefOrGetter for the title",
        "output": [
          "import { watch, toRef } from 'vue'",
          "import type { MaybeRefOrGetter } from 'vue'",
          "",
          "export function useDocumentTitle(title: MaybeRefOrGetter<string>) {",
          "  watch(toRef(title), (t) => {",
          "    document.title = t",
          "  }, { immediate: true })",
          "}"
        ]
      },
      {
        "input": "Build a useCounter composable with MaybeRef for initial count",
        "output": [
          "import { watch, toRef } from 'vue'",
          "import type { MaybeRef } from 'vue'",
          "",
          "function useCounter(count: MaybeRef<number>) {",
          "  const countRef = toRef(count)",
          "  function add() {",
          "    countRef.value++",
          "  }",
          "  return { add }",
          "}"
        ]
      }
    ],
    "best_practices": [
      "Use MaybeRefOrGetter for read-only, computed-friendly inputs to accept refs, getters, or plain values",
      "Use toRef() inside watch/watchEffect sources to properly resolve reactive dependencies",
      "Use toValue() for non-reactive value normalization to extract actual values",
      "Avoid MaybeRefOrGetter for function parameters that might be callback functions to prevent accidental invocation"
    ],
    "anti_patterns": [
      "Do not pass user-provided callbacks directly to MaybeRefOrGetter without type guards",
      "Do not normalize inputs outside reactive contexts like watch or watchEffect",
      "Do not mix toRef() and toValue() inconsistently within the same composable",
      "Do not assume all parameters should be MaybeRef - use plain types when reactivity is not needed"
    ],
    "faq": [
      {
        "question": "What is the difference between MaybeRef and MaybeRefOrGetter?",
        "answer": "MaybeRef accepts values, refs, shallowRefs, and writable computed refs. MaybeRefOrGetter adds ComputedRef and getter functions. Use MaybeRef for writable parameters and MaybeRefOrGetter for read-only inputs."
      },
      {
        "question": "When should I use toRef() vs toValue()?",
        "answer": "Use toRef() for watch/watchEffect sources to maintain reactivity. Use toValue() for extracting plain values from refs, getters, or non-reactive inputs in non-reactive contexts."
      },
      {
        "question": "Can I use these composables in Nuxt 3?",
        "answer": "Yes, Nuxt 3 is built on Vue 3 and fully supports the Composition API including MaybeRef, MaybeRefOrGetter, toRef(), and toValue()."
      },
      {
        "question": "How do I handle undefined or null values?",
        "answer": "Explicitly include null or undefined in your type definition like MaybeRef<T | null>. The toValue() function handles null/undefined appropriately."
      },
      {
        "question": "Should I use MaybeRefOrGetter for event handlers?",
        "answer": "No, avoid MaybeRefOrGetter for callbacks. Callbacks are functions, not getters. Using MaybeRefOrGetter might accidentally invoke them. Use explicit function types instead."
      },
      {
        "question": "How do I create composables with multiple MaybeRef parameters?",
        "answer": "Apply the pattern to each parameter individually. Use toRef() or toValue() in watch/watchEffect to normalize each input. Example: watch([toRef(a), toRef(b)], ([newA, newB]) => {...})"
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 77
    }
  ]
}
