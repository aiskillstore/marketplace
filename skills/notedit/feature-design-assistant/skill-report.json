{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T18:26:11.661Z",
    "slug": "notedit-feature-design-assistant",
    "source_url": "https://github.com/notedit/happy-coding-agent/tree/main/skills/feature-design-assistant",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "c0bf62b6db9dac077616d0e44dc42338f0476d45529d2e254345830e83544291",
    "tree_hash": "f98bcbd9cd898cd29d77ed7940e24ee635cbb2dcf2c892863980a79c820b7b2a"
  },
  "skill": {
    "name": "feature-design-assistant",
    "description": "Turn ideas into fully formed designs and specs through natural collaborative dialogue. Use when planning new features, designing architecture, or making significant changes to the codebase.",
    "summary": "Turn ideas into fully formed designs and specs through natural collaborative dialogue. Use when planning new features or designing architecture.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "notedit",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "feature-planning",
      "architecture",
      "requirements-gathering",
      "design-specs"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Static scanner flagged 131 potential issues, but all are false positives. The skill is a pure documentation guide (SKILL.md only) containing no executable code, no network calls, and no shell commands. Scanner misinterpreted markdown code fences as shell backticks and SHA256 hashes/URL strings as cryptographic patterns.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 26,
            "line_end": 26
          },
          {
            "file": "SKILL.md",
            "line_start": 75,
            "line_end": 75
          },
          {
            "file": "SKILL.md",
            "line_start": 79,
            "line_end": 79
          },
          {
            "file": "SKILL.md",
            "line_start": 128,
            "line_end": 128
          },
          {
            "file": "SKILL.md",
            "line_start": 132,
            "line_end": 132
          },
          {
            "file": "SKILL.md",
            "line_start": 181,
            "line_end": 181
          },
          {
            "file": "SKILL.md",
            "line_start": 188,
            "line_end": 188
          },
          {
            "file": "SKILL.md",
            "line_start": 204,
            "line_end": 204
          },
          {
            "file": "SKILL.md",
            "line_start": 207,
            "line_end": 207
          },
          {
            "file": "SKILL.md",
            "line_start": 223,
            "line_end": 223
          },
          {
            "file": "SKILL.md",
            "line_start": 229,
            "line_end": 229
          },
          {
            "file": "SKILL.md",
            "line_start": 246,
            "line_end": 246
          },
          {
            "file": "SKILL.md",
            "line_start": 250,
            "line_end": 250
          },
          {
            "file": "SKILL.md",
            "line_start": 265,
            "line_end": 265
          },
          {
            "file": "SKILL.md",
            "line_start": 280,
            "line_end": 280
          },
          {
            "file": "SKILL.md",
            "line_start": 296,
            "line_end": 296
          },
          {
            "file": "SKILL.md",
            "line_start": 302,
            "line_end": 302
          },
          {
            "file": "SKILL.md",
            "line_start": 304,
            "line_end": 304
          },
          {
            "file": "SKILL.md",
            "line_start": 318,
            "line_end": 318
          },
          {
            "file": "SKILL.md",
            "line_start": 322,
            "line_end": 322
          },
          {
            "file": "SKILL.md",
            "line_start": 325,
            "line_end": 325
          },
          {
            "file": "SKILL.md",
            "line_start": 333,
            "line_end": 333
          },
          {
            "file": "SKILL.md",
            "line_start": 338,
            "line_end": 338
          },
          {
            "file": "SKILL.md",
            "line_start": 342,
            "line_end": 342
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 1425,
    "audit_model": "claude",
    "audited_at": "2026-01-21T18:26:11.661Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Design Features with Structured Planning",
    "value_statement": "Feature development often stalls due to unclear requirements and missing context. The Feature Design Assistant guides you through structured information gathering to capture all necessary details before implementation, resulting in complete designs and actionable implementation tasks.",
    "seo_keywords": [
      "feature design",
      "software architecture",
      "requirements gathering",
      "technical specification",
      "feature planning",
      "design documentation",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Guide users through structured requirement gathering with categorized questions",
      "Present multiple design approaches with pros, cons, and best-fit scenarios",
      "Generate comprehensive design documents with architecture and data models",
      "Create implementation task breakdowns with priorities, dependencies, and time estimates"
    ],
    "limitations": [
      "Does not execute code or modify the codebase directly",
      "Cannot access external systems or APIs for research",
      "Relies on user input for project-specific context and constraints",
      "Output is limited to markdown documentation and task lists"
    ],
    "use_cases": [
      {
        "title": "Plan a New Feature from Scratch",
        "description": "Use when you need to design a completely new feature. The assistant walks you through goal definition, user identification, scope assessment, and timeline planning before proposing architecture options.",
        "target_user": "Product managers and developers planning new capabilities"
      },
      {
        "title": "Refactor or Enhance Existing Features",
        "description": "Apply when extending or improving existing functionality. The assistant captures backwards compatibility requirements, integration dependencies, and testing strategies specific to existing codebases.",
        "target_user": "Senior developers and architects handling feature evolution"
      },
      {
        "title": "Create Technical Specifications",
        "description": "Generate detailed technical documents for team review. The assistant produces structured designs covering data models, API contracts, component interfaces, and error handling strategies.",
        "target_user": "Technical leads creating documentation for team alignment"
      }
    ],
    "prompt_templates": [
      {
        "title": "Quick Feature Kickoff",
        "prompt": "I want to design a new feature. Help me gather requirements using the feature-design-assistant skill. Start by exploring the codebase structure to understand our patterns, then ask me the core questions about goals, users, scope, and timeline.",
        "scenario": "Starting a new feature design session"
      },
      {
        "title": "Architecture Review",
        "prompt": "Use feature-design-assistant to help me explore options for implementing [specific feature]. After gathering requirements, present 3 different architectural approaches with trade-offs so I can choose the best fit.",
        "scenario": "Evaluating implementation strategies"
      },
      {
        "title": "Detailed Design Session",
        "prompt": "Run a complete feature design session using all 6 phases of feature-design-assistant. Start with context discovery, then gather requirements in rounds, explore approaches, present detailed designs, and generate implementation tasks.",
        "scenario": "Comprehensive feature design workshop"
      },
      {
        "title": "Quick Spec Generation",
        "prompt": "I have a clear idea of what I want. Skip the exploration phase and jump straight to detailed design. Ask me the technical questions about layers, quality requirements, error handling, and testing. Then create a design document with implementation tasks.",
        "scenario": "Fast-tracking when context is already known"
      }
    ],
    "output_examples": [
      {
        "input": "Help me design a notification system for our SaaS application",
        "output": [
          "## Design Document: Notification System\n\n### Summary\nReal-time notification system supporting email, in-app, and push notifications with preference management.\n\n### Requirements\n- **Goal:** New Functionality\n- **Users:** End Users, System\n- **Scope:** Medium (3-5 days)\n\n### Architecture\n- Event-driven architecture using message queue\n- Notification service with provider abstraction\n- Preference store for user settings\n\n### Implementation Tasks\n- [ ] Create notification models and migrations\n- [ ] Implement event publishers\n- [ ] Build notification dispatch service\n- [ ] Add preference management UI"
        ]
      },
      {
        "input": "Design an API rate limiting feature",
        "output": [
          "## Approach Options\n\n### Option A: Token Bucket (Recommended)\n- **Pros:** Flexible, handles bursts well\n- **Cons:** Slightly more complex implementation\n- **Best for:** APIs with variable traffic patterns\n\n### Option B: Fixed Window\n- **Pros:** Simple, memory efficient\n- **Cons:** Traffic spikes can occur at window boundaries\n- **Best for:** Simple rate limiting needs\n\n### Option C: Sliding Log\n- **Pros:** Accurate, no boundary issues\n- **Cons:** Higher memory usage\n- **Best for:** Precise rate enforcement"
        ]
      }
    ],
    "best_practices": [
      "Complete all requirement gathering rounds before discussing architecture to avoid premature design decisions",
      "Always present multiple approaches with clear trade-offs to help users make informed decisions",
      "Validate understanding after each design section before proceeding to the next"
    ],
    "anti_patterns": [
      "Skipping the context discovery phase and missing important project conventions",
      "Asking too many questions at once instead of batching into structured rounds",
      "Proposing solutions before fully understanding user needs and constraints"
    ],
    "faq": [
      {
        "question": "How long does a complete feature design session take?",
        "answer": "A full session typically takes 30-60 minutes depending on feature complexity. You can also run abbreviated sessions focusing on specific phases like requirements gathering or design review."
      },
      {
        "question": "Can I use this skill for bug fix planning?",
        "answer": "Yes. Select Bug Fix as the goal type. The assistant will guide you through reproduction steps, error handling approaches, and testing strategies appropriate for fixes."
      },
      {
        "question": "Does the skill generate actual code?",
        "answer": "No. The skill produces design documents and implementation task lists. It does not write code directly. You can use other skills to execute the implementation tasks afterward."
      },
      {
        "question": "How detailed are the implementation tasks?",
        "answer": "Tasks include file paths, dependencies, time estimates, and step-by-step checklists. Tasks follow TDD conventions with test-first guidance when selected."
      },
      {
        "question": "Can I save designs for later?",
        "answer": "Yes. Phase 5 saves designs to docs/designs/YYYY-MM-DD-topic-design.md. You can also export task lists as markdown for external tracking tools."
      },
      {
        "question": "What if I do not know all the answers upfront?",
        "answer": "The skill handles uncertainty well. Select Unsure for estimates and Planning Only for timeline. The design document captures what is known and flags areas needing future investigation."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 369
    }
  ]
}
