{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T19:59:39.319Z",
    "slug": "eis-its-frontend-components",
    "source_url": "https://github.com/EIS-ITS/vss-cli/tree/main/.claude/skills/frontend-components",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "d611185f001688ed42abbe3f32bcb954749c91caba40e9f14062a9ca137ca723",
    "tree_hash": "f0f50b5926ed4c7695e57edc0c286f89142974816d689d9eca8f7fa51a93bbfb"
  },
  "skill": {
    "name": "frontend-components",
    "description": "Design and build reusable, composable UI components following single responsibility principle with clear props, proper encapsulation, and minimal state management. Use this skill when creating or modifying React, Vue, Svelte, or web components, defining component props or interfaces, managing component state, building component libraries, or refactoring UI code. Apply when working with .jsx, .tsx, .vue, .svelte files, component directories, or any code that defines reusable UI building blocks with configurable interfaces and composable architectures.",
    "summary": "Build reusable UI components with proper encapsulation and minimal state management",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "EIS-ITS",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "react",
      "vue",
      "svelte",
      "components",
      "frontend",
      "ui"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill is safe for publication. All 16 static findings were false positives from pattern matching on Markdown file extensions and documentation paths. The skill contains only documentation guidance for frontend component development with no executable code or security risks.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 282,
    "audit_model": "claude",
    "audited_at": "2026-01-21T19:59:39.319Z"
  },
  "content": {
    "user_title": "Build Reusable Frontend Components with Best Practices",
    "value_statement": "Frontend component development often leads to tightly coupled code that is difficult to maintain and reuse. This skill guides Claude Code to create modular, composable UI components following single responsibility principle with proper encapsulation.",
    "seo_keywords": [
      "Claude",
      "Claude Code",
      "Codex",
      "React components",
      "Vue components",
      "Svelte",
      "UI components",
      "frontend development",
      "component library",
      "reusable components"
    ],
    "actual_capabilities": [
      "Create new React, Vue, Svelte, or web components with proper structure and interfaces",
      "Define component props, TypeScript interfaces, and PropTypes with clear contracts",
      "Refactor large components into smaller, focused components following single responsibility",
      "Implement component state management and lifecycle hooks correctly",
      "Design composable component architectures with clear parent-child relationships",
      "Build component libraries and design systems with consistent patterns"
    ],
    "limitations": [
      "Does not provide framework-specific performance optimizations beyond general best practices",
      "Requires external documentation reference at agent-os/standards/frontend/components.md to be available",
      "Does not include specific styling methodologies or CSS framework recommendations",
      "Focuses on component structure rather than business logic implementation"
    ],
    "use_cases": [
      {
        "title": "Component Library Development",
        "description": "Build a design system with reusable button, card, modal, and form components that follow consistent patterns and accept configurable props for different use cases.",
        "target_user": "Frontend developers building shared component libraries"
      },
      {
        "title": "Refactoring Legacy Components",
        "description": "Break down large, monolithic components into smaller, focused units that are easier to test, maintain, and reuse across different parts of the application.",
        "target_user": "Teams modernizing existing frontend codebases"
      },
      {
        "title": "New Feature Development",
        "description": "Create new UI features using well-structured components with clear props, minimal state, and proper encapsulation that integrate seamlessly with existing architecture.",
        "target_user": "Product teams building new application features"
      }
    ],
    "prompt_templates": [
      {
        "title": "Create Basic Component",
        "prompt": "Create a reusable Button component in React with TypeScript that accepts variant, size, and disabled props",
        "scenario": "Starting a new component library with foundational elements"
      },
      {
        "title": "Refactor Component Structure",
        "prompt": "Refactor this UserProfile component into smaller components following single responsibility principle",
        "scenario": "Breaking down complex components for better maintainability"
      },
      {
        "title": "Add Component Props",
        "prompt": "Add proper TypeScript interfaces for this Modal component with required title, optional footer, and children props",
        "scenario": "Improving type safety and component contracts"
      },
      {
        "title": "Build Composite Component",
        "prompt": "Create a DataTable component that composes Header, Row, and Cell components with proper state management for sorting and filtering",
        "scenario": "Building complex features from composable parts"
      }
    ],
    "output_examples": [
      {
        "input": "Create a reusable Card component in React with header, content, and footer sections",
        "output": "Component created with proper TypeScript interfaces, optional props for header and footer, children prop for content, and clear documentation of the component API"
      },
      {
        "input": "Refactor this 300-line component into smaller focused components",
        "output": "Original component split into 5 smaller components, each with single responsibility, clear props interfaces, and improved testability while maintaining the same functionality"
      },
      {
        "input": "Add state management to this form component following best practices",
        "output": "Form component updated with controlled inputs, proper state lifting, validation logic separated into hooks, and clear event handler props for parent communication"
      }
    ],
    "best_practices": [
      "Define clear component interfaces with TypeScript or PropTypes before implementation",
      "Keep components focused on single responsibility and extract logic into custom hooks",
      "Use composition over inheritance and lift state to the appropriate level in the component tree"
    ],
    "anti_patterns": [
      "Avoid creating deeply nested prop drilling chains without considering context or state management",
      "Do not mix business logic with presentation components without clear separation",
      "Never skip prop validation or TypeScript interfaces for components that will be reused"
    ],
    "faq": [
      {
        "question": "Which frontend frameworks does this skill support?",
        "answer": "This skill supports React, Vue, Svelte, and standard web components. It focuses on universal component design principles that apply across frameworks."
      },
      {
        "question": "Does this skill require external documentation to work?",
        "answer": "The skill references external standards at agent-os/standards/frontend/components.md. While it provides general guidance, full effectiveness requires this documentation to be available."
      },
      {
        "question": "Can this skill help with component performance optimization?",
        "answer": "This skill focuses on structural best practices like proper encapsulation and state management. Framework-specific optimizations like React.memo or Vue computed properties should be handled separately."
      },
      {
        "question": "How does this skill handle component styling?",
        "answer": "This skill focuses on component structure and logic rather than styling approaches. It works with any styling methodology like CSS modules, styled-components, or Tailwind."
      },
      {
        "question": "Can I use this skill for refactoring existing components?",
        "answer": "Yes, this skill is designed for both creating new components and refactoring existing ones into smaller, more maintainable units following single responsibility principle."
      },
      {
        "question": "Does this skill work with TypeScript?",
        "answer": "Yes, this skill fully supports TypeScript and encourages proper type definitions for component props and interfaces to ensure type safety."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 30
    }
  ]
}
