{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-17T06:22:34.039Z",
    "slug": "eis-its-backend-queries",
    "source_url": "https://github.com/EIS-ITS/vss-cli/tree/main/.claude/skills/backend-queries",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "03411ed68c492d42e0c703ce7b2360b8c8381d024f943a2b00c57af5fa521185",
    "tree_hash": "050c88709af435ebef2d4d57394912fcfc4eac3fc172d1993f22e871d1c5680a"
  },
  "skill": {
    "name": "backend-queries",
    "description": "Write secure, optimized database queries using parameterized statements, eager loading, proper indexing, and transaction management. Use this skill when writing database queries, implementing data fetching logic, optimizing query performance, preventing SQL injection, handling N+1 query problems, using ORMs or query builders, implementing caching strategies, or managing database transactions. Apply when working with SQL queries, ORM query methods, database repository patterns, or any code that retrieves or manipulates data from databases.",
    "summary": "Write secure, optimized database queries using parameterized statements, eager loading, proper index...",
    "icon": "üóÑÔ∏è",
    "version": "1.0.0",
    "author": "EIS-ITS",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "database",
      "sql",
      "orm",
      "performance",
      "security"
    ],
    "supported_tools": [
      "claude",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a documentation-only skill containing coding standards for database queries. It contains no executable code, network calls, file operations, or system access. All 20 static findings are false positives caused by the analyzer misinterpreting documentation text as security patterns. The skill provides security best practices including SQL injection prevention.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          },
          {
            "file": "SKILL.md",
            "line_start": 29,
            "line_end": 29
          },
          {
            "file": "SKILL.md",
            "line_start": 29,
            "line_end": 29
          },
          {
            "file": "SKILL.md",
            "line_start": 29,
            "line_end": 29
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 207,
    "audit_model": "claude",
    "audited_at": "2026-01-17T06:22:34.039Z"
  },
  "content": {
    "user_title": "Write Secure Database Queries with AI Guidance",
    "value_statement": "Database queries often suffer from security vulnerabilities and performance issues. This skill provides Claude with expert guidance to write secure, optimized queries that prevent SQL injection and eliminate N+1 problems.",
    "seo_keywords": [
      "database queries",
      "SQL injection prevention",
      "query optimization",
      "Claude Code",
      "ORM best practices",
      "database performance",
      "secure coding",
      "N+1 query problem",
      "parameterized queries",
      "Claude AI"
    ],
    "actual_capabilities": [
      "Prevents SQL injection through parameterized queries",
      "Optimizes queries with proper indexing strategies",
      "Eliminates N+1 query problems using eager loading",
      "Implements secure transaction management patterns",
      "Provides performance monitoring and timeout guidance",
      "Enforces column selection best practices"
    ],
    "limitations": [
      "Only provides guidance, does not execute queries",
      "Requires existing database knowledge for implementation",
      "Focuses on relational databases, limited NoSQL guidance",
      "Cannot analyze existing query performance without code"
    ],
    "use_cases": [
      {
        "target_user": "Backend developers",
        "title": "Secure API Development",
        "description": "Build secure REST APIs with properly parameterized database queries that prevent injection attacks while maintaining optimal performance."
      },
      {
        "target_user": "Database administrators",
        "title": "Query Performance Tuning",
        "description": "Optimize slow queries by implementing proper indexing, eager loading, and efficient JOIN operations with AI-assisted recommendations."
      },
      {
        "target_user": "Full-stack developers",
        "title": "ORM Best Practices",
        "description": "Learn to use ORMs effectively with proper relationship loading, transaction boundaries, and query optimization techniques."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Query Security",
        "scenario": "Converting raw SQL to parameterized queries",
        "prompt": "Help me convert this raw SQL query to use parameterized statements to prevent SQL injection: SELECT * FROM users WHERE email = '$email' AND status = '$status'"
      },
      {
        "title": "N+1 Problem Fix",
        "scenario": "Optimizing related data loading",
        "prompt": "I have a query that loads users and their posts separately, causing N+1 queries. Show me how to use eager loading to fix this in SQLAlchemy."
      },
      {
        "title": "Complex JOIN Optimization",
        "scenario": "Writing efficient multi-table queries",
        "prompt": "Write an optimized query to get orders with customer details, order items, and product information using proper JOINs and indexes."
      },
      {
        "title": "Transaction Management",
        "scenario": "Implementing safe multi-table updates",
        "prompt": "Help me implement a transaction that transfers funds between accounts with proper rollback handling and deadlock prevention."
      }
    ],
    "output_examples": [
      {
        "input": "Convert this vulnerable query to prevent SQL injection: SELECT * FROM products WHERE name = '$productName' AND price < $maxPrice",
        "output": [
          "Original vulnerable query uses string concatenation allowing SQL injection",
          "Converted to parameterized query: SELECT * FROM products WHERE name = ? AND price < ?",
          "Parameters are bound separately preventing malicious SQL execution",
          "Added input validation for price range and product name format",
          "Implemented query timeout to prevent resource exhaustion"
        ]
      },
      {
        "input": "Fix my N+1 query problem where I load posts and then separately load comments for each post",
        "output": [
          "Current approach issues separate queries for each post's comments causing N+1 problem",
          "Recommended solution: Use eager loading with preload or joinedload in SQLAlchemy",
          "Single query fetches all posts and their comments in one database round-trip",
          "Added query timeout to prevent long-running queries",
          "Consider using selectinload for better performance with large datasets"
        ]
      },
      {
        "input": "Write a safe transaction for transferring money between accounts",
        "output": [
          "Implemented transaction with proper ACID properties and rollback on failure",
          "Used SELECT FOR UPDATE to lock rows preventing race conditions",
          "Added deadlock detection and retry logic for concurrent transfers",
          "Implemented balance checks before and after transfer operations",
          "Set query timeouts to prevent long-running transactions"
        ]
      }
    ],
    "best_practices": [
      "Always use parameterized queries instead of string concatenation",
      "Select only required columns instead of using SELECT *",
      "Implement query timeouts to prevent resource exhaustion"
    ],
    "anti_patterns": [
      "Never build queries by concatenating user input directly",
      "Avoid loading all records into memory for large datasets",
      "Don't ignore database indexes when designing queries"
    ],
    "faq": [
      {
        "question": "Which databases does this skill support?",
        "answer": "The skill focuses on relational databases like PostgreSQL, MySQL, SQLite, and SQL Server with ORM-agnostic principles."
      },
      {
        "question": "Can this skill analyze my existing query performance?",
        "answer": "No, the skill provides guidance for writing new queries. For performance analysis, you will need database profiling tools."
      },
      {
        "question": "Does it work with NoSQL databases?",
        "answer": "The skill is optimized for relational databases but some principles apply to document databases with query languages."
      },
      {
        "question": "How does it prevent SQL injection?",
        "answer": "It enforces parameterized queries where user input is bound as parameters, never concatenated into SQL strings."
      },
      {
        "question": "What if my query is still slow after optimization?",
        "answer": "Consider database schema changes, additional indexes, or query restructuring. The skill provides foundational guidance."
      },
      {
        "question": "Is this skill suitable for beginners?",
        "answer": "Yes, it provides step-by-step guidance from basic security to advanced optimization patterns with clear examples."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 30
    }
  ]
}
