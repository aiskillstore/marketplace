{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T16:03:03.584Z",
    "slug": "cain96-typescript-dev",
    "source_url": "https://github.com/Cain96/dotfiles/tree/main/dot_config/claude/skills/typescript-dev",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "397f1eaa0723485b70a20a1c47d16b73c4d06c0e5c183e78b50302e0a0aa31d6",
    "tree_hash": "13c2373a7614c290aef1266765d336633b9a6c56fa83c87039b2fdad679b3f56"
  },
  "skill": {
    "name": "typescript-dev",
    "description": "TypeScript development best practices, code quality tools, and documentation templates. Activated when working with .ts, .tsx files or TypeScript projects.",
    "summary": "TypeScript development guide covering strict typing, ES modules, TSDoc documentation, and code quality tools for professional projects.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "Cain96",
    "license": "MIT",
    "tags": [
      "typescript",
      "code-quality",
      "type-safety",
      "documentation",
      "best-practices"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings evaluated as false positives. The skill is legitimate TypeScript development documentation containing example code patterns and best practices. No actual security risks found.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 712,
    "audit_model": "claude",
    "audited_at": "2026-01-21T16:03:03.584Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Write TypeScript with Confidence",
    "value_statement": "TypeScript projects require careful attention to type safety and code quality. This skill provides best practices, linting rules, and documentation templates to help developers write maintainable, type-safe code.",
    "seo_keywords": [
      "TypeScript",
      "type safety",
      "code quality",
      "ES modules",
      "TSDoc",
      "strict mode",
      "generics",
      "utility types",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Enforce strict TypeScript configuration with strict mode enabled",
      "Guide proper use of ES modules and avoid CommonJS require() patterns",
      "Provide TSDoc documentation templates for public APIs",
      "Recommend type inference, generics, and utility types for cleaner code",
      "Suggest error handling patterns like Result types and custom error classes",
      "Include React performance optimizations for TypeScript components"
    ],
    "limitations": [
      "Does not execute code or run type checks directly",
      "Does not modify project configuration files automatically",
      "Does not provide runtime type validation",
      "Focuses on best practices rather than framework-specific implementations"
    ],
    "use_cases": [
      {
        "title": "New TypeScript Project Setup",
        "description": "Get guidance on configuring tsconfig.json with strict mode, choosing between ES modules and CommonJS, and setting up TSDoc documentation from the start.",
        "target_user": "Developers starting new TypeScript projects"
      },
      {
        "title": "Code Review Assistance",
        "description": "Receive checklist-based feedback during code reviews, ensuring proper type definitions, avoiding any types, and maintaining consistent documentation standards.",
        "target_user": "Senior developers and team leads conducting code reviews"
      },
      {
        "title": "Learning TypeScript Best Practices",
        "description": "Learn patterns for error handling, async operations, type guards, and performance optimization through documented examples and anti-pattern explanations.",
        "target_user": "Developers learning TypeScript or improving their skills"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic TypeScript Question",
        "prompt": "How should I define a typesafe function that handles errors properly in TypeScript? Show an example with proper typing.",
        "scenario": "Asking for guidance on type-safe error handling patterns"
      },
      {
        "title": "Type Definition Review",
        "prompt": "Review this TypeScript code and suggest improvements to the type definitions. Point out any 'any' types and suggest proper alternatives.",
        "scenario": "Requesting code review for type safety improvements"
      },
      {
        "title": "Documentation Generation",
        "prompt": "Add TSDoc comments to these exported functions and classes. Focus on documenting parameters, return types, and edge cases where intent is not obvious.",
        "scenario": "Generating documentation for a module"
      },
      {
        "title": "Performance Optimization",
        "prompt": "Review this TypeScript React component for performance issues. Suggest where to use React.memo, useMemo, useCallback, and lazy loading for code splitting.",
        "scenario": "Optimizing TypeScript React component performance"
      }
    ],
    "output_examples": [
      {
        "input": "How do I create a type-safe API call function?",
        "output": "Here is a type-safe API function using the Result pattern:\n\n```typescript\ntype Result<T, E = Error> =\n  | { success: true; data: T }\n  | { success: false; error: E };\n\nasync function fetchUserData(id: string): Promise<Result<UserData>> {\n  try {\n    const response = await fetch(`/api/users/${id}`);\n    if (!response.ok) {\n      return { success: false, error: new Error('Failed to fetch') };\n    }\n    const data = await response.json();\n    return { success: true, data };\n  } catch (error) {\n    return { success: false, error: error as Error };\n  }\n}\n```"
      },
      {
        "input": "How should I document this function?",
        "output": "Here is the function with TSDoc documentation:\n\n```typescript\n/**\n * Calculates the total price including tax and discounts.\n *\n * @param basePrice - The original price before any modifications\n * @param taxRate - The tax rate as a decimal (e.g., 0.08 for 8%)\n * @param discountPercent - Optional discount percentage (0-100)\n * @returns The final calculated price, never negative\n */\nfunction calculateTotal(\n  basePrice: number,\n  taxRate: number,\n  discountPercent: number = 0\n): number {\n  const discounted = basePrice * (1 - discountPercent / 100);\n  return Math.max(0, discounted * (1 + taxRate));\n}\n```"
      }
    ],
    "best_practices": [
      "Enable strict mode in tsconfig.json and avoid the any type to catch errors at compile time rather than runtime",
      "Use ES modules (import/export) instead of require() for better tree-shaking and modern tooling support",
      "Document public APIs with TSDoc comments, focusing on parameters, return values, and non-obvious behavior"
    ],
    "anti_patterns": [
      "Using 'any' type to silence TypeScript errors instead of properly defining types",
      "Using implicit any by omitting parameter types in function definitions",
      "Overusing type assertions (as Type) instead of proper type narrowing or guard functions"
    ],
    "faq": [
      {
        "question": "Does this skill modify my project files?",
        "answer": "No, this skill provides guidance and recommendations. It does not automatically modify tsconfig.json, code files, or any project configuration."
      },
      {
        "question": "What tools does this skill recommend?",
        "answer": "The skill recommends pnpm as the package manager, strict TypeScript configuration, TSDoc for documentation, and common quality tools like formatters and linters."
      },
      {
        "question": "Can I use this skill with JavaScript projects?",
        "answer": "This skill is specifically designed for TypeScript. It covers TypeScript-specific features like generics, utility types, and strict mode that do not apply to plain JavaScript."
      },
      {
        "question": "Does this skill work with React and Next.js?",
        "answer": "Yes, the skill includes TypeScript patterns for React including performance optimizations like React.memo, useMemo, useCallback, and lazy loading."
      },
      {
        "question": "What is the Result pattern and why should I use it?",
        "answer": "The Result pattern is a type-safe way to handle operations that might fail. Instead of throwing exceptions, functions return an object with success or failure status and associated data or error."
      },
      {
        "question": "How do I handle nullable values in TypeScript?",
        "answer": "Use optional chaining (?.) for accessing potentially null properties and nullish coalescing (??) for providing default values. Enable strict null checks in your TypeScript configuration."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 152
    }
  ]
}
