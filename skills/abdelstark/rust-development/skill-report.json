{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-16T15:33:12.315Z",
    "slug": "abdelstark-rust-development",
    "source_url": "https://github.com/AbdelStark/guts/tree/main/.claude/skills/rust-development",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "710bdc4dfb7f2cfc4655c821a73dfb2e0e51739af0540c8dd2d770085a5404e1",
    "tree_hash": "4ba1bc9cf5810519f114e08198fba694ba131978226897ffab15ce7451f263de"
  },
  "skill": {
    "name": "rust-development",
    "description": "Rust development best practices for the Guts project - idiomatic code, error handling, async patterns, and commonware integration",
    "summary": "Rust development best practices for the Guts project - idiomatic code, error handling, async pattern...",
    "icon": "ðŸ¦€",
    "version": "1.0.0",
    "author": "AbdelStark",
    "license": "MIT OR Apache-2.0",
    "category": "coding",
    "tags": [
      "rust",
      "commonware",
      "decentralized",
      "p2p",
      "consensus"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing Rust best practices and code examples. No executable code, scripts, network calls, filesystem access, or command execution. The static findings are false positives - code examples (Ed25519, Tokio), markdown code blocks, and GitHub URLs in metadata were misidentified as security issues.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          },
          {
            "file": "SKILL.md",
            "line_start": 144,
            "line_end": 144
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 126,
            "line_end": 126
          },
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 16,
            "line_end": 16
          },
          {
            "file": "SKILL.md",
            "line_start": 16,
            "line_end": 16
          },
          {
            "file": "SKILL.md",
            "line_start": 21,
            "line_end": 25
          },
          {
            "file": "SKILL.md",
            "line_start": 25,
            "line_end": 29
          },
          {
            "file": "SKILL.md",
            "line_start": 29,
            "line_end": 45
          },
          {
            "file": "SKILL.md",
            "line_start": 45,
            "line_end": 51
          },
          {
            "file": "SKILL.md",
            "line_start": 51,
            "line_end": 66
          },
          {
            "file": "SKILL.md",
            "line_start": 66,
            "line_end": 70
          },
          {
            "file": "SKILL.md",
            "line_start": 70,
            "line_end": 79
          },
          {
            "file": "SKILL.md",
            "line_start": 79,
            "line_end": 83
          },
          {
            "file": "SKILL.md",
            "line_start": 83,
            "line_end": 100
          },
          {
            "file": "SKILL.md",
            "line_start": 100,
            "line_end": 106
          },
          {
            "file": "SKILL.md",
            "line_start": 106,
            "line_end": 107
          },
          {
            "file": "SKILL.md",
            "line_start": 107,
            "line_end": 108
          },
          {
            "file": "SKILL.md",
            "line_start": 108,
            "line_end": 109
          },
          {
            "file": "SKILL.md",
            "line_start": 109,
            "line_end": 110
          },
          {
            "file": "SKILL.md",
            "line_start": 110,
            "line_end": 114
          },
          {
            "file": "SKILL.md",
            "line_start": 114,
            "line_end": 132
          },
          {
            "file": "SKILL.md",
            "line_start": 132,
            "line_end": 136
          },
          {
            "file": "SKILL.md",
            "line_start": 136,
            "line_end": 164
          },
          {
            "file": "SKILL.md",
            "line_start": 164,
            "line_end": 168
          },
          {
            "file": "SKILL.md",
            "line_start": 168,
            "line_end": 169
          },
          {
            "file": "SKILL.md",
            "line_start": 169,
            "line_end": 170
          },
          {
            "file": "SKILL.md",
            "line_start": 170,
            "line_end": 171
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 350,
    "audit_model": "claude",
    "audited_at": "2026-01-16T15:33:12.315Z"
  },
  "content": {
    "user_title": "Apply Rust best practices for decentralized projects",
    "value_statement": "Building decentralized infrastructure requires careful attention to memory safety, error handling, and async patterns. This skill provides verified Rust development guidelines tailored for commonware-based projects like Guts, ensuring secure and idiomatic code.",
    "seo_keywords": [
      "rust development",
      "commonware",
      "decentralized",
      "claude code",
      "idiomatic rust",
      "tokio async",
      "error handling",
      "p2p networking",
      "bft consensus",
      "claude"
    ],
    "actual_capabilities": [
      "Guide idiomatic Rust code following project conventions",
      "Implement error handling patterns with thiserror and anyhow",
      "Apply async patterns using Tokio with structured concurrency",
      "Integrate commonware crates for cryptography, P2P, and consensus",
      "Structure Rust modules for public API exposure",
      "Configure Cargo.toml with workspace dependencies and linting rules"
    ],
    "limitations": [
      "Provides guidance only - does not write or modify code directly",
      "Focused on Guts project patterns - may not suit all Rust projects",
      "Assumes basic familiarity with Rust syntax and concepts"
    ],
    "use_cases": [
      {
        "target_user": "Rust developers new to decentralized systems",
        "title": "Learn decentralized Rust patterns",
        "description": "Understand how to write safe, idiomatic Rust for P2P networks and BFT consensus using commonware primitives"
      },
      {
        "target_user": "Guts project contributors",
        "title": "Follow Guts project conventions",
        "description": "Maintain consistent code style, error handling, and module structure across the Guts codebase"
      },
      {
        "target_user": "Backend engineers building distributed systems",
        "title": "Apply async patterns and error handling",
        "description": "Learn structured concurrency with Tokio channels and proper error type design for reliable distributed systems"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic code review",
        "scenario": "Review Rust code for Guts",
        "prompt": "Review this Rust code for the Guts project. Check if it follows idiomatic Rust patterns, proper error handling with thiserror, and structured concurrency with Tokio."
      },
      {
        "title": "Error type design",
        "scenario": "Design error types",
        "prompt": "Design error types using thiserror for a new module in Guts. Include From implementations for underlying storage and network errors."
      },
      {
        "title": "Commonware integration",
        "scenario": "Integrate commonware crate",
        "prompt": "Show me how to integrate commonware-cryptography or commonware-p2p into a Guts service. Include proper initialization and error handling."
      },
      {
        "title": "Async architecture",
        "scenario": "Design async service architecture",
        "prompt": "Design an async service using Tokio with structured concurrency. Include channel-based command handling, oneshot responses, and shutdown signaling."
      }
    ],
    "output_examples": [
      {
        "input": "Create an error type for a repository module",
        "output": [
          "Define an enum implementing thiserror::Error",
          "Use #[error(\"...\")] macros for user-friendly messages",
          "Add #[from] attributes for automatic error conversion",
          "Create a public Result<T> type alias",
          "Example: NotFound, PermissionDenied, Storage variants"
        ]
      },
      {
        "input": "Set up a new Guts service with Tokio",
        "output": [
          "Create Service struct with mpsc::Sender<Command>",
          "Implement async methods using oneshot channels for responses",
          "Add shutdown signaling with cancellation tokens",
          "Use tokio::select! for handling multiple tasks",
          "Configure clippy to deny warnings in Cargo.toml"
        ]
      },
      {
        "input": "Use Ed25519 signatures for identity",
        "output": [
          "Generate keypair using Ed25519::generate()",
          "Implement sign(message) method returning Signature",
          "Use Verifier trait to verify signatures",
          "Store keypair securely in Identity struct",
          "Integrate with commonware-cryptography crate"
        ]
      }
    ],
    "best_practices": [
      "Run cargo fmt and cargo clippy before every commit to maintain code quality",
      "Use thiserror for library errors and anyhow for application-level errors",
      "Prefer Tokio channels over shared mutable state for inter-task communication"
    ],
    "anti_patterns": [
      "Avoid using unsafe code unless absolutely necessary for FFI or performance",
      "Do not ignore clippy warnings - treat them as compile errors",
      "Avoid blocking async code with .wait() or synchronous I/O in async contexts"
    ],
    "faq": [
      {
        "question": "Which Rust edition should I use?",
        "answer": "Use Rust 2021 edition for new Guts code. Set edition = 2021 in Cargo.toml and rust-version = 1.75 or higher."
      },
      {
        "question": "When should I use thiserror versus anyhow?",
        "answer": "Use thiserror for library errors that need custom types. Use anyhow for applications where you want flexible error handling."
      },
      {
        "question": "How do I handle errors from commonware crates?",
        "answer": "Use #[from] attributes in your error enum to automatically convert commonware errors to your custom error types."
      },
      {
        "question": "Is my data safe when using this skill?",
        "answer": "Yes. This skill only provides guidance through prompts. It does not access, read, or write any files or data on your system."
      },
      {
        "question": "Why is clippy configured to deny warnings?",
        "answer": "Denying clippy warnings catches potential bugs early. All warnings should be fixed before committing code."
      },
      {
        "question": "How does this compare to standard Rust documentation?",
        "answer": "This skill provides Guts-specific patterns. For general Rust questions, refer to the official Rust book and standard documentation."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 172
    }
  ]
}
