{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-16T15:38:03.111Z",
    "slug": "abdelstark-testing",
    "source_url": "https://github.com/AbdelStark/guts/tree/main/.claude/skills/testing",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "f80bd69718fe43fa8a4261ef91364e8c4c88817771368daa48569d88c62a42c2",
    "tree_hash": "ed88e087dc80fa2a305958318844c7a030a7108ab8d196f6ab1c35336d763ba7"
  },
  "skill": {
    "name": "testing",
    "description": "Comprehensive testing strategies for Guts including unit tests, integration tests, property-based testing, and fuzzing",
    "summary": "Comprehensive testing strategies for Guts including unit tests, integration tests, property-based te...",
    "icon": "ðŸ§ª",
    "version": "1.0.0",
    "author": "AbdelStark",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "rust",
      "testing",
      "distributed-systems",
      "property-testing",
      "fuzzing"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a pure prompt-based skill containing only documentation and test pattern examples. No executable code, no file access, no network calls, and no command execution capabilities. The content provides legitimate Rust testing guidance using standard testing frameworks and patterns. All 52 static findings are false positives caused by the scanner flagging markdown code examples and metadata fields as security issues.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 12,
            "line_end": 18
          },
          {
            "file": "SKILL.md",
            "line_start": 18,
            "line_end": 24
          },
          {
            "file": "SKILL.md",
            "line_start": 24,
            "line_end": 47
          },
          {
            "file": "SKILL.md",
            "line_start": 47,
            "line_end": 51
          },
          {
            "file": "SKILL.md",
            "line_start": 51,
            "line_end": 64
          },
          {
            "file": "SKILL.md",
            "line_start": 64,
            "line_end": 70
          },
          {
            "file": "SKILL.md",
            "line_start": 70,
            "line_end": 99
          },
          {
            "file": "SKILL.md",
            "line_start": 99,
            "line_end": 103
          },
          {
            "file": "SKILL.md",
            "line_start": 103,
            "line_end": 127
          },
          {
            "file": "SKILL.md",
            "line_start": 127,
            "line_end": 131
          },
          {
            "file": "SKILL.md",
            "line_start": 131,
            "line_end": 133
          },
          {
            "file": "SKILL.md",
            "line_start": 133,
            "line_end": 150
          },
          {
            "file": "SKILL.md",
            "line_start": 150,
            "line_end": 154
          },
          {
            "file": "SKILL.md",
            "line_start": 154,
            "line_end": 156
          },
          {
            "file": "SKILL.md",
            "line_start": 156,
            "line_end": 166
          },
          {
            "file": "SKILL.md",
            "line_start": 166,
            "line_end": 170
          },
          {
            "file": "SKILL.md",
            "line_start": 170,
            "line_end": 188
          },
          {
            "file": "SKILL.md",
            "line_start": 188,
            "line_end": 192
          },
          {
            "file": "SKILL.md",
            "line_start": 192,
            "line_end": 204
          },
          {
            "file": "SKILL.md",
            "line_start": 204,
            "line_end": 208
          },
          {
            "file": "SKILL.md",
            "line_start": 208,
            "line_end": 228
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 408,
    "audit_model": "claude",
    "audited_at": "2026-01-16T15:38:03.111Z"
  },
  "content": {
    "user_title": "Write comprehensive tests for Rust distributed systems",
    "value_statement": "Writing reliable tests for distributed systems is challenging without structured guidance. This skill provides testing patterns for unit tests, integration tests, property-based testing, and fuzzing to help developers ensure code quality and catch edge cases.",
    "seo_keywords": [
      "testing skill",
      "Rust testing",
      "unit tests",
      "integration tests",
      "property-based testing",
      "fuzzing",
      "distributed systems testing",
      "proptest",
      "cargo-fuzz",
      "Claude Code testing"
    ],
    "actual_capabilities": [
      "Guide unit test creation with async support and error handling",
      "Design integration test fixtures for multi-node scenarios",
      "Implement property-based testing with proptest strategies",
      "Set up fuzzing targets with cargo-fuzz for protocol parsing",
      "Configure CI test matrices across multiple Rust versions and OS",
      "Mock dependencies with mockall for isolated service testing"
    ],
    "limitations": [
      "Does not execute tests or return test results",
      "Does not modify or create test files in your project",
      "Does not integrate with external testing services",
      "Focused on Rust testing patterns, not other languages"
    ],
    "use_cases": [
      {
        "target_user": "Rust developers",
        "title": "Adopt testing pyramid",
        "description": "Implement comprehensive test coverage with unit, integration, E2E, and property tests following industry best practices"
      },
      {
        "target_user": "Distributed systems engineers",
        "title": "Test P2P synchronization",
        "description": "Write multi-node integration tests to verify repository sync and consensus behavior across validators"
      },
      {
        "target_user": "Security-focused developers",
        "title": "Implement fuzz testing",
        "description": "Set up fuzzing targets to discover edge cases and potential vulnerabilities in protocol parsing code"
      }
    ],
    "prompt_templates": [
      {
        "title": "Unit test basics",
        "scenario": "Create basic unit tests",
        "prompt": "Help me write unit tests for my Rust module. Include async tests with tokio::test and use pretty_assertions for readable diffs."
      },
      {
        "title": "Integration fixtures",
        "scenario": "Set up test infrastructure",
        "prompt": "Create a test fixture for integration testing that sets up a temporary node with a temp directory and test configuration."
      },
      {
        "title": "Property testing",
        "scenario": "Generate property-based tests",
        "prompt": "Write proptest strategies for validating repository name handling. Include regex-based name generation and signature verification tests."
      },
      {
        "title": "Fuzzing setup",
        "scenario": "Configure fuzz testing",
        "prompt": "Set up a cargo-fuzz target for parsing network messages. Ensure the fuzzer handles malformed input without panicking."
      }
    ],
    "output_examples": [
      {
        "input": "Help me write unit tests for a Repository struct with success and error cases",
        "output": [
          "Group related tests in a tests module",
          "Use #[test] for sync tests and #[tokio::test] for async tests",
          "Test both success paths and error conditions",
          "Use pretty_assertions::assert_eq for readable diffs",
          "Test edge cases like empty strings and invalid inputs",
          "Example: Repository::new invalid name returns RepositoryError::InvalidName"
        ]
      },
      {
        "input": "How do I set up property-based testing for my protocol code",
        "output": [
          "Define proptest strategies that match your input domain",
          "Use regex-based generation for string fields",
          "Test round-trip serialization and deserialization",
          "Generate random byte vectors for binary protocols",
          "Configure failure persistence to debug failing cases",
          "Run thousands of iterations to catch edge cases"
        ]
      },
      {
        "input": "Create integration tests for multi-node synchronization",
        "output": [
          "Set up multiple TestNode instances with temp directories",
          "Use futures::future::join_all to start nodes in parallel",
          "Connect nodes using async connect methods",
          "Create repositories on one node and verify propagation",
          "Add delays to allow sync operations to complete",
          "Assert that all nodes have the synchronized state"
        ]
      }
    ],
    "best_practices": [
      "Follow the testing pyramid: many unit tests, some integration tests, few E2E tests",
      "Use property-based testing to catch edge cases that manual tests miss",
      "Run fuzzers continuously to discover parsing vulnerabilities in protocol code"
    ],
    "anti_patterns": [
      "Avoid putting all tests in a single #[test] function",
      "Do not skip error case testing in favor of happy path only",
      "Avoid coupling tests to implementation details that change frequently"
    ],
    "faq": [
      {
        "question": "Which Rust testing frameworks does this skill support?",
        "answer": "Standard library testing, tokio::test for async, proptest for property-based testing, and cargo-fuzz for fuzzing."
      },
      {
        "question": "What is the maximum test coverage recommended?",
        "answer": "Aim for high coverage on critical paths. Use cargo llvm-cov to generate reports and identify untested code."
      },
      {
        "question": "Can I use this skill with existing test frameworks?",
        "answer": "Yes, the patterns work with any Rust testing framework. mockall is suggested for mocking dependencies."
      },
      {
        "question": "Is my test data safe?",
        "answer": "This skill only provides guidance. It does not read, write, or transmit any test data from your project."
      },
      {
        "question": "Why are my async tests timing out?",
        "answer": "Ensure you use #[tokio::test] and avoid blocking in async contexts. Check for missing await points."
      },
      {
        "question": "How is this different from cargo test?",
        "answer": "This skill provides testing patterns and guidance. cargo test is the actual command to run tests in your project."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 229
    }
  ]
}
