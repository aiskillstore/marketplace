{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T15:14:27.826Z",
    "slug": "benny9193-code-patterns",
    "source_url": "https://github.com/Benny9193/devflow/tree/master/skills/code-patterns",
    "source_ref": "master",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "b1b9facde043ad8d3dd33c3f1b452d4c26df1bde1ed9da2678a19c4bd4f9a81d",
    "tree_hash": "7b2fd548d0d043a56be2faf633d43c86954d9783c9b6fc1d39070e7c5ce808cd"
  },
  "skill": {
    "name": "code-patterns",
    "description": "Common code patterns and best practices reference for quick lookup",
    "summary": "Common code patterns and best practices reference for quick lookup",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "Benny9193",
    "license": "MIT",
    "tags": [
      "design-patterns",
      "software-architecture",
      "typescript",
      "best-practices",
      "reference"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings are false positives. The skill contains only documentation with TypeScript code examples. No executable code, network calls, or command execution patterns exist. Scanner misinterpreted template literals in documentation as shell backticks and JSON structure as cryptographic code.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 895,
    "audit_model": "claude",
    "audited_at": "2026-01-21T15:14:27.826Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Apply Common Design Patterns",
    "value_statement": "Developers waste time reinventing solutions to common problems. This skill provides ready-to-use TypeScript code patterns for creational, structural, and behavioral design patterns along with async and data access patterns.",
    "seo_keywords": [
      "Claude",
      "Codex",
      "Claude Code",
      "design patterns",
      "software patterns",
      "TypeScript patterns",
      "factory pattern",
      "observer pattern",
      "strategy pattern",
      "code best practices"
    ],
    "actual_capabilities": [
      "Provides TypeScript implementations of Gang of Four design patterns",
      "Includes error handling patterns like Result type and retry with backoff",
      "Offers async patterns including promise queue and debounce",
      "Documents data access patterns like Repository and Unit of Work",
      "Covers creational, structural, and behavioral pattern categories"
    ],
    "limitations": [
      "Contains only code examples, does not execute any code",
      "Patterns are starting points that require adaptation for specific use cases",
      "Does not include testing patterns or performance optimization techniques"
    ],
    "use_cases": [
      {
        "title": "Architecture Decisions",
        "description": "Senior developers use this skill to patterns when select appropriate designing new features or refactoring existing code.",
        "target_user": "Software architects and senior developers"
      },
      {
        "title": "Learning Design Patterns",
        "description": "Intermediate developers reference this skill to learn when and how to apply common software design patterns in their TypeScript projects.",
        "target_user": "Developers learning software design"
      },
      {
        "title": "Quick Pattern Lookup",
        "description": "Developers quickly find working code examples for patterns like Factory, Observer, Strategy, or Repository when implementing features.",
        "target_user": "All developers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Pattern Request",
        "prompt": "Show me the [PATTERN_NAME] pattern in TypeScript with a practical example.",
        "scenario": "Looking for a specific design pattern"
      },
      {
        "title": "Problem-Solution Match",
        "prompt": "I need to solve [PROBLEM_DESCRIPTION]. Which pattern should I use and show me the implementation.",
        "scenario": "Matching problems to patterns"
      },
      {
        "title": "Pattern Comparison",
        "prompt": "What is the difference between [PATTERN_A] and [PATTERN_B]? Show me how to implement both in TypeScript.",
        "scenario": "Choosing between similar patterns"
      },
      {
        "title": "Real-World Application",
        "prompt": "Show me how to use the [PATTERN_NAME] pattern in a real-world scenario with [USE_CASE].",
        "scenario": "Applying patterns to specific contexts"
      }
    ],
    "output_examples": [
      {
        "input": "Show me the Observer pattern",
        "output": "The Observer pattern enables objects to notify other objects about state changes. It uses a subscription model where listeners register to receive updates. Common use cases include event handling systems, UI updates, and real-time data feeds. The pattern consists of a subject that maintains a list of listeners and notifies them when events occur."
      },
      {
        "input": "How do I handle errors without exceptions?",
        "output": "The Result type pattern represents operations that can fail without throwing exceptions. It returns { ok: true, value: T } on success or { ok: false, error: E } on failure. This pattern is useful for expected failures where exceptions would be too heavy, such as validation errors or business logic failures. Callers check the ok property before accessing the value."
      },
      {
        "input": "How do I limit concurrent API calls?",
        "output": "The Promise Queue pattern limits the number of concurrent async operations. It maintains a queue of functions and processes them based on a concurrency limit. Use this pattern when making multiple API calls or file operations that could overwhelm resources if run in parallel. The queue processes items one at a time up to the concurrency limit."
      }
    ],
    "best_practices": [
      "Prefer composition over inheritance when applying structural patterns like Decorator",
      "Use the Result type pattern for expected failures instead of exceptions",
      "Apply the Strategy pattern to make algorithms swappable at runtime"
    ],
    "anti_patterns": [
      "Avoid Singleton pattern as a global state solution; prefer dependency injection",
      "Do not use patterns blindly without understanding the problem they solve",
      "Avoid over-engineering with patterns for simple one-off solutions"
    ],
    "faq": [
      {
        "question": "What is the Factory pattern?",
        "answer": "The Factory pattern creates objects without specifying the exact class. A factory class has a method that returns instances based on input parameters. Use it when object creation logic is complex or when the system should remain flexible about which classes it instantiates."
      },
      {
        "question": "When should I use the Strategy pattern?",
        "answer": "Use the Strategy pattern when you need to select an algorithm at runtime. It defines a family of algorithms, encapsulates each one, and makes them interchangeable. Common use cases include payment processing, sorting algorithms, and validation strategies."
      },
      {
        "question": "What is the difference between Observer and Pub/Sub?",
        "answer": "The Observer pattern has a direct relationship between subjects and observers. Pub/Sub adds a message broker or event channel between publishers and subscribers, providing more decoupling. Observer is simpler for direct notification use cases; Pub/Sub scales better for distributed systems."
      },
      {
        "question": "How do I handle transient failures?",
        "answer": "Use the Retry with Backoff pattern. It attempts an operation multiple times with increasing delays between attempts. Exponential backoff prevents overwhelming failing services while giving them time to recover. Set a maximum attempt count to avoid infinite loops."
      },
      {
        "question": "What is the Repository pattern?",
        "answer": "The Repository pattern abstracts data access logic behind a clean interface. It separates the domain model from data persistence details. Repositories provide methods like findById, findAll, and save without exposing database-specific queries to the business logic layer."
      },
      {
        "question": "When should I use the Decorator pattern?",
        "answer": "Use the Decorator pattern when you need to add behavior to objects dynamically without modifying their class. It wraps objects in a decorator class that adds functionality. This is useful for cross-cutting concerns like logging, caching, or validation that should apply to specific objects rather than entire classes."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 290
    }
  ]
}
