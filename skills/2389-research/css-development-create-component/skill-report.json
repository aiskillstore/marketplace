{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T15:41:35.138Z",
    "slug": "2389-research-css-development-create-component",
    "source_url": "https://github.com/2389-research/claude-plugins/tree/main/css-development/skills/create-component",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "fed57b783260b83b5caff6e9671b42b3809a8cb4fea50594c0127d5f8be301c7",
    "tree_hash": "7babc1a9932a79e31bb5610d44190502ec1fff37a58f9ac55436679011e02e88"
  },
  "skill": {
    "name": "css-development-create-component",
    "description": "This skill should be used when creating new styled components or adding new CSS classes. Triggers on \"create component\", \"new button\", \"new card\", \"add styles\", \"style component\", \"build UI element\". Guides semantic naming, Tailwind composition, dark mode support, and test coverage.",
    "summary": "Guides creating new CSS components with semantic naming, Tailwind composition, dark mode support, and test coverage.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "2389-research",
    "license": "MIT",
    "category": "design",
    "tags": [
      "css",
      "tailwind",
      "components",
      "styling",
      "dark-mode"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill is a pure CSS development guide with no executable code or security risks. All 95 static findings are false positives from pattern matching on documentation content. The skill contains only markdown documentation with code examples showing CSS component creation workflows. No network access, no shell execution, no file operations exist in actual skill code.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 1386,
    "audit_model": "claude",
    "audited_at": "2026-01-21T15:41:35.138Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Create CSS Components with Best Practices",
    "value_statement": "Building consistent, maintainable CSS components requires following established patterns and conventions. This skill guides you through creating components with semantic naming, Tailwind composition, dark mode support, and comprehensive test coverage.",
    "seo_keywords": [
      "CSS components",
      "Tailwind CSS",
      "component development",
      "semantic CSS",
      "dark mode CSS",
      "CSS testing",
      "Claude",
      "Codex",
      "Claude Code",
      "atomic design"
    ],
    "actual_capabilities": [
      "Guide creation of new CSS components following established naming patterns",
      "Enforce semantic class naming conventions with base and variant patterns",
      "Apply Tailwind utility composition using @apply directives",
      "Include dark mode variants by default for all color and background properties",
      "Create static CSS tests to verify class existence and dark mode variants",
      "Generate component rendering tests to verify className application"
    ],
    "limitations": [
      "Provides guidance workflow only, does not automatically generate files",
      "Requires existing CSS structure and established naming conventions in project",
      "Does not generate visual designs, design tokens, or style guides",
      "Assumes project uses Tailwind CSS or similar utility-first CSS framework"
    ],
    "use_cases": [
      {
        "title": "Create reusable button components",
        "description": "Build button components with multiple variants (primary, secondary, danger) including proper hover states, focus rings, and dark mode support for consistent UI patterns.",
        "target_user": "Frontend developers building component libraries"
      },
      {
        "title": "Design card components with proper structure",
        "description": "Create card components following atomic design principles with semantic sub-elements, proper spacing, shadows, and responsive variants.",
        "target_user": "UI designers and frontend developers"
      },
      {
        "title": "Extend design systems consistently",
        "description": "Add new component variants to existing design systems while maintaining consistency with established patterns, naming conventions, and test coverage.",
        "target_user": "Developers maintaining large-scale design systems"
      }
    ],
    "prompt_templates": [
      {
        "title": "Create basic component",
        "prompt": "Create a new CSS component for a {component_name}. Use semantic naming, Tailwind @apply composition, and include dark mode support.",
        "scenario": "Quick component creation with standard requirements"
      },
      {
        "title": "Create component with multiple variants",
        "prompt": "Create a {component_name} component with {number} variants: {variant_list}. Each variant needs hover states, focus states, and dark mode variants. Include static CSS tests.",
        "scenario": "Building components with multiple style variations"
      },
      {
        "title": "Follow existing codebase patterns",
        "prompt": "Read the existing components.css file to understand current patterns. Then create a {component_name} that follows the same composition approach, naming conventions, and test structure.",
        "scenario": "Maintaining consistency with established codebase conventions"
      },
      {
        "title": "Complete component development workflow",
        "prompt": "Create a complete {component_type} component following the full workflow: survey existing components, check composition options, identify atomic level, choose semantic name, write component class with dark variants, create markup examples, write static CSS test, write rendering test, and document usage.",
        "scenario": "Full production-ready component with tests and documentation"
      }
    ],
    "output_examples": [
      {
        "input": "Create a primary button component",
        "output": "I'm using the css-development:create-component skill to guide creating this new CSS component.\n\nCreating CSS Component:\n- Survey existing components (read components.css)\n- Check if composition solves it\n- Identify component type\n- Choose semantic name\n- Write component class\n- Create markup integration\n- Write static CSS test\n- Write component rendering test\n- Document component\n\nStep 1: Reading components.css to understand existing patterns..."
      },
      {
        "input": "Add a danger variant to the existing button",
        "output": "I've surveyed the existing components and found .button-primary and .button-secondary classes using @apply directives with dark mode variants.\n\nFollowing the established pattern, I'll create .button-danger with:\n- Red color scheme (bg-red-500, hover:bg-red-700)\n- Dark mode variants (dark:bg-red-600, dark:hover:bg-red-800)\n- Same spacing and transitions as other button variants\n\nAdding to components.css now..."
      },
      {
        "input": "Should I create a new class for a blue card?",
        "output": "Let me check if composition can solve this need.\n\nAfter reviewing components.css, I see a base .card class exists. For a blue variant, you have two options:\n\n1. Composition (recommended): Use .card with bg-blue-100 dark:bg-blue-900 utility classes\n2. New class: Create .card-blue if this combination appears frequently\n\nGiven YAGNI principle, I recommend using composition unless this blue card appears in 5+ locations. Would you like to proceed with composition or create a new class?"
      }
    ],
    "best_practices": [
      "Follow semantic naming conventions: use descriptive purpose-based names like button-primary instead of abbreviated or utility names like btn-blue",
      "Always include dark mode variants for colors and backgrounds using the dark: prefix, placing them after light variants for proper CSS specificity",
      "Write both static CSS tests (verify class exists in components.css) and component rendering tests (verify className applies correctly in framework components)"
    ],
    "anti_patterns": [
      "Avoid creating new classes when composing existing utilities would work; follow YAGNI principle and only create abstractions when duplication becomes problematic",
      "Do not use generic, abbreviated, or utility-style class names like component, item, btn, or card-sm; use semantic purpose-based names instead",
      "Avoid mixing raw CSS properties with Tailwind @apply directives; choose one approach per project and maintain consistency throughout the codebase"
    ],
    "faq": [
      {
        "question": "What naming convention should I use for CSS classes?",
        "answer": "Use semantic, purpose-based names following the pattern of Base plus Variant or Component plus Sub-element. Examples include button-primary, card-title, and form-field. Avoid utility names like btn-blue or abbreviations like btn."
      },
      {
        "question": "How do I properly handle dark mode in components?",
        "answer": "Include dark: variants for all color and background properties. Place dark variants after light variants in your @apply directives. Example: @apply bg-indigo-500 hover:bg-indigo-700 dark:bg-indigo-600 dark:hover:bg-indigo-800. This ensures proper stacking and predictable behavior."
      },
      {
        "question": "Should I create a new CSS class or compose existing ones?",
        "answer": "Try composition first by combining existing classes. Only create a new class when composition creates excessive markup duplication or when the combination appears in many locations. Follow the YAGNI principle: you are not going to need it until you actually do."
      },
      {
        "question": "What tests should I write for CSS components?",
        "answer": "Write two types of tests. Static CSS tests verify the class exists in components.css and includes dark mode variants. Component rendering tests verify the className is applied correctly in your framework components and that custom classes can be added without conflicts."
      },
      {
        "question": "How do I determine the atomic design level for my component?",
        "answer": "Atoms are basic building blocks like button, input, and badge. Molecules combine multiple atoms like card, form-field, and alert. Organisms are complex combinations like page-layout, navigation, and session-card. Choose the level that matches your component complexity and dependencies."
      },
      {
        "question": "How do I integrate the new component into my project?",
        "answer": "Add the component class to styles/components.css using the Edit tool. Create markup examples showing usage in React, Vue, or vanilla HTML. Add static CSS tests to verify the class exists. Add component rendering tests to verify className application. Document the component API and usage patterns."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 362
    }
  ]
}
