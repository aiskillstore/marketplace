{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T09:10:24.997Z",
    "slug": "2389-research-building-multiagent-systems",
    "source_url": "https://github.com/2389-research/claude-plugins/tree/main/building-multiagent-systems/skills",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "ca0ba2fc4876e3629a29642a762c28ea61d0cb19faebe8eb709b980bb4cb2dc5",
    "tree_hash": "e8e6bfa64fd5f65a83053764e9c627e5da2aed216d29c3613fdb3f25c16e4d90"
  },
  "skill": {
    "name": "building-multiagent-systems",
    "description": "This skill should be used when designing or implementing systems with multiple AI agents that coordinate to accomplish tasks. Triggers on \"multi-agent\", \"orchestrator\", \"sub-agent\", \"coordination\", \"delegation\", \"parallel agents\", \"sequential pipeline\", \"fan-out\", \"map-reduce\", \"spawn agents\", \"agent hierarchy\".",
    "summary": "This skill should be used when designing or implementing systems with multiple AI agents that coordi...",
    "icon": "agent",
    "version": "1.0.0",
    "author": "2389-research",
    "license": "MIT",
    "category": "architecture",
    "tags": [
      "multi-agent",
      "orchestration",
      "coordination",
      "patterns",
      "architecture"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure prompt-based skill containing only markdown documentation and TypeScript pseudocode examples. No executable code, network calls, file access, or external commands. The skill provides architectural guidance through educational patterns and best practices.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 6,
    "total_lines": 967,
    "audit_model": "claude",
    "audited_at": "2026-01-10T09:10:24.997Z"
  },
  "content": {
    "user_title": "Design production-ready multi-agent AI systems",
    "value_statement": "Building systems with multiple coordinating AI agents requires careful architecture. This skill provides seven battle-tested coordination patterns and four-layer architecture guidance to design robust, scalable multi-agent systems that handle cleanup, cost tracking, and error recovery.",
    "seo_keywords": [
      "multi-agent systems",
      "agent orchestration",
      "coordination patterns",
      "Claude Code",
      "Claude",
      "Codex",
      "fan-out fan-in",
      "map-reduce",
      "agent hierarchy",
      "cascading stop"
    ],
    "actual_capabilities": [
      "Ask six discovery questions to understand requirements before architecting",
      "Recommend one of seven coordination patterns based on use case: fan-out/fan-in, pipeline, delegation, work-stealing, map-reduce, peer collaboration, or MAKER",
      "Guide implementation of four-layer architecture (reasoning, orchestration, tool bus, deterministic adapters)",
      "Provide cascading stop pattern to prevent orphaned agents",
      "Show cost tracking across agent hierarchies using hierarchical IDs",
      "Design tool coordination with permission inheritance, resource locking, and rate limiting"
    ],
    "limitations": [
      "Provides architectural guidance only; does not generate complete working code",
      "Language-agnostic patterns require implementation in your chosen language",
      "Assumes basic familiarity with agentic AI concepts and tool use",
      "Does not integrate with specific agent frameworks or platforms"
    ],
    "use_cases": [
      {
        "target_user": "System architects",
        "title": "Choose coordination pattern",
        "description": "Select the right pattern for your workload by answering six discovery questions about scale, state, and constraints"
      },
      {
        "target_user": "ML engineers",
        "title": "Implement agent lifecycle",
        "description": "Build cascading stop, orphan detection, and checkpointing for reliable multi-agent systems that survive crashes"
      },
      {
        "target_user": "DevOps engineers",
        "title": "Track costs at scale",
        "description": "Aggregate costs across agent hierarchies and implement rate limiting to prevent budget overruns"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic architecture",
        "scenario": "First multi-agent system",
        "prompt": "I need to build a multi-agent system. What patterns should I consider and what questions should I ask before starting?"
      },
      {
        "title": "Pattern selection",
        "scenario": "Choosing coordination approach",
        "prompt": "I have 100 files that need analysis. Each analysis is independent but results need synthesis. Which pattern fits best?"
      },
      {
        "title": "Production hardening",
        "scenario": "Making systems reliable",
        "prompt": "My multi-agent system keeps leaving orphaned agents. How do I implement cascading stop and orphan detection?"
      },
      {
        "title": "Cost optimization",
        "scenario": "Managing budget",
        "prompt": "I want to use different models for different tasks to reduce costs. How do I implement map-reduce with cheap mappers and smart reducers?"
      }
    ],
    "output_examples": [
      {
        "input": "I want to build a system where one orchestrator coordinates 5 specialist agents in parallel, each analyzing a pull request from a different perspective (security, performance, style, tests, docs)",
        "output": [
          "Recommended pattern: Fan-Out/Fan-In",
          "Key considerations:",
          "  - Use hierarchical IDs like session.1.1, session.1.2 for cost aggregation",
          "  - Set timeouts on each sub-agent (2 minutes recommended)",
          "  - Aggregate results regardless of partial failures",
          "  - Implement cascading stop: always stop children before stopping orchestrator",
          "  - Track costs per reviewer using parent-child cost propagation",
          "  - Use smart models for complex tasks (security, tests), fast models for simple ones (style, docs)"
        ]
      }
    ],
    "best_practices": [
      "Implement four-layer architecture: keep tools deterministic (no LLM calls below Layer 1) for testability",
      "Use hierarchical IDs to track costs and delegate depth; prevent infinite recursion with max-depth limits",
      "Always stop children before stopping parent (cascading stop) to prevent orphaned agents consuming resources"
    ],
    "anti_patterns": [
      "Placing LLM calls inside tool implementations breaks determinism and makes testing impossible",
      "Missing cascading stop leads to orphaned agents when the orchestrator crashes or exits",
      "No permission inheritance allows sub-agents to escalate privileges beyond what the parent has access to"
    ],
    "faq": [
      {
        "question": "What languages does this skill support?",
        "answer": "Language-agnostic. Patterns apply to TypeScript, Python, Go, Rust, and other languages with agent frameworks."
      },
      {
        "question": "How many agents can this handle?",
        "answer": "Patterns scale from 2-5 agents (small) to 10-50 (medium) to 100+ (large). Choose pattern based on your scale."
      },
      {
        "question": "Can I integrate with existing agent frameworks?",
        "answer": "Yes. The skill provides pattern guidance that works with any framework implementing agent spawning and lifecycle management."
      },
      {
        "question": "Is data safe with multi-agent systems?",
        "answer": "This skill emphasizes permission inheritance (children inherit subset of parent permissions) to prevent privilege escalation."
      },
      {
        "question": "Why are agents getting orphaned?",
        "answer": "Missing cascading stop pattern. Always stop children before stopping parent. Implement heartbeat monitoring to detect orphans."
      },
      {
        "question": "How is this different from simple parallel processing?",
        "answer": "Multi-agent systems involve AI reasoning at each step. Coordination patterns address agent-specific challenges like cost tracking, error recovery, and cleanup."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "coordination-patterns.md",
          "type": "file",
          "path": "references/coordination-patterns.md"
        },
        {
          "name": "four-layer-architecture.md",
          "type": "file",
          "path": "references/four-layer-architecture.md"
        },
        {
          "name": "maker-pattern.md",
          "type": "file",
          "path": "references/maker-pattern.md"
        },
        {
          "name": "production-hardening.md",
          "type": "file",
          "path": "references/production-hardening.md"
        },
        {
          "name": "tool-coordination.md",
          "type": "file",
          "path": "references/tool-coordination.md"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
