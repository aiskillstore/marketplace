{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T15:34:28.049Z",
    "slug": "2389-research-binary-re-static-analysis",
    "source_url": "https://github.com/2389-research/claude-plugins/tree/main/binary-re/skills/static-analysis",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "775f3af2482098aa126fd02c5c1882ce50136a31955f9dd16b0999fb63dbe9ef",
    "tree_hash": "846fdee621d9c61c073138e1884ed79f2d421f4d1248567773de13deab70912e"
  },
  "skill": {
    "name": "binary-re-static-analysis",
    "description": "Use when analyzing binary structure, disassembling code, or decompiling functions. Deep static analysis via radare2 (r2) and Ghidra headless - function enumeration, cross-references (xrefs), decompilation, control flow graphs. Keywords - \"disassemble\", \"decompile\", \"what does this function do\", \"find functions\", \"analyze code\", \"r2\", \"ghidra\", \"pdg\", \"afl\"",
    "summary": "Static binary analysis using radare2 and Ghidra. Disassemble, decompile, and map function structures.",
    "icon": "üîç",
    "version": "1.0.0",
    "author": "2389-research",
    "license": "MIT",
    "tags": [
      "reverse-engineering",
      "binary-analysis",
      "radare2",
      "ghidra",
      "disassembly"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "external_commands",
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Static analysis tool for binary reverse engineering. All detected patterns are legitimate reverse engineering techniques using radare2 and Ghidra. External command execution is intentional and necessary for invoking analysis tools. No malicious patterns found.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 25,
            "line_end": 48
          },
          {
            "file": "SKILL.md",
            "line_start": 65,
            "line_end": 67
          },
          {
            "file": "SKILL.md",
            "line_start": 71,
            "line_end": 78
          },
          {
            "file": "SKILL.md",
            "line_start": 103,
            "line_end": 116
          },
          {
            "file": "SKILL.md",
            "line_start": 120,
            "line_end": 129
          },
          {
            "file": "SKILL.md",
            "line_start": 160,
            "line_end": 168
          },
          {
            "file": "SKILL.md",
            "line_start": 188,
            "line_end": 194
          },
          {
            "file": "SKILL.md",
            "line_start": 200,
            "line_end": 208
          },
          {
            "file": "SKILL.md",
            "line_start": 219,
            "line_end": 228
          },
          {
            "file": "SKILL.md",
            "line_start": 232,
            "line_end": 241
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 202,
            "line_end": 202
          },
          {
            "file": "SKILL.md",
            "line_start": 34,
            "line_end": 35
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 1320,
    "audit_model": "claude",
    "audited_at": "2026-01-21T15:34:28.049Z"
  },
  "content": {
    "user_title": "Analyze binary structure and code",
    "value_statement": "Reverse engineering binaries requires understanding function structures, data flows, and code logic without execution. This skill provides systematic methods for static analysis using radare2 and Ghidra to map code, trace references, and decompile functions.",
    "seo_keywords": [
      "Claude",
      "Codex",
      "Claude Code",
      "binary analysis",
      "reverse engineering",
      "radare2",
      "ghidra",
      "disassembly",
      "decompilation",
      "static analysis"
    ],
    "actual_capabilities": [
      "Enumerate all functions in a binary using radare2 analysis commands",
      "Trace cross-references to understand function call relationships",
      "Decompile specific functions to pseudo-C using r2ghidra",
      "Generate control flow graphs for complex functions",
      "Identify crypto imports and network-related functions",
      "Export structured analysis findings in JSON format"
    ],
    "limitations": [
      "Requires radare2 and Ghidra to be installed on the system",
      "Cannot analyze encrypted or obfuscated binaries without decryption",
      "Limited by analysis depth settings for very large binaries",
      "Does not provide runtime behavior or dynamic execution results"
    ],
    "use_cases": [
      {
        "title": "Security vulnerability research",
        "description": "Analyze closed-source binaries to identify potential vulnerabilities, trace data flows, and understand security-critical code paths before dynamic testing.",
        "target_user": "Security analysts and researchers"
      },
      {
        "title": "Malware analysis",
        "description": "Examine malicious software safely through static techniques. Map function structures, identify network indicators, and understand behavior without triggering payloads.",
        "target_user": "Malware analysts and threat researchers"
      },
      {
        "title": "Legacy software understanding",
        "description": "Understand undocumented or legacy binaries when source code is unavailable. Recover function signatures, map APIs, and document software behavior.",
        "target_user": "Software engineers and maintainers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic function analysis",
        "prompt": "Analyze this binary and list all functions. Identify the main function and any network-related functions like socket, connect, send, or recv.",
        "scenario": "Initial reconnaissance of binary structure"
      },
      {
        "title": "Cross-reference tracing",
        "prompt": "Find all callers of function at address [ADDRESS]. Trace the call chain from main to understand how this function is reached.",
        "scenario": "Understanding function relationships"
      },
      {
        "title": "Decompilation request",
        "prompt": "Decompile function [FUNCTION_NAME] using r2ghidra. Provide the pseudo-C output and explain what the function appears to do.",
        "scenario": "Understanding function logic in detail"
      },
      {
        "title": "Complete static analysis",
        "prompt": "Perform a full static analysis: enumerate functions, identify crypto and network calls, trace cross-references for interesting functions, and decompile the main function. Export findings as structured JSON.",
        "scenario": "Comprehensive binary analysis"
      }
    ],
    "output_examples": [
      {
        "input": "Analyze function main",
        "output": "The main function at 0x10800 calls:\n- 0x9000: init_config (reads config file)\n- 0x8400: network_init (socket, connect)\n- 0x10800: main_loop\n\nThe network_init function at 0x8400:\n- Creates socket(AF_INET, SOCK_STREAM, 0)\n- Connects to 192.168.1.100:8080\n- Sends data using send()\n\nKey strings found: \"config.json\", \"api.example.com\""
      },
      {
        "input": "Find all crypto functions",
        "output": "Crypto imports detected:\n- EVP_EncryptInit at 0x12340 (called by 0x8400, 0x8500)\n- AES_encrypt at 0x12348 (called by 0x8450)\n- SHA256 at 0x12350 (called by 0x8800)\n\nNo hardcoded keys found in analyzed strings."
      }
    ],
    "best_practices": [
      "Start with light analysis (aa; aac) and escalate to deep analysis only for functions of interest to save time on large binaries.",
      "Use the two-stage approach: enumerate and map first, then decompile specific functions rather than the entire binary.",
      "Always document hypotheses and supporting evidence during analysis for later verification."
    ],
    "anti_patterns": [
      "Running full analysis (aaa) on large binaries without timeout settings can hang the analysis session.",
      "Skipping cross-reference analysis and jumping straight to decompilation misses the broader code context.",
      "Assuming decompiled output is exact source code - decompilation is an approximation and may have inaccuracies."
    ],
    "faq": [
      {
        "question": "What tools does this skill use?",
        "answer": "This skill uses radare2 (r2) for disassembly and analysis, with the r2ghidra plugin for decompilation. For large binaries, it can also invoke Ghidra headless mode."
      },
      {
        "question": "Can this skill analyze any binary format?",
        "answer": "It supports common formats including ELF, PE, Mach-O, and raw binaries. Support depends on radare2 capabilities for the specific architecture."
      },
      {
        "question": "How long does analysis take?",
        "answer": "Light analysis takes seconds to minutes depending on binary size. Deep decompilation of specific functions adds minimal overhead. Large binaries may require timeout settings."
      },
      {
        "question": "Is the output accurate?",
        "answer": "Disassembly is accurate for instruction recovery. Decompilation provides a reasonable approximation but may not match original source exactly, especially with optimizations."
      },
      {
        "question": "Can I analyze stripped binaries?",
        "answer": "Yes, radare2 can analyze stripped binaries by focusing on code structure rather than symbols. Function names will be address-based (sub_XXXX) rather than named."
      },
      {
        "question": "What should I analyze first?",
        "answer": "Start with function enumeration and imports to understand the binary's surface. Then identify interesting functions based on imports and strings before deep analysis."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 407
    }
  ]
}
