{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T15:30:24.404Z",
    "slug": "2389-research-binary-re",
    "source_url": "https://github.com/2389-research/claude-plugins/tree/main/binary-re/skills",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "4061fd7006c6646815936b91deb516e840c42ee5f45a87d1cc3ea2b02eef6e9c",
    "tree_hash": "89685b89acb146296e456a6197a6444978a52fed7b106946fc3ded94b903212e"
  },
  "skill": {
    "name": "binary-re",
    "description": "This skill should be used when analyzing binaries, executables, or bytecode to understand what they do or how they work. Triggers on \"binary\", \"executable\", \"ELF\", \"what does this do\", \"reverse engineer\", \"disassemble\", \"decompile\", \"pyc file\", \"python bytecode\", \"analyze binary\", \"figure out\", \"marshal\". Routes to sub-skills for triage, static analysis, dynamic analysis, synthesis, or tool setup.",
    "summary": "Comprehensive binary reverse engineering workflow with guided static and dynamic analysis capabilities",
    "icon": "üîç",
    "version": "1.0.0",
    "author": "2389-research",
    "license": "MIT",
    "category": "security",
    "tags": [
      "reverse-engineering",
      "binary-analysis",
      "security-research",
      "malware-analysis",
      "debugging"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "external_commands",
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill provides guidance for binary reverse engineering using standard security research tools. The static analyzer detected 508 patterns related to tool execution commands (radare2, QEMU, GDB, Docker), but these are false positives in context: they are documentation and setup instructions for legitimate security research tools, not malicious code execution. The skill includes proper human-in-the-loop safeguards requiring approval before binary execution. No actual malicious behavior or data exfiltration detected.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "tool-setup/SKILL.md",
            "line_start": 37,
            "line_end": 60
          },
          {
            "file": "dynamic-analysis/SKILL.md",
            "line_start": 26,
            "line_end": 50
          },
          {
            "file": "static-analysis/SKILL.md",
            "line_start": 25,
            "line_end": 48
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "tool-setup/SKILL.md",
            "line_start": 194,
            "line_end": 217
          },
          {
            "file": "dynamic-analysis/SKILL.md",
            "line_start": 144,
            "line_end": 170
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [
      {
        "title": "Tool Installation Commands Require Elevated Privileges",
        "description": "The skill documentation includes sudo commands for installing reverse engineering tools on Linux systems. These are legitimate installation procedures for standard security research tools and include clear documentation of what is being installed. Users retain control over whether to execute these commands.",
        "locations": [
          {
            "file": "tool-setup/SKILL.md",
            "line_start": 38,
            "line_end": 60
          }
        ]
      },
      {
        "title": "Docker Privileged Mode Used for Emulation Setup",
        "description": "The skill uses Docker privileged mode to register binfmt handlers for multi-architecture emulation on macOS. This is the standard method for enabling QEMU user-mode emulation in Docker and is well-documented in the Docker ecosystem. The command is clearly explained and only runs during one-time setup.",
        "locations": [
          {
            "file": "tool-setup/SKILL.md",
            "line_start": 132,
            "line_end": 134
          },
          {
            "file": "dynamic-analysis/SKILL.md",
            "line_start": 38,
            "line_end": 40
          }
        ]
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 7,
    "total_lines": 7387,
    "audit_model": "claude",
    "audited_at": "2026-01-21T15:30:24.404Z",
    "risk_factors": [
      "external_commands",
      "filesystem"
    ]
  },
  "content": {
    "user_title": "Analyze Unknown Binaries with Guided Reverse Engineering",
    "value_statement": "Binary reverse engineering is complex and requires specialized tools and methodologies. This skill provides Claude Code with step-by-step guidance for analyzing executables across architectures using industry-standard tools like radare2, QEMU, and Ghidra with proper safety protocols.",
    "seo_keywords": [
      "Claude Code",
      "Claude",
      "Codex",
      "reverse engineering",
      "binary analysis",
      "malware analysis",
      "disassembly",
      "decompilation",
      "security research",
      "radare2"
    ],
    "actual_capabilities": [
      "Guide systematic analysis of binary executables across multiple architectures including x86, ARM, MIPS, and RISC-V",
      "Provide structured workflows for triage, static analysis, dynamic analysis, and reporting phases",
      "Generate commands for using reverse engineering tools like radare2, Ghidra, QEMU, GDB, and Frida",
      "Detect architecture, ABI, dependencies, and capabilities from binary metadata",
      "Create cross-architecture emulation setups using QEMU and Docker for safe execution",
      "Extract functions, strings, cross-references, and decompiled pseudocode from binaries"
    ],
    "limitations": [
      "Does not include the actual reverse engineering tools; users must install radare2, QEMU, Ghidra separately",
      "Requires human approval before executing any binaries for safety",
      "Cross-architecture dynamic analysis requires proper sysroot and toolchain setup",
      "Effectiveness depends on binary characteristics such as obfuscation, stripping, and packing"
    ],
    "use_cases": [
      {
        "title": "Analyze Suspicious Firmware Binary",
        "description": "Security researchers can use this skill to systematically analyze unknown firmware extracted from IoT devices, identifying backdoors, hardcoded credentials, or vulnerabilities through guided static and dynamic analysis.",
        "target_user": "Security Researcher"
      },
      {
        "title": "Debug Cross-Platform Embedded Software",
        "description": "Embedded developers can analyze compiled ARM or MIPS binaries to understand behavior, identify bugs, or verify correct compilation when source code is unavailable or when debugging stripped production builds.",
        "target_user": "Embedded Systems Developer"
      },
      {
        "title": "Understand Legacy Binary Behavior",
        "description": "Software maintainers can reverse engineer undocumented legacy binaries to understand their functionality, extract business logic, or prepare for migration when original source code is lost.",
        "target_user": "Software Maintainer"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Binary Identification",
        "prompt": "I have a binary file called firmware.bin. What architecture is it and what does it do?",
        "scenario": "Starting point for analyzing an unknown binary file"
      },
      {
        "title": "Find Hardcoded Credentials",
        "prompt": "Analyze this binary for hardcoded passwords, API keys, or authentication secrets",
        "scenario": "Security audit focusing on credential exposure"
      },
      {
        "title": "Trace Network Behavior",
        "prompt": "Run this binary in a safe environment and show me what network connections it attempts to make",
        "scenario": "Dynamic analysis of network activity using QEMU and strace"
      },
      {
        "title": "Decompile Specific Function",
        "prompt": "Decompile the function at address 0x8048450 and explain what it does",
        "scenario": "Deep dive into specific function behavior with Ghidra decompilation"
      }
    ],
    "output_examples": [
      {
        "input": "What architecture is this binary?",
        "output": "Analysis Results:\n\nArchitecture: ARM 32-bit (little-endian)\nABI: Linux EABI5 (hard-float)\nInterpreter: /lib/ld-linux-armhf.so.3\nStripped: Yes\n\nThe binary is compiled for ARM v7 processors with hardware floating point. It requires glibc and can be emulated using qemu-arm with the armhf sysroot."
      },
      {
        "input": "Find hardcoded credentials in this binary",
        "output": "Security Findings:\n\nHardcoded Credentials Detected:\n\n1. admin:admin123 at offset 0x4a20\n   Context: Basic authentication string in .rodata section\n   Reference: Used by function authenticate_user at 0x8040\n\n2. API Key: sk_live_abc123xyz at offset 0x5100\n   Context: Plaintext API token in data section\n   Reference: Passed to curl_easy_setopt in network_request function\n\nRecommendation: These credentials should be moved to secure configuration files with proper encryption."
      }
    ],
    "best_practices": [
      "Always verify binary hash against known good samples before analysis to ensure you are analyzing the correct version",
      "Use QEMU user-mode emulation or Docker containers for safe execution rather than running unknown binaries directly on your system",
      "Document all findings with specific evidence including file offsets, function addresses, and tool commands used for verification"
    ],
    "anti_patterns": [
      "Running unknown binaries directly on your host system without sandboxing or emulation can compromise your security",
      "Analyzing binaries without first performing triage wastes time on wrong architecture assumptions or missing dependencies",
      "Skipping human approval gates when executing binaries defeats the safety mechanisms built into this workflow"
    ],
    "faq": [
      {
        "question": "Do I need to install reverse engineering tools separately?",
        "answer": "Yes, this skill provides guidance for using tools but does not include them. You need to install radare2, QEMU, and optionally Ghidra on your system. The skill includes installation instructions for Linux, macOS, and Windows."
      },
      {
        "question": "Is it safe to analyze malware with this skill?",
        "answer": "The skill includes safety protocols using QEMU emulation and Docker containers for isolated execution. However, you should always use a dedicated analysis virtual machine and ensure proper network isolation when analyzing potentially malicious binaries."
      },
      {
        "question": "What architectures are supported?",
        "answer": "The skill supports x86 32-bit and 64-bit, ARM 32-bit and 64-bit, MIPS 32-bit, and RISC-V 32-bit and 64-bit. Support quality depends on QEMU emulation accuracy and availability of proper sysroots."
      },
      {
        "question": "Can this skill analyze Windows PE files?",
        "answer": "The skill is primarily designed for Linux ELF binaries. While radare2 can analyze PE files, the dynamic analysis workflows using QEMU are Linux-focused. For Windows binaries, static analysis will work but dynamic analysis is limited."
      },
      {
        "question": "How does this compare to using IDA Pro or Binary Ninja?",
        "answer": "This skill uses open-source tools like radare2 and Ghidra rather than commercial tools. The workflow is designed for AI-guided analysis where Claude Code executes tool commands. It complements rather than replaces manual analysis in dedicated RE tools."
      },
      {
        "question": "What if the binary is obfuscated or packed?",
        "answer": "The skill includes techniques for identifying packers and obfuscation, but heavily protected binaries may require manual unpacking first. Dynamic analysis with QEMU can sometimes bypass packing by observing runtime behavior after unpacking occurs in memory."
      }
    ]
  },
  "file_structure": [
    {
      "name": "dynamic-analysis",
      "type": "dir",
      "path": "dynamic-analysis",
      "children": [
        {
          "name": "SKILL.md",
          "type": "file",
          "path": "dynamic-analysis/SKILL.md",
          "lines": 564
        }
      ]
    },
    {
      "name": "static-analysis",
      "type": "dir",
      "path": "static-analysis",
      "children": [
        {
          "name": "SKILL.md",
          "type": "file",
          "path": "static-analysis/SKILL.md",
          "lines": 407
        }
      ]
    },
    {
      "name": "synthesis",
      "type": "dir",
      "path": "synthesis",
      "children": [
        {
          "name": "SKILL.md",
          "type": "file",
          "path": "synthesis/SKILL.md",
          "lines": 374
        }
      ]
    },
    {
      "name": "tool-setup",
      "type": "dir",
      "path": "tool-setup",
      "children": [
        {
          "name": "SKILL.md",
          "type": "file",
          "path": "tool-setup/SKILL.md",
          "lines": 486
        }
      ]
    },
    {
      "name": "triage",
      "type": "dir",
      "path": "triage",
      "children": [
        {
          "name": "SKILL.md",
          "type": "file",
          "path": "triage/SKILL.md",
          "lines": 268
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 312
    }
  ]
}
