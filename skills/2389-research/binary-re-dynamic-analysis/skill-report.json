{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T15:32:17.078Z",
    "slug": "2389-research-binary-re-dynamic-analysis",
    "source_url": "https://github.com/2389-research/claude-plugins/tree/main/binary-re/skills/dynamic-analysis",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "ade40608679c066ff4102ff9d4c34d02e3fa07d6d3aa9c268c0d3ecb95f141ca",
    "tree_hash": "886576ed39ca8342a8f974d0b168b2e2badda30109df263ddfb47a167992e6c8"
  },
  "skill": {
    "name": "binary-re-dynamic-analysis",
    "description": "Dynamic binary analysis toolkit for security research and reverse engineering. Enables runtime observation of binaries through QEMU emulation, GDB debugging, Frida hooking, and syscall tracing. Supports cross-architecture analysis with sandbox isolation.",
    "summary": "Execute and analyze binaries at runtime with QEMU, GDB, Frida, and strace",
    "icon": "ðŸ”¬",
    "version": "1.0.0",
    "author": "2389-research",
    "license": "MIT",
    "category": "security",
    "tags": [
      "reverse-engineering",
      "binary-analysis",
      "debugging",
      "dynamic-analysis",
      "security-research"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "external_commands",
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a legitimate security research and reverse engineering skill for authorized binary analysis. All static findings are false positives related to documentation examples showing proper use of analysis tools. The skill requires explicit human approval before executing any binaries and emphasizes sandbox isolation. No malicious patterns detected.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 26,
            "line_end": 41
          },
          {
            "file": "SKILL.md",
            "line_start": 73,
            "line_end": 107
          },
          {
            "file": "SKILL.md",
            "line_start": 136,
            "line_end": 202
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 144,
            "line_end": 144
          },
          {
            "file": "SKILL.md",
            "line_start": 404,
            "line_end": 428
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [
      {
        "title": "Documentation Contains Security Tool Examples",
        "description": "The skill documentation includes examples of using QEMU, GDB, Frida, and strace for binary analysis. These are legitimate security research tools used for authorized reverse engineering. The skill explicitly requires human approval before execution and emphasizes sandbox configuration. All flagged patterns are documentation examples, not executable code.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 1,
            "line_end": 564
          }
        ]
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 1912,
    "audit_model": "claude",
    "audited_at": "2026-01-21T15:32:17.078Z",
    "risk_factors": [
      "external_commands",
      "filesystem"
    ]
  },
  "content": {
    "user_title": "Analyze Binaries with Dynamic Runtime Tracing",
    "value_statement": "Security researchers need to observe actual binary behavior at runtime, not just static code. This skill provides safe, sandboxed execution with QEMU emulation, GDB debugging, and Frida hooking to trace syscalls, inspect memory, and validate reverse engineering hypotheses.",
    "seo_keywords": [
      "Claude Code",
      "Claude",
      "Codex",
      "binary analysis",
      "reverse engineering",
      "QEMU emulation",
      "GDB debugging",
      "Frida hooking",
      "syscall tracing",
      "security research"
    ],
    "actual_capabilities": [
      "Execute binaries cross-architecture using QEMU user-mode emulation with syscall tracing",
      "Attach GDB debugger to running binaries for instruction-level analysis and breakpoints",
      "Hook function calls with Frida to intercept and inspect runtime arguments",
      "Trace syscalls to observe network connections, file access, and process operations",
      "Run binaries in Docker containers with platform emulation for cross-arch analysis on macOS",
      "Configure sandbox environments with resource limits and network isolation"
    ],
    "limitations": [
      "Requires explicit human approval before executing any binary for safety",
      "Frida cannot attach to QEMU user-mode targets, requires native architecture or on-device deployment",
      "Some syscalls may be unsupported in QEMU emulation requiring on-device analysis",
      "Anti-analysis techniques in binaries may require additional bypass strategies"
    ],
    "use_cases": [
      {
        "title": "Malware Analysis in Sandbox",
        "description": "Security analysts can safely execute suspicious binaries in isolated QEMU environments to observe network behavior, file modifications, and syscall patterns without risking the host system.",
        "target_user": "Security researchers and malware analysts"
      },
      {
        "title": "Cross-Architecture Firmware Debugging",
        "description": "Embedded systems developers can debug ARM or MIPS binaries on x86 development machines using QEMU emulation with GDB, eliminating the need for physical hardware during analysis.",
        "target_user": "Firmware engineers and IoT developers"
      },
      {
        "title": "Reverse Engineering Protected Binaries",
        "description": "Penetration testers can use Frida hooks to intercept cryptographic functions, authentication checks, and network protocols in compiled applications to understand their behavior and find vulnerabilities.",
        "target_user": "Penetration testers and security auditors"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Syscall Trace",
        "prompt": "Use QEMU to run this ARM binary and trace all syscalls to identify what network connections it makes",
        "scenario": "Initial behavior mapping of an unknown binary"
      },
      {
        "title": "Debug with Breakpoints",
        "prompt": "Start this binary under QEMU with GDB attached, set a breakpoint at address 0x8400, and show me the register state when it hits",
        "scenario": "Investigating specific code behavior at known address"
      },
      {
        "title": "Hook Network Functions",
        "prompt": "Create a Frida script to intercept all connect() calls in this binary and log the IP addresses and ports it tries to reach",
        "scenario": "Analyzing network communication patterns"
      },
      {
        "title": "Cross-Platform Container Execution",
        "prompt": "Run this ARM32 binary in a Docker container on macOS with platform emulation and capture all library loading events using LD_DEBUG",
        "scenario": "Advanced cross-architecture analysis with dependency tracing"
      }
    ],
    "output_examples": [
      {
        "input": "Run this binary with QEMU strace and tell me what files it accesses",
        "output": "Executed binary using QEMU user-mode emulation with syscall tracing. Observed file access patterns:\n- Read: /etc/config.json (configuration data)\n- Write: /var/log/app.log (logging output)\n- Read: /usr/lib/libssl.so (SSL library dependency)\nNo network syscalls detected. Binary appears to be a local configuration processor."
      },
      {
        "input": "Use Frida to hook the authenticate() function and show me what password it checks",
        "output": "Attached Frida to running binary and intercepted authenticate() function at offset 0x2a40. Captured argument at call time: password buffer contains \"admin123\". Function returns 1 (success) when this value matches, 0 otherwise. This appears to be a hardcoded authentication check."
      },
      {
        "input": "Debug this binary with GDB and examine memory at the stack pointer when main() starts",
        "output": "Started binary under QEMU with GDB server on port 1234. Set breakpoint at main() symbol. Execution paused at 0x000084c0. Stack pointer (sp) is at 0xbefff7a0. Memory dump shows:\n0xbefff7a0: argc=2\n0xbefff7a4: argv pointer\n0xbefff7a8: environment variables\nStack is properly aligned for ARM ABI."
      }
    ],
    "best_practices": [
      "Always get explicit human approval before executing any binary and document the sandbox configuration being used",
      "Start with QEMU syscall tracing before deeper analysis to understand high-level behavior safely",
      "Use network isolation in sandbox environments when analyzing binaries with unknown network behavior"
    ],
    "anti_patterns": [
      "Running unknown binaries without sandbox isolation or on production systems",
      "Attempting to use Frida with QEMU user-mode emulation (architecture mismatch will fail)",
      "Using /tmp directory paths for Docker volume mounts on Colima (fails silently, use home directory instead)"
    ],
    "faq": [
      {
        "question": "Can this skill execute Windows PE binaries?",
        "answer": "This skill focuses on Linux ELF binaries. For Windows PE analysis, you would need Wine or a Windows VM rather than QEMU user-mode emulation."
      },
      {
        "question": "Is it safe to run malware with this skill?",
        "answer": "The skill emphasizes sandbox isolation using QEMU, Docker, or nsjail. However, you must configure appropriate network isolation and get human approval before executing any suspicious binary."
      },
      {
        "question": "Why does Frida not work with QEMU emulated binaries?",
        "answer": "Frida requires native architecture execution to inject its agent. QEMU user-mode creates a different process space that Frida cannot attach to. Use on-device frida-server for cross-arch targets."
      },
      {
        "question": "What sandbox configuration should I use for unknown binaries?",
        "answer": "Start with QEMU user-mode which provides high isolation. Add network blocking, resource limits, and run as unprivileged user. Document your configuration and get approval before execution."
      },
      {
        "question": "Can I debug ARM binaries on an x86 machine?",
        "answer": "Yes, QEMU user-mode emulation allows running ARM binaries on x86 hosts. You can attach gdb-multiarch for debugging. On macOS, use Docker with platform emulation."
      },
      {
        "question": "How do I handle anti-debugging techniques in binaries?",
        "answer": "QEMU user-mode bypasses many anti-debug checks like ptrace detection and /proc inspection. For timing checks, use GDB or patch the detection code. The skill provides mitigation strategies in the documentation."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 564
    }
  ]
}
