{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T15:54:29.805Z",
    "slug": "2389-research-scenario-testing",
    "source_url": "https://github.com/2389-research/claude-plugins/tree/main/scenario-testing/skills",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "34e5e44b31de86d7f4a4e7d1f305fb78ba9850d8317016cc2f2aacfdf499cd4a",
    "tree_hash": "0222ef252be442317449c61be4e0428d468ff7403abf36ee07c791b88437a1d3"
  },
  "skill": {
    "name": "scenario-testing",
    "description": "This skill should be used when writing tests, validating features, or needing to verify code works. Triggers on \"write tests\", \"add test coverage\", \"validate feature\", \"integration test\", \"end-to-end\", \"e2e test\", \"mock\", \"unit test\". Enforces scenario-driven testing with real dependencies in .scratch/ directory.",
    "summary": "Enforces scenario-driven testing with real dependencies to validate code actually works.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "2389-research",
    "license": "MIT",
    "tags": [
      "testing",
      "validation",
      "integration-testing",
      "e2e-testing",
      "scenario-driven"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings are false positives. Scanner misidentified JSON structure as C2 keywords, YAML frontmatter as cryptographic code, markdown formatting as shell execution, and testing methodology text as system reconnaissance. This is legitimate scenario-driven testing documentation with no security concerns.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 391,
    "audit_model": "claude",
    "audited_at": "2026-01-21T15:54:29.805Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Validate Code with Scenario Testing",
    "value_statement": "Tests using mocks create false confidence. This skill enforces scenario-driven testing with real dependencies to prove code works in production-like conditions.",
    "seo_keywords": [
      "scenario testing",
      "integration testing",
      "end-to-end testing",
      "test validation",
      "real dependencies",
      "mock-free testing",
      "feature validation",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Triggers on test-related prompts to enforce scenario-driven testing methodology",
      "Validates features by running scenarios with real dependencies in .scratch/",
      "Promotes reusable testing patterns to scenarios.jsonl specifications",
      "Ensures zero mocks in test scenarios for authentic validation",
      "Validates scenarios run independently without ordering dependencies"
    ],
    "limitations": [
      "Does not generate test code automatically",
      "Does not mock external dependencies - requires real access",
      "Does not run scenarios automatically - requires manual execution",
      "Does not integrate with specific test frameworks directly"
    ],
    "use_cases": [
      {
        "title": "Validate New Features",
        "description": "Before declaring a feature complete, create a scenario in .scratch/ that exercises the real system end-to-end to prove it works.",
        "target_user": "Developers implementing new features who need to validate their work"
      },
      {
        "title": "Replace Mock-Based Testing",
        "description": "When tempted to use mocks for speed, switch to scenario testing with real dependencies to get accurate validation.",
        "target_user": "QA engineers and developers who want more reliable test coverage"
      },
      {
        "title": "Document Reusable Test Patterns",
        "description": "Extract successful scenarios into scenarios.jsonl to create a living specification of validated system behaviors.",
        "target_user": "Teams building maintainable test suites and documentation"
      }
    ],
    "prompt_templates": [
      {
        "title": "Validate a Feature",
        "prompt": "Use the scenario-testing skill to validate this feature. Create a scenario in .scratch/ that exercises the real system with zero mocks. The scenario must pass before the feature is considered complete.",
        "scenario": "When you need to prove a feature actually works"
      },
      {
        "title": "Replace Unit Tests",
        "prompt": "Instead of writing unit tests with mocks, create scenario tests in .scratch/ that use real dependencies. Follow the scenario-testing methodology.",
        "scenario": "When tempted to write mock-based unit tests"
      },
      {
        "title": "Document a Testing Pattern",
        "prompt": "Extract this successful scenario into scenarios.jsonl. Include name, description, given/when/then structure, and what it validates.",
        "scenario": "When you have a working scenario to standardize"
      },
      {
        "title": "Verify CI/CD Readiness",
        "prompt": "Review that all scenarios in .scratch/ run independently without ordering dependencies. Confirm each scenario can execute in parallel for CI/CD.",
        "scenario": "When preparing tests for continuous integration"
      }
    ],
    "output_examples": [
      {
        "input": "Validate the user registration feature",
        "output": [
          "Creating scenario in .scratch/test-user-registration.py",
          "Using real database and auth service (test mode)",
          "Running scenario to verify it passes",
          "Extracting pattern to scenarios.jsonl"
        ]
      },
      {
        "input": "Write tests for the payment processing",
        "scenario": "Converting mock-based tests to scenario testing",
        "output": [
          "Instead of mocking the payment API, creating scenario that hits sandbox endpoint",
          "Scenario exercises real payment flow end-to-end",
          "No mocks - real dependencies validate actual behavior"
        ]
      }
    ],
    "best_practices": [
      "Always use real dependencies in .scratch/ scenarios - mocks hide bugs",
      "Keep .scratch/ in .gitignore - scratch scenarios are for validation only",
      "Extract successful patterns to scenarios.jsonl for future reference",
      "Ensure each scenario runs independently for reliable CI/CD integration"
    ],
    "anti_patterns": [
      "Using mocks to speed up tests - speed does not matter if tests lie",
      "Skipping validation because a unit test passes - unit tests do not validate features",
      "Committing .scratch/ scenarios - keep scratch work private and ignored",
      "Assuming API credentials are unavailable - ask for real test credentials"
    ],
    "faq": [
      {
        "question": "What is scenario-driven testing?",
        "answer": "Scenario-driven testing validates code by running real scenarios with actual dependencies. It proves code works in production-like conditions rather than in isolated unit tests with mocks."
      },
      {
        "question": "Why are mocks considered harmful?",
        "answer": "Mocks test your assumptions about how dependencies behave, not how they actually behave. Only scenarios with real dependencies validate that your code integrates correctly with real systems."
      },
      {
        "question": "What goes in .scratch/?",
        "answer": "Temporary test scenarios that exercise your feature with real dependencies. These should never be committed and must remain in .gitignore."
      },
      {
        "question": "What is scenarios.jsonl?",
        "answer": "A committed file containing extracted testing patterns as JSON lines. Each line documents a validated scenario with its name, description, given/when/then structure, and what it validates."
      },
      {
        "question": "Can I use test/sandbox modes for APIs?",
        "answer": "Yes. Using sandbox or test modes for external APIs is acceptable as long as you are hitting the real service, not mocking its responses."
      },
      {
        "question": "How does scenario testing differ from integration testing?",
        "answer": "Scenario testing focuses on user-facing workflows that exercise multiple systems together. Integration testing focuses on component interactions. Both use real dependencies, but scenarios prioritize end-to-end user value."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 98
    }
  ]
}
