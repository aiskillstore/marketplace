{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T19:48:30.600Z",
    "slug": "dyai2025-root-cause-tracing",
    "source_url": "https://github.com/DYAI2025/Stoppclock-page/tree/main/stoppclock_speckit/.claude/commands/skills/root-cause-tracing",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "287daace001bad319d7b87c0cff917769988b7ea03db685c897479bc347b1c91",
    "tree_hash": "36deefd34ba29ee8cb0de5d6981866c7ff88d290e369555f8906defeba7d2034"
  },
  "skill": {
    "name": "root-cause-tracing",
    "description": "Use when errors occur deep in execution and you need to trace back to find the original trigger - systematically traces bugs backward through call stack, adding instrumentation when needed, to identify source of invalid data or incorrect behavior",
    "summary": "Trace bugs backward through call stacks to find original triggers, then fix at the source instead of treating symptoms",
    "icon": "üîç",
    "version": "1.0.0",
    "author": "DYAI2025",
    "license": "MIT",
    "tags": [
      "debugging",
      "troubleshooting",
      "root-cause-analysis",
      "testing",
      "software-engineering"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "external_commands",
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "The skill is legitimate debugging methodology documentation. Static findings are false positives triggered by example shell commands in documentation (npm test, grep) and a bisection script for test pollution detection. SHA256 hash strings in the report were misidentified as cryptographic vulnerabilities or C2 keywords. No malicious intent or actual security risks present.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "find-polluter.sh",
            "line_start": 22,
            "line_end": 22
          },
          {
            "file": "find-polluter.sh",
            "line_start": 23,
            "line_end": 23
          },
          {
            "file": "find-polluter.sh",
            "line_start": 30,
            "line_end": 30
          },
          {
            "file": "find-polluter.sh",
            "line_start": 1,
            "line_end": 1
          },
          {
            "file": "SKILL.md",
            "line_start": 16,
            "line_end": 29
          },
          {
            "file": "SKILL.md",
            "line_start": 29,
            "line_end": 40
          },
          {
            "file": "SKILL.md",
            "line_start": 40,
            "line_end": 42
          },
          {
            "file": "SKILL.md",
            "line_start": 42,
            "line_end": 46
          },
          {
            "file": "SKILL.md",
            "line_start": 46,
            "line_end": 48
          },
          {
            "file": "SKILL.md",
            "line_start": 48,
            "line_end": 51
          },
          {
            "file": "SKILL.md",
            "line_start": 51,
            "line_end": 56
          },
          {
            "file": "SKILL.md",
            "line_start": 56,
            "line_end": 60
          },
          {
            "file": "SKILL.md",
            "line_start": 60,
            "line_end": 61
          },
          {
            "file": "SKILL.md",
            "line_start": 61,
            "line_end": 61
          },
          {
            "file": "SKILL.md",
            "line_start": 61,
            "line_end": 66
          },
          {
            "file": "SKILL.md",
            "line_start": 66,
            "line_end": 69
          },
          {
            "file": "SKILL.md",
            "line_start": 69,
            "line_end": 75
          },
          {
            "file": "SKILL.md",
            "line_start": 75,
            "line_end": 88
          },
          {
            "file": "SKILL.md",
            "line_start": 88,
            "line_end": 90
          },
          {
            "file": "SKILL.md",
            "line_start": 90,
            "line_end": 93
          },
          {
            "file": "SKILL.md",
            "line_start": 93,
            "line_end": 95
          },
          {
            "file": "SKILL.md",
            "line_start": 95,
            "line_end": 108
          },
          {
            "file": "SKILL.md",
            "line_start": 108,
            "line_end": 110
          },
          {
            "file": "SKILL.md",
            "line_start": 110,
            "line_end": 116
          },
          {
            "file": "SKILL.md",
            "line_start": 116,
            "line_end": 116
          },
          {
            "file": "SKILL.md",
            "line_start": 116,
            "line_end": 119
          },
          {
            "file": "SKILL.md",
            "line_start": 119,
            "line_end": 119
          },
          {
            "file": "SKILL.md",
            "line_start": 119,
            "line_end": 122
          },
          {
            "file": "SKILL.md",
            "line_start": 122,
            "line_end": 123
          },
          {
            "file": "SKILL.md",
            "line_start": 123,
            "line_end": 137
          },
          {
            "file": "SKILL.md",
            "line_start": 137,
            "line_end": 157
          },
          {
            "file": "SKILL.md",
            "line_start": 157,
            "line_end": 163
          },
          {
            "file": "SKILL.md",
            "line_start": 163,
            "line_end": 166
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "find-polluter.sh",
            "line_start": 42,
            "line_end": 42
          },
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 3,
    "total_lines": 919,
    "audit_model": "claude",
    "audited_at": "2026-01-21T19:48:30.600Z",
    "risk_factors": [
      "external_commands",
      "filesystem"
    ]
  },
  "content": {
    "user_title": "Trace bugs to their source",
    "value_statement": "Debugging often treats symptoms instead of finding root causes. This skill teaches systematic backward tracing through call stacks to identify the original trigger of errors, preventing recurring bugs.",
    "seo_keywords": [
      "root cause analysis",
      "debugging techniques",
      "bug tracing",
      "troubleshooting",
      "software debugging",
      "error debugging",
      "Claude",
      "Codex",
      "Claude Code",
      "stack trace analysis"
    ],
    "actual_capabilities": [
      "Trace error origins backward through call chains to find original triggers",
      "Identify where invalid data enters the system versus where symptoms appear",
      "Add stack trace instrumentation to code when manual tracing is insufficient",
      "Use bisection scripts to isolate which test is polluting test state",
      "Apply defense-in-depth validation at multiple layers to prevent recurrence",
      "Distinguish between symptom-level fixes and true root cause corrections"
    ],
    "limitations": [
      "Requires access to source code and ability to add instrumentation",
      "Cannot automatically trace through third-party libraries without source",
      "Effectiveness depends on code readability and available stack traces",
      "Does not prevent bugs in legacy code with high coupling"
    ],
    "use_cases": [
      {
        "title": "Debug complex test failures",
        "description": "When a test fails deep in the call stack and the immediate error message does not reveal the source, trace backward through the chain to find which test setup or fixture introduced the problematic state.",
        "target_user": "QA engineers and test developers"
      },
      {
        "title": "Fix recurring production bugs",
        "description": "When the same bug keeps reappearing after fixes, use root cause tracing to find the original trigger point and implement proper validation at the source rather than patching symptoms.",
        "target_user": "Software engineers and SREs"
      },
      {
        "title": "Identify test pollution sources",
        "description": "When tests create unwanted files or state (like .git directories in wrong locations) but you cannot determine which test is responsible, use the bisection technique to isolate the polluter.",
        "target_user": "Development teams with large test suites"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic error trace",
        "prompt": "I'm getting an error: [error message]. The stack trace shows [stack trace]. Trace backward through the call chain to find the original trigger. What called the immediate cause and what value was passed that led to this error?",
        "scenario": "When you have a clear error with a stack trace and want systematic backward analysis"
      },
      {
        "title": "Debug with instrumentation",
        "prompt": "I need to trace where [problematic behavior] is originating. Add stack trace logging before the operation that fails. The function that directly causes the issue is [function name]. Help me construct the instrumentation and analyze the output.",
        "scenario": "When manual tracing is difficult and you need to add debugging code"
      },
      {
        "title": "Find test polluter",
        "prompt": "Something is creating [unwanted file or state] during tests but I do not know which test. The test pattern is [pattern like 'src/**/*.test.ts']. Guide me through using the bisection technique to identify the specific test responsible.",
        "scenario": "When test state pollution needs to be isolated to a specific test file"
      },
      {
        "title": "Apply defense in depth",
        "prompt": "I found the root cause of [bug]: [description of root cause]. Help me design validation at multiple layers to make this bug impossible to reintroduce. Include checks at the entry point, intermediate layers, and the operation itself.",
        "scenario": "When you have identified the root cause and want to prevent recurrence"
      }
    ],
    "output_examples": [
      {
        "input": "Error: git init failed in /Users/project/packages/core",
        "output": [
          "**Tracing backward from the symptom:**",
          "1. `git init` runs with empty `cwd` ‚Üí resolves to `process.cwd()`",
          "2. `WorktreeManager.createSessionWorktree()` called with empty projectDir",
          "3. `Session.create()` passed empty string from test setup",
          "4. Test accessed `context.tempDir` before `beforeEach` ran",
          "",
          "**Root cause:** Top-level variable initialization accessing empty value",
          "",
          "**Recommended fix:** Make tempDir a getter that throws if accessed before beforeEach",
          "",
          "**Defense-in-depth layers:**",
          "- Layer 1: Project.create() validates directory is not empty",
          "- Layer 2: WorkspaceManager validates path exists",
          "- Layer 3: NODE_ENV guard refuses git operations outside tmpdir",
          "- Layer 4: Stack trace logging before git operations"
        ]
      },
      {
        "input": "Tests are creating .git directories in the source folder during CI",
        "output": [
          "**Using bisection to find the polluter:**",
          "",
          "Run the find-polluter.sh script:",
          "```bash",
          "./find-polluter.sh '.git' 'src/**/*.test.ts'",
          "```",
          "",
          "**What the script does:**",
          "- Runs tests one by one in sorted order",
          "- Checks if .git appears after each test",
          "- Stops at first test that creates the pollution",
          "",
          "**If pollution exists before any test:**",
          "Run `rm -rf .git` before bisection to establish clean state",
          "",
          "**After identifying the test:**",
          "- Run just that test: `npm test path/to/test.ts`",
          "- Review the test setup for tempDir or directory handling",
          "- Look for calls to git operations with dynamic paths"
        ]
      }
    ],
    "best_practices": [
      "Always trace backward through the complete call chain before making any fix. Fixing where the error appears treats a symptom, not the cause.",
      "Add stack trace logging before the problematic operation, not after it fails. Capture the directory, cwd, and relevant parameters.",
      "When you find the root cause, implement validation at multiple layers. Each layer makes the bug harder to reintroduce accidentally."
    ],
    "anti_patterns": [
      "Fixing the error at the point where it manifests rather than tracing back to find where invalid data or state originated.",
      "Only adding a check at the immediate cause without validating at earlier entry points where the bug could bypass the check.",
      "Using a logger that may be suppressed in test environments instead of console.error for critical debugging output."
    ],
    "faq": [
      {
        "question": "When should I use root cause tracing instead of normal debugging?",
        "answer": "Use root cause tracing when errors appear deep in a long call chain, when the same bug keeps recurring after fixes, or when the error message does not clearly indicate what went wrong. If the fix would only prevent the symptom from appearing without addressing why invalid data reached that point, you need tracing."
      },
      {
        "question": "How do I trace through code I did not write?",
        "answer": "Add instrumentation before the problematic operation that logs the stack trace, directory, and parameters. This shows where in external code the call originated. Then trace forward from that entry point using the logged parameters to understand the data flow."
      },
      {
        "question": "What is test pollution and why does it matter?",
        "answer": "Test pollution occurs when one test leaves state (files, directories, database records) that affects other tests. This causes intermittent failures and makes debugging difficult. The bisection technique finds which specific test creates the pollution."
      },
      {
        "question": "How do I know when I have found the true root cause?",
        "answer": "You have found the root cause when: the fix at that point prevents the bug from occurring, the fix does not require changes at multiple downstream points, and the bug cannot bypass the fix by reaching the same problematic operation through a different path."
      },
      {
        "question": "What is defense in depth for bug fixing?",
        "answer": "Defense in depth means adding validation at multiple layers between the entry point and the operation that fails. If one layer is bypassed, another catches the problem. This makes bugs impossible to reintroduce accidentally through future code changes."
      },
      {
        "question": "How do I use the find-polluter.sh script?",
        "answer": "Run `./find-polluter.sh <file_or_dir_to_check> <test_pattern>`. For example: `./find-polluter.sh '.git' 'src/**/*.test.ts'`. The script runs tests one by one and stops at the first test that creates the specified file or directory. Remove any existing pollution first with `rm -rf .git`."
      }
    ]
  },
  "file_structure": [
    {
      "name": "find-polluter.sh",
      "type": "file",
      "path": "find-polluter.sh",
      "lines": 64
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 175
    },
    {
      "name": "SKILL.zip",
      "type": "file",
      "path": "SKILL.zip"
    }
  ]
}
