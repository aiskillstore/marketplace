{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-17T05:40:16.140Z",
    "slug": "dyai2025-dispatching-parallel-agents",
    "source_url": "https://github.com/DYAI2025/Stoppclock-page/tree/main/stoppclock_speckit/.claude/commands/skills/dispatching-parallel-agents",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "9be7af768b55f8e54c0bc863544168f4798fb204c80123712c954cf292245341",
    "tree_hash": "28681368bac396fb441c0579a37a9dbd9d066df0645bd6beb52d412ecd85c287"
  },
  "skill": {
    "name": "dispatching-parallel-agents",
    "description": "Use when facing 3+ independent failures that can be investigated without shared state or dependencies - dispatches multiple Claude agents to investigate and fix independent problems concurrently",
    "summary": "Use when facing 3+ independent failures that can be investigated without shared state or dependencie...",
    "icon": "⚡",
    "version": "1.0.0",
    "author": "DYAI2025",
    "license": "UNLICENSED",
    "category": "coding",
    "tags": [
      "debugging",
      "testing",
      "multi-agent",
      "parallel",
      "workflow"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing only markdown methodology content. No executable code, no file system access, no network calls, no command execution. The static scanner flagged JSON metadata fields, markdown code block fences, and documentation patterns as false positives. All 18 findings are dismissed.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 16,
            "line_end": 32
          },
          {
            "file": "SKILL.md",
            "line_start": 32,
            "line_end": 66
          },
          {
            "file": "SKILL.md",
            "line_start": 66,
            "line_end": 72
          },
          {
            "file": "SKILL.md",
            "line_start": 72,
            "line_end": 89
          },
          {
            "file": "SKILL.md",
            "line_start": 89,
            "line_end": 108
          },
          {
            "file": "SKILL.md",
            "line_start": 108,
            "line_end": 143
          },
          {
            "file": "SKILL.md",
            "line_start": 143,
            "line_end": 147
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 363,
    "audit_model": "claude",
    "audited_at": "2026-01-17T05:40:16.140Z"
  },
  "content": {
    "user_title": "Dispatch multiple agents to fix independent failures",
    "value_statement": "Multiple test failures waste time when investigated one by one. This skill provides a pattern for dispatching multiple Claude agents to investigate and fix independent problems concurrently, reducing debugging time.",
    "seo_keywords": [
      "parallel debugging",
      "multi-agent dispatch",
      "Claude Code debugging",
      "concurrent investigation",
      "test failure fix",
      "agent workflow",
      "parallel agents",
      "debugging automation",
      "multiple failures",
      "agent task dispatch"
    ],
    "actual_capabilities": [
      "Identify independent problem domains from multiple failures",
      "Create focused agent tasks with clear scope and goals",
      "Dispatch multiple agents to work in parallel",
      "Review and integrate independent agent results",
      "Apply constraints to prevent agent interference"
    ],
    "limitations": [
      "Requires failures to be independent with no shared state",
      "Does not apply to related failures that might affect each other",
      "Cannot be used when full system context is required",
      "Exploratory debugging without known failures is not supported"
    ],
    "use_cases": [
      {
        "target_user": "QA Engineers",
        "title": "Parallel Test Fixes",
        "description": "Fix multiple failing test files simultaneously when each has a different root cause"
      },
      {
        "target_user": "DevOps Teams",
        "title": "Multi-Service Debugging",
        "description": "Investigate failures across independent microservices at the same time"
      },
      {
        "target_user": "Software Developers",
        "title": "Concurrent Bug Resolution",
        "description": "Dispatch agents to fix different bugs in separate subsystems concurrently"
      }
    ],
    "prompt_templates": [
      {
        "title": "Fix Test Failures",
        "scenario": "Multiple independent test files failing",
        "prompt": "Fix the failing tests in [test-file-1], [test-file-2], and [test-file-3]. Each file has a different root cause: [describe each issue]. Create three separate agent tasks to investigate and fix each problem independently."
      },
      {
        "title": "Debug Subsystems",
        "scenario": "Different subsystems failing independently",
        "prompt": "Investigate failures in [subsystem-A], [subsystem-B], and [subsystem-C]. These systems are independent with no shared state. Dispatch one agent per subsystem to identify and fix the issues."
      },
      {
        "title": "Resolve Edge Cases",
        "scenario": "Multiple edge cases failing in isolation",
        "prompt": "Fix these edge case failures: [list each failure with its component]. Each edge case is isolated. Dispatch separate agents for each independent issue."
      },
      {
        "title": "Integrate Fixes",
        "scenario": "Agents completed independent investigations",
        "prompt": "Three agents have completed fixes for [issue-1], [issue-2], and [issue-3]. Review each summary, check for conflicts, run the full test suite, and integrate all changes."
      }
    ],
    "output_examples": [
      {
        "input": "I have 5 failing tests across 3 different test files with unrelated root causes. Can you help fix them all?",
        "output": [
          "Analysis: 3 independent problem domains identified",
          "Agent 1 → Fixed timing issues in file A (3 tests)",
          "Agent 2 → Fixed event structure bug in file B (1 test)",
          "Agent 3 → Fixed async completion in file C (1 test)",
          "Integration: All fixes verified, full suite passing"
        ]
      },
      {
        "input": "Three microservices are failing independently. Service A has auth issues, Service B has database timeouts, and Service C has caching problems.",
        "output": [
          "Domain analysis: 3 independent issues confirmed",
          "Agent 1 → Service A auth configuration fixed",
          "Agent 2 → Service B database connection pool adjusted",
          "Agent 3 → Service C cache invalidation logic updated",
          "All services healthy after integrated fix verification"
        ]
      }
    ],
    "best_practices": [
      "Identify independent problem domains before dispatching agents",
      "Provide each agent with specific scope, clear goals, and expected output format",
      "Set constraints to prevent agents from interfering with each other"
    ],
    "anti_patterns": [
      "Dispatching agents without verifying failures are truly independent",
      "Creating overly broad agent tasks like fix all the tests",
      "Failing to provide enough context for each agent to understand its problem"
    ],
    "faq": [
      {
        "question": "What makes failures independent enough for parallel dispatch?",
        "answer": "Failures are independent when fixing one does not affect the others, they require no shared context, and agents can work on them without editing the same files or resources."
      },
      {
        "question": "How many agents should I dispatch at once?",
        "answer": "Dispatch one agent per problem domain. If you have 3 independent issues across different files or subsystems, dispatch 3 agents working in parallel."
      },
      {
        "question": "Can this skill integrate with my existing CI/CD pipeline?",
        "answer": "Yes. After agents complete their investigations, you can run your full test suite in CI to verify all fixes integrate correctly before merging."
      },
      {
        "question": "Is my codebase data safe during parallel agent execution?",
        "answer": "Yes. The skill only dispatches agents to investigate. All code changes happen in your local environment with your full control and review before acceptance."
      },
      {
        "question": "What if agents return conflicting changes?",
        "answer": "Review each agent summary before integrating. Check which files each agent modified. If conflicts exist, resolve them manually or dispatch a coordinating agent."
      },
      {
        "question": "How is this different from running tasks sequentially?",
        "answer": "Sequential investigation waits for each task to complete before starting the next. Parallel dispatch starts all independent investigations simultaneously, reducing total debugging time significantly."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 181
    },
    {
      "name": "SKILL.zip",
      "type": "file",
      "path": "SKILL.zip"
    }
  ]
}
