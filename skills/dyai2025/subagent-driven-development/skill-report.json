{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T19:54:57.208Z",
    "slug": "dyai2025-subagent-driven-development",
    "source_url": "https://github.com/DYAI2025/Stoppclock-page/tree/main/stoppclock_speckit/.claude/commands/skills/subagent-driven-development",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "ceb49771637624dc97d78263cdd64c3b1a1839f540f561dc4d3aa388fb33f22f",
    "tree_hash": "5b7b1010b1af35f48089fa7e70a5f854605279654283cf8905166f654d57d96d"
  },
  "skill": {
    "name": "subagent-driven-development",
    "description": "Use when executing implementation plans with independent tasks in the current session - dispatches fresh subagent for each task with code review between tasks, enabling fast iteration with quality gates",
    "summary": "Execute implementation plans by dispatching fresh subagents per task with automated code review checkpoints",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "DYAI2025",
    "license": "MIT",
    "category": "productivity",
    "tags": [
      "workflow",
      "subagents",
      "code-review",
      "task-automation",
      "quality-gates"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill is purely instructional content that documents a workflow methodology for using Claude Code's Task tool system. All 19 static findings are false positives - the detected patterns are either markdown formatting, documentation metadata, or the word 'task' incorrectly flagged as cryptographic references. The skill contains no executable code, network operations, or file system access beyond standard Claude Code functionality.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 469,
    "audit_model": "claude",
    "audited_at": "2026-01-21T19:54:57.208Z"
  },
  "content": {
    "user_title": "Execute Plans with Automated Subagent Quality Gates",
    "value_statement": "Managing complex implementation plans often leads to context pollution and quality issues when working in a single session. This skill provides a structured workflow that dispatches fresh subagents for each independent task with automated code review checkpoints, enabling fast iteration while maintaining quality standards.",
    "seo_keywords": [
      "Claude Code",
      "Claude",
      "Codex",
      "subagent workflow",
      "task automation",
      "code review automation",
      "quality gates",
      "implementation plans",
      "TDD workflow",
      "development methodology"
    ],
    "actual_capabilities": [
      "Provides structured workflow for executing implementation plans using Claude Code Task tool with fresh subagents per task",
      "Integrates automated code review checkpoints after each task completion using the code-reviewer subagent",
      "Implements quality gates with issue severity classification and mandatory fixes before proceeding to next task",
      "Coordinates with writing-plans, requesting-code-review, and finishing-a-development-branch skills for complete development lifecycle",
      "Supports test-driven development by ensuring subagents follow TDD methodology for each task implementation"
    ],
    "limitations": [
      "Requires tasks to be mostly independent - tightly coupled tasks may need manual execution instead",
      "Higher cost due to multiple subagent invocations compared to single-session manual execution",
      "Not suitable when plan needs revision or extensive brainstorming before execution",
      "Requires existing implementation plan created by writing-plans skill or equivalent planning process"
    ],
    "use_cases": [
      {
        "title": "Multi-Feature Implementation",
        "description": "Execute a plan with 5-10 independent features where each needs implementation, testing, and review before moving to the next.",
        "target_user": "Software developers implementing complex feature sets"
      },
      {
        "title": "Refactoring with Quality Gates",
        "description": "Break down large refactoring into independent tasks with automated review ensuring no regressions after each step.",
        "target_user": "Engineering teams maintaining code quality during refactors"
      },
      {
        "title": "TDD Sprint Execution",
        "description": "Execute test-driven development plan where each task requires writing tests first, then implementation, with reviews validating test coverage.",
        "target_user": "Teams practicing test-driven development methodology"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Plan Execution",
        "prompt": "Use subagent-driven-development to execute the plan in plan.md",
        "scenario": "You have a plan file ready and want to execute it with automated quality gates"
      },
      {
        "title": "Execute with Custom Review Focus",
        "prompt": "Execute plan.md using subagent-driven-development, with code reviews focusing on security and performance",
        "scenario": "You need execution with specific review criteria beyond standard quality checks"
      },
      {
        "title": "Resume Interrupted Execution",
        "prompt": "Resume subagent-driven-development from Task 3 in implementation-plan.md, previous tasks are complete",
        "scenario": "Continuing work after interruption, need to pick up where you left off"
      },
      {
        "title": "Execute Plan with Parallel-Safe Tasks",
        "prompt": "Execute feature-plan.md using subagent-driven-development, tasks are independent database migrations",
        "scenario": "Advanced use case where task independence needs to be emphasized for safe execution"
      }
    ],
    "output_examples": [
      {
        "input": "Use subagent-driven-development to execute refactor-plan.md",
        "output": "I will execute this plan using Subagent-Driven Development workflow. I have loaded refactor-plan.md with 4 tasks. Starting Task 1: Extract user validation logic. Dispatching implementation subagent. Subagent completed implementation with 6 passing tests. Dispatching code-reviewer for Task 1. Review complete - no critical issues found. Task 1 marked complete. Moving to Task 2: Create validation service class."
      },
      {
        "input": "Execute the API migration plan with code reviews after each endpoint",
        "output": "Using subagent-driven-development for API migration. Loaded 8 tasks from api-migration-plan.md. Task 1: Migrate GET users endpoint. Implementation subagent deployed. Subagent reports: endpoint migrated, 12 tests passing, response format unchanged. Code review dispatched. Reviewer feedback: 1 Important issue - missing rate limit configuration. Dispatching fix subagent. Fix applied, rate limiting added. Task 1 complete."
      }
    ],
    "best_practices": [
      "Always read the plan file carefully before starting and create TodoWrite entries for all tasks to track progress",
      "Wait for code review results after each task and fix Critical and Important issues before proceeding to next task",
      "Use the finishing-a-development-branch skill after all tasks complete to properly verify tests and present merge options"
    ],
    "anti_patterns": [
      "Do not skip code review checkpoints between tasks - this defeats the quality gate purpose of the workflow",
      "Do not dispatch multiple implementation subagents in parallel - this causes merge conflicts and context pollution",
      "Do not use this skill for tightly coupled tasks where later tasks depend heavily on earlier implementation details"
    ],
    "faq": [
      {
        "question": "When should I use this instead of executing-plans skill?",
        "answer": "Use subagent-driven-development when staying in current session with mostly independent tasks. Use executing-plans when you need to review the plan first or work in a parallel session."
      },
      {
        "question": "What happens if a subagent fails to complete a task?",
        "answer": "Dispatch a fix subagent with specific instructions about what failed. Do not try to fix manually as this causes context pollution. The fix subagent has fresh context to resolve the issue."
      },
      {
        "question": "How does this integrate with test-driven development?",
        "answer": "Subagents dispatched by this workflow automatically follow TDD methodology. Each task implementation writes tests first, then code, ensuring quality from the start."
      },
      {
        "question": "Can I customize the code review criteria for each task?",
        "answer": "Yes, when dispatching the code-reviewer subagent you can specify focus areas like security, performance, or test coverage in the review request."
      },
      {
        "question": "What is the cost difference compared to manual execution?",
        "answer": "This workflow uses more subagent invocations but catches issues early. The cost is higher upfront but typically lower overall than debugging problems found later in development."
      },
      {
        "question": "Do I need other skills to use this effectively?",
        "answer": "Yes, this requires writing-plans to create the plan, requesting-code-review for reviews, and finishing-a-development-branch to complete work. These skills form a complete development workflow."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 190
    },
    {
      "name": "SKILL.zip",
      "type": "file",
      "path": "SKILL.zip"
    }
  ]
}
