{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-17T06:15:34.697Z",
    "slug": "dyai2025-professional-senior-chrome-extension-architect-developer",
    "source_url": "https://github.com/DYAI2025/Skill-chromeEXT/tree/main/",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "a04e2176f6f4ffcff04747db95f627ab208a44ba275834f925657cf32825ee49",
    "tree_hash": "273acd0f8b3e372af5eb9b34008c639df07ca95c9226db892040fd96c5aa13eb"
  },
  "skill": {
    "name": "professional-senior-chrome-extension-architect-developer",
    "description": "Verwandelt den Agenten in einen professionellen MV3-Architekten und Entwickler mit Fokus auf AI-Integration, Sicherheit, Performance, Testing und Publishing-Compliance.",
    "summary": "Verwandelt den Agenten in einen professionellen MV3-Architekten und Entwickler mit Fokus auf AI-Inte...",
    "icon": "ðŸ§©",
    "version": "1.0.0",
    "author": "DYAI2025",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "chrome extension",
      "manifest v3",
      "ai integration",
      "security",
      "architecture"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "scripts",
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a legitimate Chrome extension development skill with minimal risk. It provides architectural guidance, code templates, and security patterns for building Manifest V3 extensions. The static scanner flagged documentation examples and educational content as security issues. The actual implementation demonstrates secure coding patterns: API keys stored in chrome.storage.session (RAM-only), no eval() in runtime code, Shadow DOM for UI isolation, and minimal permissions. The skill explicitly promotes security best practices including no remote code loading, proper consent flows, and CSP compliance.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "src/shared/utils.ts",
            "line_start": 117,
            "line_end": 124
          }
        ]
      },
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "src/ui/popup.ts",
            "line_start": 48,
            "line_end": 78
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "src/background/index.ts",
            "line_start": 1,
            "line_end": 12
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [
      {
        "title": "Broad host permissions for page analysis",
        "description": "The extension requests host permissions http://*/* and https://*/* to analyze page content. This is legitimate for a page analyzer extension. The content script collects only meta tags, headings, links, and images - not sensitive form data or user input.",
        "locations": [
          {
            "file": "manifest.json",
            "line_start": 16,
            "line_end": 16
          }
        ]
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 21,
    "total_lines": 2249,
    "audit_model": "claude",
    "audited_at": "2026-01-17T06:15:34.697Z"
  },
  "content": {
    "user_title": "Build secure Chrome extensions with MV3 architecture",
    "value_statement": "Building Chrome extensions requires understanding service workers, security patterns, and Chrome Web Store compliance. This skill provides architectural guidance, code templates, and security best practices for creating professional extensions with optional AI integration.",
    "seo_keywords": [
      "chrome extension",
      "manifest v3",
      "claude",
      "codex",
      "claude-code",
      "mv3",
      "service worker",
      "ai integration",
      "openai",
      "security"
    ],
    "actual_capabilities": [
      "Design MV3-compliant extension architecture with service workers, content scripts, and popup UI",
      "Implement secure patterns: Shadow DOM isolation, session-only token storage, CSP configuration",
      "Create typed messaging contracts between background, content scripts, and popup",
      "Integrate AI features with OpenAI API while maintaining user privacy",
      "Generate manifest configurations with minimal permissions and explicit host access",
      "Apply security review checklists: no eval(), no remote code, proper consent flows"
    ],
    "limitations": [
      "Does not execute code in user environment - provides guidance and templates only",
      "Does not access external APIs beyond the extension being built",
      "Does not modify existing extensions without explicit user request",
      "Chrome-specific - does not cover Firefox, Safari, or Edge extension development"
    ],
    "use_cases": [
      {
        "target_user": "Extension developers",
        "title": "Design new extension architecture",
        "description": "Create a new Chrome extension with proper MV3 structure, security patterns, and AI integration from scratch."
      },
      {
        "target_user": "Security auditors",
        "title": "Review extension security",
        "description": "Audit existing extensions for security issues like eval(), remote code, improper token storage, and permission overreach."
      },
      {
        "target_user": "MV2 to MV3 migrators",
        "title": "Migrate legacy extensions",
        "description": "Convert Manifest V2 extensions to V3 with service worker patterns, declarativeNetRequest, and modern security practices."
      }
    ],
    "prompt_templates": [
      {
        "title": "Create basic extension",
        "scenario": "New MV3 extension with popup",
        "prompt": "Create a simple Manifest V3 Chrome extension with a popup that counts open tabs. Include the manifest.json, background service worker, and popup UI with proper permissions."
      },
      {
        "title": "Add AI analysis",
        "scenario": "Extension with OpenAI integration",
        "prompt": "Add OpenAI API integration to my Chrome extension. Store the API key securely in chrome.storage.session. Create a service worker function that sends page content to GPT and displays the AI response in the popup."
      },
      {
        "title": "Security review",
        "scenario": "Audit existing extension",
        "prompt": "Review my Chrome extension for security issues. Check for: eval() usage, remote script loading, tokens in localStorage, excessive permissions, missing CSP, and Shadow DOM usage. Report findings with fixes."
      },
      {
        "title": "Production hardening",
        "scenario": "Prepare for Chrome Web Store",
        "prompt": "Prepare my extension for Chrome Web Store submission. Include privacy policy, proper permission justifications, manifest validation, and compliance with CWS policies."
      }
    ],
    "output_examples": [
      {
        "input": "Create a new Chrome extension that analyzes page SEO and shows a score in a floating button",
        "output": [
          "Manifest configuration with permissions: activeTab, scripting, storage, tabs",
          "Content script that collects: title, meta description, headings, images, links",
          "Service worker with scoring algorithm and OpenAI integration option",
          "Popup UI for API key management and initiating analysis",
          "Shadow DOM styling for the floating analysis button",
          "Security checklist: no eval, API key in session storage, minimal permissions"
        ]
      },
      {
        "input": "Build a tab counter extension that shows the count in the extension badge",
        "output": [
          "Manifest V3 with tabs permission and action configuration",
          "Service worker using chrome.tabs.query to count tabs",
          "Badge update logic with chrome.action.setBadgeText",
          "Event-driven architecture (no polling, uses onCreated/onRemoved listeners)",
          "Minimal host permissions (no all_urls needed)"
        ]
      }
    ],
    "best_practices": [
      "Always use chrome.storage.session for API keys and tokens - never localStorage for sensitive data",
      "Inject UI elements with Shadow DOM to prevent style conflicts with host page",
      "Request minimal permissions and use optional permissions for features that can be enabled later"
    ],
    "anti_patterns": [
      "Using eval() or dynamic code execution - violates CSP and creates security vulnerabilities",
      "Loading scripts from external CDNs - enables supply chain attacks",
      "Storing credentials in localStorage - accessible by any script on the page"
    ],
    "faq": [
      {
        "question": "Which Chrome APIs does this skill cover?",
        "answer": "Service workers, content scripts, popup options pages, offscreen documents, chrome.storage, chrome.tabs, chrome.scripting, chrome.offscreen, and chrome.alarms."
      },
      {
        "question": "What AI integrations are supported?",
        "answer": "OpenAI API integration is demonstrated with secure key storage. Local models can be added using WebLLM or similar libraries running in offscreen documents."
      },
      {
        "question": "Is the generated code Chrome Web Store compliant?",
        "answer": "The skill includes compliance checklists and guidelines. However, always verify current CWS policies as they change quarterly."
      },
      {
        "question": "How are API keys protected?",
        "answer": "API keys are stored in chrome.storage.session which keeps data in RAM only. Keys are not persisted across browser restarts."
      },
      {
        "question": "Why is my extension being blocked by Chrome?",
        "answer": "Common issues: remote code loading, excessive permissions, missing permission justifications, or policy-violating features. Review the security checklist."
      },
      {
        "question": "How does this compare to WXT or Plasmo?",
        "answer": "This skill provides fundamental MV3 patterns. WXT and Plasmo are frameworks that abstract these patterns. Understanding the underlying architecture helps debug framework issues."
      }
    ]
  },
  "file_structure": [
    {
      "name": "assets",
      "type": "dir",
      "path": "assets",
      "children": [
        {
          "name": "icons.base64.json",
          "type": "file",
          "path": "assets/icons.base64.json",
          "lines": 6
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "copy-static.js",
          "type": "file",
          "path": "scripts/copy-static.js",
          "lines": 40
        },
        {
          "name": "generate-icons.js",
          "type": "file",
          "path": "scripts/generate-icons.js",
          "lines": 45
        }
      ]
    },
    {
      "name": "src",
      "type": "dir",
      "path": "src",
      "children": [
        {
          "name": "background",
          "type": "dir",
          "path": "src/background",
          "children": [
            {
              "name": "index.ts",
              "type": "file",
              "path": "src/background/index.ts",
              "lines": 79
            },
            {
              "name": "offscreen.html",
              "type": "file",
              "path": "src/background/offscreen.html",
              "lines": 11
            },
            {
              "name": "offscreen.ts",
              "type": "file",
              "path": "src/background/offscreen.ts",
              "lines": 19
            }
          ]
        },
        {
          "name": "content",
          "type": "dir",
          "path": "src/content",
          "children": [
            {
              "name": "index.ts",
              "type": "file",
              "path": "src/content/index.ts",
              "lines": 71
            }
          ]
        },
        {
          "name": "shared",
          "type": "dir",
          "path": "src/shared",
          "children": [
            {
              "name": "contracts.ts",
              "type": "file",
              "path": "src/shared/contracts.ts",
              "lines": 70
            },
            {
              "name": "utils.ts",
              "type": "file",
              "path": "src/shared/utils.ts",
              "lines": 135
            }
          ]
        },
        {
          "name": "ui",
          "type": "dir",
          "path": "src/ui",
          "children": [
            {
              "name": "popup.html",
              "type": "file",
              "path": "src/ui/popup.html",
              "lines": 90
            },
            {
              "name": "popup.ts",
              "type": "file",
              "path": "src/ui/popup.ts",
              "lines": 114
            }
          ]
        }
      ]
    },
    {
      "name": "tests",
      "type": "dir",
      "path": "tests",
      "children": [
        {
          "name": "e2e",
          "type": "dir",
          "path": "tests/e2e",
          "children": [
            {
              "name": "README.md",
              "type": "file",
              "path": "tests/e2e/README.md",
              "lines": 7
            }
          ]
        },
        {
          "name": "unit",
          "type": "dir",
          "path": "tests/unit",
          "children": [
            {
              "name": "utils.test.ts",
              "type": "file",
              "path": "tests/unit/utils.test.ts",
              "lines": 28
            }
          ]
        }
      ]
    },
    {
      "name": "blueprint_Chrome-extension-skill.md",
      "type": "file",
      "path": "blueprint_Chrome-extension-skill.md",
      "lines": 917
    },
    {
      "name": "LICENSE",
      "type": "file",
      "path": "LICENSE",
      "lines": 22
    },
    {
      "name": "manifest.json",
      "type": "file",
      "path": "manifest.json",
      "lines": 44
    },
    {
      "name": "README.md",
      "type": "file",
      "path": "README.md",
      "lines": 67
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 59
    },
    {
      "name": "tsconfig.build.json",
      "type": "file",
      "path": "tsconfig.build.json",
      "lines": 10
    },
    {
      "name": "tsconfig.json",
      "type": "file",
      "path": "tsconfig.json",
      "lines": 19
    }
  ]
}
