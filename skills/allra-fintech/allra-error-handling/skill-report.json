{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T15:21:16.632Z",
    "slug": "allra-fintech-allra-error-handling",
    "source_url": "https://github.com/Allra-Fintech/allra-ai-skills/tree/main/backend-plugin/skills/error-handling",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "c33cfc8a4d6e8d58be1c7cdcf357ec07af2a1fedb1893bb669b527f8c53bd28d",
    "tree_hash": "9c71c8b8b08287c9cbae74648df751924988c3bfb611f37baa0aab09b2c6ca9f"
  },
  "skill": {
    "name": "allra-error-handling",
    "description": "Allra Î∞±ÏóîÎìú ÏóêÎü¨ Ìï∏Îì§ÎßÅ Î∞è ÏòàÏô∏ Ï≤òÎ¶¨ ÌëúÏ§Ä. Use when handling errors, creating custom exceptions, or implementing error responses.",
    "summary": "Standardizes backend error handling, exception patterns, and logging conventions for Java Spring applications.",
    "icon": "üì¶",
    "version": "1.0.0",
    "author": "Allra-Fintech",
    "license": "MIT",
    "tags": [
      "error-handling",
      "exceptions",
      "spring-boot",
      "java",
      "backend"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings are false positives. The skill is a documentation-only skill containing Java code examples for error handling patterns. No actual security risks present.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 758,
    "audit_model": "claude",
    "audited_at": "2026-01-21T15:21:16.632Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Implement Standardized Error Handling",
    "value_statement": "Java Spring applications often lack consistent error handling patterns. This skill provides a complete error handling standard including exception hierarchies, global exception handlers, and structured error responses.",
    "seo_keywords": [
      "Claude",
      "Codex",
      "Claude Code",
      "error handling",
      "exception handling",
      "Java Spring",
      "REST API error responses",
      "global exception handler",
      "business exception"
    ],
    "actual_capabilities": [
      "Creates custom exception hierarchies following the BusinessException pattern",
      "Implements Global Exception Handler with @RestControllerAdvice",
      "Designs structured error response DTOs with error codes and field validation details",
      "Defines ErrorCode enums with HTTP status codes and error messages",
      "Implements proper logging strategies with appropriate log levels",
      "Adds entity-level exception classes for domain-specific error scenarios"
    ],
    "limitations": [
      "Focuses on Java Spring Boot applications only",
      "Does not provide code for error monitoring or alerting integration",
      "Does not include internationalization (i18n) for error messages",
      "Does not generate code for distributed tracing or error correlation"
    ],
    "use_cases": [
      {
        "title": "Build Consistent API Error Responses",
        "description": "Design a standardized error response format across all REST endpoints with consistent error codes, messages, and field-level validation details.",
        "target_user": "Backend developers building REST APIs"
      },
      {
        "title": "Implement Domain-Specific Exceptions",
        "description": "Create a hierarchy of custom exceptions for business logic errors such as EntityNotFoundException, DuplicateResourceException, and authorization failures.",
        "target_user": "Software architects defining error standards"
      },
      {
        "title": "Add Centralized Exception Handling",
        "description": "Implement a global exception handler that catches and processes all exceptions uniformly, ensuring consistent error responses to API clients.",
        "target_user": "Full-stack developers working on API backends"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Error Handling",
        "prompt": "Create a business exception hierarchy for a Java Spring Boot application. Include a base BusinessException class, an ErrorCode enum with common HTTP error codes, and examples of domain-specific exceptions like UserNotFoundException.",
        "scenario": "Starting a new Spring Boot project and need error handling foundations"
      },
      {
        "title": "Global Exception Handler",
        "prompt": "Implement a @RestControllerAdvice GlobalExceptionHandler that handles BusinessException, MethodArgumentNotValidException for validation errors, and generic Exception. Return a structured ErrorResponse with timestamp, error code, message, and field errors.",
        "scenario": "Adding centralized error handling to an existing API"
      },
      {
        "title": "Structured Error Responses",
        "prompt": "Design an ErrorResponse record in Java that includes error code, message, a list of field-level errors with field name, rejected value, and error message, plus a timestamp. Provide factory methods for different error scenarios.",
        "scenario": "Creating a consistent API error response format"
      },
      {
        "title": "Service Layer Error Patterns",
        "prompt": "Show how to use custom exceptions in a Spring service layer. Include examples of orElseThrow with EntityNotFoundException, duplicate resource validation with DuplicateResourceException, and authorization checks with ForbiddenException.",
        "scenario": "Writing service methods with proper error handling"
      }
    ],
    "output_examples": [
      {
        "input": "Create a custom exception for user not found scenarios",
        "output": [
          "public class UserNotFoundException extends BusinessException {",
          "    public UserNotFoundException(Long userId) {",
          "        super(ErrorCode.USER_NOT_FOUND,",
          "              String.format(\"ÏÇ¨Ïö©Ïûê(id=%d)Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§\", userId));",
          "    }",
          "}"
        ]
      },
      {
        "input": "Implement error handling for validation failures",
        "output": [
          "public record ErrorResponse(",
          "    String code,",
          "    String message,",
          "    List<FieldError> errors,",
          "    LocalDateTime timestamp",
          ") {}"
        ]
      }
    ],
    "best_practices": [
      "Define a centralized ErrorCode enum with consistent HTTP status codes and error codes for all business exceptions",
      "Use WARN level logging for expected business exceptions and ERROR level for unexpected system exceptions",
      "Exclude sensitive data from error responses and log messages to prevent information leakage"
    ],
    "anti_patterns": [
      "Throwing generic Exception or RuntimeException instead of custom business exceptions",
      "Exposing stack traces or internal error details directly to API clients",
      "Using string concatenation instead of parameterized logging for structured log output"
    ],
    "faq": [
      {
        "question": "How does this skill differ from Spring's default error handling?",
        "answer": "This skill provides a standardized, enterprise-grade error handling pattern with custom exception hierarchies, structured error responses, and consistent logging. Spring's default error handling is basic and not suitable for production APIs."
      },
      {
        "question": "Can I use this with non-Spring Java applications?",
        "answer": "The exception hierarchy and error response patterns can be adapted to any Java application. However, the @RestControllerAdvice examples are specific to Spring Boot."
      },
      {
        "question": "How do I handle validation errors from request bodies?",
        "answer": "Use @Valid on request body parameters and catch MethodArgumentNotValidException in the GlobalExceptionHandler. Extract field errors from the BindingResult and include them in the ErrorResponse."
      },
      {
        "question": "Should I include stack traces in error responses?",
        "answer": "No. Stack traces expose internal implementation details and can leak sensitive information. Always return user-friendly messages in production environments."
      },
      {
        "question": "How do I log errors properly without exposing sensitive data?",
        "answer": "Use parameterized logging with placeholders like log.warn(\"User not found: userId={}\", id). Never directly log user input, passwords, or sensitive fields."
      },
      {
        "question": "Can I extend this pattern for microservices?",
        "answer": "Yes. Add correlation IDs to ErrorResponse for distributed tracing. Consider standardizing ErrorCode enums across services for consistent error handling in microservice architectures."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 366
    }
  ]
}
