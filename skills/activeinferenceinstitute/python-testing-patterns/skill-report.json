{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T10:04:16.271Z",
    "slug": "activeinferenceinstitute-python-testing-patterns",
    "source_url": "https://github.com/ActiveInferenceInstitute/Journal-Utilities/tree/main/.claude/skills/python-testing-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "dc473f2ccc2998bd05cbbf62bf790574025c503c49a7779dcf06e52abdb2a664",
    "tree_hash": "b9b103b9717918f4eb8455e4b944ca4dfcae374132b0162b70685382eea0790b"
  },
  "skill": {
    "name": "python-testing-patterns",
    "description": "Implement comprehensive testing strategies with pytest, fixtures, mocking, and test-driven development. Use when writing Python tests, setting up test suites, or implementing testing best practices.",
    "summary": "Implement comprehensive testing strategies with pytest, fixtures, mocking, and test-driven developme...",
    "icon": "ðŸ§ª",
    "version": "1.0.0",
    "author": "ActiveInferenceInstitute",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "pytest",
      "testing",
      "python",
      "tdd",
      "test-driven-development"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing only educational markdown content. No executable code, no file system access, no network calls, no environment variable access. This is a prompt-based knowledge skill.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 908,
    "audit_model": "claude",
    "audited_at": "2026-01-10T10:04:16.271Z"
  },
  "content": {
    "user_title": "Implement Python Tests with pytest Patterns",
    "value_statement": "Writing tests for Python code can be time-consuming and inconsistent without clear patterns. This skill provides ready-to-use pytest patterns for fixtures, mocking, async code, and TDD workflows to help you build reliable test suites quickly.",
    "seo_keywords": [
      "pytest patterns",
      "python testing",
      "claude code testing",
      "pytest fixtures",
      "mocking in python",
      "test driven development",
      "async testing python",
      "claude testing",
      "codex python tests",
      "python unit tests"
    ],
    "actual_capabilities": [
      "Write unit tests using pytest with AAA pattern",
      "Create reusable fixtures with setup and teardown",
      "Mock external dependencies with unittest.mock",
      "Test async code using pytest-asyncio",
      "Implement property-based testing with Hypothesis",
      "Configure test coverage reporting in CI/CD"
    ],
    "limitations": [
      "Does not execute tests or run test suites",
      "Does not integrate with specific test frameworks beyond providing patterns",
      "Does not generate test code from production code",
      "Requires user to implement patterns in their own project"
    ],
    "use_cases": [
      {
        "target_user": "Python Developer",
        "title": "Set Up Test Suite",
        "description": "Create new test infrastructure with fixtures, mocking, and coverage for Python projects."
      },
      {
        "target_user": "QA Engineer",
        "title": "Write Integration Tests",
        "description": "Build integration tests for APIs, databases, and external services using pytest patterns."
      },
      {
        "target_user": "DevOps Engineer",
        "title": "Configure CI/CD Tests",
        "description": "Set up automated testing pipelines with coverage reporting and test markers."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Unit Test",
        "scenario": "Write a simple unit test",
        "prompt": "Write a pytest unit test for a function called calculate_total that takes a list of prices and returns the sum with tax. Include test cases for normal input, empty list, and single item."
      },
      {
        "title": "Fixture Setup",
        "scenario": "Create test fixtures",
        "prompt": "Create a pytest fixture for database testing. The fixture should connect to an in-memory SQLite database, create tables, yield a session, then clean up after the test."
      },
      {
        "title": "Mock External API",
        "scenario": "Mock API calls",
        "prompt": "Write tests for an API client that fetches user data. Use unittest.mock patch to mock the requests.get call. Test both success and 404 error cases."
      },
      {
        "title": "Async Testing",
        "scenario": "Test async code",
        "prompt": "Write async tests for a function that fetches data from multiple URLs concurrently using asyncio.gather. Show how to use pytest-asyncio mark and fixtures with async setup."
      }
    ],
    "output_examples": [
      {
        "input": "Write a test for user authentication that checks login success and failure cases",
        "output": [
          "Test login success with valid credentials",
          "Test login failure with invalid password",
          "Test account lockout after multiple failed attempts",
          "Mock the database query to isolate authentication logic"
        ]
      }
    ],
    "best_practices": [
      "Use descriptive test names that explain what is being tested and expected outcome",
      "Keep tests independent with no shared state between test cases",
      "Test edge cases and error conditions, not just happy paths"
    ],
    "anti_patterns": [
      "Avoid testing multiple assertions in a single test when they could be separate tests",
      "Do not make tests depend on execution order or shared state",
      "Avoid hardcoding values that should come from fixtures or configuration"
    ],
    "faq": [
      {
        "question": "What Python versions are supported?",
        "answer": "Patterns work with Python 3.7+ and pytest 7.0+. Async patterns require pytest-asyncio."
      },
      {
        "question": "What is the maximum test complexity?",
        "answer": "Patterns support simple unit tests to complex integration tests with multiple fixtures and mocks."
      },
      {
        "question": "Can this integrate with existing test code?",
        "answer": "Yes, patterns are compatible with existing pytest setups and can be added incrementally."
      },
      {
        "question": "Is test data handled securely?",
        "answer": "Patterns use in-memory data and temporary files. No sensitive data is stored or transmitted."
      },
      {
        "question": "Why are my tests failing with import errors?",
        "answer": "Ensure pytest is installed, test files start with test_, and Python path includes your project root."
      },
      {
        "question": "How does this compare to unittest framework?",
        "answer": "pytest is more modern with fixtures, parametrize, and better assertions. Patterns here use pytest features unavailable in unittest."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
