{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T09:57:46.622Z",
    "slug": "activeinferenceinstitute-async-python-patterns",
    "source_url": "https://github.com/ActiveInferenceInstitute/Journal-Utilities/tree/main/.claude/skills/async-python-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "92c333c184463b8b3f22fadc6340b4c9943726f5e333d5ebb665f248ffb06c3c",
    "tree_hash": "a25c1ffc146d67e86db5164400b50cc25d7bd80b237a910cf0ff285125527b8e"
  },
  "skill": {
    "name": "async-python-patterns",
    "description": "Master Python asyncio, concurrent programming, and async/await patterns for high-performance applications. Use when building async APIs, concurrent systems, or I/O-bound applications requiring non-blocking operations.",
    "summary": "Master Python asyncio, concurrent programming, and async/await patterns for high-performance applica...",
    "icon": "âš¡",
    "version": "1.0.0",
    "author": "ActiveInferenceInstitute",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "python",
      "asyncio",
      "concurrent",
      "async",
      "performance"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure prompt-based skill containing only documentation and educational code examples. No executable code, scripts, network calls, file system access, or external commands detected.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 695,
    "audit_model": "claude",
    "audited_at": "2026-01-10T09:57:46.622Z"
  },
  "content": {
    "user_title": "Master Python async patterns",
    "value_statement": "Building async applications in Python requires understanding complex patterns for concurrent execution, task management, and performance optimization. This skill provides comprehensive guidance on asyncio fundamentals, real-world patterns, and best practices for building high-performance non-blocking systems.",
    "seo_keywords": [
      "async python patterns",
      "python asyncio tutorial",
      "async await guide",
      "concurrent python",
      "claude async python",
      "claude code async",
      "codex async python",
      "python async programming",
      "asyncio best practices",
      "python concurrency patterns"
    ],
    "actual_capabilities": [
      "Explains asyncio fundamentals including event loops, coroutines, tasks, and futures",
      "Provides code examples for concurrent execution using asyncio.gather()",
      "Demonstrates error handling and timeout patterns in async code",
      "Covers advanced patterns including async context managers and iterators",
      "Shows producer-consumer patterns with asyncio.Queue",
      "Illustrates real-world applications like web scraping and database operations"
    ],
    "limitations": [
      "Contains code examples only; does not execute or validate user code",
      "Does not provide debugging or profiling tools",
      "Focused on Python standard library asyncio; third-party library specifics are introductory",
      "Does not generate complete project scaffolds or boilerplate"
    ],
    "use_cases": [
      {
        "target_user": "Python developers",
        "title": "Build async web APIs",
        "description": "Learn patterns for creating high-performance async APIs using FastAPI, aiohttp, or Sanic"
      },
      {
        "target_user": "Backend engineers",
        "title": "Concurrent I/O operations",
        "description": "Implement efficient concurrent database, file, and network operations without blocking"
      },
      {
        "target_user": "Full-stack developers",
        "title": "Real-time applications",
        "description": "Develop WebSocket servers, chat systems, and event-driven applications"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic async pattern",
        "scenario": "Learning asyncio fundamentals",
        "prompt": "Show me how to use asyncio.gather() to run multiple async functions concurrently in Python"
      },
      {
        "title": "Error handling",
        "scenario": "Handling async exceptions",
        "prompt": "How do I properly handle errors and timeouts when using asyncio.wait_for() in Python"
      },
      {
        "title": "Rate limiting",
        "scenario": "Controlling concurrent requests",
        "prompt": "Explain how to use asyncio.Semaphore to rate limit concurrent API calls in Python"
      },
      {
        "title": "Producer-consumer",
        "scenario": "Building concurrent pipelines",
        "prompt": "Show me an example of the producer-consumer pattern using asyncio.Queue for processing items concurrently"
      }
    ],
    "output_examples": [
      {
        "input": "How do I prevent blocking the event loop when running CPU-intensive tasks in async Python code?",
        "output": [
          "Use `asyncio.to_thread()` (Python 3.9+) or `loop.run_in_executor()` to offload blocking CPU work to a thread pool",
          "Never use `time.sleep()` in async code - use `await asyncio.sleep()` instead",
          "Example pattern: wrap CPU-intensive functions with run_in_executor to keep the event loop responsive"
        ]
      }
    ],
    "best_practices": [
      "Always use `asyncio.run()` as the entry point for async programs (Python 3.7+)",
      "Use `asyncio.gather()` for concurrent execution of independent async operations",
      "Implement proper timeout handling with `asyncio.wait_for()` to prevent hanging operations"
    ],
    "anti_patterns": [
      "Calling async functions without await - this returns a coroutine object instead of executing the function",
      "Using blocking operations like `time.sleep()` or CPU-intensive work directly in async code",
      "Mixing synchronous and asynchronous code without proper translation using asyncio.run()"
    ],
    "faq": [
      {
        "question": "What Python version is required for asyncio?",
        "answer": "Python 3.7+ provides asyncio.run() for simple entry points. Newer versions add features like asyncio.to_thread()."
      },
      {
        "question": "What is the maximum number of concurrent tasks?",
        "answer": "The event loop can handle thousands of tasks. Use semaphores to limit actual concurrency based on system resources."
      },
      {
        "question": "Can I use asyncio with FastAPI?",
        "answer": "Yes, FastAPI is built on Starlette and natively supports async/await patterns for maximum performance."
      },
      {
        "question": "Does this skill send data to external services?",
        "answer": "No. This is a prompt-based skill providing documentation only. No data is sent anywhere."
      },
      {
        "question": "Why is my async code running slowly?",
        "answer": "Common causes include using blocking operations, not awaiting coroutines, or excessive sequential instead of concurrent execution."
      },
      {
        "question": "How does asyncio compare to threading?",
        "answer": "Asyncio uses single-threaded cooperative multitasking, which is more efficient for I/O-bound work than threading."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
