{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T17:03:34.076Z",
    "slug": "barissozen-defi-expert",
    "source_url": "https://github.com/BarisSozen/claude/tree/main/.claude/skills/defi-expert",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "a598ec5b7b31eef580439bb0d3ae0fe897f81fc228633149fcc8c2a252b8f361",
    "tree_hash": "847739a0a4a7b6a01102dbf62e591e9aa966b02854328cd9b474e0fee14cdbc1"
  },
  "skill": {
    "name": "defi-expert",
    "description": "DeFi protocol expert ensuring correct data formats, types, denominations, and API structures. MUST be consulted before writing ANY protocol integration code. Triggers on ANY mention of Aave, Compound, Uniswap, Curve, Balancer, or DeFi terms like liquidation, swap, flash loan, health factor.",
    "summary": "DeFi protocol expert ensuring correct data formats, types, denominations, and API structures for safe DeFi integrations.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "BarisSozen",
    "license": "MIT",
    "tags": [
      "defi",
      "blockchain",
      "smart-contracts",
      "ethereum",
      "tokenomics"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All 15 static findings are false positives. The scanner incorrectly flagged common words (main, hash), SHA256 integrity hashes, and TypeScript code examples as security threats. This is a documentation-only skill with no executable code, network calls, or file system access. Safe for publication.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 59,
            "line_end": 68
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 324,
    "audit_model": "claude",
    "audited_at": "2026-01-21T17:03:34.076Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Review DeFi Protocol Integrations",
    "value_statement": "DeFi integrations often fail due to decimal mishandling and incorrect unit conversions. This skill provides expert validation for token amounts, denominations, and API structures across major protocols.",
    "seo_keywords": [
      "DeFi expert",
      "DeFi protocol integration",
      "Claude",
      "Codex",
      "Claude Code",
      "token decimals",
      "smart contract development",
      "Aave integration",
      "Uniswap swap",
      "liquidation prevention"
    ],
    "actual_capabilities": [
      "Validate token decimal handling for USDC, USDT, WBTC, and other assets",
      "Verify correct denomination units (wei, ray, wad, bps) for different protocols",
      "Review address checksum formatting for transaction safety",
      "Identify common DeFi integration errors before deployment",
      "Provide protocol-specific guidance for Aave, Compound, Uniswap, Curve, and Balancer"
    ],
    "limitations": [
      "Does not execute transactions or interact with live DeFi protocols",
      "Does not provide real-time price feeds or market data",
      "Does not generate deployable smart contract code from scratch",
      "Relies on user-provided context for specific protocol versions"
    ],
    "use_cases": [
      {
        "title": "Smart Contract Developer",
        "description": "Validate token handling code before deploying DeFi integrations. Prevent costly bugs like using 18 decimals for USDC or incorrect health factor calculations.",
        "target_user": "Smart contract developers building DeFi applications"
      },
      {
        "title": "Protocol Audit Review",
        "description": "Review existing DeFi integrations for common precision errors and denomination mistakes. Catch issues that could lead to loss of funds or failed transactions.",
        "target_user": "Security auditors and protocol reviewers"
      },
      {
        "title": "DeFi Integration Testing",
        "description": "Verify swap implementations, lending positions, and liquidity provisions use correct units and handle all edge cases for major protocols.",
        "target_user": "QA engineers and integration testers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Token Validation",
        "prompt": "Review this DeFi code for token decimal handling. The code handles [TOKEN_NAME] with [AMOUNT] amount. Check if the decimals are correctly applied.",
        "scenario": "Simple token amount validation"
      },
      {
        "title": "Lending Protocol Review",
        "prompt": "Review this Aave/Compound lending position code. The health factor calculation is [CODE_SNIPPET]. Verify the denominator used (1e18 vs 1e27) is correct.",
        "scenario": "Health factor and lending position validation"
      },
      {
        "title": "Swap Integration Check",
        "prompt": "Check this Uniswap/Curve swap implementation. The input amount is [CODE_SNIPPET]. Confirm the decimals, routing, and slippage parameters are set correctly.",
        "scenario": "DEX swap integration validation"
      },
      {
        "title": "Full Protocol Audit",
        "prompt": "Perform a complete audit of this DeFi integration file. Check: (1) token decimals for all tokens, (2) denomination units (wei/ray/wad/bps), (3) address checksums, (4) precision calculations. List all issues found.",
        "scenario": "Comprehensive protocol integration audit"
      }
    ],
    "output_examples": [
      {
        "input": "Review this code: const amount = parseEther(value); // for USDC",
        "output": "ISSUE FOUND: USDC uses 6 decimals, not 18. Using parseEther (1e18) will cause 12 orders of magnitude error.\n\nCORRECT: Use parseUnits(value, 6) for USDC or call await token.decimals() dynamically.\n\nOther common mistakes:\n- Aave health factor: Use 1e27 (ray), not 1e18\n- MakerDAO wad: Use 1e18 (correct)\n- ETHwei: Use 1e18 (correct)"
      },
      {
        "input": "How should I handle WBTC decimals?",
        "output": "WBTC uses 8 decimals, not 18 like ETH.\n\nWRONG: parseEther(btcAmount)\nCORRECT: parseUnits(btcAmount, 8)\n\nAlways verify decimals at runtime: const decimals = await token.decimals();\n\nQuick reference:\n- ETH, WETH, DAI: 18 decimals\n- USDC, USDT: 6 decimals\n- WBTC: 8 decimals"
      },
      {
        "input": "Check this Aave health factor calculation: const hf = rawHF / 1e18",
        "output": "ISSUE: Aave uses RAY unit (1e27) for interest rates and health factors.\n\nCORRECT: const hf = rawHF / 1e27\n\nNote: rawHF from Aave V3 Pool.getUserAccountData() returns values in ray units. Divide by 1e27 to get the human-readable health factor."
      }
    ],
    "best_practices": [
      "Always fetch token decimals at runtime rather than hardcoding. Tokens can have non-standard decimals.",
      "Use protocol-specific denominations: ray (1e27) for Aave, wad (1e18) for MakerDAO, bps (1e4) for percentages.",
      "Validate checksummed addresses for all external protocol calls to prevent transaction failures."
    ],
    "anti_patterns": [
      "Hardcoding 18 decimals for all tokens (USDC has 6, WBTC has 8)",
      "Using parseEther for non-ETH tokens without decimal conversion",
      "Ignoring the distinction between ray, wad, and wei units in calculations"
    ],
    "faq": [
      {
        "question": "What DeFi protocols does this skill cover?",
        "answer": "This skill provides guidance for Aave, Compound, Uniswap, Curve, Balancer, and other major DeFi protocols. It covers lending, borrowing, swapping, and liquidity operations."
      },
      {
        "question": "How do I handle variable decimals?",
        "answer": "Always call await token.decimals() at runtime rather than hardcoding. Some tokens like rebasing tokens or fee-on-transfer tokens may have special handling requirements."
      },
      {
        "question": "What is the difference between wei, ray, and wad?",
        "answer": "Wei is ETH smallest unit (1e18). Wad is 18-decimal fixed point (MakerDAO). Ray is 27-decimal fixed point (Aave). Using the wrong unit causes massive calculation errors."
      },
      {
        "question": "Does this skill generate smart contract code?",
        "answer": "This skill reviews and validates existing code for DeFi correctness. It identifies errors in decimal handling, unit conversions, and API usage. For new code generation, use a coding skill."
      },
      {
        "question": "How do I verify checksummed addresses?",
        "answer": "Use ethers.js checksumAddress function or web3.utils.toChecksumAddress. Unchecksummed addresses will cause transactions to fail on most networks."
      },
      {
        "question": "What should I check before deploying DeFi code?",
        "answer": "Verify: (1) all token decimals, (2) correct denomination units, (3) checksummed addresses, (4) proper slippage parameters, (5) health factor safety margins. Test on testnet first."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 69
    }
  ]
}
