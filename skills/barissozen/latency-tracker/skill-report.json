{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-16T18:04:56.342Z",
    "slug": "barissozen-latency-tracker",
    "source_url": "https://github.com/BarisSozen/claude/tree/main/.claude/skills/latency-tracker",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "4fd0fb66de92c001072bc58d607a9f0e175e123388df6acf8db2bf3c40630e73",
    "tree_hash": "659bb1c4a848db12bec0b0c9db554158497dad65ea0766be61442a3c8c439347"
  },
  "skill": {
    "name": "latency-tracker",
    "description": "Per-call and aggregated latency tracking for MEV infrastructure. Use when implementing performance monitoring or debugging slow operations. Triggers on: latency, timing, performance, slow, speed, instrumentation.",
    "summary": "Per-call and aggregated latency tracking for MEV infrastructure. Use when implementing performance m...",
    "icon": "⏱️",
    "version": "1.0.0",
    "author": "BarisSozen",
    "license": "MIT",
    "category": "data",
    "tags": [
      "performance",
      "monitoring",
      "latency",
      "mev",
      "instrumentation"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill contains only documentation files with no executable code. The static analyzer misidentified performance monitoring terminology and metadata as security threats. No network calls, filesystem access, external commands, or scripts exist in this skill.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 42,
            "line_end": 50
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 238,
    "audit_model": "claude",
    "audited_at": "2026-01-16T18:04:56.342Z"
  },
  "content": {
    "user_title": "Track latency across MEV infrastructure",
    "value_statement": "MEV infrastructure requires precise latency monitoring to maintain competitive edge. This skill provides per-call and aggregated latency tracking to identify bottlenecks, debug slow operations, and set alerting thresholds for performance anomalies.",
    "seo_keywords": [
      "latency tracking",
      "performance monitoring",
      "MEV infrastructure",
      "debugging slow operations",
      "instrumentation",
      "latency alerts",
      "Claude",
      "Codex",
      "claude-code",
      "speed optimization"
    ],
    "actual_capabilities": [
      "Track per-call latency with nested span hierarchy",
      "Monitor aggregated latency across end-to-end flows",
      "Debug slow operations with granular timing data",
      "Configure alert thresholds for latency anomalies",
      "Instrument code paths with tracker.span() calls",
      "Structure spans from root e2e_flow to individual calls"
    ],
    "limitations": [
      "Requires integration with existing MEV infrastructure code",
      "Alert thresholds must be configured manually",
      "Does not provide automatic latency optimization",
      "Performance impact from instrumentation not quantified"
    ],
    "use_cases": [
      {
        "target_user": "MEV traders",
        "title": "Optimize execution speed",
        "description": "Track latency across transaction flow to identify and eliminate bottlenecks in trading strategies."
      },
      {
        "target_user": "DevOps engineers",
        "title": "Monitor infrastructure health",
        "description": "Set up latency alerts to detect performance degradation in RPC calls and transaction processing."
      },
      {
        "target_user": "Protocol developers",
        "title": "Profile smart contract interactions",
        "description": "Instrument contract calls to understand timing characteristics and optimize gas usage patterns."
      }
    ],
    "prompt_templates": [
      {
        "title": "Track transaction flow",
        "scenario": "Monitoring MEV transaction latency",
        "prompt": "Track the latency of my transaction flow from submission to confirmation using the latency tracker skill."
      },
      {
        "title": "Debug slow RPC calls",
        "scenario": "Investigating RPC performance issues",
        "prompt": "Instrument my eth_call RPC operations to identify which specific calls are causing latency spikes."
      },
      {
        "title": "Set latency alerts",
        "scenario": "Configuring performance monitoring",
        "prompt": "Set up alert thresholds for my hot path operations where expected latency is 5-15ms."
      },
      {
        "title": "Profile complete flow",
        "scenario": "End-to-end latency analysis",
        "prompt": "Create a span hierarchy for my complete MEV strategy from e2e_flow through rust_call to tx_confirm."
      }
    ],
    "output_examples": [
      {
        "input": "Track the latency of my transaction flow",
        "output": [
          "Span hierarchy created: e2e_flow (root)",
          "├── rust_hotpath_call (5-15ms target)",
          "│   └── rpc_eth_call (5-20ms target)",
          "├── tx_submit (10-50ms target)",
          "└── tx_confirm (1-15s target)",
          "Alert thresholds configured: rust_hotpath >30ms, rpc_eth_call >50ms"
        ]
      },
      {
        "input": "Debug slow RPC calls",
        "output": [
          "Instrumenting eth_call operations",
          "Identified latency spike: rpc_eth_call averaging 45ms",
          "Root cause: network congestion during peak hours",
          "Recommended action: implement retry logic with exponential backoff"
        ]
      },
      {
        "input": "Set latency alerts",
        "output": [
          "Alert threshold configured for rust_hotpath: >30ms",
          "Alert threshold configured for rpc_eth_call: >50ms",
          "Alert threshold configured for e2e_to_submit: >100ms",
          "Monitoring active for all instrumented spans"
        ]
      }
    ],
    "best_practices": [
      "Define span hierarchy before instrumentation to ensure consistent tracking across all code paths.",
      "Set alert thresholds based on actual production measurements, not theoretical limits.",
      "Use nested spans to isolate whether latency originates from hot path or submission logic."
    ],
    "anti_patterns": [
      "Creating spans without defined expected latency ranges makes alert configuration impossible.",
      "Instrumenting every single function call creates excessive overhead and noise.",
      "Setting alert thresholds too tight causes alert fatigue and masks real issues."
    ],
    "faq": [
      {
        "question": "What latency ranges should I expect for MEV operations?",
        "answer": "Typical targets: rust_hotpath_call 5-15ms, rpc_eth_call 5-20ms, tx_submit 10-50ms, tx_confirm 1-15s."
      },
      {
        "question": "How do I configure alert thresholds?",
        "answer": "Set thresholds based on expected latency plus margin. For hot path, alert at 2x expected (e.g., >30ms for 5-15ms target)."
      },
      {
        "question": "Does latency tracking impact performance?",
        "answer": "Minimal overhead from span creation and timing capture. Avoid instrumenting high-frequency micro-operations."
      },
      {
        "question": "What spans should I create for a new strategy?",
        "answer": "Start with root e2e_flow, then add children for each major operation: rust_call, RPC calls, submit, confirm."
      },
      {
        "question": "Is my latency data stored or transmitted?",
        "answer": "This skill generates tracking code and metrics locally. Data handling depends on your implementation."
      },
      {
        "question": "How does this differ from generic profiling tools?",
        "answer": "This skill is purpose-built for MEV workflows with predefined spans for common operations like tx_confirm."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 59
    }
  ]
}
