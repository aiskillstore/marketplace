{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T15:27:21.106Z",
    "slug": "clouder0-agent-workflow",
    "source_url": "https://github.com/Clouder0/dotagent/tree/main/.claude/skills/agent-workflow",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "e6ed059be1000d14dbfc5719d233d84eb602cf822bf9aecd8619170bab5b8a84",
    "tree_hash": "a3e6c682271a410023951eb98854f9de152c40ba3196e28f789830fc6a9f898f"
  },
  "skill": {
    "name": "agent-workflow",
    "description": "Multi-agent development workflow system. Load when orchestrating development tasks, spawning subagents, or managing workflow phases.",
    "summary": "Multi-agent development workflow system for orchestrating complex software projects with specialized agents.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "Clouder0",
    "license": "MIT",
    "tags": [
      "multi-agent",
      "workflow",
      "orchestration",
      "project-management",
      "development"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "network",
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings are false positives. Network access is legitimate source URL metadata. Hash values flagged as C2 keywords are standard SHA256 content verification. Documentation examples showing Task tool syntax were misidentified as shell execution. The skill is a legitimate multi-agent workflow orchestration system with no malicious code.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 128,
            "line_end": 129
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 67,
            "line_end": 85
          },
          {
            "file": "SKILL.md",
            "line_start": 85,
            "line_end": 89
          },
          {
            "file": "SKILL.md",
            "line_start": 89,
            "line_end": 101
          },
          {
            "file": "SKILL.md",
            "line_start": 101,
            "line_end": 107
          },
          {
            "file": "SKILL.md",
            "line_start": 107,
            "line_end": 108
          },
          {
            "file": "SKILL.md",
            "line_start": 108,
            "line_end": 109
          },
          {
            "file": "SKILL.md",
            "line_start": 109,
            "line_end": 110
          },
          {
            "file": "SKILL.md",
            "line_start": 110,
            "line_end": 111
          },
          {
            "file": "SKILL.md",
            "line_start": 111,
            "line_end": 112
          },
          {
            "file": "SKILL.md",
            "line_start": 112,
            "line_end": 113
          },
          {
            "file": "SKILL.md",
            "line_start": 113,
            "line_end": 114
          },
          {
            "file": "SKILL.md",
            "line_start": 114,
            "line_end": 115
          },
          {
            "file": "SKILL.md",
            "line_start": 115,
            "line_end": 116
          },
          {
            "file": "SKILL.md",
            "line_start": 116,
            "line_end": 117
          },
          {
            "file": "SKILL.md",
            "line_start": 117,
            "line_end": 118
          },
          {
            "file": "SKILL.md",
            "line_start": 118,
            "line_end": 122
          },
          {
            "file": "SKILL.md",
            "line_start": 122,
            "line_end": 123
          },
          {
            "file": "SKILL.md",
            "line_start": 123,
            "line_end": 124
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 570,
    "audit_model": "claude",
    "audited_at": "2026-01-21T15:27:21.106Z"
  },
  "content": {
    "user_title": "Orchestrate Multi-Agent Development Workflows",
    "value_statement": "Managing complex software projects across multiple phases and specialized agents is challenging. This skill provides a structured framework for orchestrating development workflows with tiered agents for requirements, architecture, implementation, verification, and reflection.",
    "seo_keywords": [
      "Claude",
      "Codex",
      "Claude Code",
      "multi-agent",
      "workflow",
      "orchestration",
      "development",
      "project management",
      "subagent",
      "agent system"
    ],
    "actual_capabilities": [
      "Manages multi-phase development workflows from requirements to delivery",
      "Spawns specialized subagents for different tasks (PM, Architect, Executor, QA, Reflector)",
      "Coordinates parallel work across multiple agents",
      "Handles workflow phase transitions and blockers",
      "Supports both custom Dotagent system agents and built-in Claude Code agents"
    ],
    "limitations": [
      "Does not execute code directly, only orchestrates other agents",
      "Requires the Task tool to spawn and manage subagents",
      "Does not persist state between sessions without external memory management",
      "Cannot modify project files without additional tools"
    ],
    "use_cases": [
      {
        "title": "Complex Feature Development",
        "description": "Lead a multi-agent team through the complete development cycle for a new feature, from requirements gathering to implementation and verification.",
        "target_user": "Software developers working on complex features requiring multiple specialized tasks"
      },
      {
        "title": "Codebase Exploration and Analysis",
        "description": "Use the Explorer agent to quickly understand a new codebase, then spawn Implementers to make changes based on findings.",
        "target_user": "Developers onboarding to unfamiliar codebases or conducting initial analysis"
      },
      {
        "title": "System Refactoring Projects",
        "description": "Coordinate Architects for design, Executors for implementation, and Verifiers for testing across a large-scale refactoring effort.",
        "target_user": "Engineering teams undertaking significant architectural changes"
      }
    ],
    "prompt_templates": [
      {
        "title": "Start New Development Task",
        "prompt": "I need to develop a new feature: [feature description]. Please load the agent-workflow skill and guide me through the full workflow. Start with the REQUIREMENTS phase by having the PM agent gather and clarify the requirements. Then proceed through ARCHITECTURE, IMPLEMENTATION, and VERIFICATION phases.",
        "scenario": "Starting a new development task with full workflow guidance"
      },
      {
        "title": "Parallel Agent Spawning",
        "prompt": "For this task: [task description], I want to work in parallel. Please spawn an architect agent to design the solution while simultaneously spawning an explorer agent to understand the existing codebase. Use the Executor agent to coordinate both and synthesize their outputs.",
        "scenario": "Running parallel work streams with multiple agents"
      },
      {
        "title": "Handle Blocked Task",
        "prompt": "My current task [describe task] is blocked because [explain blocker]. Please use the Contract Resolver agent to identify options for resolving this blocker, then guide me on how to proceed once the blocker is resolved.",
        "scenario": "Resolving blockers and getting unstuck"
      },
      {
        "title": "Post-Implementation Review",
        "prompt": "We have completed implementation of [feature/project]. Please use the QA agent to verify the implementation, then use the Reflector agent to capture learnings and the Evolver agent to suggest improvements for future iterations.",
        "scenario": "Conducting verification and capturing learnings after delivery"
      }
    ],
    "output_examples": [
      {
        "input": "Start a new development task to build a REST API for user authentication",
        "output": "I'll load the agent-workflow skill and guide you through the complete development workflow.\n\n**Phase 1: REQUIREMENTS**\nSpawning PM agent to gather authentication requirements...\n\nThe PM agent has identified these requirements:\n- User registration and login endpoints\n- JWT token generation and validation\n- Password hashing with bcrypt\n- Session management\n\n**Phase 2: ARCHITECTURE**\nSpawning Architect agent to design the API structure...\n\nWhat would you like to do next? Proceed to implementation, modify requirements, or adjust the architecture?"
      },
      {
        "input": "Explore the codebase to understand how the authentication module works, then implement refresh token functionality",
        "output": "Running parallel exploration and planning:\n\n**Explorer Agent** is scanning the codebase for authentication-related files...\n\n**Architect Agent** is designing the refresh token implementation...\n\nBoth agents will report back, then we can proceed with the Executor coordinating the implementers."
      },
      {
        "input": "Verify the authentication implementation and capture learnings",
        "output": "**Phase 4: VERIFICATION**\nSpawning QA agent to validate the authentication implementation...\n\nQA Findings:\n- All 12 test cases pass\n- Security review: JWT expiration properly configured\n- Integration test: Login and token refresh working\n\n**Phase 5: REFLECTION**\nSpawning Reflector agent to capture learnings...\n\nKey Learnings:\n1. Token refresh logic should be isolated in middleware\n2. Consider adding rate limiting for login endpoints\n3. Documentation for token lifecycle was helpful\n\nWould you like me to spawn the Evolver agent to create an improvement plan?"
      }
    ],
    "best_practices": [
      "Start with clear requirements before spawning specialized agents",
      "Use the appropriate agent model (haiku for exploration, sonnet for implementation, opus for complex design)",
      "Complete one phase before moving to the next for focused results",
      "Use the Reflector agent after project completion to capture learnings"
    ],
    "anti_patterns": [
      "Spawning too many agents simultaneously without coordination",
      "Skipping the requirements phase and starting implementation too early",
      "Not using the Contract Resolver when encountering blockers",
      "Forgetting the verification and reflection phases after implementation"
    ],
    "faq": [
      {
        "question": "What is the difference between custom Dotagent agents and built-in Claude Code agents?",
        "answer": "Custom Dotagent agents (pm, architect, executor, etc.) are specialized for the workflow system with defined roles. Built-in agents (Explore, Plan, general-purpose) are standard Claude Code agents that can be used alongside or within the workflow."
      },
      {
        "question": "Can I use this skill for small, simple tasks?",
        "answer": "For simple tasks, using the full workflow may be overkill. Consider using specific agents directly (like just the Explorer or Implementer) or starting with a simpler approach and escalating to the full workflow if needed."
      },
      {
        "question": "How do I persist workflow state between sessions?",
        "answer": "The skill references memory files like @memory/state/phase.json. You can implement external state management by reading and writing these files or using a shared storage solution."
      },
      {
        "question": "What models should I use for each agent type?",
        "answer": "Exploration and testing tasks work well with haiku. Implementation and coordination tasks work well with sonnet. Complex architectural design and synthesis tasks benefit from opus."
      },
      {
        "question": "How do I handle conflicts between agents working on the same files?",
        "answer": "Use the Contract Resolver agent to identify conflicts. Establish clear boundaries for each agent, serialize access to shared files, or implement a merge strategy."
      },
      {
        "question": "Can I customize the workflow phases for my team?",
        "answer": "The skill provides a default workflow structure. You can modify the workflow definitions or add custom phases by editing the workflow configuration files referenced in SKILL.md."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 130
    }
  ]
}
