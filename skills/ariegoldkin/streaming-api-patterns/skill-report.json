{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T10:52:09.620Z",
    "slug": "ariegoldkin-streaming-api-patterns",
    "source_url": "https://github.com/ArieGoldkin/ai-agent-hub/tree/main/skills/streaming-api-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "9b544eb4aa9440b9be5866d149086f2be66cd10c9b52c9349bfbfccc532da117",
    "tree_hash": "e6c94cd16be4e19b563774a2cdc752ffa69f6c3cec08a9fecea98137fe083805"
  },
  "skill": {
    "name": "streaming-api-patterns",
    "description": "Implement real-time data streaming with Server-Sent Events (SSE), WebSockets, and ReadableStream APIs. Master backpressure handling, reconnection strategies, and LLM streaming for 2025+ real-time applications.",
    "summary": "Implement real-time data streaming with Server-Sent Events (SSE), WebSockets, and ReadableStream API...",
    "icon": "ðŸ“¡",
    "version": "1.0.0",
    "author": "AI Agent Hub",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "streaming",
      "sse",
      "websocket",
      "real-time",
      "api",
      "2025"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation and code template skill containing no executable scripts, network calls, or filesystem access beyond its own files. All code examples are educational patterns for streaming API implementation.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 3,
    "total_lines": 420,
    "audit_model": "claude",
    "audited_at": "2026-01-10T10:52:09.620Z"
  },
  "content": {
    "user_title": "Build real-time streaming APIs",
    "value_statement": "Modern applications require real-time data delivery for LLM interfaces, notifications, and live updates. This skill provides code patterns for Server-Sent Events, WebSockets, and the ReadableStream API to implement production-ready streaming solutions.",
    "seo_keywords": [
      "streaming API",
      "Server-Sent Events",
      "SSE",
      "WebSockets",
      "real-time",
      "ReadableStream",
      "backpressure",
      "LLM streaming",
      "Claude",
      "Claude Code",
      "Codex"
    ],
    "actual_capabilities": [
      "Implement Server-Sent Events (SSE) endpoints for server-to-client streaming",
      "Build WebSocket servers and clients for bidirectional real-time communication",
      "Handle backpressure with the ReadableStream API for efficient data flow",
      "Implement reconnection strategies with exponential backoff for resilient connections",
      "Stream LLM responses token-by-token for ChatGPT-style interfaces",
      "Configure proper headers and caching for streaming responses"
    ],
    "limitations": [
      "Does not include live coding environment or execution sandbox",
      "Requires separate backend server to run the demonstrated patterns",
      "Security features mentioned require separate implementation and validation"
    ],
    "use_cases": [
      {
        "target_user": "Frontend developers",
        "title": "LLM chat interfaces",
        "description": "Build streaming chat UIs that display AI responses token-by-token as they generate"
      },
      {
        "target_user": "Backend engineers",
        "title": "Real-time notifications",
        "description": "Implement server-push systems for live updates, alerts, and monitoring dashboards"
      },
      {
        "target_user": "Full-stack developers",
        "title": "Live data feeds",
        "description": "Create streaming endpoints for stock prices, analytics dashboards, and collaborative tools"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic SSE endpoint",
        "scenario": "Create a simple streaming endpoint",
        "prompt": "Show me how to create a basic Server-Sent Events endpoint in Next.js that streams data to the client"
      },
      {
        "title": "WebSocket server",
        "scenario": "Build a real-time chat server",
        "prompt": "Write a WebSocket server implementation that broadcasts messages to all connected clients"
      },
      {
        "title": "LLM streaming",
        "scenario": "Stream OpenAI responses",
        "prompt": "Create an API endpoint that streams OpenAI chat completions to the client token by token using ReadableStream"
      },
      {
        "title": "Reconnection logic",
        "scenario": "Handle client disconnections",
        "prompt": "Implement a ReconnectingEventSource class with exponential backoff that automatically reconnects when the connection is lost"
      }
    ],
    "output_examples": [
      {
        "input": "Create a streaming endpoint for LLM responses",
        "output": [
          "Use ReadableStream with TextEncoder to format SSE messages",
          "Stream each token as it arrives with 'data: {token}\\n\\n' format",
          "Send '[DONE]' marker when streaming completes",
          "Set headers: Content-Type: text/event-stream, Cache-Control: no-cache",
          "Handle client disconnection with req.signal.aborted check"
        ]
      }
    ],
    "best_practices": [
      "Send keepalive comments every 30 seconds to prevent timeout disconnections",
      "Use exponential backoff for reconnection delays to reduce server load",
      "Monitor buffer sizes and implement backpressure to handle slow consumers"
    ],
    "anti_patterns": [
      "Blocking the event loop with synchronous operations in stream handlers",
      "Sending large numbers of tiny messages without batching",
      "Failing to close streams properly causing memory leaks on long connections"
    ],
    "faq": [
      {
        "question": "What is the difference between SSE and WebSockets?",
        "answer": "SSE is one-way (server to client) over HTTP, simpler for streaming. WebSockets provide bidirectional communication but require a different protocol and connection upgrade."
      },
      {
        "question": "How do I handle browser connection limits with SSE?",
        "answer": "Browsers limit SSE connections to 6 per domain. Use HTTP/2 for multiplexing or shard connections across subdomains if needed."
      },
      {
        "question": "What is backpressure and why does it matter?",
        "answer": "Backpressure is flow control when data arrives faster than it can be consumed. Without it, memory fills up and the system can crash."
      },
      {
        "question": "Is SSE secure for sensitive data?",
        "answer": "SSE runs over HTTPS so data is encrypted in transit. Implement authentication tokens and validate origins for production use."
      },
      {
        "question": "How do I test streaming endpoints?",
        "answer": "Use curl for SSE tests. For WebSockets, use browser dev tools or tools like wscat. Test reconnection scenarios and slow network conditions."
      },
      {
        "question": "Can I use SSE with serverless functions?",
        "answer": "Yes, but with limitations. Serverless platforms have timeout limits. For long streams, use a persistent server or service like Vercel Edge Functions."
      }
    ]
  },
  "file_structure": [
    {
      "name": "checklists",
      "type": "dir",
      "path": "checklists",
      "children": [
        {
          "name": "streaming-checklist.md",
          "type": "file",
          "path": "checklists/streaming-checklist.md"
        }
      ]
    },
    {
      "name": "templates",
      "type": "dir",
      "path": "templates",
      "children": [
        {
          "name": "sse-endpoint-template.ts",
          "type": "file",
          "path": "templates/sse-endpoint-template.ts"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
