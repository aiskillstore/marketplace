{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-26T07:54:01.950Z",
    "slug": "softaworks-command-creator",
    "source_url": "https://github.com/softaworks/agent-toolkit/tree/main/skills/command-creator/",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "705b3c0c91357abced75fbdc5314fa07ee658273106489190e3a7115aaacd5ad",
    "tree_hash": "cb79a79c6c3fbe8f2ac0eff3577c78c89206345798294df843d2458a472cc3bc"
  },
  "skill": {
    "name": "command-creator",
    "description": "This skill should be used when creating a Claude Code slash command. Use when users ask to \"create a command\", \"make a slash command\", \"add a command\", or want to document a workflow as a reusable command. Essential for creating optimized, agent-executable slash commands with proper structure and best practices.",
    "summary": "Create optimized, agent-executable slash commands for Claude Code with proper structure and best practices.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "softaworks",
    "license": "MIT",
    "tags": [
      "slash-commands",
      "workflow-automation",
      "productivity",
      "claude-code"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "filesystem",
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a documentation-only skill containing markdown guides and command examples. Static analyzer flagged 452 pattern matches but all are false positives: (1) markdown code examples flagged as 'external_commands', (2) Claude config path references flagged as 'hidden file access', (3) YAML frontmatter flagged as 'weak cryptographic algorithm', (4) git command documentation flagged as 'system reconnaissance'. The skill does not execute code, make network requests, or access files. All findings are documentation artifacts that pose no security risk.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": []
      },
      {
        "factor": "filesystem",
        "evidence": []
      },
      {
        "factor": "network",
        "evidence": []
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 5,
    "total_lines": 2400,
    "audit_model": "claude",
    "audited_at": "2026-01-26T07:54:01.950Z"
  },
  "content": {
    "user_title": "Create Slash Commands",
    "value_statement": "Transform repetitive workflows into reusable slash commands. This skill guides you through designing, implementing, and testing agent-optimized commands that can be invoked with /command-name in Claude Code conversations.",
    "seo_keywords": [
      "Claude",
      "Codex",
      "Claude Code",
      "slash command",
      "slash commands",
      "workflow automation",
      "command creator",
      "claude-code",
      "reusable commands"
    ],
    "actual_capabilities": [
      "Determines appropriate command location (project-level or global)",
      "Guides users through command creation workflow (6 steps)",
      "Provides pattern-based design guidance (4 command patterns)",
      "Generates agent-optimized markdown command files",
      "Enforces naming conventions and best practices",
      "Includes bundled reference documentation (patterns, examples, best practices)"
    ],
    "limitations": [
      "Does not execute commands or perform actions itself",
      "Does not access or modify user files without explicit request",
      "Cannot create commands that require interactive input",
      "Only generates markdown files, does not run shell scripts"
    ],
    "use_cases": [
      {
        "title": "Automate Repetitive Development Tasks",
        "description": "Create commands for common workflows like submitting PR stacks, fixing CI failures, running code reviews, or deploying applications. Transform multi-step processes into single slash commands that execute autonomously.",
        "target_user": "Developers with repetitive workflows"
      },
      {
        "title": "Standardize Team Processes",
        "description": "Build project-specific commands that enforce team standards, run linters, create consistent PR descriptions, or automate release procedures. Commands are version-controlled with the project.",
        "target_user": "Engineering teams and leads"
      },
      {
        "title": "Personal Productivity Boost",
        "description": "Create global commands available across all projects for git cleanup, codebase analysis, refactoring patterns, or planning workflows. Personal productivity tools that work everywhere.",
        "target_user": "Individual developers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Command Request",
        "prompt": "Create a slash command that [describe your workflow]. I want it to [main steps it should perform].",
        "scenario": "Simple command creation with basic workflow description"
      },
      {
        "title": "Command with Arguments",
        "prompt": "Create a global command called [command-name] that takes [arguments]. The command should [purpose]. Use this pattern: [steps].",
        "scenario": "Creating a parameterized command with specific arguments"
      },
      {
        "title": "Project-Level Command",
        "prompt": "Create a project-level slash command for [project-specific workflow]. This command should [detailed steps]. It needs to [requirements].",
        "scenario": "Building a command specific to the current project"
      },
      {
        "title": "Command Refinement",
        "prompt": "Review my existing command at [path]. It should [intended behavior]. Help me improve it by [specific improvements needed].",
        "scenario": "Iterating on an existing command to improve quality"
      }
    ],
    "output_examples": [
      {
        "input": "Create a command to iteratively fix CI failures",
        "output": "I'll help you create a CI fixer command. This will be a project-level command using the Iterative Fixing pattern.\n\n**Chosen Location:** `.claude/commands/` (project-level)\n**Pattern:** Iterative Fixing (Run â†’ Parse â†’ Fix â†’ Repeat)\n\nLet me gather some details:\n1. What test command should it run? (e.g., `pytest`, `npm test`)\n2. What arguments, if any, should the command accept?\n3. Are there specific files or patterns to focus on?"
      },
      {
        "input": "Make a global command to review code with Codex",
        "output": "Creating a global code review command using the Simple Execution pattern.\n\n**Chosen Location:** `~/.claude/commands/` (global - available everywhere)\n**Pattern:** Simple Execution (Run command with args)\n\n**Generated Command:** `~/.claude/commands/codex-review.md`\n```yaml\n---\ndescription: Review code files using Codex\nargument-hint: <file-path>\n---\n\n# Codex Review\n\nReview the specified file(s) using the codex skill..."
      }
    ],
    "best_practices": [
      "Use imperative verb-first language in commands: \"Run tests\" not \"You should run tests\"",
      "Define clear success criteria: \"Continue until all tests pass (exit code 0)\"",
      "Include explicit error handling: \"If pytest fails, parse the output to identify failing tests\""
    ],
    "anti_patterns": [
      "Avoid ambiguous instructions that require interpretation",
      "Do not include interactive prompts - commands must be autonomous",
      "Avoid user confirmation loops that break automation"
    ],
    "faq": [
      {
        "question": "What is the difference between project-level and global commands?",
        "answer": "Project-level commands (`.claude/commands/`) are specific to a repository and version-controlled. Global commands (`~/.claude/commands/`) are available across all projects but are local to your machine."
      },
      {
        "question": "Can I create a command that takes arguments?",
        "answer": "Yes. Use `argument-hint: <required>` for required arguments or `argument-hint: [optional]` for optional ones. Users invoke as `/command-name value` or `/command-name`."
      },
      {
        "question": "What command patterns are available?",
        "answer": "Four patterns: Workflow Automation (analyze â†’ act â†’ report), Iterative Fixing (run â†’ parse â†’ fix â†’ repeat), Agent Delegation (context â†’ delegate â†’ iterate), and Simple Execution (run command with args)."
      },
      {
        "question": "How do I test a newly created command?",
        "answer": "Invoke it directly in the chat: `/command-name [arguments]`. The skill will suggest testing after creation. Iterate based on feedback."
      },
      {
        "question": "What naming conventions must I follow?",
        "answer": "Commands must use kebab-case: `submit-stack`, not `submit_stack`. File names match command names exactly: `my-command.md` invokes as `/my-command`."
      },
      {
        "question": "Can I edit commands after creating them?",
        "answer": "Yes. Open the markdown file directly or ask this skill to review and improve an existing command. Commands are plain markdown files."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "best-practices.md",
          "type": "file",
          "path": "references/best-practices.md",
          "lines": 720
        },
        {
          "name": "examples.md",
          "type": "file",
          "path": "references/examples.md",
          "lines": 583
        },
        {
          "name": "patterns.md",
          "type": "file",
          "path": "references/patterns.md",
          "lines": 363
        }
      ]
    },
    {
      "name": "README.md",
      "type": "file",
      "path": "README.md",
      "lines": 523
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 211
    }
  ]
}
