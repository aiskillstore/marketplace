{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-16T19:42:23.686Z",
    "slug": "chemiseblanc-git-commit",
    "source_url": "https://github.com/Chemiseblanc/ai/tree/main/skill/git-commit",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "006b4aea7bfd0530ceed12cb4d634db85058723b1bb3b3e9038cb92ad9affae6",
    "tree_hash": "81f4ae7bc2bd4c0a99eee781bd060034d900771e29946935771d7655a7acbaf7"
  },
  "skill": {
    "name": "git-commit",
    "description": "Guide for breaking changes into logical, atomic commits using interactive staging. Use when committing changes that span multiple concerns, when needing to stage parts of files (hunks), when asked to create well-organized commit history, or when changes should be split into multiple commits.",
    "summary": "Guide for breaking changes into logical, atomic commits using interactive staging. Use when committi...",
    "icon": "üìù",
    "version": "1.0.0",
    "author": "Chemiseblanc",
    "license": "MIT",
    "category": "devops",
    "tags": [
      "git",
      "version-control",
      "commit",
      "staging",
      "best-practices"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a documentation-only skill containing static markdown with git best practices. No executable code, network calls, or data access. Pure educational content describing interactive staging commands.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 85,
            "line_end": 85
          },
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 20,
            "line_end": 25
          },
          {
            "file": "SKILL.md",
            "line_start": 25,
            "line_end": 48
          },
          {
            "file": "SKILL.md",
            "line_start": 48,
            "line_end": 52
          },
          {
            "file": "SKILL.md",
            "line_start": 52,
            "line_end": 56
          },
          {
            "file": "SKILL.md",
            "line_start": 56,
            "line_end": 58
          },
          {
            "file": "SKILL.md",
            "line_start": 58,
            "line_end": 61
          },
          {
            "file": "SKILL.md",
            "line_start": 61,
            "line_end": 64
          },
          {
            "file": "SKILL.md",
            "line_start": 64,
            "line_end": 65
          },
          {
            "file": "SKILL.md",
            "line_start": 65,
            "line_end": 66
          },
          {
            "file": "SKILL.md",
            "line_start": 66,
            "line_end": 67
          },
          {
            "file": "SKILL.md",
            "line_start": 67,
            "line_end": 68
          },
          {
            "file": "SKILL.md",
            "line_start": 68,
            "line_end": 72
          },
          {
            "file": "SKILL.md",
            "line_start": 72,
            "line_end": 74
          },
          {
            "file": "SKILL.md",
            "line_start": 74,
            "line_end": 80
          },
          {
            "file": "SKILL.md",
            "line_start": 80,
            "line_end": 88
          },
          {
            "file": "SKILL.md",
            "line_start": 88,
            "line_end": 91
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 273,
    "audit_model": "claude",
    "audited_at": "2026-01-16T19:42:23.686Z"
  },
  "content": {
    "user_title": "Organize Git Commits with Interactive Staging",
    "value_statement": "Managing multiple changes across files makes commit organization challenging. This skill provides step-by-step guidance for breaking changes into logical, atomic commits using git interactive staging features.",
    "seo_keywords": [
      "git commit",
      "interactive staging",
      "git add patch",
      "atomic commits",
      "git best practices",
      "Claude",
      "Claude Code",
      "version control",
      "git workflow",
      "commit organization"
    ],
    "actual_capabilities": [
      "Explains how to analyze changes and identify logical commit boundaries",
      "Guides using git add -p for interactive hunk staging",
      "Shows how to split mixed changes into separate commits",
      "Demonstrates commit verification with git diff --cached",
      "Provides workflow for organizing multi-commit feature branches"
    ],
    "limitations": [
      "Documentation only - does not execute git commands automatically",
      "Requires manual git command execution in terminal",
      "Does not resolve merge conflicts",
      "Assumes basic familiarity with git concepts"
    ],
    "use_cases": [
      {
        "target_user": "Developers",
        "title": "Clean Up Feature Branches",
        "description": "Organize mixed changes into separate commits for features, fixes, and refactors before creating pull requests."
      },
      {
        "target_user": "Team Leads",
        "title": "Improve Team Commit History",
        "description": "Guide team members to create atomic commits that are easy to review and understand during code reviews."
      },
      {
        "target_user": "Open Source Contributors",
        "title": "Follow Contribution Guidelines",
        "description": "Maintain clean commit history in open source projects that require organized, well-structured commits."
      }
    ],
    "prompt_templates": [
      {
        "title": "First Steps",
        "scenario": "Learning interactive staging",
        "prompt": "Show me how to use git add -p to stage specific parts of my changes"
      },
      {
        "title": "Separate Changes",
        "scenario": "Mixed changes in same files",
        "prompt": "I have bug fixes and new features in the same files. How do I split them into different commits?"
      },
      {
        "title": "Verify Staged Changes",
        "scenario": "Before committing",
        "prompt": "How can I review exactly what will be included in my next commit before I commit it?"
      },
      {
        "title": "Split Large Hunks",
        "scenario": "Complex hunk splitting",
        "prompt": "A hunk is too large and contains multiple unrelated changes. How do I split it into smaller pieces?"
      }
    ],
    "output_examples": [
      {
        "input": "I changed 3 files with a bug fix, a new feature, and some refactoring. How do I organize these?",
        "output": [
          "Run 'git status' to see all changed files",
          "Use 'git add -p' to interactively stage hunks",
          "Stage bug fix changes first and commit with a descriptive message",
          "Stage feature changes and commit separately",
          "Stage refactoring changes and commit last",
          "Verify each commit with 'git diff --cached'"
        ]
      },
      {
        "input": "What are the keyboard shortcuts for interactive staging?",
        "output": [
          "Press 'y' to stage the current hunk",
          "Press 'n' to skip this hunk",
          "Press 's' to split into smaller hunks",
          "Press 'q' to quit and keep already-staged hunks",
          "Press '?' to see all available options"
        ]
      },
      {
        "input": "Should I stage whole files or individual hunks?",
        "output": [
          "Stage whole files when all changes belong to one logical commit",
          "Use hunk staging when a file contains multiple concerns",
          "Split hunks when changes are unrelated within the same area",
          "Trust your judgment based on what makes review easier"
        ]
      }
    ],
    "best_practices": [
      "Review staged changes with 'git diff --cached' before each commit to verify what will be committed",
      "Use conventional commit format for clear, standardized commit messages",
      "Keep commits atomic by ensuring each commit represents one logical change that can be reverted independently"
    ],
    "anti_patterns": [
      "Avoid committing unrelated changes together in a single commit",
      "Do not stage entire files without reviewing the specific changes first",
      "Never skip commit message quality for faster delivery"
    ],
    "faq": [
      {
        "question": "Is this skill compatible with all git versions?",
        "answer": "Yes, the git commands shown work with all modern git versions 2.x and later."
      },
      {
        "question": "What are the limits of hunk staging?",
        "answer": "Some complex changes cannot be automatically split. You may need to manually edit files or use multiple staging passes."
      },
      {
        "question": "Can I use this with my IDE git features?",
        "answer": "Most IDEs have staging features. Use this skill to understand the underlying git commands they execute."
      },
      {
        "question": "Is my code safe with interactive staging?",
        "answer": "Yes, interactive staging only affects what gets committed. Your working directory remains unchanged."
      },
      {
        "question": "What if I accidentally stage the wrong hunk?",
        "answer": "Use 'git reset HEAD <file>' to unstage everything, or 'git reset -p' to unstage specific hunks."
      },
      {
        "question": "How is this different from git stash?",
        "answer": "Interactive staging commits changes permanently. Git stash temporarily saves changes for later use without committing."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 94
    }
  ]
}
