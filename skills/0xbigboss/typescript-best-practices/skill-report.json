{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T14:56:16.119Z",
    "slug": "0xbigboss-typescript-best-practices",
    "source_url": "https://github.com/0xBigBoss/claude-code/tree/main/.claude/skills/typescript-best-practices",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "e57a1ffe09fa023d9563c076ad3b618778b6506ba6c9a9959bdb7dc1b8459878",
    "tree_hash": "93e9336bd1b5d00eee2031000ff6a39a746fab69a9ec23fb49daff6136644ea1"
  },
  "skill": {
    "name": "typescript-best-practices",
    "description": "Provides TypeScript patterns for type-first development, making illegal states unrepresentable, exhaustive handling, and runtime validation. Must use when reading or writing TypeScript/JavaScript files.",
    "summary": "Provides TypeScript patterns for type-first development, making illegal states unrepresentable, exha...",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "0xBigBoss",
    "license": "MIT",
    "tags": [
      "typescript",
      "type-safety",
      "best-practices"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Static analysis detected 117 patterns but all are false positives. JavaScript template literals flagged as shell backticks, crypto.randomUUID() flagged as weak crypto, example config patterns flagged as credential access. This is legitimate TypeScript documentation with no actual security risks.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 1449,
    "audit_model": "claude",
    "audited_at": "2026-01-21T14:56:16.119Z"
  },
  "content": {
    "user_title": "Apply TypeScript Best Practices",
    "value_statement": "Writing TypeScript without patterns leads to runtime bugs and difficult maintenance. This skill provides patterns for type-first development that catches errors at compile time, makes invalid states unrepresentable, and adds runtime validation.",
    "seo_keywords": [
      "TypeScript best practices",
      "TypeScript patterns",
      "type-first development",
      "type safety",
      "exhaustive type checking",
      "Zod validation",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Applies discriminated unions for mutually exclusive states",
      "Creates branded types for domain primitives",
      "Adds exhaustive switch handling with never checks",
      "Implements Zod runtime validation with type inference",
      "Configures typed environment variable loading with validation"
    ],
    "limitations": [
      "Does not modify existing code without explicit instruction",
      "Does not run or execute TypeScript code",
      "Does not install or configure build tools or compilers",
      "Does not generate tests or documentation files"
    ],
    "use_cases": [
      {
        "title": "Fixing Bug-Prone Code",
        "description": "Refactor code that uses optional flags into discriminated unions, making invalid states impossible to represent at compile time.",
        "target_user": "Developers fixing runtime bugs in TypeScript applications"
      },
      {
        "title": "Adding Runtime Validation",
        "description": "Add Zod schemas with type inference to validate external data at trust boundaries, preventing type mismatches at runtime.",
        "target_user": "Backend developers securing API contracts"
      },
      {
        "title": "Enforcing Compile-Time Guarantees",
        "description": "Add exhaustive switch statements with never checks that fail compilation when new variants are added.",
        "target_user": "Team leads enforcing code quality standards"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Type Pattern",
        "prompt": "Apply TypeScript best practices to this code. Make illegal states unrepresentable using discriminated unions where boolean flags represent mutually exclusive states.",
        "scenario": "Refactoring bug-prone code with optional flags"
      },
      {
        "title": "Runtime Validation",
        "prompt": "Add runtime validation using Zod. Define a schema as the single source of truth and infer TypeScript types from it. Use safeParse for input validation and strict parse at trust boundaries.",
        "scenario": "Adding runtime validation to API handlers"
      },
      {
        "title": "Exhaustive Error Handling",
        "prompt": "Add exhaustive switch handling with never checks to this code. Every code path must return a value or throw. Unhandled cases should become compile errors.",
        "scenario": "Ensuring all enum/union cases are handled"
      },
      {
        "title": "Type-Safe Configuration",
        "prompt": "Create a typed configuration module using Zod validation. Load config from environment variables at startup, validate with Zod, and export a typed config object. Avoid accessing process.env directly in application code.",
        "scenario": "Setting up type-safe configuration management"
      }
    ],
    "output_examples": [
      {
        "input": "Refactor this state to use discriminated unions:\n```ts\ntype LoadingState = { loading: boolean; data?: Data; error?: Error };```",
        "output": "```ts\ntype LoadingState<T> =\n  | { status: 'idle' }\n  | { status: 'loading' }\n  | { status: 'success'; data: T }\n  | { status: 'error'; error: Error };\n\n// Compiler now enforces exhaustive handling\nfunction processState<T>(state: LoadingState<T>): Result {\n  switch (state.status) {\n    case 'idle': return defaultResult();\n    case 'loading': return pendingResult();\n    case 'success': return successResult(state.data);\n    case 'error': return errorResult(state.error);\n    default: const _exhaustive: never = state;\n      throw new Error(`unhandled state: ${_exhaustive}`);\n  }\n}\n```"
      },
      {
        "input": "Add Zod validation with type inference:\n```ts\ninterface User {\n  id: string;\n  email: string;\n  name: string;\n}\n\nasync function createUser(data: unknown): Promise<User> {\n  // TODO: validate data\n  return data as User;\n}\n```",
        "output": "```ts\nimport { z } from 'zod';\n\nconst UserSchema = z.object({\n  id: z.string().uuid(),\n  email: z.string().email(),\n  name: z.string().min(1),\n});\n\ntype User = z.infer<typeof UserSchema>;\n\nasync function createUser(raw: unknown): Promise<User> {\n  const result = UserSchema.safeParse(raw);\n  if (!result.success) {\n    throw new Error(`Invalid user: ${result.error.message}`);\n  }\n  return result.data;\n}\n```"
      }
    ],
    "best_practices": [
      "Define types before implementation. Let the type system guide what data structures and function signatures are needed.",
      "Use discriminated unions instead of optional properties to make invalid states unrepresentable at compile time.",
      "Add never checks in default switch cases. New enum variants will cause compile errors instead of silent bugs."
    ],
    "anti_patterns": [
      "Using optional properties and boolean flags for mutually exclusive states leads to invalid combinations.",
      "Skipping runtime validation at trust boundaries allows type mismatches to cause runtime crashes.",
      "Accessing process.env throughout the codebase creates untypeable configuration dependencies."
    ],
    "faq": [
      {
        "question": "When should I use branded types instead of string?",
        "answer": "Use branded types when you have multiple string types that should not be mixed, like UserId and OrderId. The compiler will catch passing an OrderId where a UserId is expected."
      },
      {
        "question": "How do I handle empty arrays in type-safe code?",
        "answer": "Use conditional checks before mapping or reducing. The type system narrows array types based on length checks. Add explicit handling for the empty case."
      },
      {
        "question": "Should I use Zod or type-only validation?",
        "answer": "Use Zod for data from external sources (APIs, user input, files). Use TypeScript types for internal code contracts. Zod provides runtime guarantees; types only provide compile-time checks."
      },
      {
        "question": "How do I handle unknown API responses safely?",
        "answer": "Use safeParse to attempt parsing, then handle both success and error cases. Never use type assertions on untrusted data. Log parse errors for debugging."
      },
      {
        "question": "What is the never type used for?",
        "answer": "The never type represents values that never occur. Use it in exhaustive switch statements as a compile-time check. If all cases are handled, the never variable assignment proves completeness."
      },
      {
        "question": "How do I keep types and schemas in sync?",
        "answer": "Define schemas as the single source of truth and infer TypeScript types with z.infer. Avoid duplicating type and schema definitions. Update the schema and the inferred type updates automatically."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 271
    }
  ]
}
