{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T18:43:50.475Z",
    "slug": "ruvnet-agentdb-memory-patterns",
    "source_url": "https://github.com/ruvnet/claude-flow/tree/main/.claude/skills/agentdb-memory-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "00f7af880dac8da73417ff6b09b129023848131d0ddd0605225367b02e8b003a",
    "tree_hash": "df4c4977bb9f0ab8b105c7a025a44759e832af2267e5cd0d169c81e4a98bf026"
  },
  "skill": {
    "name": "agentdb-memory-patterns",
    "description": "Implement persistent memory patterns for AI agents using AgentDB. Includes session memory, long-term storage, pattern learning, and context management. Use when building stateful agents, chat systems, or intelligent assistants.",
    "summary": "Implement persistent memory patterns for AI agents using AgentDB. Includes session memory, long-term storage, pattern learning, and context management.",
    "icon": "ðŸ§ ",
    "version": "1.0.0",
    "author": "ruvnet",
    "license": "MIT",
    "tags": [
      "memory",
      "persistent-storage",
      "agent-context",
      "vector-database"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings evaluated as false positives. The skill provides documentation for AgentDB persistent memory patterns. Scanner flagged CLI command examples, database file references, and metadata URL as risks, but these are legitimate components of a database documentation skill with no actual code execution or credential access.",
    "risk_factor_evidence": [
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 26,
            "line_end": 36
          },
          {
            "file": "SKILL.md",
            "line_start": 192,
            "line_end": 215
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 1036,
    "audit_model": "claude",
    "audited_at": "2026-01-21T18:43:50.475Z"
  },
  "content": {
    "user_title": "Implement Persistent Memory for AI Agents",
    "value_statement": "Building AI agents that forget context between conversations leads to poor user experiences. This skill provides AgentDB memory patterns for persistent storage, enabling agents to remember interactions, learn from experiences, and maintain context across sessions.",
    "seo_keywords": [
      "Claude memory",
      "persistent agent memory",
      "AgentDB patterns",
      "AI context management",
      "Claude Code memory",
      "agent memory storage",
      "vector database",
      "session memory",
      "long-term memory",
      "Claude Codex"
    ],
    "actual_capabilities": [
      "Store and retrieve conversation history using session memory patterns",
      "Persist long-term facts and user preferences across sessions",
      "Implement pattern learning from successful agent interactions",
      "Manage hierarchical memory with immediate, short-term, and long-term tiers",
      "Query vector embeddings with HNSW indexing for fast similarity search",
      "Integrate with ReasoningBank for automatic memory consolidation"
    ],
    "limitations": [
      "Requires AgentDB v1.0.7 or higher for full functionality",
      "In-memory mode loses data when the process terminates",
      "Does not provide built-in encryption for stored memories",
      "Memory consolidation strategy requires manual configuration"
    ],
    "use_cases": [
      {
        "title": "Build Stateful Chat Assistants",
        "description": "Create chat agents that remember previous conversations, user preferences, and context to provide personalized responses across sessions.",
        "target_user": "Chatbot developers building customer support or personal AI assistants"
      },
      {
        "title": "Enable Pattern-Based Learning Agents",
        "description": "Implement agents that learn from successful interactions by storing patterns and applying them to future similar contexts.",
        "target_user": "ML engineers building adaptive AI systems"
      },
      {
        "title": "Create Multi-Tier Memory Systems",
        "description": "Build agents with hierarchical memory architecture separating immediate context, session state, and persistent knowledge.",
        "target_user": "Research developers building complex agent architectures"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Session Memory Setup",
        "prompt": "Set up AgentDB with session memory for my AI agent. Initialize a database at .agentdb/reasoningbank.db and show me how to store conversation messages and retrieve them for context.",
        "scenario": "Getting started with basic memory storage"
      },
      {
        "title": "Long-Term Preference Storage",
        "prompt": "Help me implement long-term memory for storing user preferences like language, tone, and frequently used commands. Show how to persist these across sessions and retrieve them efficiently.",
        "scenario": "Storing user preferences persistently"
      },
      {
        "title": "Pattern Learning Integration",
        "prompt": "Implement pattern learning for my agent. When the agent successfully handles a request, store the trigger and response pattern. Then show how to retrieve and apply these patterns to similar future requests.",
        "scenario": "Learning from successful interactions"
      },
      {
        "title": "Hierarchical Memory with Consolidation",
        "prompt": "Create a complete hierarchical memory system with immediate (last 10 messages), short-term (session context), and long-term (important facts) tiers. Include automatic memory consolidation to prune low-quality patterns.",
        "scenario": "Advanced multi-tier memory architecture"
      }
    ],
    "output_examples": [
      {
        "input": "Set up session memory and store a user message",
        "output": "Session memory initialized at .agentdb/reasoningbank.db\n\nStored message:\n- Role: user\n- Content: 'What is the capital of France?'\n- Timestamp: 1737472800000\n\nTo retrieve context later, call retrieveWithReasoning() with the query embedding."
      },
      {
        "input": "Store a user preference for language",
        "output": "Fact stored successfully:\n- Category: user_preference\n- Key: language\n- Value: English\n- Confidence: 1.0\n- Source: explicit\n\nThis preference will persist across sessions."
      },
      {
        "input": "Check database statistics",
        "output": "Database Statistics:\n- Total patterns: 1,247\n- Average confidence: 0.82\n- Last consolidated: 2 hours ago\n- Vector dimensions: 768\n- Quantization: scalar (4x memory reduction)"
      }
    ],
    "best_practices": [
      "Enable quantization (scalar or binary) to reduce memory usage by 4-32x without significant accuracy loss",
      "Configure a cache of 1000+ patterns for sub-millisecond retrieval performance",
      "Use batch operations for inserting multiple patterns to achieve 500x faster performance",
      "Schedule regular memory consolidation to prune low-quality patterns and maintain performance"
    ],
    "anti_patterns": [
      "Storing every single message without filtering - this leads to memory bloat and slower queries",
      "Using in-memory mode for production deployments where data persistence is required",
      "Skipping regular consolidation - low-quality patterns accumulate and degrade search quality",
      "Storing sensitive information without considering the database file security"
    ],
    "faq": [
      {
        "question": "What is AgentDB and how does it differ from traditional databases?",
        "answer": "AgentDB is a persistent vector database designed for AI agents. It combines vector similarity search with relational storage, enabling fast pattern matching based on embeddings while also storing structured metadata."
      },
      {
        "question": "How do I migrate from ReasoningBank to AgentDB?",
        "answer": "Use the migrateToAgentDB function with your source and destination paths. The migration automatically transfers all patterns with validation. Example: migrateToAgentDB('.swarm/memory.db', '.agentdb/reasoningbank.db')"
      },
      {
        "question": "Can I use this skill with Claude Code directly?",
        "answer": "Yes. Run 'npx agentdb@latest mcp' to start the MCP server, then use 'claude mcp add agentdb npx agentdb@latest mcp' to integrate with Claude Code."
      },
      {
        "question": "What performance can I expect from vector searches?",
        "answer": "With HNSW indexing enabled, vector similarity searches complete in under 100 microseconds. Pattern retrieval with caching achieves sub-millisecond performance. Batch inserts process 100 patterns in approximately 2 milliseconds."
      },
      {
        "question": "How does pattern learning work in this skill?",
        "answer": "Pattern learning stores successful interaction patterns (trigger conditions and responses) in the database. When processing new requests, the system retrieves similar patterns and can apply them automatically or suggest them for use."
      },
      {
        "question": "What learning algorithms are available for pattern learning?",
        "answer": "Nine learning algorithms are available including Decision Transformer (sequence modeling), Q-Learning (value-based), SARSA (on-policy), Actor-Critic (policy gradient), Active Learning, Adversarial Training, Curriculum Learning, Federated Learning, and Multi-task Learning."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 340
    }
  ]
}
