{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T15:17:39.395Z",
    "slug": "akabanakk-high-quality-commit",
    "source_url": "https://github.com/AKABANAKK/claude-code-marketplace/tree/main/akb7/skills/high-quality-commit",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "75b2afe3189503ad69aca30f9c4d3937d51881e783a3ade7472cf395c983b628",
    "tree_hash": "40fd16b9dfc0e9411456faa428bafd18ce267a610af1e2371e4807fe21759177"
  },
  "skill": {
    "name": "high-quality-commit",
    "description": "ã‚³ãƒ¼ãƒ‰å¤‰æ›´ã‚’é©åˆ‡ãªgitã‚³ãƒŸãƒƒãƒˆæˆ¦ç•¥ã§git commitã—ã¾ã™ã€‚åŸºæœ¬çš„ã«ã¯æ—¢å­˜ã®gitã‚³ãƒŸãƒƒãƒˆã¸ã®squashæˆ¦ç•¥ã‚’æ¡ç”¨ã—ã€å¿…è¦ã«å¿œã˜ã¦ãƒ–ãƒ©ãƒ³ãƒå…¨ä½“ã®gitã‚³ãƒŸãƒƒãƒˆå±¥æ­´ã‚’å†æ§‹æˆã—ã¾ã™ã€‚å®Ÿè£…å®Œäº†æ™‚ã‚„ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒgit commitã‚’ä¾é ¼ã—ãŸæ™‚ã«ä½¿ç”¨ã—ã¾ã™ã€‚",
    "summary": "ã‚³ãƒ¼ãƒ‰å¤‰æ›´ã‚’é©åˆ‡ãªgitã‚³ãƒŸãƒƒãƒˆæˆ¦ç•¥ã§git commitã—ã¾ã™ã€‚åŸºæœ¬éƒ½æ˜¯æ—¢å­˜gitã‚³ãƒŸãƒƒãƒˆã¸ã®squashæˆ¦ç•¥ã‚’æ¡ç”¨ã€‚",
    "icon": "ğŸ“¦",
    "version": "1.0.0",
    "author": "AKABANAKK",
    "license": "MIT",
    "tags": [
      "git",
      "commit",
      "version-control",
      "workflow"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "external_commands",
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings are false positives. External commands are standard git operations (commit, log, status, rebase) for version control. No command injection risk - subcommands are hardcoded. Network finding is metadata field only. High-entropy string alerts triggered by documentation examples, not malicious code.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 16,
            "line_end": 19
          },
          {
            "file": "SKILL.md",
            "line_start": 40,
            "line_end": 43
          },
          {
            "file": "examples.md",
            "line_start": 13,
            "line_end": 30
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 57,
            "line_end": 60
          },
          {
            "file": "reference.md",
            "line_start": 21,
            "line_end": 30
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 4,
    "total_lines": 1907,
    "audit_model": "claude",
    "audited_at": "2026-01-21T15:17:39.395Z"
  },
  "content": {
    "user_title": "Create quality git commits",
    "value_statement": "Developers struggle with inconsistent commit messages and messy git history. This skill automates commit creation using proven strategies like squash-and-merge to maintain clean, readable repository history.",
    "seo_keywords": [
      "Claude",
      "Codex",
      "Claude Code",
      "git",
      "commit",
      "git commit",
      "commit message",
      "version control",
      "squash commit",
      "git workflow"
    ],
    "actual_capabilities": [
      "Creates commits using intelligent squash strategy for clean history",
      "Rebases and rewrites branch commit history when needed",
      "Generates well-formatted commit messages automatically",
      "Follows conventional commit standards for better changelogs"
    ],
    "limitations": [
      "Cannot access remote repositories directly",
      "Requires git to be installed and initialized",
      "Limited customization of commit message templates",
      "May not support all git workflows out of the box"
    ],
    "use_cases": [
      {
        "title": "Finish implementation and commit",
        "description": "Automatically stages changes, squash existing commits, and create a single quality commit message when feature implementation is complete.",
        "target_user": "Individual developers"
      },
      {
        "title": "Clean up feature branch",
        "description": "Rebase and reorganize multiple work-in-progress commits into a clean commit sequence before merging to main branch.",
        "target_user": "Feature team members"
      },
      {
        "title": "Standardize team commits",
        "description": "Enforce consistent commit message format across team members with automatic formatting and validation.",
        "target_user": "Engineering teams"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic commit",
        "prompt": "Create a git commit for my changes. Use squash strategy to combine related commits into one.",
        "scenario": "Quick commit for completed work"
      },
      {
        "title": "Feature completion",
        "prompt": "I finished implementing the feature. Stage all relevant changes, squash work-in-progress commits, and create a descriptive commit message.",
        "scenario": "Feature branch completion"
      },
      {
        "title": "Before merge",
        "prompt": "Clean up this branch before merge. Squash fixup commits, rebase on main, and create a single well-structured commit.",
        "scenario": "Pull request preparation"
      },
      {
        "title": "Team workflow",
        "prompt": "Create a commit following our team conventions. Use conventional commits format, reference any issue numbers, and ensure the message describes the change clearly.",
        "scenario": "Team standardized workflow"
      }
    ],
    "output_examples": [
      {
        "input": "Commit my changes with squash strategy",
        "output": "Created commit abc1234:\nfeat(api): add user authentication endpoint\n\n- Implement JWT-based login\n- Add password hashing with bcrypt\n- Create auth middleware\n- Add unit tests for auth module"
      },
      {
        "input": "Finish feature and commit",
        "output": "Squashed 5 commits into one:\nrefactor(database): optimize query performance\n\n- Add index on user_email column\n- Cache frequently accessed data\n- Reduce query complexity from O(n) to O(log n)"
      }
    ],
    "best_practices": [
      "Use squash strategy to keep history clean and readable",
      "Create atomic commits that represent single logical changes",
      "Write commit messages that explain why, not just what changed",
      "Rebase before merge to maintain linear history"
    ],
    "anti_patterns": [
      "Creating commits without reviewing the diff first",
      "Using default commit messages without modification",
      "Merging without cleaning up fixup or WIP commits",
      "Committing unrelated changes in a single commit"
    ],
    "faq": [
      {
        "question": "What is the squash strategy?",
        "answer": "Squash combines multiple related commits into one. This keeps git history clean by replacing several small commits with a single comprehensive commit."
      },
      {
        "question": "Does this modify remote branches?",
        "answer": "No. This skill only operates on local commits. You must push changes manually after creating commits."
      },
      {
        "question": "Can I customize commit message format?",
        "answer": "The skill uses conventional commits format by default. You can provide custom message guidance in your prompt."
      },
      {
        "question": "What if I have merge conflicts?",
        "answer": "The skill will pause and alert you to resolve conflicts manually before continuing with the commit process."
      },
      {
        "question": "Does this work with GitHub Flow?",
        "answer": "Yes. The squash strategy works well with GitHub Flow by creating clean, descriptive commits before opening pull requests."
      },
      {
        "question": "Is my work safe during rebase?",
        "answer": "Yes. Rebase only rewrites local commit history. Your changes are preserved. Force push only after you confirm the result."
      }
    ]
  },
  "file_structure": [
    {
      "name": "examples.md",
      "type": "file",
      "path": "examples.md",
      "lines": 351
    },
    {
      "name": "reference.md",
      "type": "file",
      "path": "reference.md",
      "lines": 254
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 148
    }
  ]
}
