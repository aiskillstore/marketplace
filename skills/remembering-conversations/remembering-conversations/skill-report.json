{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-02-07T08:40:13.321Z",
    "slug": "remembering-conversations",
    "source_url": "https://github.com/obra/episodic-memory/tree/main/skills/remembering-conversations/",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "28f5ca1756b1c621cf41c27ae7d541d29104df79666b779041f33e804826534f",
    "tree_hash": "9d1ae793e503e78e50fe4c5d0f0c17f1efdc9a2808378a9e3315a58e3d9b817f"
  },
  "skill": {
    "name": "remembering-conversations",
    "description": "Search past conversations to avoid repeating work and find decisions, patterns, and solutions from previous sessions. Reduces context window usage by 50-100x through intelligent search.",
    "summary": "Search past conversations to avoid repeating work and find decisions, patterns, and solutions",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "obra",
    "license": "MIT",
    "category": "productivity",
    "tags": [
      "Claude Code",
      "Claude",
      "Codex",
      "conversation memory",
      "search"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "No confirmed security issues. Static scanner flagged multiple false positives including Ruby/shell backtick execution and hidden file access. The skill is pure documentation/reference material with no actual code execution, network access, or file system operations. Risk factors are documented by the scanner but apply only to the documentation examples, not actual functionality.",
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "risk_factor_evidence": [],
    "files_scanned": 2,
    "total_lines": 204,
    "audit_model": "claude",
    "audited_at": "2026-02-07T08:40:13.321Z"
  },
  "content": {
    "user_title": "Search Past Conversations",
    "value_statement": "Avoid repeating work by finding previous decisions, patterns, and solutions. Reduces context window usage by 50-100x through intelligent search of conversation history.",
    "seo_keywords": [
      "Claude Code",
      "Claude",
      "Codex",
      "conversation search",
      "memory",
      "productivity",
      "context management",
      "reuse"
    ],
    "actual_capabilities": [
      "Search past conversations using semantic or text-based queries",
      "Filter results by date ranges for temporal-specific decisions",
      "Read full conversations in markdown format for detailed review",
      "Focus searches on specific topics like decisions, patterns, gotchas, code examples",
      "Use multi-concept AND searches to find conversations matching multiple criteria"
    ],
    "limitations": [
      "Only searches conversations within configured episodic memory archive",
      "Cannot access current conversation context - requires explicit search for history",
      "Search quality depends on quality of past conversation archiving",
      "Large conversations may require pagination when reading full transcripts"
    ],
    "use_cases": [
      {
        "title": "Architectural Decision Review",
        "description": "When making important architectural choices, search past conversations to find similar decisions, trade-offs discussed, and lessons learned from previous projects. Great for teams adopting Claude Code across multiple projects.",
        "target_user": "Technical leads and architects"
      },
      {
        "title": "Troubleshooting Persistent Issues",
        "description": "When encountering recurring problems that aren't solved by current code exploration, search for previous solutions, similar error patterns, and workarounds already discussed in past sessions.",
        "target_user": "Developers debugging complex issues"
      },
      {
        "title": "Onboarding New Team Members",
        "description": "When team members join a project, search conversation history to identify key decisions, design patterns, and context that would have taken days to discover through code review alone.",
        "target_user": "New developers and team members"
      }
    ],
    "prompt_templates": [
      {
        "title": "Beginner: Simple Topic Search",
        "prompt": "User asks: 'How should I structure the database schema for this feature?'\n\nWhat to do: Search past conversations for database schema discussions, patterns, or examples. Focus on looking for similar architectural patterns and decisions made in previous projects or sessions.",
        "scenario": "Basic topic search after user describes what they want to build"
      },
      {
        "title": "Intermediate: Pattern-Based Search",
        "prompt": "User asks: 'What's the best approach for authentication in a microservices setup?'\n\nWhat to do: Search for 'authentication microservices', 'JWT patterns', and 'auth architecture decisions'. Look for conversations discussing similar patterns, gotchas, and trade-offs. Read top 2-3 most relevant results and synthesize findings.",
        "scenario": "After exploring code, user asks for architectural approach recommendation"
      },
      {
        "title": "Advanced: Multi-Concept AND Search",
        "prompt": "User asks: 'We keep hitting race conditions in our async processing. Any solutions?'\n\nWhat to do: Search for ['race conditions', 'async processing', 'concurrency patterns']. Filter for conversations from the last 6 months to find recent discussions. Read full results and synthesize 200-1000 words of actionable insights.",
        "scenario": "Complex technical problem that isn't solved by current code exploration"
      },
      {
        "title": "Expert: Full Conversation Review",
        "prompt": "User says: 'Can you remember what we decided about error handling last month?'\n\nWhat to do: Search with specific query and date filtering (after: '2025-01-01', before: '2025-02-01'). Read the full conversation to understand the complete context, rationale, and final decision. Provide comprehensive answer with full rationale and trade-offs discussed.",
        "scenario": "User references past work with specific temporal context"
      }
    ],
    "output_examples": [
      {
        "input": "User: 'What's the best pattern for handling external API rate limits?'",
        "output": "Based on past conversations, here are several patterns discussed:\n\n1. **Token Bucket Algorithm**: Used in payment processing projects. Each API client has a bucket of tokens that refill over time. Rate limit errors are handled by waiting and retrying.\n\n2. **Exponential Backoff with Jitter**: Common in microservices. After each error, wait exponentially longer (1s, 2s, 4s, 8s) with random jitter to avoid thundering herd.\n\n3. **Bulk Batching**: When possible, aggregate requests to reduce API calls. Example from a recent project: batched 20 small requests into 3 larger ones.\n\nRecommendation depends on your scale and requirements. For most use cases, Exponential Backoff with Jitter provides good balance of safety and speed."
      },
      {
        "input": "User: 'We're stuck on this deployment issue. Any past solutions?'",
        "output": "Found 5 relevant conversations from last quarter:\n\n**Most relevant (score 0.92):** 'Deployment failures during Blue-Green' - November 2025\nDiscussed Docker volume mounting issues and how to verify new containers are healthy before switching traffic. Key insight: use health check endpoints that verify database connection before accepting traffic.\n\n**Second most relevant (score 0.87):** 'Rollback automation for Kubernetes' - December 2025\nImplemented Helm rollback scripts with automatic artifact retention for debugging. Recommended keeping previous deployments accessible for 7 days.\n\n**Key patterns from all conversations:**\n- Always verify health checks before traffic switching\n- Have automated rollback ready before deployment\n- Keep deployment artifacts for debugging\n\nI've read the full details for the top result. Would you like me to share the complete conversation?"
      }
    ],
    "best_practices": [
      "Search BEFORE starting implementation - it saves time and avoids repeating mistakes",
      "Always read full results rather than relying on just the first few matches",
      "Use date filtering when searching for decisions made during specific time periods",
      "Focus searches on what you're looking for: decisions, patterns, gotchas, code examples",
      "Don't search for things you can find in the current conversation - search is for history only"
    ],
    "anti_patterns": [
      "Searching current conversation context instead of past conversations",
      "Skipping search and starting fresh implementation after reviewing code",
      "Using generic queries like 'solution' instead of specific topics like 'authentication patterns'",
      "Reading raw long conversations without first using search to find relevant sections",
      "Assuming decisions in past conversations still apply without checking context and dates"
    ],
    "faq": [
      {
        "question": "Does this skill access my current conversation?",
        "answer": "No. This skill searches past conversations in your episodic memory archive, not the current conversation. The current conversation is always available to you directly."
      },
      {
        "question": "What if no past conversations match my search?",
        "answer": "The search will return no results. This indicates either no relevant history exists, or the archive needs to be expanded. You can then rely on code exploration and current context."
      },
      {
        "question": "How does the search differ from using Grep or Read?",
        "answer": "This skill searches your episodic memory archive which contains past conversations across sessions and projects. Grep searches current code files, and Read reads current conversations. Use this skill when you need historical context beyond what's in the current session."
      },
      {
        "question": "Can I search across multiple projects?",
        "answer": "Yes, if your episodic memory archive is configured to include multiple projects. The search tool will find conversations from any archived project that match your query."
      },
      {
        "question": "What's the difference between vector and text search?",
        "answer": "Vector search uses semantic similarity (finds related concepts), text search uses exact matching (finds specific phrases), and 'both' combines both approaches. For most cases, 'both' provides the best results."
      },
      {
        "question": "Why are there code examples with hardcoded file paths?",
        "answer": "Those are documentation examples showing how to use the MCP tools programmatically. They're not actual code running in the skill - they illustrate parameter structures. The skill itself doesn't execute these examples."
      }
    ]
  },
  "file_structure": [
    {
      "name": "MCP-TOOLS.md",
      "type": "file",
      "path": "MCP-TOOLS.md",
      "lines": 138
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 66
    }
  ]
}
