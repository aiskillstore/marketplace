{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-16T23:47:42.246Z",
    "slug": "crazydubya-test-coverage-analyzer",
    "source_url": "https://github.com/CrazyDubya/claude-skills/tree/main/test-coverage-analyzer",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "fc889bc13a0541b6210b6c8954404c98401f375abc40d4cf747d85873f27b19b",
    "tree_hash": "780b674f9dfcfa94b0677c9c86c833815c9a6f811ebf1e7439c0252537ed0db4"
  },
  "skill": {
    "name": "test-coverage-analyzer",
    "description": "Analyzes test coverage gaps and suggests test cases for untested code paths. Use when user requests test improvements, coverage analysis, or wants to increase test coverage.",
    "summary": "Analyzes test coverage gaps and suggests test cases for untested code paths. Use when user requests ...",
    "icon": "ðŸ“Š",
    "version": "1.0.0",
    "author": "CrazyDubya",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "testing",
      "code-quality",
      "coverage",
      "test-automation"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "external_commands",
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill is a legitimate test coverage analyzer with no malicious behavior. The bash script parses standard coverage file formats using common CLI tools. All static findings are false positives: external commands (jq, grep, awk) are standard development tools, filesystem access is read-only, and the critical heuristic finding misinterprets benign coverage parsing as dangerous behavior. No network calls, no credential access, no data exfiltration.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "scripts/parse-coverage.sh",
            "line_start": 1,
            "line_end": 144
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "scripts/parse-coverage.sh",
            "line_start": 20,
            "line_end": 112
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [
      {
        "title": "Bash script with external command execution",
        "description": "The parse-coverage.sh script executes external commands including jq, grep, awk, lcov, coverage, and go tools. These are legitimate coverage analysis tools. The script is read-only for coverage data and does not modify system files or exfiltrate data.",
        "locations": [
          {
            "file": "scripts/parse-coverage.sh",
            "line_start": 32,
            "line_end": 89
          }
        ]
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 6,
    "total_lines": 1085,
    "audit_model": "claude",
    "audited_at": "2026-01-16T23:47:42.246Z"
  },
  "content": {
    "user_title": "Analyze test coverage gaps",
    "value_statement": "Identifying untested code paths manually is time consuming. This skill parses coverage reports to find gaps and suggests specific test cases to improve code quality.",
    "seo_keywords": [
      "test coverage analyzer",
      "code coverage",
      "test gap analysis",
      "Claude Code",
      "Claude",
      "Codex",
      "unit test suggestions",
      "test automation",
      "code quality",
      "coverage report"
    ],
    "actual_capabilities": [
      "Detects testing frameworks (Jest, pytest, Go test, JUnit, Mocha, Vitest)",
      "Parses coverage reports in JSON, lcov.info, .coverage, and coverage.out formats",
      "Identifies files and functions with low coverage",
      "Suggests specific test cases for uncovered code paths",
      "Generates test file stubs for JavaScript, Python, and Go",
      "Calculates coverage metrics and prioritizes critical gaps"
    ],
    "limitations": [
      "Does not execute tests or modify source code directly",
      "Requires existing coverage reports to analyze",
      "Cannot generate tests for complex dependencies without user guidance",
      "Limited to supported coverage formats (JSON, lcov, Python, Go)"
    ],
    "use_cases": [
      {
        "target_user": "Quality engineers",
        "title": "Improve coverage metrics",
        "description": "Identify low-coverage files and prioritize test writing efforts based on business impact"
      },
      {
        "target_user": "Developers",
        "title": "Write missing tests",
        "description": "Get specific suggestions for untested code paths with example test cases and assertions"
      },
      {
        "target_user": "Code reviewers",
        "title": "Verify test adequacy",
        "description": "Review coverage gaps before merging code to ensure critical paths are tested"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic coverage check",
        "scenario": "Analyze project coverage",
        "prompt": "Analyze test coverage for this project. Find coverage reports and identify files with the lowest coverage. List the top 5 priorities for adding tests."
      },
      {
        "title": "Generate test cases",
        "scenario": "Create tests for specific file",
        "prompt": "Find coverage gaps in src/utils/validator.js. What lines are untested? Suggest 3 specific test cases to cover the missing paths."
      },
      {
        "title": "Framework detection",
        "scenario": "Check testing setup",
        "prompt": "What testing framework does this project use? Do they have coverage configured? Show me the current coverage summary."
      },
      {
        "title": "Full coverage plan",
        "scenario": "Comprehensive coverage improvement",
        "prompt": "Run a complete coverage analysis. List all files under 60% coverage with specific line numbers and suggested test cases for each gap. Generate test file stubs where helpful."
      }
    ],
    "output_examples": [
      {
        "input": "Analyze test coverage and suggest improvements",
        "output": [
          "Coverage Summary: 67% overall (Statements: 65%, Branches: 58%, Functions: 72%)",
          "Priority 1: src/payment/processor.js (23% coverage) - Missing error handling for payment failures, retry logic tests",
          "Priority 2: src/auth/validator.js (45% coverage) - Missing invalid token handling, expired session tests",
          "Suggested Test: Validate that validateEmail rejects invalid formats (covers lines 15-18)",
          "Suggested Test: Test empty string input handling (covers lines 23-25)"
        ]
      }
    ],
    "best_practices": [
      "Focus on critical paths first: authentication, payments, and data validation",
      "Test behavior over implementation details for maintainable tests",
      "Set minimum coverage thresholds (e.g., 80%) and track progress over time"
    ],
    "anti_patterns": [
      "Writing tests only to increase coverage numbers without validating behavior",
      "Ignoring edge cases and error handling paths in tests",
      "Testing private methods or implementation details instead of public APIs"
    ],
    "faq": [
      {
        "question": "What coverage formats are supported?",
        "answer": "Jest coverage-summary.json, lcov.info, Python .coverage, and Go coverage.out formats are supported."
      },
      {
        "question": "What is a good coverage target?",
        "answer": "80% is a common target, but prioritize business-critical code over achieving 100% coverage."
      },
      {
        "question": "Does this modify my code?",
        "answer": "No. This skill only reads coverage data and suggests tests. It does not modify source or test files."
      },
      {
        "question": "Is my code data safe?",
        "answer": "Yes. All analysis happens locally. Code is only read to identify gaps, never transmitted externally."
      },
      {
        "question": "Why no coverage report found?",
        "answer": "Run your test suite with coverage: npm test -- --coverage, pytest --cov, or go test -cover."
      },
      {
        "question": "How is this different from coverage tools?",
        "answer": "Coverage tools show what is covered. This skill explains what is NOT covered and suggests specific tests."
      }
    ]
  },
  "file_structure": [
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "parse-coverage.sh",
          "type": "file",
          "path": "scripts/parse-coverage.sh",
          "lines": 144
        }
      ]
    },
    {
      "name": "templates",
      "type": "dir",
      "path": "templates",
      "children": [
        {
          "name": "test-template.go",
          "type": "file",
          "path": "templates/test-template.go",
          "lines": 173
        },
        {
          "name": "test-template.js",
          "type": "file",
          "path": "templates/test-template.js",
          "lines": 100
        },
        {
          "name": "test-template.py",
          "type": "file",
          "path": "templates/test-template.py",
          "lines": 141
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 254
    }
  ]
}
