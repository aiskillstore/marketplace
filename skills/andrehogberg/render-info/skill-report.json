{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-16T16:39:44.003Z",
    "slug": "andrehogberg-render-info",
    "source_url": "https://github.com/AndreHogberg/summit-ui/tree/main/.claude/skills/render-info",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "a850decca9b872a5f83c7e899328edf3bb75278075090c0757c0c1e675892b03",
    "tree_hash": "d2fe5a99fc2a733e3fab928af2ed3b169d66ea7494cce26577dd0a6e80185760"
  },
  "skill": {
    "name": "render-info",
    "description": "Using the RendererInfo class in Blazor to detect rendering context and interactivity.",
    "summary": "Using the RendererInfo class in Blazor to detect rendering context and interactivity.",
    "icon": "ðŸ“‹",
    "version": "1.0.0",
    "author": "AndreHogberg",
    "license": "MIT",
    "category": "documentation",
    "tags": [
      "blazor",
      "rendererinfo",
      "render-modes",
      "interactivity",
      "dotnet"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a documentation-only skill containing markdown content about Blazor's RendererInfo class. All 49 static findings are false positives: the scanner misidentified C# Razor syntax (@if, @onclick) as shell commands, triggered on common words in JSON metadata as crypto algorithms, and flagged the source_url field as a network threat. No executable code, scripts, network calls, or filesystem access exists.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 8,
            "line_end": 8
          },
          {
            "file": "SKILL.md",
            "line_start": 12,
            "line_end": 12
          },
          {
            "file": "SKILL.md",
            "line_start": 13,
            "line_end": 13
          },
          {
            "file": "SKILL.md",
            "line_start": 17,
            "line_end": 26
          },
          {
            "file": "SKILL.md",
            "line_start": 26,
            "line_end": 28
          },
          {
            "file": "SKILL.md",
            "line_start": 28,
            "line_end": 29
          },
          {
            "file": "SKILL.md",
            "line_start": 29,
            "line_end": 32
          },
          {
            "file": "SKILL.md",
            "line_start": 32,
            "line_end": 33
          },
          {
            "file": "SKILL.md",
            "line_start": 33,
            "line_end": 34
          },
          {
            "file": "SKILL.md",
            "line_start": 34,
            "line_end": 35
          },
          {
            "file": "SKILL.md",
            "line_start": 35,
            "line_end": 37
          },
          {
            "file": "SKILL.md",
            "line_start": 37,
            "line_end": 39
          },
          {
            "file": "SKILL.md",
            "line_start": 39,
            "line_end": 44
          },
          {
            "file": "SKILL.md",
            "line_start": 44,
            "line_end": 44
          },
          {
            "file": "SKILL.md",
            "line_start": 44,
            "line_end": 46
          },
          {
            "file": "SKILL.md",
            "line_start": 46,
            "line_end": 50
          },
          {
            "file": "SKILL.md",
            "line_start": 50,
            "line_end": 55
          },
          {
            "file": "SKILL.md",
            "line_start": 55,
            "line_end": 67
          },
          {
            "file": "SKILL.md",
            "line_start": 67,
            "line_end": 70
          },
          {
            "file": "SKILL.md",
            "line_start": 70,
            "line_end": 70
          },
          {
            "file": "SKILL.md",
            "line_start": 70,
            "line_end": 70
          },
          {
            "file": "SKILL.md",
            "line_start": 70,
            "line_end": 70
          },
          {
            "file": "SKILL.md",
            "line_start": 70,
            "line_end": 70
          },
          {
            "file": "SKILL.md",
            "line_start": 70,
            "line_end": 70
          },
          {
            "file": "SKILL.md",
            "line_start": 70,
            "line_end": 70
          },
          {
            "file": "SKILL.md",
            "line_start": 70,
            "line_end": 73
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 251,
    "audit_model": "claude",
    "audited_at": "2026-01-16T16:39:44.003Z"
  },
  "content": {
    "user_title": "Detect Blazor render modes with RendererInfo",
    "value_statement": "Blazor components need different behavior during static rendering versus interactive modes. This skill provides documentation and code examples for using RendererInfo to detect rendering context, disable inputs during prerendering, and conditionally render content based on interactivity.",
    "seo_keywords": [
      "RendererInfo Blazor",
      "Blazor render modes",
      "detect interactivity Blazor",
      "InteractiveServer",
      "InteractiveWebAssembly",
      "Blazor prerendering",
      "Server-side rendering Blazor",
      "Client-side rendering Blazor",
      "Claude Code Blazor",
      "Blazor component lifecycle"
    ],
    "actual_capabilities": [
      "Detect if component is interactive using RendererInfo.IsInteractive",
      "Identify render mode name (Static, Server, WebAssembly, WebView)",
      "Disable inputs during prerendering phase",
      "Conditionally render static vs interactive content",
      "Use AssignedRenderMode for component-level render mode detection"
    ],
    "limitations": [
      "RendererInfo is available in .NET 8.0 and later only",
      "AssignedRenderMode may be null during static rendering",
      "Cannot change render mode at runtime once component is initialized",
      "Documentation only - no code execution or file generation"
    ],
    "use_cases": [
      {
        "target_user": "Blazor developers",
        "title": "Fix prerendering bugs",
        "description": "Disable buttons and inputs during server prerendering to prevent user confusion when event handlers are not yet active."
      },
      {
        "target_user": "UI/UX designers",
        "title": "Adaptive UI patterns",
        "description": "Show simplified HTML forms for static SSR and rich interactive components for WebAssembly or Server modes."
      },
      {
        "target_user": "Full-stack developers",
        "title": "Debug render issues",
        "description": "Display current render mode in application for troubleshooting unexpected behavior across different hosting models."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic usage",
        "scenario": "Check if component is interactive",
        "prompt": "How do I use RendererInfo.IsInteractive in Blazor to check if my component is running interactively?"
      },
      {
        "title": "Render mode detection",
        "scenario": "Identify current renderer",
        "prompt": "What are the possible values for RendererInfo.Name and what do they mean in Blazor?"
      },
      {
        "title": "Prerendering handling",
        "scenario": "Disable inputs during prerender",
        "prompt": "How do I disable a button during Blazor prerendering so users cannot click it before JavaScript loads?"
      },
      {
        "title": "Content switching",
        "scenario": "Static vs interactive content",
        "prompt": "Show me how to render a simple HTML form for static SSR and a Blazor component for interactive modes using RendererInfo."
      }
    ],
    "output_examples": [
      {
        "input": "How do I check if my Blazor component is interactive?",
        "output": [
          "Use RendererInfo.IsInteractive to check interactivity status",
          "During prerendering or static SSR, IsInteractive returns false",
          "In Interactive Server or WebAssembly modes, it returns true",
          "Example: @if (!RendererInfo.IsInteractive) { <p>Loading...</p> } else { <button @onclick=\"Submit\">Submit</button> }"
        ]
      },
      {
        "input": "What are the different render modes in Blazor?",
        "output": [
          "Static: Running in server-side rendering without interactivity",
          "Server: Interactive Server mode using SignalR connections",
          "WebAssembly: Client-side rendering in browser via WebAssembly",
          "WebView: Hybrid apps running in MAUI, WPF, or WinForms"
        ]
      },
      {
        "input": "How do I handle prerendering in Blazor?",
        "output": [
          "Check RendererInfo.IsInteractive before rendering interactive elements",
          "Show loading state when IsInteractive is false",
          "Disable event handlers like @onclick during prerendering",
          "Use RendererInfo.Name to conditionally render static or interactive content"
        ]
      }
    ],
    "best_practices": [
      "Check RendererInfo.IsInteractive before attaching event handlers to prevent errors during prerendering",
      "Use RendererInfo.Name for logging and debugging to understand which renderer is active",
      "Combine RendererInfo with ComponentBase.AssignedRenderMode for complete render mode awareness"
    ],
    "anti_patterns": [
      "Assuming event handlers work during prerendering without checking RendererInfo.IsInteractive",
      "Using hardcoded renderer names instead of the built-in constants or detection methods",
      "Relying solely on AssignedRenderMode during prerendering since it may be null"
    ],
    "faq": [
      {
        "question": "What .NET version supports RendererInfo?",
        "answer": "RendererInfo is available in .NET 8.0 and later versions only."
      },
      {
        "question": "What are the possible RendererInfo.Name values?",
        "answer": "Static, Server, WebAssembly, and WebView depending on the hosting model."
      },
      {
        "question": "How does RendererInfo differ from AssignedRenderMode?",
        "answer": "RendererInfo shows current runtime state; AssignedRenderMode shows what was assigned to the component."
      },
      {
        "question": "Is data safe with this skill?",
        "answer": "Yes, this is a documentation-only skill with no file access or network calls."
      },
      {
        "question": "Why are buttons sometimes disabled in my Blazor app?",
        "answer": "Buttons may be disabled during prerendering when event handlers are not yet active. Use RendererInfo.IsInteractive to control this."
      },
      {
        "question": "Can I use this with Blazor Hybrid apps?",
        "answer": "Yes, RendererInfo.Name returns WebView for Blazor Hybrid applications running in MAUI, WPF, or WinForms."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 75
    }
  ]
}
