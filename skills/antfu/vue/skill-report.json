{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-30T08:50:53.891Z",
    "slug": "antfu-vue",
    "source_url": "https://github.com/antfu/skills/tree/main/skills/vue/",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "47ab92815e89ae1ebeb11f9dc9d20a64f6567057fc3509c9c076824969e8a5c3",
    "tree_hash": "191c2c29d47c9029127163dc363b16bc2366741049a1d6d16d519fbcc6e1843e"
  },
  "skill": {
    "name": "vue",
    "description": "Vue.js progressive JavaScript framework. Use when building Vue components, working with reactivity (ref, reactive, computed, watch), or implementing Vue Composition API patterns.",
    "summary": "Vue.js framework documentation for building reactive components using Composition API patterns.",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "antfu",
    "license": "MIT",
    "tags": [
      "vue",
      "vue3",
      "javascript",
      "frontend",
      "composition-api",
      "reactivity"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "network"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Documentation-only skill containing Vue.js reference materials. All 493 flagged patterns are in markdown documentation files and represent code examples, not executable code. No actual security risks identified. Safe for publication.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "GENERATION.md",
            "line_start": 3,
            "line_end": 4
          },
          {
            "file": "SKILL.md",
            "line_start": 14,
            "line_end": 61
          }
        ]
      },
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "references/advanced-async-suspense.md",
            "line_start": 68,
            "line_end": 73
          }
        ]
      },
      {
        "factor": "network",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 7,
            "line_end": 7
          },
          {
            "file": "references/core-reactivity.md",
            "line_start": 239,
            "line_end": 288
          },
          {
            "file": "references/features-typescript.md",
            "line_start": 249,
            "line_end": 273
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [
      {
        "title": "Documentation Pattern False Positives",
        "description": "All 'external_commands', 'scripts', and 'network' patterns are in markdown documentation files. These represent code examples in documentation, not executable code. The static scanner cannot distinguish documentation examples from actual code. No security risk exists.",
        "locations": [
          {
            "file": "references/core-reactivity.md",
            "line_start": 12,
            "line_end": 12
          },
          {
            "file": "references/core-reactivity.md",
            "line_start": 239,
            "line_end": 263
          },
          {
            "file": "references/features-typescript.md",
            "line_start": 14,
            "line_end": 257
          },
          {
            "file": "SKILL.md",
            "line_start": 14,
            "line_end": 61
          }
        ],
        "verdict": "FALSE_POSITIVE",
        "confidence": 0.95,
        "confidence_reasoning": "All patterns are in .md markdown files containing Vue.js documentation. Backtick syntax in documentation is code examples, not shell execution. No executable code exists in this skill."
      }
    ],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 15,
    "total_lines": 2937,
    "audit_model": "claude",
    "audited_at": "2026-01-30T08:50:53.891Z"
  },
  "content": {
    "user_title": "Build Vue.js Components",
    "value_statement": "Building Vue.js applications requires understanding reactive state management, component composition, and modern JavaScript patterns. This skill provides expert guidance on Vue Composition API, component design, and reactivity fundamentals.",
    "seo_keywords": [
      "Vue.js",
      "Vue 3",
      "Composition API",
      "Vue components",
      "reactivity",
      "ref",
      "reactive",
      "computed",
      "watch",
      "Vue directives",
      "Vue slots",
      "Vue props",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Guide Vue component architecture using Composition API patterns",
      "Explain reactive primitives (ref, reactive, computed, watch) and their use cases",
      "Provide examples for component communication (props, emits, v-model, slots)",
      "Show TypeScript integration patterns with Vue components",
      "Demonstrate advanced features like Suspense, async components, and provide/inject",
      "Explain template refs and DOM access patterns in Vue"
    ],
    "limitations": [
      "This is a documentation skill - it provides reference information, not code execution",
      "Does not install or configure Vue projects",
      "Does not run or test Vue code",
      "Does not provide backend or deployment guidance"
    ],
    "use_cases": [
      {
        "title": "Building a Reactive Component",
        "description": "Learn how to create Vue components with reactive state using ref, reactive, and computed properties.",
        "target_user": "Frontend developers new to Vue 3"
      },
      {
        "title": "Component Communication Patterns",
        "description": "Master props, custom events, v-model binding, and scoped slots for flexible component APIs.",
        "target_user": "Vue developers building reusable component libraries"
      },
      {
        "title": "TypeScript with Vue Composition API",
        "description": "Write type-safe Vue components with proper TypeScript annotations and inference.",
        "target_user": "Developers adding TypeScript to Vue projects"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Vue Component",
        "prompt": "Show me how to create a basic Vue 3 component using the Composition API with script setup. Include reactive state with ref and a computed property.",
        "scenario": "Learning Vue 3 basics"
      },
      {
        "title": "Custom v-model Component",
        "prompt": "How do I create a custom component that supports v-model? Show how to handle modelValue prop and update:modelValue emit events.",
        "scenario": "Building form components with two-way binding"
      },
      {
        "title": "Composable Pattern",
        "prompt": "Explain the composable pattern in Vue 3. Show how to extract and reuse stateful logic across multiple components using the use prefix convention.",
        "scenario": "Sharing logic between components"
      },
      {
        "title": "TypeScript Component",
        "prompt": "Write a Vue 3 component with full TypeScript support. Include typed props with defineProps, typed emits with defineEmits, and proper inference for refs.",
        "scenario": "Type-safe Vue component development"
      }
    ],
    "output_examples": [
      {
        "input": "How do I use ref vs reactive in Vue 3?",
        "output": [
          "Use ref for primitive values and when you need to replace the entire value.",
          "Use reactive for objects when you want deep reactivity.",
          "ref requires .value in script but not in template.",
          "reactive cannot be destructured without losing reactivity - use toRefs() instead."
        ]
      },
      {
        "input": "When should I use slots in Vue components?",
        "output": [
          "Use slots when you want to pass template content to child components.",
          "Named slots enable multiple insertion points with v-slot directive.",
          "Scoped slots allow child components to pass data back to slot content.",
          "Fallback content displays when no slot content is provided."
        ]
      },
      {
        "input": "How does Vue reactivity work under the hood?",
        "output": [
          "Vue uses Proxy-based reactivity for reactive().",
          "ref uses an object with a private value property.",
          "Dependencies are tracked during render and effect execution.",
          "When dependencies change, effects are re-run automatically."
        ]
      }
    ],
    "best_practices": [
      "Use script setup syntax for cleaner, more concise components with better TypeScript support",
      "Use ref for primitives and reactive for objects - destructure reactive with toRefs()",
      "Use computed for derived state instead of methods to benefit from caching"
    ],
    "anti_patterns": [
      "Avoid using reactive on primitives - use ref instead",
      "Do not destructure reactive objects without toRefs() - you lose reactivity",
      "Avoid mutating props directly - emit events to update parent state"
    ],
    "faq": [
      {
        "question": "What is the difference between ref and reactive in Vue 3?",
        "answer": "ref creates a reactive wrapper for any value type and requires .value access in script. reactive creates a proxy for objects and maintains deep reactivity. ref is preferred for primitives; reactive for nested objects."
      },
      {
        "question": "How do I share state between components in Vue?",
        "answer": "Options include props/emits for parent-child, provide/inject for ancestor-descendant, Pinia for global state, and composables for reusable stateful logic."
      },
      {
        "question": "What is the Composition API?",
        "answer": "The Composition API is a set of functions (ref, reactive, computed, watch, lifecycle hooks) that allow organizing code by feature rather than options object. It enables better TypeScript support and logic reuse."
      },
      {
        "question": "How do I use v-model on a custom component?",
        "answer": "Accept a modelValue prop and emit update:modelValue. For multiple models, use defineModel or custom naming with v-model:propName."
      },
      {
        "question": "What are lifecycle hooks available in Composition API?",
        "answer": "onMounted, onUpdated, onUnmounted, onBeforeMount, onBeforeUpdate, onBeforeUnmount, onErrorCaptured, and others matching Options API hooks."
      },
      {
        "question": "How do I access DOM elements in Vue 3?",
        "answer": "Use template refs with ref() function. Assign the ref to an element with ref attribute. Access the element via ref.value after component mount."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "advanced-async-suspense.md",
          "type": "file",
          "path": "references/advanced-async-suspense.md",
          "lines": 247
        },
        {
          "name": "advanced-provide-inject.md",
          "type": "file",
          "path": "references/advanced-provide-inject.md",
          "lines": 175
        },
        {
          "name": "components-emits.md",
          "type": "file",
          "path": "references/components-emits.md",
          "lines": 140
        },
        {
          "name": "components-lifecycle.md",
          "type": "file",
          "path": "references/components-lifecycle.md",
          "lines": 193
        },
        {
          "name": "components-props.md",
          "type": "file",
          "path": "references/components-props.md",
          "lines": 212
        },
        {
          "name": "components-slots.md",
          "type": "file",
          "path": "references/components-slots.md",
          "lines": 202
        },
        {
          "name": "components-v-model.md",
          "type": "file",
          "path": "references/components-v-model.md",
          "lines": 184
        },
        {
          "name": "core-reactivity.md",
          "type": "file",
          "path": "references/core-reactivity.md",
          "lines": 290
        },
        {
          "name": "features-composables.md",
          "type": "file",
          "path": "references/features-composables.md",
          "lines": 263
        },
        {
          "name": "features-directives.md",
          "type": "file",
          "path": "references/features-directives.md",
          "lines": 225
        },
        {
          "name": "features-script-setup.md",
          "type": "file",
          "path": "references/features-script-setup.md",
          "lines": 248
        },
        {
          "name": "features-template-refs.md",
          "type": "file",
          "path": "references/features-template-refs.md",
          "lines": 213
        },
        {
          "name": "features-typescript.md",
          "type": "file",
          "path": "references/features-typescript.md",
          "lines": 275
        }
      ]
    },
    {
      "name": "GENERATION.md",
      "type": "file",
      "path": "GENERATION.md",
      "lines": 6
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 64
    }
  ]
}
