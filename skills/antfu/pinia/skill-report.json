{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-30T08:51:01.169Z",
    "slug": "antfu-pinia",
    "source_url": "https://github.com/antfu/skills/tree/main/skills/pinia/",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "529b7c35001298f8e5869fbbe55c4c8a2af8e50a145122a4d66b0a7ed1e74343",
    "tree_hash": "00b91bb0ef25c244026a6d5f788f04e05cfe9c9840713e3b28d89578a793d7e9"
  },
  "skill": {
    "name": "pinia",
    "description": "Pinia official Vue state management library, type-safe and extensible. Use when defining stores, working with state/getters/actions, or implementing store patterns in Vue apps.",
    "summary": "Pinia official Vue state management library, type-safe and extensible. Use when defining stores, wor...",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "antfu",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "vue",
      "state-management",
      "pinia",
      "vue-composition-api",
      "typescript"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All 292 static findings are false positives. This skill contains only markdown documentation with code examples for Pinia (official Vue state management library). No executable code, network operations, file system access, or command execution. Scanner misinterpreted markdown code blocks as shell commands and function names like defineStore as cryptographic functions.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 11,
    "total_lines": 1543,
    "audit_model": "claude",
    "audited_at": "2026-01-30T08:51:01.169Z"
  },
  "content": {
    "user_title": "Define Vue stores with Pinia",
    "value_statement": "Building Vue applications requires predictable state management across components. Pinia provides a type-safe, intuitive API for defining stores with state, getters, and actions. This skill provides comprehensive references for building scalable Vue state management patterns.",
    "seo_keywords": [
      "Pinia",
      "Vue state management",
      "Vue store",
      "Vue Composition API",
      "Vue reactive state",
      "Vuex alternative",
      "TypeScript Vue",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Define stores using Options API or Composition API syntax",
      "Manage state, getters, and actions with full TypeScript support",
      "Compose multiple stores together for modular architecture",
      "Extend stores with custom plugins for shared functionality",
      "Test stores with @pinia/testing utilities",
      "Implement SSR state hydration and Nuxt integration"
    ],
    "limitations": [
      "Does not provide runtime code execution or file operations",
      "Does not install or configure Pinia in Vue projects",
      "Does not generate boilerplate code automatically",
      "Does not include Vue component examples beyond store usage"
    ],
    "use_cases": [
      {
        "title": "Building user authentication stores",
        "description": "Create Pinia stores to manage user sessions, authentication state, and permissions across Vue applications.",
        "target_user": "Vue developers building authenticated applications"
      },
      {
        "title": "Implementing cart and checkout flows",
        "description": "Design stores for e-commerce functionality including shopping cart state, product catalogs, and order processing.",
        "target_user": "Frontend developers working on e-commerce platforms"
      },
      {
        "title": "Creating shared UI state libraries",
        "description": "Develop reusable Pinia plugins and composable stores for theme management, modal dialogs, and notification systems.",
        "target_user": "Library authors and component developers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic store creation",
        "prompt": "How do I define a Pinia store for managing user preferences like theme and language settings? Show both Options API and Composition API approaches.",
        "scenario": "Learning store definition basics"
      },
      {
        "title": "Getters and computed state",
        "prompt": "Create a Pinia store for a shopping cart that uses getters to calculate subtotal, tax, and total. Show how to access these computed values in components.",
        "scenario": "Implementing computed store values"
      },
      {
        "title": "Store actions with TypeScript",
        "prompt": "Write a Pinia store for handling async API calls with proper TypeScript typing for actions, payload, and return values. Include error handling patterns.",
        "scenario": "Building typed async store actions"
      },
      {
        "title": "Cross-store communication",
        "prompt": "How can I compose multiple Pinia stores together? Show a pattern where an auth store provides user data that a cart store uses for personalization.",
        "scenario": "Composing stores for modular architecture"
      }
    ],
    "output_examples": [
      {
        "input": "How do I persist Pinia state to localStorage?",
        "output": [
          "Use a Pinia plugin to synchronize state with localStorage:",
          "",
          "```ts",
          "import { defineStore } from 'pinia'",
          "import { watch } from 'vue'",
          "",
          "export const useCounterStore = defineStore('counter', {",
          "  state: () => ({ count: 0, name: 'Eduardo' }),",
          "})",
          "",
          "// Watch for changes and persist to localStorage",
          "watch(",
          "  useCounterStore(),",
          "  (state) => {",
          "    localStorage.setItem('counter', JSON.stringify(state))",
          "  },",
          "  { deep: true }",
          ")",
          "```"
        ]
      },
      {
        "input": "What is the difference between Option Stores and Setup Stores?",
        "output": [
          "**Option Stores** use an object with properties like state, getters, and actions:",
          "",
          "```ts",
          "export const useCounterStore = defineStore('counter', {",
          "  state: () => ({ count: 0 }),",
          "  getters: { doubleCount: (state) => state.count * 2 },",
          "  actions: { increment() { this.count++ } }",
          "})",
          "```",
          "",
          "**Setup Stores** use a function returning refs and functions:",
          "",
          "```ts",
          "export const useCounterStore = defineStore('counter', () => {",
          "  const count = ref(0)",
          "  const doubleCount = computed(() => count.value * 2)",
          "  function increment() { count.value++ }",
          "  return { count, doubleCount, increment }",
          "})",
          "```"
        ]
      },
      {
        "input": "How do I reset all stores in tests?",
        "output": [
          "Use setActivePinia and createPinia with beforeEach:",
          "",
          "```ts",
          "import { setActivePinia, createPinia } from 'pinia'",
          "",
          "beforeEach(() => {",
          "  const pinia = createPinia()",
          "  setActivePinia(pinia)",
          "})",
          "",
          "it('resets state', () => {",
          "  const store = useCounterStore()",
          "  store.count = 5",
          "  // Reset for next test",
          "  store.$reset()",
          "  expect(store.count).toBe(0)",
          "})",
          "```"
        ]
      }
    ],
    "best_practices": [
      "Use setup stores for complex logic with composables, watchers, and advanced TypeScript patterns",
      "Return all state properties from setup stores to ensure Pinia tracks reactivity properly",
      "Use storeToRefs() when destructuring state or getters to preserve reactivity"
    ],
    "anti_patterns": [
      "Destructuring state directly without storeToRefs (breaks reactivity)",
      "Calling stores at module scope instead of inside functions (causes SSR issues)",
      "Storing components or non-serializable objects in state (prevents hydration)"
    ],
    "faq": [
      {
        "question": "What is Pinia and why should I use it?",
        "answer": "Pinia is the official state management library for Vue.js. It provides a simpler, type-safe API compared to Vuex with better TypeScript support, smaller bundle size, and a more intuitive composition-based approach."
      },
      {
        "question": "How does Pinia differ from Vuex?",
        "answer": "Pinia eliminates mutations (actions directly modify state), uses a simpler API, provides better TypeScript inference, has no required modules, and supports Vue DevTools 6+ with a more modern plugin system."
      },
      {
        "question": "Can I use Pinia with Options API and Composition API?",
        "answer": "Yes, Pinia supports both approaches. Option Stores resemble Vuex with state, getters, and actions objects. Setup Stores use composition function syntax returning reactive state and methods."
      },
      {
        "question": "How do I test Pinia stores?",
        "answer": "Use @pinia/testing package with createTestingPinia(). This provides mocked stores for unit tests that work with Vue Test Utils. You can stub actions, set initial state, and assert on store behavior."
      },
      {
        "question": "Does Pinia work with server-side rendering?",
        "answer": "Yes, Pinia includes built-in SSR support. Use pinia.state.value to serialize state for hydration and deserialize it on the client. Nuxt has first-class integration with auto-imports."
      },
      {
        "question": "How do I persist Pinia state across page reloads?",
        "answer": "Create a Pinia plugin that watches state changes and writes to localStorage or a cookie. On initialization, read from storage and hydrate state. Popular community plugins like pinia-plugin-persistedstate automate this pattern."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "advanced-hmr.md",
          "type": "file",
          "path": "references/advanced-hmr.md",
          "lines": 62
        },
        {
          "name": "advanced-nuxt.md",
          "type": "file",
          "path": "references/advanced-nuxt.md",
          "lines": 120
        },
        {
          "name": "advanced-ssr.md",
          "type": "file",
          "path": "references/advanced-ssr.md",
          "lines": 122
        },
        {
          "name": "best-practices-outside-component.md",
          "type": "file",
          "path": "references/best-practices-outside-component.md",
          "lines": 116
        },
        {
          "name": "best-practices-testing.md",
          "type": "file",
          "path": "references/best-practices-testing.md",
          "lines": 213
        },
        {
          "name": "core-stores.md",
          "type": "file",
          "path": "references/core-stores.md",
          "lines": 390
        },
        {
          "name": "features-composables.md",
          "type": "file",
          "path": "references/features-composables.md",
          "lines": 115
        },
        {
          "name": "features-composing-stores.md",
          "type": "file",
          "path": "references/features-composing-stores.md",
          "lines": 135
        },
        {
          "name": "features-plugins.md",
          "type": "file",
          "path": "references/features-plugins.md",
          "lines": 204
        }
      ]
    },
    {
      "name": "GENERATION.md",
      "type": "file",
      "path": "GENERATION.md",
      "lines": 6
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 60
    }
  ]
}
