{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T15:18:54.061Z",
    "slug": "cleanexpo-truth-layer",
    "source_url": "https://github.com/CleanExpo/Unite-Hub/tree/main/.claude/skills/truth-layer",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "0dfa7f8b396b79d189c8add8b98ee502fdf2cc64e7df3c7f2b2ae62c07003be3",
    "tree_hash": "d17ba15daba6b1185b6074a5a0e89029a8ac767f0ac5f32bca8b773659136e6a"
  },
  "skill": {
    "name": "truth-layer",
    "description": "Validates all claims, detects false positives, and blocks progress when issues are unresolved using radical honesty-first verification.",
    "summary": "Honesty-first verification agent that validates claims and blocks progress when issues remain unresolved",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "CleanExpo",
    "license": "MIT",
    "category": "productivity",
    "tags": [
      "verification",
      "testing",
      "validation",
      "quality-assurance",
      "build-automation"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "The skill is documentation-only with no executable code. All static findings are false positives from pattern detection in the JSON report itself and example code snippets within the documentation. The skill describes verification workflows but does not implement any network calls, filesystem operations, or command execution.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 451,
    "audit_model": "claude",
    "audited_at": "2026-01-21T15:18:54.061Z"
  },
  "content": {
    "user_title": "Validate Claims with Radical Honesty",
    "value_statement": "Development teams often struggle with false positive reports and undetected blockers that surface at deployment. This skill validates all claims against actual codebase state and blocks progress until issues are genuinely resolved.",
    "seo_keywords": [
      "Claude",
      "Claude Code",
      "Codex",
      "verification",
      "testing",
      "validation",
      "quality assurance",
      "build automation",
      "honesty-first development",
      "blocker detection"
    ],
    "actual_capabilities": [
      "Validates claims against actual codebase state before reporting completion",
      "Detects false positive reports such as successful builds with hidden errors",
      "Identifies blockers that would prevent features from working in production",
      "Provides structured verification reports with confidence levels and root causes",
      "Integrates with build systems and test runners to verify actual outcomes"
    ],
    "limitations": [
      "Requires manual integration with existing CI/CD pipelines and build systems",
      "Does not automatically fix detected issues, only reports and blocks progress",
      "Verification confidence depends on quality of available tooling and logs",
      "May require custom configuration for non-standard project structures"
    ],
    "use_cases": [
      {
        "title": "Prevent False Build Success Reports",
        "description": "Verify that build processes genuinely succeed by running actual build commands and checking for hidden errors in logs rather than trusting status codes alone.",
        "target_user": "DevOps Engineers"
      },
      {
        "title": "Validate Test Coverage Claims",
        "description": "Check that test files contain real test cases rather than empty stubs by analyzing file size and parsing test structure before accepting coverage reports.",
        "target_user": "QA Engineers"
      },
      {
        "title": "Block Deployment with Unresolved Issues",
        "description": "Stop feature deployment when type errors, failing tests, or unresolved dependencies exist even if the build appears to succeed.",
        "target_user": "Software Developers"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Claim Verification",
        "prompt": "Verify that the build completes successfully with no hidden errors or warnings",
        "scenario": "Before marking a feature complete, ensure the build system reports genuine success"
      },
      {
        "title": "Test Coverage Validation",
        "prompt": "Check if test coverage report is backed by actual test cases and not empty stub files",
        "scenario": "After running tests, validate that coverage percentages reflect real test implementation"
      },
      {
        "title": "Blocker Identification",
        "prompt": "Identify all blockers preventing deployment and list dependent features that cannot proceed",
        "scenario": "Before attempting deployment, surface all unresolved issues that would cause failures"
      },
      {
        "title": "End-to-End Feature Validation",
        "prompt": "Validate that the user authentication feature works end-to-end including database, API, and UI layers",
        "scenario": "Advanced validation requiring cross-system verification before feature release"
      }
    ],
    "output_examples": [
      {
        "input": "Verify that the build completes successfully with no hidden errors or warnings",
        "output": "BLOCKER FOUND: Turbopack build fails\n- What failed: Cannot write manifest.json file\n- Impact: Deployment cannot proceed\n- Root cause: Missing directory structure in build output\n- Current state: Build command exits with 0 but manifest not generated\n- Next step: Create output directory structure before build\n\nSTOP PROGRESS on UI changes, API updates, feature deployment\nRoute to: Build Diagnostics Agent"
      },
      {
        "input": "Check if test coverage report is backed by actual test cases",
        "output": "Truth Layer Verification: 2026-01-21T10:30:00Z\n\nCLAIM: 100% test coverage on authentication module\nREALITY: Test file is 412 bytes with empty describe blocks\nCONFIDENCE: 95%\n\nBLOCKERS FOUND: Yes\n- Test file contains no assertions\n- Coverage is false positive from stub file\n\nDEPENDENT FEATURES BLOCKED: Authentication deployment, user management\n\nACTION: Write real test cases with assertions before claiming coverage"
      }
    ],
    "best_practices": [
      "Run actual build and test commands rather than checking cached status to ensure current state accuracy",
      "Set confidence thresholds based on verification method used, with manual inspection having higher confidence than automated checks",
      "Create blocker reports immediately when issues are detected rather than waiting for task completion"
    ],
    "anti_patterns": [
      "Assuming build success from exit codes alone without inspecting logs for hidden errors or warnings",
      "Accepting test coverage percentages without validating that test files contain real assertions and logic",
      "Reporting features as complete before running end-to-end verification across all dependent systems"
    ],
    "faq": [
      {
        "question": "What makes this different from standard CI/CD checks?",
        "answer": "This skill focuses on detecting false positives where automated checks pass but real issues exist, such as builds with hidden Turbopack errors or test coverage from empty stub files."
      },
      {
        "question": "How does the skill determine confidence levels?",
        "answer": "Confidence is based on verification method. Direct command execution and log parsing has higher confidence than status code checks or file existence tests."
      },
      {
        "question": "Will this skill automatically fix detected blockers?",
        "answer": "No. The skill identifies and reports blockers with root cause analysis but does not attempt fixes. It routes issues to appropriate specialist agents."
      },
      {
        "question": "What happens when a blocker is found?",
        "answer": "Progress is immediately halted on dependent features. A structured report is generated with the specific issue, impact, root cause, and recommended next steps."
      },
      {
        "question": "Can this skill work with custom build systems?",
        "answer": "Yes, but it requires configuration to specify which commands to run and which log patterns indicate success or failure for your specific setup."
      },
      {
        "question": "How does this integrate with the Orchestrator agent?",
        "answer": "The skill sits before every agent task, validating preconditions and blocking task execution if issues exist. Valid tasks route to specialist agents while blocked tasks route to diagnostics."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 163
    }
  ]
}
