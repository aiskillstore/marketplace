{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T12:05:57.541Z",
    "slug": "chasewnorton-remix-cache",
    "source_url": "https://github.com/ChaseWNorton/remix-cache/tree/main/remix-cache-skill/",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "40b8127089430e2a4bc81005e460f410f4573382444313fb6a0ebea98a42c931",
    "tree_hash": "9b5b09fc3a7a241c6328df01661a6d044ee6f38f24b06736561dcce4d063a4a5"
  },
  "skill": {
    "name": "remix-cache",
    "description": "A type-safe, Redis-backed caching library for Remix applications with SSE-based real-time invalidation, stale-while-revalidate, pattern matching, and automatic React revalidation. Use when working with Remix caching, Redis, cache invalidation, implementing caching strategies, or real-time data synchronization in Remix apps.",
    "summary": "A type-safe, Redis-backed caching library for Remix applications with SSE-based real-time invalidati...",
    "icon": "âš¡",
    "version": "1.0.0",
    "author": "ChaseWNorton",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "redis",
      "remix",
      "caching",
      "performance"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill contains only documentation and TypeScript code examples for using the remix-cache library. No executable code, scripts, network calls, file system access, or environment variable reading is present. The skill is purely instructional content for implementing caching patterns.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 9,
    "total_lines": 4269,
    "audit_model": "claude",
    "audited_at": "2026-01-10T12:05:57.541Z"
  },
  "content": {
    "user_title": "Implement Redis caching in Remix apps",
    "value_statement": "Remix applications often face slow database queries that impact performance. This skill provides expert guidance on implementing type-safe Redis caching with automatic invalidation, real-time updates via Server-Sent Events, and seamless React integration for instant data synchronization.",
    "seo_keywords": [
      "remix cache",
      "redis caching",
      "remix performance",
      "server-sent events",
      "cache invalidation",
      "stale-while-revalidate",
      "type-safe cache",
      "remix redis",
      "claude",
      "codex",
      "claude code"
    ],
    "actual_capabilities": [
      "Create type-safe Redis cache definitions with automatic TypeScript inference",
      "Implement tag-based, key-based, and pattern-based cache invalidation",
      "Set up SSE endpoints for real-time cache invalidation events",
      "Configure stale-while-revalidate and sliding window TTL strategies",
      "Integrate React hooks for automatic component revalidation",
      "Apply circuit breaker and request deduplication for resilience"
    ],
    "limitations": [
      "Does not provide actual caching code - users implement remix-cache library",
      "Requires existing Redis server to use the patterns described",
      "Does not cover non-Redis cache backends",
      "Focuses on Remix framework patterns - not general caching concepts"
    ],
    "use_cases": [
      {
        "target_user": "Full-stack Remix developers",
        "title": "Optimize database performance",
        "description": "Cache expensive database queries in Remix loaders using Redis with automatic invalidation when data changes."
      },
      {
        "target_user": "E-commerce developers",
        "title": "Build real-time product catalogs",
        "description": "Create product caching with SSE-based inventory updates that immediately reflect across all connected clients."
      },
      {
        "target_user": "SaaS application teams",
        "title": "Implement multi-tenant caching",
        "description": "Design organization-scoped caching with proper tenant isolation and cascading invalidation patterns."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic setup",
        "scenario": "Getting started with remix-cache",
        "prompt": "Help me set up remix-cache in my Remix app. I need to create a cache instance and define a user cache that fetches from my database with a 5-minute TTL."
      },
      {
        "title": "Real-time updates",
        "scenario": "Implementing SSE invalidation",
        "prompt": "Show me how to set up Server-Sent Events with remix-cache so that when I invalidate a cache entry in my action, all connected clients automatically revalidate their data."
      },
      {
        "title": "Complex invalidation",
        "scenario": "Tag-based cascade patterns",
        "prompt": "I want to implement cascading invalidation where invalidating a blog post also invalidates the author's post list, category page, and tag pages. How do I configure the invalidate function in my cache definition?"
      },
      {
        "title": "Production resilience",
        "scenario": "Circuit breaker configuration",
        "prompt": "My Redis connection sometimes fails under load. Help me configure the circuit breaker pattern in remix-cache so my app degrades gracefully when Redis is unavailable."
      }
    ],
    "output_examples": [
      {
        "input": "Set up a user cache that automatically invalidates when user data changes",
        "output": [
          "1. Create cache instance with Redis configuration",
          "2. Define userCache with name, key function, fetch function, and TTL",
          "3. Add tags like ['user', 'user:123'] to cache definition",
          "4. Invalidate by tag in actions: await cache.invalidateByTag('user')",
          "5. Wrap app with CacheProvider in root.tsx",
          "6. Add useCache({ tags: ['user'] }) to components"
        ]
      }
    ],
    "best_practices": [
      "Always include user ID in cache keys to prevent cross-user data leaks",
      "Set up error event listeners to monitor cache failures in production",
      "Use tags for invalidation rather than specific keys for better flexibility"
    ],
    "anti_patterns": [
      "Caching user-specific data with shared keys that return same data for all users",
      "Forgetting to invalidate cache after data updates in actions",
      "Caching sensitive data like passwords or tokens without proper sanitization"
    ],
    "faq": [
      {
        "question": "What Redis permissions does remix-cache require?",
        "answer": "Remix-cache needs basic Redis commands: GET, SET, DEL, SCAN, and SET operations for tags. No admin commands required."
      },
      {
        "question": "What is the maximum number of cache entries?",
        "answer": "Redis can handle millions of keys. Local LRU cache defaults to 1000 items but is configurable based on memory constraints."
      },
      {
        "question": "Does this work with Vercel or other serverless platforms?",
        "answer": "Yes, use serverless mode which disables local cache and uses versioned Redis keys. Compatible with Upstash Redis on Vercel."
      },
      {
        "question": "Is cached data encrypted at rest?",
        "answer": "Redis handles data storage. For sensitive data, sanitize before caching and consider Redis encryption options or encrypted storage backends."
      },
      {
        "question": "Why are my cache misses happening every request?",
        "answer": "Common causes: TTL is 0, cache key includes dynamic values like timestamps, or Redis connection is failing. Check event listeners for errors."
      },
      {
        "question": "How is this different from built-in Remix HTTP caching?",
        "answer": "Remix HTTP caching controls browser/CDN caching. Remix-cache provides server-side data caching with Redis, enabling shared cache across server instances and real-time invalidation."
      }
    ]
  },
  "file_structure": [
    {
      "name": "API_REFERENCE.md",
      "type": "file",
      "path": "API_REFERENCE.md"
    },
    {
      "name": "EXAMPLES.md",
      "type": "file",
      "path": "EXAMPLES.md"
    },
    {
      "name": "GETTING_STARTED.md",
      "type": "file",
      "path": "GETTING_STARTED.md"
    },
    {
      "name": "PATTERNS.md",
      "type": "file",
      "path": "PATTERNS.md"
    },
    {
      "name": "REACT_INTEGRATION.md",
      "type": "file",
      "path": "REACT_INTEGRATION.md"
    },
    {
      "name": "README.md",
      "type": "file",
      "path": "README.md"
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    },
    {
      "name": "TESTING.md",
      "type": "file",
      "path": "TESTING.md"
    },
    {
      "name": "TROUBLESHOOTING.md",
      "type": "file",
      "path": "TROUBLESHOOTING.md"
    }
  ]
}
