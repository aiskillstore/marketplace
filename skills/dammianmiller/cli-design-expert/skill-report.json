{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T13:41:23.137Z",
    "slug": "dammianmiller-cli-design-expert",
    "source_url": "https://github.com/DammianMiller/universal-agent-memory/tree/main/.factory/skills/cli-design-expert",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "7194e664ce95a473cb644f2a1bbaebe911d49ee428bee108c8b253987bc0b05a",
    "tree_hash": "eb447031433b3a13a8c9a784ecc4e6c5b51bc946eeb4e45cd19fd1b695cd9977"
  },
  "skill": {
    "name": "cli-design-expert",
    "description": "Expert CLI/TUI designer for building intuitive, user-friendly, and professional command-line interfaces. Focuses on UX patterns, help systems, progressive disclosure, and developer ergonomics.",
    "summary": "Expert CLI/TUI designer for building intuitive, user-friendly, and professional command-line interfa...",
    "icon": "⌨️",
    "version": "1.0.0",
    "author": "DammianMiller",
    "license": "MIT",
    "category": "development",
    "tags": [
      "cli",
      "ux",
      "command-line",
      "developer-tools",
      "design"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure documentation skill containing only CLI design guidance. No executable code, scripts, network operations, or file system access. Safe for publication.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 577,
    "audit_model": "claude",
    "audited_at": "2026-01-10T13:41:23.137Z"
  },
  "content": {
    "user_title": "Design Professional Command-Line Interfaces",
    "value_statement": "Building intuitive CLI tools is challenging without clear design patterns. This skill provides expert guidance for creating commands that work as users expect, with progressive disclosure and helpful error messages.",
    "seo_keywords": [
      "cli design",
      "command-line interface",
      "claude code",
      "codex",
      "ux patterns",
      "help system",
      "terminal",
      "developer tools",
      "progressive disclosure"
    ],
    "actual_capabilities": [
      "Design command structures following git-style noun-verb patterns",
      "Create three-tier help systems with progressive detail",
      "Write error messages that guide users to solutions",
      "Implement interactive prompts with confirmation for destructive actions",
      "Format output with tables, colors, and progress indicators",
      "Add shell completion support for bash, zsh, and fish"
    ],
    "limitations": [
      "Provides guidance only, does not execute code or modify files",
      "Does not generate CLI scaffolding or boilerplate code",
      "Does not validate existing CLI implementations",
      "Focuses on TypeScript/Node.js patterns, may need adaptation for other languages"
    ],
    "use_cases": [
      {
        "target_user": "Tool Developers",
        "title": "Build User-Friendly CLI Tools",
        "description": "Create commands that follow established patterns like git and npm with clear help and error handling."
      },
      {
        "target_user": "DevOps Engineers",
        "title": "Improve Internal Tool Adoption",
        "description": "Design CLIs that developers actually want to use with progressive disclosure and excellent documentation."
      },
      {
        "target_user": "Open Source Maintainers",
        "title": "Polish Project Command Interfaces",
        "description": "Add professional polish to project tools with semantic colors, tables, and helpful error suggestions."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Command Design",
        "scenario": "Creating a new CLI command",
        "prompt": "Design a CLI command structure for [your tool]. It should [describe what it does]. Follow CLI best practices."
      },
      {
        "title": "Help System",
        "scenario": "Writing command documentation",
        "prompt": "Create a three-tier help system for a command called [name] with subcommands [list them]. Include examples at each level."
      },
      {
        "title": "Error Messages",
        "scenario": "Handling error cases",
        "prompt": "Design error handling for a CLI that validates [input type]. Show error codes, messages, and user suggestions for common failures."
      },
      {
        "title": "Interactive Prompts",
        "scenario": "Building user workflows",
        "prompt": "Create an interactive wizard flow for [task] using confirmations for dangerous actions. Show code patterns for inquirer.js integration."
      }
    ],
    "output_examples": [
      {
        "input": "Design a CLI command for creating feature branches with a help system and error handling",
        "output": [
          "Command: branch create <name> [--base <branch>] [--no-PR]",
          "Exit codes: 0=success, 1=error, 2=invalid usage, 66=no-input",
          "Help shows: usage, options, examples, and common issues",
          "Error for missing branch name shows suggestion: 'Run with --base develop'",
          "Dangerous actions like force delete require --force flag or confirmation prompt"
        ]
      }
    ],
    "best_practices": [
      "Follow the noun-verb pattern (git commit, npm install) for intuitive command structures",
      "Provide both short (-h) and long (--help) options for all common flags",
      "Design error messages to explain what went wrong AND how to fix it"
    ],
    "anti_patterns": [
      "Using cryptic error codes without explanations or suggestions",
      "Requiring users to read external documentation for basic usage",
      "Performing destructive actions without confirmation or force flags"
    ],
    "faq": [
      {
        "question": "Does this skill work with all programming languages?",
        "answer": "Concepts apply universally. Code examples use TypeScript/Node.js but patterns work for any language."
      },
      {
        "question": "What exit codes should my CLI use?",
        "answer": "Standard codes: 0=success, 1=general error, 2=invalid usage, 66=no input file, 78=config error."
      },
      {
        "question": "How do I support shell completion?",
        "answer": "Generate completion scripts for bash, zsh, and fish that parse command structure and suggest subcommands."
      },
      {
        "question": "Is my data safe with this skill?",
        "answer": "Yes. This skill is read-only documentation. It provides guidance without accessing any files or executing code."
      },
      {
        "question": "Why are my error messages ignored by users?",
        "answer": "Users ignore errors without solutions. Always include suggestion lines starting with 'How to fix:' or 'Run:'"
      },
      {
        "question": "How is this different from using commander.js or oclif directly?",
        "answer": "Those are frameworks. This skill provides design principles that work with any framework or language."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
