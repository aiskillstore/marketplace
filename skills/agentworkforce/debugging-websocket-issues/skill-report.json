{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T15:13:33.499Z",
    "slug": "agentworkforce-debugging-websocket-issues",
    "source_url": "https://github.com/AgentWorkforce/relay/tree/main/.claude/skills/debugging-websocket-issues",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "d9bdf8bfdc57974ffd7b86a5d0059f81c949d846b89b65ef7c3f1eb99565ba63",
    "tree_hash": "e2d247dfbc46930c7bb1b9ff5b8f339d5fed408466cbbd0c873c884038dae25b"
  },
  "skill": {
    "name": "debugging-websocket-issues",
    "description": "Use when seeing WebSocket errors like \"Invalid frame header\", \"RSV1 must be clear\", or \"WS_ERR_UNEXPECTED_RSV_1\" - covers multiple WebSocketServer conflicts, compression issues, and raw frame debugging techniques",
    "summary": "Debug WebSocket errors including Invalid frame header, RSV1 errors, and multiple server conflicts",
    "icon": "ðŸ”Œ",
    "version": "1.0.0",
    "author": "AgentWorkforce",
    "license": "MIT",
    "category": "devops",
    "tags": [
      "websocket",
      "debugging",
      "nodejs",
      "real-time",
      "network"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All 55 static findings evaluated as false positives. The skill contains only documentation and TypeScript code examples for WebSocket debugging. Pattern matching incorrectly flagged WebSocket protocol terms like RSV1 and perMessageDeflate as cryptographic operations, TypeScript template literals as shell commands, and legitimate URL parsing examples as network risks. No executable code, network requests, or security threats identified.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 763,
    "audit_model": "claude",
    "audited_at": "2026-01-21T15:13:33.499Z"
  },
  "content": {
    "user_title": "Debug WebSocket Connection Issues",
    "value_statement": "WebSocket connections frequently fail with cryptic errors like Invalid frame header or RSV1 must be clear. This skill provides structured debugging techniques to diagnose and fix multiple WebSocketServer conflicts, compression mismatches, and raw frame inspection methods.",
    "seo_keywords": [
      "websocket debugging",
      "websocket errors",
      "RSV1 must be clear",
      "Invalid frame header",
      "WebSocketServer",
      "Node.js WebSocket",
      "real-time debugging",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Diagnose Invalid frame header errors caused by multiple WebSocketServer instances",
      "Fix RSV1 and compression-related WebSocket failures",
      "Inspect raw WebSocket frames for HTTP contamination",
      "Implement proper upgrade request routing with noServer mode",
      "Identify hex patterns that indicate common WebSocket problems",
      "Debug abnormal closure code 1006 disconnections"
    ],
    "limitations": [
      "Cannot fix network infrastructure issues like load balancers or proxies",
      "Does not cover WebSocket security configurations like authentication",
      "Limited to Node.js ws library patterns",
      "Does not address client-side WebSocket implementation issues"
    ],
    "use_cases": [
      {
        "title": "Fix Multiple WebSocketServer Conflicts",
        "description": "Diagnose and resolve errors when multiple WebSocketServer instances on the same HTTP server cause frame corruption and unexpected disconnections.",
        "target_user": "Backend developers working with Node.js WebSocket servers"
      },
      {
        "title": "Debug Compression-Related WebSocket Errors",
        "description": "Identify and fix RSV1 errors caused by perMessageDeflate compression mismatches between client and server.",
        "target_user": "Full-stack developers troubleshooting real-time communication"
      },
      {
        "title": "Inspect Raw WebSocket Frame Data",
        "description": "Use frame inspection techniques to detect when raw HTTP responses are being written to WebSocket connections.",
        "target_user": "DevOps engineers debugging production WebSocket issues"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic WebSocket Error",
        "prompt": "I am seeing the error 'Invalid WebSocket frame: RSV1 must be clear' in my Node.js WebSocket server. Help me diagnose the cause and fix it.",
        "scenario": "Diagnosing RSV1 errors"
      },
      {
        "title": "Multiple WebSocket Servers",
        "prompt": "I have two WebSocketServer instances attached to the same HTTP server with different paths. Clients are receiving garbled data. How do I fix this conflict?",
        "scenario": "Resolving WebSocketServer conflicts"
      },
      {
        "title": "Frame Inspection",
        "prompt": "How can I inspect the raw bytes being received on my WebSocket connection to debug what the client is actually receiving?",
        "scenario": "Raw frame debugging"
      },
      {
        "title": "Client-Server Compression Mismatch",
        "prompt": "My WebSocket connection works in isolation but fails when integrated into my application with error WS_ERR_UNEXPECTED_RSV_1. The client does not support compression. How do I disable perMessageDeflate on the server?",
        "scenario": "Fixing compression mismatches"
      }
    ],
    "output_examples": [
      {
        "input": "Invalid WebSocket frame: RSV1 must be clear error",
        "output": "This error typically has two causes: (1) Multiple WebSocketServer instances conflicting on the same HTTP server, or (2) Compression mismatch where client does not support perMessageDeflate.\n\nTo fix, use noServer mode and manually route upgrades:\n\n```typescript\nconst wss = new WebSocketServer({ noServer: true, perMessageDeflate: false });\nserver.on('upgrade', (request, socket, head) => {\n  const pathname = new URL(request.url || '', `http://${request.headers.host}`).pathname;\n  if (pathname === '/ws') {\n    wss.handleUpgrade(request, socket, head, (ws) => wss.emit('connection', ws, request));\n  } else {\n    socket.destroy();\n  }\n});\n```"
      },
      {
        "input": "WebSocket connects then immediately disconnects with code 1006",
        "output": "Code 1006 indicates abnormal closure. Common causes include:\n\n1. Multiple WebSocketServer handlers - both fire upgrade listeners\n2. abortHandshake being called after partial upgrade\n3. Raw HTTP written to upgraded socket\n\nCheck for hex pattern 48545450 (HTTP) in received data. If present, you have an upgrade handler writing HTTP responses to an already-upgraded socket.\n\nSolution: Ensure only ONE upgrade handler processes each connection path."
      }
    ],
    "best_practices": [
      "Use noServer mode with manual routing when attaching multiple WebSocketServer instances to prevent upgrade handler conflicts",
      "Disable perMessageDeflate explicitly when clients may not support compression to avoid RSV1 errors",
      "Inspect raw frame bytes during debugging to distinguish between actual frame corruption and HTTP contamination"
    ],
    "anti_patterns": [
      "Attaching multiple WebSocketServer instances to the same HTTP server without using noServer mode",
      "Assuming RSV1 errors always indicate compression issues without checking for raw HTTP contamination",
      "Not verifying that upgrade handlers properly destroy sockets for unrecognized paths"
    ],
    "faq": [
      {
        "question": "What causes Invalid frame header errors in WebSocket?",
        "answer": "Most Invalid frame header errors stem from raw HTTP being written to an upgraded WebSocket socket, not actual frame corruption. The most common cause is multiple WebSocketServer instances where both upgrade handlers fire, and the non-matching one writes an HTTP 400 response to the now-WebSocket socket."
      },
      {
        "question": "How do I fix RSV1 must be clear errors?",
        "answer": "This error occurs when RSV1 bit is set on a frame that should not have it. Fix by setting perMessageDeflate: false on your WebSocketServer configuration, or ensure client and server have matching compression capabilities."
      },
      {
        "question": "Why does my WebSocket work in isolation but fail in my app?",
        "answer": "This is the classic symptom of multiple WebSocketServer conflict. When integrated, another library or code path also attaches an upgrade handler, causing the upgrade process to be interrupted or have HTTP written to it."
      },
      {
        "question": "What does hex pattern 48545450 indicate?",
        "answer": "48545450 is the hex representation of HTTP. When you see this in WebSocket frame data, it means raw HTTP text was written to the WebSocket connection instead of proper WebSocket frames."
      },
      {
        "question": "What is code 1006 in WebSocket?",
        "answer": "WebSocket close code 1006 means abnormal closure. It indicates the connection was closed without a proper WebSocket close handshake, often due to server-side abortHandshake calls or socket destruction."
      },
      {
        "question": "Should I use perMessageDeflate compression?",
        "answer": "Only if both client and server support it. Compression reduces bandwidth but adds processing overhead and can cause compatibility issues. When in doubt, explicitly set perMessageDeflate: false for maximum compatibility."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 129
    }
  ]
}
