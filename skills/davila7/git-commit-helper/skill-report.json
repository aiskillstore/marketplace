{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-07T01:15:28.214Z",
    "slug": "davila7-git-commit-helper",
    "source_url": "https://github.com/davila7/claude-code-templates/tree/main/cli-tool/components/skills/development/git-commit-helper",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "b1180952f773ae74e4937609518296b80d1cc766825fbcba12ed61488acb9f05",
    "tree_hash": "e5f520b2fd227282fc29aa4e6b635b73153c016d0d0fe3546f018b38ea194745"
  },
  "skill": {
    "name": "Git Commit Helper",
    "description": "Generate descriptive commit messages by analyzing git diffs. Use when the user asks for help writing commit messages or reviewing staged changes.",
    "summary": "Generate descriptive commit messages by analyzing git diffs. Use when the user asks for help writing...",
    "icon": "üìù",
    "version": "1.0.0",
    "author": "davila7",
    "license": "MIT",
    "category": "development",
    "tags": [
      "git",
      "commits",
      "version-control",
      "conventional-commits",
      "documentation"
    ],
    "supported_tools": [
      "claude",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure prompt-based skill containing only documentation and guidelines for writing git commit messages. No executable code, scripts, network operations, or filesystem access beyond reading its own content.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 204,
    "audit_model": "claude",
    "audited_at": "2026-01-07T01:15:28.214Z"
  },
  "content": {
    "user_title": "Generate descriptive git commit messages",
    "value_statement": "Writing clear commit messages is difficult. This skill analyzes git diffs and generates well-structured commit messages following conventional commits format, making your commit history readable and maintainable.",
    "seo_keywords": [
      "git commit helper",
      "conventional commits",
      "commit message generator",
      "git commit messages",
      "Claude Code skill",
      "version control best practices",
      "git workflow",
      "commit message format",
      "code review",
      "git history"
    ],
    "actual_capabilities": [
      "Analyzes git diffs to understand code changes",
      "Generates conventional commits format messages",
      "Suggests appropriate commit types (feat, fix, docs, refactor, test, chore)",
      "Identifies scopes for frontend, backend, and infrastructure changes",
      "Detects and documents breaking changes",
      "Reviews staged changes before committing"
    ],
    "limitations": [
      "Does not execute git commands directly - provides guidance for users",
      "Does not amend or push commits automatically",
      "Does not integrate with external git hosting services",
      "Requires user to run git commands and provide diff output"
    ],
    "use_cases": [
      {
        "target_user": "Developer",
        "title": "Quick commit messages",
        "description": "Generate clear, consistent commit messages for daily development work without memorizing conventions."
      },
      {
        "target_user": "Team lead",
        "title": "Enforce commit standards",
        "description": "Help team members write standardized commit messages that work well with automated changelog tools."
      },
      {
        "target_user": "Open source maintainer",
        "title": "Maintain clean history",
        "description": "Create meaningful commit histories that make it easier to understand project evolution and write release notes."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic commit",
        "scenario": "Generate a simple commit message",
        "prompt": "Help me write a commit message for these staged changes:\n\ngit diff --staged output here\n\nUse conventional commits format with appropriate type and scope."
      },
      {
        "title": "Feature commit",
        "scenario": "Document a new feature",
        "prompt": "I am adding a new feature. Analyze my staged changes and create a conventional commit message:\n\n[git diff --staged output]\n\nInclude the type, scope, and a clear description in the summary line."
      },
      {
        "title": "Breaking change",
        "scenario": "Document breaking changes",
        "prompt": "My changes include breaking changes. Generate a conventional commit message that clearly indicates this:\n\n[git diff --staged output]\n\nUse the ! notation and explain the breaking change in the footer."
      },
      {
        "title": "Complex refactor",
        "scenario": "Document multi-file refactoring",
        "prompt": "I have refactored multiple files. Analyze all the staged changes and create a single commit message that captures the overall refactoring purpose:\n\n[git diff --staged output]\n\nInclude a summary and body that explains the refactoring rationale."
      }
    ],
    "output_examples": [
      {
        "input": "Generate a commit message for these staged changes that add user authentication with JWT tokens",
        "output": [
          "feat(auth): add JWT authentication system",
          "",
          "Implement user login with JWT-based authentication:",
          "- Add login endpoint with token generation",
          "- Create token validation middleware",
          "- Add refresh token support for session management",
          "",
          "BREAKING CHANGE: Auth service now requires config object with secret key"
        ]
      }
    ],
    "best_practices": [
      "Use imperative mood in summary line (add, fix, refactor not added, fixed, refactored)",
      "Keep summary under 50 characters and explain changes in body when needed",
      "Reference issue numbers and clearly mark breaking changes with BREAKING CHANGE footer"
    ],
    "anti_patterns": [
      "Using vague messages like 'update', 'fix stuff', or 'misc changes'",
      "Including technical implementation details in the summary line",
      "Mixing unrelated changes into a single commit (non-atomic commits)"
    ],
    "faq": [
      {
        "question": "What AI tools support this skill?",
        "answer": "This skill works with Claude Code and Claude. It provides guidance for generating commit messages through natural conversation."
      },
      {
        "question": "What is the character limit for commit summaries?",
        "answer": "Keep commit summaries under 50 characters. This is a soft convention to ensure readability in git log and GitHub interfaces."
      },
      {
        "question": "Does this integrate with git hosting platforms?",
        "answer": "No, this skill provides guidance and message suggestions. Users must run git commands and commit changes themselves."
      },
      {
        "question": "Is my code or repository data sent anywhere?",
        "answer": "No. This is a local guidance skill. Git diff output is analyzed locally within your conversation without being sent to external services."
      },
      {
        "question": "Why are my generated messages rejected by my team?",
        "answer": "Check that you are using the correct type (feat/fix/docs/style/refactor/test/chore), appropriate scope, and following your team's commit message conventions."
      },
      {
        "question": "How is this different from git commit templates?",
        "answer": "Git commit templates set a starting point for messages. This skill actively analyzes your actual code changes and generates specific, contextual commit messages."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
