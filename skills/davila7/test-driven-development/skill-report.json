{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-07T01:35:24.279Z",
    "slug": "davila7-test-driven-development",
    "source_url": "https://github.com/davila7/claude-code-templates/tree/main/cli-tool/components/skills/development/test-driven-development",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "d11666ee4a93cc0b2ca8b9f1e47f64508c455a55d1f210d61a81c30740fd62d9",
    "tree_hash": "34f4dcb54ce5486493dd77c9731399b5298b55f0c0d155d5fa964bbf075b07a9"
  },
  "skill": {
    "name": "test-driven-development",
    "description": "Use when implementing any feature or bugfix, before writing implementation code",
    "summary": "Use when implementing any feature or bugfix, before writing implementation code",
    "icon": "ðŸ§ª",
    "version": "1.0.0",
    "author": "davila7",
    "license": "MIT",
    "category": "development",
    "tags": [
      "testing",
      "tdd",
      "software-quality",
      "test-first",
      "red-green-refactor"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Pure prompt-based skill with no executable code. Contains only markdown documentation for TDD methodology and testing best practices.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 672,
    "audit_model": "claude",
    "audited_at": "2026-01-07T01:35:24.279Z"
  },
  "content": {
    "user_title": "Apply Test-Driven Development",
    "value_statement": "Writing tests after code passes immediately and proves nothing. Test-first forces you to see the test fail, proving it actually tests the right behavior. TDD catches bugs before they reach production and enables confident refactoring.",
    "seo_keywords": [
      "test-driven development",
      "TDD",
      "Claude Code",
      "software testing",
      "red-green-refactor",
      "test-first",
      "unit testing",
      "automated tests",
      "software quality",
      "bug prevention"
    ],
    "actual_capabilities": [
      "Guides red-green-refactor TDD cycle step-by-step",
      "Provides test verification commands and checklists",
      "Identifies common TDD rationalizations and red flags",
      "Offers debugging integration techniques",
      "Includes testing anti-patterns reference documentation"
    ],
    "limitations": [
      "Does not generate specific test code - user provides test content",
      "Does not execute or run tests automatically",
      "Does not integrate with specific testing frameworks",
      "Does not provide test coverage analysis"
    ],
    "use_cases": [
      {
        "target_user": "Software Developers",
        "title": "New Feature Implementation",
        "description": "Write failing test first for new feature, implement minimal code to pass, then refactor while keeping tests green"
      },
      {
        "target_user": "Bug Fixes",
        "title": "Bug Reproduction Tests",
        "description": "Create failing test that reproduces the bug, fix the code to make test pass, ensuring regression prevention"
      },
      {
        "target_user": "Code Reviewers",
        "title": "TDD Process Validation",
        "description": "Verify code was written using TDD by checking that tests existed before implementation and failed first"
      }
    ],
    "prompt_templates": [
      {
        "title": "Start TDD Cycle",
        "scenario": "New feature or bug fix",
        "prompt": "Apply TDD methodology. First, help me write a failing test for [describe feature/bug]. I want to see it fail before implementing any solution."
      },
      {
        "title": "Refactor Safely",
        "scenario": "Code cleanup",
        "prompt": "Help me refactor [code section] while keeping all tests passing. Show me how TDD enables safe refactoring."
      },
      {
        "title": "Write Better Tests",
        "scenario": "Test improvement",
        "prompt": "Review my test for [functionality] and suggest improvements. Is this testing real behavior or just mock existence?"
      },
      {
        "title": "Debug with Tests",
        "scenario": "Bug investigation",
        "prompt": "I found a bug in [component]. Help me write a failing test that reproduces it, then use TDD to fix it properly."
      }
    ],
    "output_examples": [
      {
        "input": "Help me implement a retry function using TDD",
        "output": [
          "Step 1 - Write failing test: Define expected retry behavior with test that fails",
          "Step 2 - Verify RED: Run test to confirm it fails for expected reason",
          "Step 3 - Write minimal code: Implement just enough to pass the test",
          "Step 4 - Verify GREEN: Confirm test passes and all tests still pass",
          "Step 5 - Refactor: Clean up code while keeping tests green",
          "Step 6 - Repeat: Next failing test for next feature"
        ]
      }
    ],
    "best_practices": [
      "Always watch each test fail before implementing - proves test actually tests what you need",
      "Write minimal code to pass tests - resist adding features not required by tests",
      "Use real code in tests - mocks should isolate dependencies, not be the thing being tested"
    ],
    "anti_patterns": [
      "Writing implementation code before the test - delete and start over with TDD",
      "Testing mock behavior instead of real component behavior",
      "Keeping implementation code as 'reference' while writing tests - you will adapt it"
    ],
    "faq": [
      {
        "question": "What testing frameworks work with this skill?",
        "answer": "This skill provides TDD methodology. Works with any framework like Jest, Vitest, pytest, JUnit, or Mocha."
      },
      {
        "question": "What are the limits of TDD?",
        "answer": "TDD is unsuitable for throwaway prototypes, generated code, and configuration files. Ask your human partner for exceptions."
      },
      {
        "question": "How does TDD integrate with existing code?",
        "answer": "Add tests for existing code before modifying it. TDD prevents regressions when changing legacy systems."
      },
      {
        "question": "Is my data safe when using TDD?",
        "answer": "Yes. This skill provides guidance only. No code execution, no file access, no data collection."
      },
      {
        "question": "What if my test passes immediately?",
        "answer": "You are testing existing behavior, not required behavior. Fix the test to describe what SHOULD happen, not what currently happens."
      },
      {
        "question": "How is this different from test-after development?",
        "answer": "Test-after answers 'what does this code do?' TDD answers 'what should this code do?' Test-first forces edge case discovery before implementing."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    },
    {
      "name": "testing-anti-patterns.md",
      "type": "file",
      "path": "testing-anti-patterns.md"
    }
  ]
}
