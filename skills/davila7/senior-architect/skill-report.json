{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-17T01:37:49.936Z",
    "slug": "davila7-senior-architect",
    "source_url": "https://github.com/davila7/claude-code-templates/tree/main/cli-tool/components/skills/development/senior-architect",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "140183c294f27cf6c452fbda8b5e5bc3a7a8cc3a45a9ed63de5681f745a53b85",
    "tree_hash": "755b869b6a93b64ea5d53760ea54a63f3f4501a87907a21e81710135a0b32ca7"
  },
  "skill": {
    "name": "senior-architect",
    "description": "Comprehensive software architecture skill for designing scalable, maintainable systems using ReactJS, NextJS, NodeJS, Express, React Native, Swift, Kotlin, Flutter, Postgres, GraphQL, Go, Python. Includes architecture diagram generation, system design patterns, tech stack decision frameworks, and dependency analysis. Use when designing system architecture, making technical decisions, creating architecture diagrams, evaluating trade-offs, or defining integration patterns.",
    "summary": "Comprehensive software architecture skill for designing scalable, maintainable systems using ReactJS...",
    "icon": "üèõÔ∏è",
    "version": "1.0.0",
    "author": "davila7",
    "license": "MIT",
    "category": "development",
    "tags": [
      "software architecture",
      "system design",
      "scalability",
      "architecture patterns",
      "tech stack"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All 101 static findings are FALSE POSITIVEs. The scanner detected documentation patterns (markdown code block delimiters, bash examples in SKILL.md) as security threats. The three Python scripts (project_architect.py, architecture_diagram_generator.py, dependency_analyzer.py) use only standard library imports (os, sys, json, argparse, pathlib), contain no external commands, no network calls, and no cryptographic operations. Filesystem writes only occur to user-specified output paths when explicitly requested via --output flag.",
    "risk_factor_evidence": [
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "scripts/project_architect.py",
            "line_start": 1,
            "line_end": 115
          },
          {
            "file": "scripts/architecture_diagram_generator.py",
            "line_start": 1,
            "line_end": 115
          },
          {
            "file": "scripts/dependency_analyzer.py",
            "line_start": 1,
            "line_end": 115
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "scripts/project_architect.py",
            "line_start": 107,
            "line_end": 108
          },
          {
            "file": "scripts/architecture_diagram_generator.py",
            "line_start": 107,
            "line_end": 108
          },
          {
            "file": "scripts/dependency_analyzer.py",
            "line_start": 107,
            "line_end": 108
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [
      {
        "title": "Filesystem write to user-specified output path",
        "description": "Each Python script contains a file write operation at line 107 using 'with open(args.output, 'w') as f'. This only executes when the user explicitly provides the --output flag with a file path. This is legitimate CLI behavior for saving analysis results.",
        "locations": [
          {
            "file": "scripts/project_architect.py",
            "line_start": 107,
            "line_end": 108
          },
          {
            "file": "scripts/architecture_diagram_generator.py",
            "line_start": 107,
            "line_end": 108
          },
          {
            "file": "scripts/dependency_analyzer.py",
            "line_start": 107,
            "line_end": 108
          }
        ]
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 8,
    "total_lines": 1153,
    "audit_model": "claude",
    "audited_at": "2026-01-17T01:37:49.936Z"
  },
  "content": {
    "user_title": "Design scalable software architecture",
    "value_statement": "Designing complex software systems requires deep expertise across many technologies and patterns. This skill provides a complete toolkit for architecture design including diagram generation, pattern guidance, tech stack decisions, and dependency analysis for modern applications.",
    "seo_keywords": [
      "software architecture",
      "system design",
      "Claude Code skill",
      "architecture patterns",
      "tech stack decisions",
      "scalable systems",
      "dependency analysis",
      "React architecture",
      "Node.js design patterns",
      "cloud architecture"
    ],
    "actual_capabilities": [
      "Generate architecture diagrams from project structure",
      "Analyze project dependencies and relationships",
      "Apply industry-standard architecture patterns",
      "Make informed technology stack decisions",
      "Review system designs for scalability and maintainability",
      "Document architectural decisions and trade-offs"
    ],
    "limitations": [
      "Does not modify or refactor existing code automatically",
      "Does not execute or deploy infrastructure",
      "Requires user to provide target project path for analysis",
      "Reference guides contain placeholder content"
    ],
    "use_cases": [
      {
        "target_user": "Lead developers",
        "title": "Design new system architecture",
        "description": "Plan scalable microservices or monolith architecture with proper patterns and technology choices for new projects."
      },
      {
        "target_user": "Engineering managers",
        "title": "Evaluate technical proposals",
        "description": "Review architecture proposals using established patterns and frameworks to assess feasibility and risks."
      },
      {
        "target_user": "Senior developers",
        "title": "Refactor legacy systems",
        "description": "Analyze existing systems and apply modern patterns to improve maintainability and scalability."
      }
    ],
    "prompt_templates": [
      {
        "title": "Analyze project structure",
        "scenario": "Examine existing codebase",
        "prompt": "Use the Senior Architect skill to analyze my project at [PATH] and identify the current architecture patterns, dependency structure, and any recommendations for improvement."
      },
      {
        "title": "Design new feature",
        "scenario": "Plan feature architecture",
        "prompt": "Design an architecture for a new [FEATURE] feature in my [FRAMEWORK] application. Consider scalability, security, and integration with existing systems."
      },
      {
        "title": "Technology decisions",
        "scenario": "Choose tech stack",
        "prompt": "Help me choose between [OPTION A] and [OPTION B] for my [USE CASE]. Provide a detailed comparison including scalability, maintenance, and team considerations."
      },
      {
        "title": "Architecture review",
        "scenario": "Validate design",
        "prompt": "Review my current architecture design and identify potential bottlenecks, security concerns, and areas for improvement using the architecture patterns reference."
      }
    ],
    "output_examples": [
      {
        "input": "Analyze my project structure and suggest improvements",
        "output": [
          "Current architecture: Modular monolith with clear separation of concerns",
          "Strengths: Well-organized domain boundaries, proper dependency injection",
          "Areas for improvement: Consider implementing caching layer for database queries, add circuit breaker for external API calls",
          "Recommended patterns: Repository pattern, CQRS for complex write operations",
          "Tech stack alignment: Modern choices aligned with industry best practices"
        ]
      }
    ],
    "best_practices": [
      "Start with clear requirements and non-functional constraints before designing architecture",
      "Document architectural decisions with their trade-offs for future team reference",
      "Validate architecture patterns against actual scalability requirements, not hypothetical ones"
    ],
    "anti_patterns": [
      "Choosing trendy technologies over proven solutions for team skill sets",
      "Over-engineering with unnecessary abstraction layers before needs arise",
      "Ignoring operational concerns like monitoring, logging, and deployment pipelines"
    ],
    "faq": [
      {
        "question": "Which AI tools support this skill?",
        "answer": "This skill works with Claude, Codex, and Claude Code. It uses the AI to apply architecture knowledge rather than running standalone scripts."
      },
      {
        "question": "What project types can I analyze?",
        "answer": "The skill supports JavaScript, TypeScript, Python, Go, Swift, Kotlin, and other common languages used in modern web and mobile development."
      },
      {
        "question": "Does this modify my code?",
        "answer": "No. The skill provides guidance and recommendations. It does not automatically refactor or modify any existing code in your project."
      },
      {
        "question": "Is my code data safe?",
        "answer": "Yes. Code analysis happens locally within your development environment. No code is sent to external services."
      },
      {
        "question": "Why are reference guides placeholders?",
        "answer": "The skill focuses on using AI intelligence for architecture guidance. Reference files provide structural organization for future detailed content."
      },
      {
        "question": "How is this different from other architecture tools?",
        "answer": "This skill combines AI reasoning with architectural patterns. It can adapt to your specific context rather than applying rigid templates."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "architecture_patterns.md",
          "type": "file",
          "path": "references/architecture_patterns.md",
          "lines": 104
        },
        {
          "name": "system_design_workflows.md",
          "type": "file",
          "path": "references/system_design_workflows.md",
          "lines": 104
        },
        {
          "name": "tech_decision_guide.md",
          "type": "file",
          "path": "references/tech_decision_guide.md",
          "lines": 104
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "architecture_diagram_generator.py",
          "type": "file",
          "path": "scripts/architecture_diagram_generator.py",
          "lines": 115
        },
        {
          "name": "dependency_analyzer.py",
          "type": "file",
          "path": "scripts/dependency_analyzer.py",
          "lines": 115
        },
        {
          "name": "project_architect.py",
          "type": "file",
          "path": "scripts/project_architect.py",
          "lines": 115
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 210
    }
  ]
}
