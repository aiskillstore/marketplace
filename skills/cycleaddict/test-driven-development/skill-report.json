{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T12:57:21.272Z",
    "slug": "cycleaddict-test-driven-development",
    "source_url": "https://github.com/Cycleaddict/generic-superpowers/tree/main/skills/test-driven-development",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "d11666ee4a93cc0b2ca8b9f1e47f64508c455a55d1f210d61a81c30740fd62d9",
    "tree_hash": "34f4dcb54ce5486493dd77c9731399b5298b55f0c0d155d5fa964bbf075b07a9"
  },
  "skill": {
    "name": "test-driven-development",
    "description": "Use when implementing any feature or bugfix, before writing implementation code",
    "summary": "Use when implementing any feature or bugfix, before writing implementation code",
    "icon": "ðŸ§ª",
    "version": "1.0.0",
    "author": "Cycleaddict",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "tdd",
      "testing",
      "development",
      "methodology",
      "quality"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This is a documentation-only skill containing TDD best practices and guidelines. No executable code, network calls, file system access, or external commands were found. The skill provides educational content about test-driven development methodology.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 672,
    "audit_model": "claude",
    "audited_at": "2026-01-10T12:57:21.272Z"
  },
  "content": {
    "user_title": "Master Test-Driven Development",
    "value_statement": "Writing tests after code leads to bugs and poor design. This skill enforces strict TDD discipline with red-green-refactor cycles for bulletproof code.",
    "seo_keywords": [
      "test driven development",
      "TDD",
      "unit testing",
      "red green refactor",
      "Claude testing",
      "Codex testing",
      "Claude Code TDD",
      "software testing",
      "development methodology",
      "code quality"
    ],
    "actual_capabilities": [
      "Guides strict red-green-refactor TDD cycles",
      "Prevents testing anti-patterns and mock abuse",
      "Enforces test-first development discipline",
      "Provides verification checklists for TDD compliance",
      "Teaches minimal implementation and refactoring principles"
    ],
    "limitations": [
      "Requires discipline to delete code written without tests",
      "May slow initial development speed",
      "Not suitable for throwaway prototypes without permission",
      "Demands commitment to watching tests fail before implementing"
    ],
    "use_cases": [
      {
        "target_user": "Software developers",
        "title": "Implement new features with confidence",
        "description": "Use TDD to write bulletproof code that works correctly from the start, with tests that prove functionality."
      },
      {
        "target_user": "Bug fixers",
        "title": "Fix bugs without creating new ones",
        "description": "Write failing tests that reproduce bugs, then implement minimal fixes while preventing regressions."
      },
      {
        "target_user": "Code reviewers",
        "title": "Ensure code quality standards",
        "description": "Verify that all code follows TDD principles with proper test coverage and minimal implementations."
      }
    ],
    "prompt_templates": [
      {
        "title": "Start TDD for new feature",
        "scenario": "Beginning implementation of authentication system",
        "prompt": "I need to implement user authentication. Help me write the first failing test for login functionality using TDD principles."
      },
      {
        "title": "Write failing test for bug",
        "scenario": "Fixing email validation bug",
        "prompt": "Empty emails are being accepted. Guide me through writing a failing test that proves this bug exists."
      },
      {
        "title": "Refactor with confidence",
        "scenario": "Cleaning up duplicate code after green phase",
        "prompt": "My tests are green but I see duplication. Help me refactor while keeping all tests passing."
      },
      {
        "title": "Review TDD compliance",
        "scenario": "Checking if code follows TDD properly",
        "prompt": "Review this code and tests. Did I follow TDD correctly? Did I watch each test fail before implementing?"
      }
    ],
    "output_examples": [
      {
        "input": "Help me implement a retry mechanism using TDD",
        "output": [
          "First, write a failing test that shows the retry behavior you want",
          "Run the test to confirm it fails for the right reason",
          "Implement minimal code to make the test pass",
          "Run the test again to verify it passes",
          "Refactor the code while keeping tests green",
          "Repeat for each edge case (max retries, backoff, etc.)"
        ]
      }
    ],
    "best_practices": [
      "Always watch the test fail before writing implementation code",
      "Write the simplest code possible to make tests pass",
      "Delete any code written without a failing test first",
      "Use real dependencies instead of mocks when possible"
    ],
    "anti_patterns": [
      "Writing tests after implementation is complete",
      "Keeping code as reference while writing tests",
      "Testing mock behavior instead of real functionality",
      "Adding test-only methods to production classes"
    ],
    "faq": [
      {
        "question": "Is TDD compatible with all programming languages?",
        "answer": "Yes. TDD principles work with any language that has a testing framework. The red-green-refactor cycle is universal."
      },
      {
        "question": "How do I handle legacy code without tests?",
        "answer": "Add tests before changing legacy code. Write characterization tests that capture current behavior, then refactor with TDD."
      },
      {
        "question": "Can I use TDD with existing frameworks?",
        "answer": "Absolutely. TDD works with React, Node.js, Python, Java, and any framework. Write tests that use your framework's APIs."
      },
      {
        "question": "What if my tests are too slow?",
        "answer": "Fast tests indicate good design. If tests are slow, your code may have coupling issues. TDD helps identify these problems."
      },
      {
        "question": "How minimal should green phase code be?",
        "answer": "Extremely minimal. Hardcode values, write if statements, do whatever makes the test pass. Refactor comes after green."
      },
      {
        "question": "Is TDD worth the initial time investment?",
        "answer": "Yes. TDD saves time by catching bugs early, preventing regressions, and enabling confident refactoring throughout development."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    },
    {
      "name": "testing-anti-patterns.md",
      "type": "file",
      "path": "testing-anti-patterns.md"
    }
  ]
}
