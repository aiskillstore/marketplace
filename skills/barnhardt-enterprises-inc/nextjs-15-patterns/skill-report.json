{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T14:55:39.712Z",
    "slug": "barnhardt-enterprises-inc-nextjs-15-patterns",
    "source_url": "https://github.com/Barnhardt-Enterprises-Inc/quetrex-claude/tree/main/skills/nextjs-15-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "652817027ac3c9bf63a322a8419cf92b0a09de6a72e304c1b376a9444967cd66",
    "tree_hash": "2d3a9f46ac55fd295e9f8577212539b31d92e8d8791aa544915c0572f1f90519"
  },
  "skill": {
    "name": "nextjs-15-patterns",
    "description": "Next.js 15 App Router patterns and best practices.",
    "summary": "Best practices and code patterns for Next.js 15 App Router development.",
    "icon": "âš¡",
    "version": "1.0.0",
    "author": "Barnhardt-Enterprises-Inc",
    "license": "MIT",
    "tags": [
      "nextjs",
      "react",
      "app-router",
      "server-components",
      "server-actions"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Documentation-only skill containing TypeScript code examples for Next.js 15 patterns. Static scanner flagged markdown code blocks and YAML syntax as false positives. No executable code, scripts, or runtime network calls. Safe for marketplace publication.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 5,
    "total_lines": 1299,
    "audit_model": "claude",
    "audited_at": "2026-01-21T14:55:39.712Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Apply Next.js 15 App Router Patterns",
    "value_statement": "This skill provides best practices and code patterns for Next.js 15 App Router development, covering server components, server actions, data fetching strategies, and modern React 19 patterns.",
    "seo_keywords": [
      "Next.js 15",
      "App Router",
      "React Server Components",
      "Server Actions",
      "Next.js patterns",
      "data fetching",
      "streaming",
      "Claude",
      "Codex",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Generate server component code with async/await patterns",
      "Create server action implementations with Zod validation",
      "Implement parallel and sequential data fetching with Suspense",
      "Build route handlers and API endpoints with NextResponse",
      "Add metadata generation and dynamic route patterns"
    ],
    "limitations": [
      "Does not execute code or modify project files directly",
      "Does not install dependencies or configure build tools",
      "Does not interact with databases or external services",
      "Provides patterns and examples rather than complete solutions"
    ],
    "use_cases": [
      {
        "title": "Migrate to Server Components",
        "description": "Refactor client-side components to server components where possible, reducing bundle size and improving performance.",
        "target_user": "Frontend developers modernizing legacy Next.js pages"
      },
      {
        "title": "Implement Server Actions",
        "description": "Replace API routes with server actions for form handling and data mutations, simplifying the codebase.",
        "target_user": "Full-stack developers building interactive forms"
      },
      {
        "title": "Optimize Data Fetching",
        "description": "Apply parallel fetching, caching strategies, and Suspense streaming for faster page loads.",
        "target_user": "Performance-focused developers optimizing Core Web Vitals"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Server Component",
        "prompt": "Show me how to create a server component in Next.js 15 that fetches data from a database.",
        "scenario": "Learning server component basics"
      },
      {
        "title": "Server Action with Validation",
        "prompt": "Create a server action with Zod schema validation that handles form submission and revalidates the cache.",
        "scenario": "Building a validated form with server actions"
      },
      {
        "title": "Parallel Data Fetching",
        "prompt": "Write code for fetching multiple data sources in parallel using Promise.all with Suspense fallbacks.",
        "scenario": "Optimizing dashboard data loading"
      },
      {
        "title": "Full Page Implementation",
        "prompt": "Create a complete Next.js 15 page with server components, loading states, error handling, and metadata generation.",
        "scenario": "Building a production-ready route"
      }
    ],
    "output_examples": [
      {
        "input": "Show me a server component that fetches user data",
        "output": [
          "```typescript",
          "// app/users/[id]/page.tsx",
          "import { notFound } from 'next/navigation';",
          "",
          "async function getUser(id: string) {",
          "  const user = await db.query.users.findFirst({",
          "    where: (users, { eq }) => eq(users.id, id)",
          "  });",
          "  return user;",
          "}",
          "",
          "export default async function UserPage({ params }: { params: { id: string } }) {",
          "  const user = await getUser(params.id);",
          "  if (!user) notFound();",
          "  return (",
          "    <div>",
          "      <h1>{user.name}</h1>",
          "      <p>{user.email}</p>",
          "    </div>",
          "  );",
          "}",
          "```"
        ]
      },
      {
        "input": "Create a server action with validation",
        "output": [
          "```typescript",
          "'use server';",
          "",
          "import { revalidatePath } from 'next/cache';",
          "import { z } from 'zod';",
          "",
          "const CreateUserSchema = z.object({",
          "  name: z.string().min(1),",
          "  email: z.string().email(),",
          "});",
          "",
          "export async function createUser(formData: FormData) {",
          "  const validated = CreateUserSchema.safeParse({",
          "    name: formData.get('name'),",
          "    email: formData.get('email'),",
          "  });",
          "",
          "  if (!validated.success) {",
          "    return { error: validated.error.flatten() };",
          "  }",
          "",
          "  const user = await db.insert(users).values(validated.data).returning();",
          "  revalidatePath('/users');",
          "  return { data: user };",
          "}",
          "```"
        ]
      }
    ],
    "best_practices": [
      "Prefer server components by default and only use 'use client' when client-side interactivity is required",
      "Fetch data directly in server components rather than using API routes for internal data access",
      "Use Zod for server action validation and return typed error responses"
    ],
    "anti_patterns": [
      "Avoid fetching data in client components with useEffect; use server components instead",
      "Do not use API routes for mutations when server actions provide a simpler alternative",
      "Avoid blocking rendering with sequential fetches when data can be loaded in parallel"
    ],
    "faq": [
      {
        "question": "What is the default component type in Next.js 15?",
        "answer": "Server components are the default in Next.js 15 App Router. Components are server-rendered unless marked with 'use client'."
      },
      {
        "question": "When should I use server actions versus API routes?",
        "answer": "Use server actions for form submissions and data mutations. Use API routes only when you need to expose endpoints to external clients."
      },
      {
        "question": "How does data caching work in Next.js 15?",
        "answer": "Fetch requests are cached by default. Use cache: 'no-store' for dynamic data, or next: { revalidate: 60 } for time-based revalidation."
      },
      {
        "question": "What is Suspense streaming?",
        "answer": "Suspense allows parts of the page to stream in progressively while other parts are still loading, improving perceived performance."
      },
      {
        "question": "Can I use React hooks in server components?",
        "answer": "No, hooks like useState and useEffect only work in client components. Server components render on the server without React state."
      },
      {
        "question": "How do I handle errors in server components?",
        "answer": "Create an error.tsx file with 'use client' to handle errors. Use notFound() for 404 cases and throw errors to trigger the error boundary."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "app-router.md",
          "type": "file",
          "path": "references/app-router.md",
          "lines": 53
        },
        {
          "name": "data-fetching.md",
          "type": "file",
          "path": "references/data-fetching.md",
          "lines": 130
        },
        {
          "name": "server-actions.md",
          "type": "file",
          "path": "references/server-actions.md",
          "lines": 116
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 157
    }
  ]
}
