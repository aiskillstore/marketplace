{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T11:07:06.434Z",
    "slug": "barnhardt-enterprises-inc-typescript-strict",
    "source_url": "https://github.com/Barnhardt-Enterprises-Inc/quetrex-claude/tree/main/skills/typescript-strict",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "861fa56d1c81627ae5ba626e791d6d24711904159cb1606904130b7357ca8e07",
    "tree_hash": "eeaa65834bbd47d9d2d51a8e58487cd4aaedcd1ffff376dbd8ae13114f6b2f83"
  },
  "skill": {
    "name": "typescript-strict",
    "description": "Strict TypeScript rules. Use when writing ANY TypeScript.",
    "summary": "Strict TypeScript rules. Use when writing ANY TypeScript.",
    "icon": "ðŸ“˜",
    "version": "1.0.0",
    "author": "Barnhardt-Enterprises-Inc",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "typescript",
      "coding-standards",
      "type-safety",
      "best-practices"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill contains only markdown documentation with TypeScript code examples. No executable code, scripts, network calls, file system access, or environment variable reads. Pure documentation skill with zero risk.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 1,
    "total_lines": 95,
    "audit_model": "claude",
    "audited_at": "2026-01-10T11:07:06.434Z"
  },
  "content": {
    "user_title": "Enforce strict TypeScript standards",
    "value_statement": "TypeScript projects often suffer from implicit 'any' types and loose error handling. This skill provides clear rules and examples for writing type-safe, production-ready TypeScript code that prevents runtime errors.",
    "seo_keywords": [
      "TypeScript strict mode",
      "type safety",
      "Claude Code",
      "type checking",
      "TypeScript best practices",
      "coding standards",
      "error handling TypeScript",
      "TypeScript patterns",
      "Claude",
      "Codex"
    ],
    "actual_capabilities": [
      "Enforces prohibition of 'any' type in favor of 'unknown' with type guards",
      "Requires explicit return types on all functions",
      "Mandates proper error typing with instanceof checks",
      "Prevents non-null assertions (!) without documented justification",
      "Promotes discriminated unions for error handling patterns",
      "Recommends type inference for obvious cases to reduce redundancy"
    ],
    "limitations": [
      "Does not automatically fix code - provides guidance only",
      "Does not integrate with build tools or linters",
      "Does not validate TypeScript configuration files",
      "Does not run type checking or compile code"
    ],
    "use_cases": [
      {
        "target_user": "TypeScript Developers",
        "title": "Enforce Team Coding Standards",
        "description": "Ensure all team members follow consistent TypeScript patterns for better maintainability."
      },
      {
        "target_user": "AI Coding Assistants",
        "title": "Generate Type-Safe Code",
        "description": "Guide AI tools to produce TypeScript code with proper types and error handling."
      },
      {
        "target_user": "Code Reviewers",
        "title": "Review TypeScript PRs",
        "description": "Quickly identify violations of TypeScript best practices during code reviews."
      }
    ],
    "prompt_templates": [
      {
        "title": "Type Function",
        "scenario": "Add types to a function",
        "prompt": "Write a TypeScript function called 'fetchUser' that takes a user ID and returns user data. Use strict types and proper error handling."
      },
      {
        "title": "Fix Any Types",
        "scenario": "Replace 'any' with proper types",
        "prompt": "Refactor this function to remove all 'any' types. Use 'unknown' with type guards where appropriate."
      },
      {
        "title": "Error Handling",
        "scenario": "Implement typed errors",
        "prompt": "Add proper error handling to this function. Use discriminated unions for success and failure cases."
      },
      {
        "title": "Code Review",
        "scenario": "Review TypeScript code",
        "prompt": "Review this TypeScript code for strict mode compliance. Identify any violations of the rules and suggest fixes."
      }
    ],
    "output_examples": [
      {
        "input": "Write a function that processes user data with proper error handling",
        "output": [
          "âœ“ Use 'unknown' instead of 'any' for input parameters",
          "âœ“ Add explicit return type: Promise<User | null>",
          "âœ“ Type catch block errors with instanceof checks",
          "âœ“ Use discriminated union for result: { success: true, data: T } | { success: false, error: string }",
          "âœ“ Add null check before accessing optional properties"
        ]
      }
    ],
    "best_practices": [
      "Always use 'unknown' instead of 'any' and validate with type guards before use",
      "Explicitly type all function signatures including return types for public APIs",
      "Handle errors with proper typing using instanceof checks or type predicates"
    ],
    "anti_patterns": [
      "Using 'any' to silence TypeScript errors instead of properly typing the data",
      "Non-null assertions (!) to bypass strict null checks without proper null handling",
      "Swallowing errors with empty catch blocks or generic console.log without proper error typing"
    ],
    "faq": [
      {
        "question": "Does this skill work with all TypeScript versions?",
        "answer": "Yes. The rules follow TypeScript best practices compatible with TypeScript 4.0 and newer versions."
      },
      {
        "question": "Can I use this with JavaScript projects?",
        "answer": "This skill is TypeScript-specific. Use standard JSDoc annotations for JavaScript projects instead."
      },
      {
        "question": "How does this integrate with my IDE?",
        "answer": "This skill provides guidelines. For IDE integration, use TypeScript's built-in strict mode in tsconfig.json."
      },
      {
        "question": "Does this skill store any data?",
        "answer": "No. This is a documentation-only skill that provides guidance without reading or writing any files."
      },
      {
        "question": "How is this different from ESLint?",
        "answer": "This skill provides reasoning and examples. ESLint enforces rules automatically. Use both together for best results."
      },
      {
        "question": "Should I follow these rules in legacy code?",
        "answer": "Apply rules to new code incrementally. For legacy code, create issues to track violations and address them during refactoring."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
