{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-16T17:41:36.374Z",
    "slug": "barnhardt-enterprises-inc-typescript-strict",
    "source_url": "https://github.com/Barnhardt-Enterprises-Inc/quetrex-claude/tree/main/skills/typescript-strict",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "861fa56d1c81627ae5ba626e791d6d24711904159cb1606904130b7357ca8e07",
    "tree_hash": "6a43c3a36d886ad8410fb4b0701bdde505c6cde23d018e09384f206b4e417fa5"
  },
  "skill": {
    "name": "typescript-strict",
    "description": "Strict TypeScript rules. Use when writing ANY TypeScript.",
    "summary": "Strict TypeScript rules. Use when writing ANY TypeScript.",
    "icon": "ðŸ“˜",
    "version": "1.0.0",
    "author": "Barnhardt-Enterprises-Inc",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "typescript",
      "coding-standards",
      "type-safety",
      "best-practices"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "network",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "This skill contains only markdown documentation with TypeScript code examples. All 31 static findings are false positives: template literal backticks were misidentified as shell execution, base64 hashes were flagged as crypto, and code examples were misidentified as reconnaissance. Pure documentation skill with zero risk.",
    "risk_factor_evidence": [
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "SKILL.md",
            "line_start": 10,
            "line_end": 10
          },
          {
            "file": "SKILL.md",
            "line_start": 11,
            "line_end": 19
          },
          {
            "file": "SKILL.md",
            "line_start": 19,
            "line_end": 22
          },
          {
            "file": "SKILL.md",
            "line_start": 22,
            "line_end": 28
          },
          {
            "file": "SKILL.md",
            "line_start": 28,
            "line_end": 31
          },
          {
            "file": "SKILL.md",
            "line_start": 31,
            "line_end": 41
          },
          {
            "file": "SKILL.md",
            "line_start": 41,
            "line_end": 44
          },
          {
            "file": "SKILL.md",
            "line_start": 44,
            "line_end": 50
          },
          {
            "file": "SKILL.md",
            "line_start": 50,
            "line_end": 51
          },
          {
            "file": "SKILL.md",
            "line_start": 51,
            "line_end": 54
          },
          {
            "file": "SKILL.md",
            "line_start": 54,
            "line_end": 65
          },
          {
            "file": "SKILL.md",
            "line_start": 65,
            "line_end": 68
          },
          {
            "file": "SKILL.md",
            "line_start": 68,
            "line_end": 83
          },
          {
            "file": "SKILL.md",
            "line_start": 83,
            "line_end": 89
          },
          {
            "file": "SKILL.md",
            "line_start": 89,
            "line_end": 91
          },
          {
            "file": "SKILL.md",
            "line_start": 91,
            "line_end": 92
          },
          {
            "file": "SKILL.md",
            "line_start": 92,
            "line_end": 93
          },
          {
            "file": "SKILL.md",
            "line_start": 93,
            "line_end": 94
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 272,
    "audit_model": "claude",
    "audited_at": "2026-01-16T17:41:36.374Z"
  },
  "content": {
    "user_title": "Enforce strict TypeScript standards",
    "value_statement": "TypeScript projects often suffer from implicit any types and loose error handling. This skill provides clear rules and examples for writing type-safe, production-ready TypeScript code that prevents runtime errors.",
    "seo_keywords": [
      "TypeScript strict mode",
      "type safety",
      "Claude Code",
      "type checking",
      "TypeScript best practices",
      "coding standards",
      "error handling TypeScript",
      "TypeScript patterns",
      "Claude",
      "Codex"
    ],
    "actual_capabilities": [
      "Enforces prohibition of any type in favor of unknown with type guards",
      "Requires explicit return types on all functions",
      "Mandates proper error typing with instanceof checks",
      "Prevents non-null assertions without documented justification",
      "Promotes discriminated unions for error handling patterns",
      "Recommends type inference for obvious cases to reduce redundancy"
    ],
    "limitations": [
      "Does not automatically fix code - provides guidance only",
      "Does not integrate with build tools or linters",
      "Does not validate TypeScript configuration files",
      "Does not run type checking or compile code"
    ],
    "use_cases": [
      {
        "target_user": "TypeScript Developers",
        "title": "Enforce Team Coding Standards",
        "description": "Ensure all team members follow consistent TypeScript patterns for better maintainability."
      },
      {
        "target_user": "AI Coding Assistants",
        "title": "Generate Type-Safe Code",
        "description": "Guide AI tools to produce TypeScript code with proper types and error handling."
      },
      {
        "target_user": "Code Reviewers",
        "title": "Review TypeScript PRs",
        "description": "Quickly identify violations of TypeScript best practices during code reviews."
      }
    ],
    "prompt_templates": [
      {
        "title": "Type Function",
        "scenario": "Add types to a function",
        "prompt": "Write a TypeScript function called fetchUser that takes a user ID and returns user data. Use strict types and proper error handling."
      },
      {
        "title": "Fix Any Types",
        "scenario": "Replace any with proper types",
        "prompt": "Refactor this function to remove all any types. Use unknown with type guards where appropriate."
      },
      {
        "title": "Error Handling",
        "scenario": "Implement typed errors",
        "prompt": "Add proper error handling to this function. Use discriminated unions for success and failure cases."
      },
      {
        "title": "Code Review",
        "scenario": "Review TypeScript code",
        "prompt": "Review this TypeScript code for strict mode compliance. Identify any violations of the rules and suggest fixes."
      }
    ],
    "output_examples": [
      {
        "input": "Write a function that processes user data with proper error handling",
        "output": [
          "Use unknown instead of any for input parameters",
          "Add explicit return type: Promise<User | null>",
          "Type catch block errors with instanceof checks",
          "Use discriminated union for result: { success: true, data: T } | { success: false, error: string }",
          "Add null check before accessing optional properties"
        ]
      },
      {
        "input": "Create a type-safe API response handler",
        "output": [
          "Define discriminated union for success and error states",
          "Use exhaustive type checking with switch statements",
          "Validate external data with type guards",
          "Add explicit return type annotations",
          "Handle unknown errors with proper typing"
        ]
      }
    ],
    "best_practices": [
      "Always use unknown instead of any and validate with type guards before use",
      "Explicitly type all function signatures including return types for public APIs",
      "Handle errors with proper typing using instanceof checks or type predicates"
    ],
    "anti_patterns": [
      "Using any to silence TypeScript errors instead of properly typing the data",
      "Non-null assertions to bypass strict null checks without proper null handling",
      "Swallowing errors with empty catch blocks or generic console.log without proper error typing"
    ],
    "faq": [
      {
        "question": "Does this skill work with all TypeScript versions?",
        "answer": "Yes. The rules follow TypeScript best practices compatible with TypeScript 4.0 and newer versions."
      },
      {
        "question": "Can I use this with JavaScript projects?",
        "answer": "This skill is TypeScript-specific. Use standard JSDoc annotations for JavaScript projects instead."
      },
      {
        "question": "How does this integrate with my IDE?",
        "answer": "This skill provides guidelines. For IDE integration, use TypeScript built-in strict mode in tsconfig.json."
      },
      {
        "question": "Does this skill store any data?",
        "answer": "No. This is a documentation-only skill that provides guidance without reading or writing any files."
      },
      {
        "question": "How is this different from ESLint?",
        "answer": "This skill provides reasoning and examples. ESLint enforces rules automatically. Use both together for best results."
      },
      {
        "question": "Should I follow these rules in legacy code?",
        "answer": "Apply rules to new code incrementally. For legacy code, create issues to track violations and address them during refactoring."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 95
    }
  ]
}
