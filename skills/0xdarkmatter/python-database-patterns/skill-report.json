{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T08:42:26.641Z",
    "slug": "0xdarkmatter-python-database-patterns",
    "source_url": "https://github.com/0xDarkMatter/claude-mods/tree/main/skills/python-database-patterns",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "08f9de3f2eab4deb16e7529a2dd41f0b5d26f60267b8c27b046edacd2ad46b9b",
    "tree_hash": "2c7548502e3156c6f04af4bd196454b9509edd8f53c155d6fe8fcecade609711"
  },
  "skill": {
    "name": "python-database-patterns",
    "description": "SQLAlchemy and database patterns for Python. Triggers on: sqlalchemy, database, orm, migration, alembic, async database, connection pool, repository pattern, unit of work.",
    "summary": "SQLAlchemy and database patterns for Python. Triggers on: sqlalchemy, database, orm, migration, alem...",
    "icon": "üóÑÔ∏è",
    "version": "1.0.0",
    "author": "0xDarkMatter",
    "license": "MIT",
    "category": "data",
    "tags": [
      "SQLAlchemy",
      "database",
      "Python",
      "ORM"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Documentation-only skill containing educational SQLAlchemy patterns. No executable code, no network calls, no credential access, no malicious patterns detected.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 6,
    "total_lines": 1473,
    "audit_model": "claude",
    "audited_at": "2026-01-10T08:42:26.640Z"
  },
  "content": {
    "user_title": "Implement Python database patterns with SQLAlchemy",
    "value_statement": "Writing database code is complex and error-prone. This skill provides battle-tested SQLAlchemy 2.0 patterns for models, queries, async sessions, transactions, and migrations.",
    "seo_keywords": [
      "SQLAlchemy",
      "Python database patterns",
      "database ORM",
      "async database",
      "Alembic migrations",
      "connection pooling",
      "repository pattern",
      "unit of work",
      "Claude",
      "Claude Code"
    ],
    "actual_capabilities": [
      "Define SQLAlchemy 2.0 models with mapped columns and type annotations",
      "Write queries using select, where, joins, and aggregates",
      "Configure async sessions with asyncpg and aiosqlite",
      "Implement transaction patterns with savepoints and isolation levels",
      "Set up Alembic migrations for schema changes",
      "Configure connection pooling for production workloads"
    ],
    "limitations": [
      "Does not generate complete database layers or model files",
      "Does not create database drivers or custom connectors",
      "Does not provide deployment or infrastructure code",
      "Requires existing knowledge of SQL fundamentals"
    ],
    "use_cases": [
      {
        "target_user": "Python developers new to SQLAlchemy",
        "title": "Learn SQLAlchemy 2.0",
        "description": "Get started with modern SQLAlchemy patterns for declarative models and type-safe queries"
      },
      {
        "target_user": "Backend engineers",
        "title": "Build async API backends",
        "description": "Implement FastAPI endpoints with async database sessions and transaction management"
      },
      {
        "target_user": "DevOps and platform engineers",
        "title": "Manage database schemas",
        "description": "Set up Alembic migrations and configure connection pools for production databases"
      }
    ],
    "prompt_templates": [
      {
        "title": "Define a model",
        "scenario": "Create SQLAlchemy model",
        "prompt": "Create a SQLAlchemy 2.0 model called Product with id, name, price, and category relationship"
      },
      {
        "title": "Write async query",
        "scenario": "Query with async session",
        "prompt": "Write an async function to fetch a user by email with their posts eagerly loaded"
      },
      {
        "title": "Handle transaction",
        "scenario": "Transfer funds atomically",
        "prompt": "Implement a transfer_funds function with pessimistic locking to prevent race conditions"
      },
      {
        "title": "Configure pool",
        "scenario": "Production pool settings",
        "prompt": "Show me how to configure connection pool size, overflow, and pre-ping for a production PostgreSQL async engine"
      }
    ],
    "output_examples": [
      {
        "input": "Create a User model with email unique constraint and a relationship to Post",
        "output": [
          "- Define User class with mapped columns",
          "- Add unique constraint on email field",
          "- Create one-to-many relationship to Post model",
          "- Use back_populates for bidirectional navigation"
        ]
      }
    ],
    "best_practices": [
      "Use SQLAlchemy 2.0 declarative style with Mapped and mapped_column for type safety",
      "Prefer session.execute with select() over legacy session.query() method",
      "Configure pool_pre_ping=True to catch stale connections before queries",
      "Use eager loading (selectinload/joinedload) to avoid N+1 queries in async contexts"
    ],
    "anti_patterns": [
      "Using lazy loading in async sessions causes MissingGreenlet errors",
      "Calling session.commit() inside session.begin() creates nested transaction issues",
      "Hardcoding database URLs instead of using environment configuration",
      "Skipping pool_recycle causing connections to timeout after long queries"
    ],
    "faq": [
      {
        "question": "What SQLAlchemy versions are supported?",
        "answer": "SQLAlchemy 2.0+ with Python 3.10+. Async requires asyncpg for PostgreSQL or aiosqlite for SQLite."
      },
      {
        "question": "Can I use this with FastAPI?",
        "answer": "Yes. The skill includes FastAPI dependency injection patterns for async database sessions."
      },
      {
        "question": "How do I size the connection pool?",
        "answer": "Start with pool_size=5 and max_overflow=10. Adjust based on concurrent users and query patterns."
      },
      {
        "question": "Is my data safe with these patterns?",
        "answer": "Yes. Patterns include transaction safety, optimistic locking, and proper session lifecycle management."
      },
      {
        "question": "Why are my async queries failing?",
        "answer": "Common causes include lazy loading without eager loading, uncommitted transactions, or connection pool exhaustion."
      },
      {
        "question": "How does this compare to raw SQL?",
        "answer": "SQLAlchemy provides type safety and abstraction while generating optimized SQL. Use text() for raw queries when needed."
      }
    ]
  },
  "file_structure": [
    {
      "name": "assets",
      "type": "dir",
      "path": "assets",
      "children": [
        {
          "name": "alembic.ini.template",
          "type": "file",
          "path": "assets/alembic.ini.template"
        }
      ]
    },
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "connection-pooling.md",
          "type": "file",
          "path": "references/connection-pooling.md"
        },
        {
          "name": "migrations.md",
          "type": "file",
          "path": "references/migrations.md"
        },
        {
          "name": "sqlalchemy-async.md",
          "type": "file",
          "path": "references/sqlalchemy-async.md"
        },
        {
          "name": "transactions.md",
          "type": "file",
          "path": "references/transactions.md"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
