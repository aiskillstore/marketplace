{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-21T15:42:55.570Z",
    "slug": "ancplua-verification-before-completion",
    "source_url": "https://github.com/ANcpLua/ancplua-claude-plugins/tree/main/plugins/metacognitive-guard/skills/verification-before-completion",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "e0bb72e05554f904bec693057f6bfae96454a9149dd323300dc2d6bc13248a9b",
    "tree_hash": "5e61d258037657ff051c5b2ed6045ed281ee3591880560fb6d55ec115dd5cdb7"
  },
  "skill": {
    "name": "verification-before-completion",
    "description": "Forces verification before claiming success or completion. Prevents false completion claims by requiring actual build and test execution before declaring code ready.",
    "summary": "Metacognitive guard that prevents Claude from claiming code works without verification",
    "icon": "ðŸ“¦",
    "version": "1.0.0",
    "author": "ANcpLua",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "quality-assurance",
      "verification",
      "testing",
      "metacognitive",
      "build-automation"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": []
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Legitimate metacognitive guard skill with no security risks. All static findings are false positives: C2 keywords are SHA256 integrity hashes, weak crypto alerts triggered on hash strings, network detection is metadata URL, and external commands are markdown documentation examples of standard development commands. The skill is purely instructional and contains no executable code.",
    "risk_factor_evidence": [],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [
      {
        "title": "False positive: SHA256 hashes flagged as C2 keywords",
        "description": "Static analyzer detected content_hash and tree_hash fields as potential C2 indicators. These are legitimate SHA256 integrity verification hashes used for change detection, not malicious patterns.",
        "locations": [
          {
            "file": "skill-report.json",
            "line_start": 11,
            "line_end": 12
          }
        ]
      },
      {
        "title": "False positive: Metadata URL flagged as network risk",
        "description": "The source_url field in metadata flagged as hardcoded URL. This is standard metadata pointing to the GitHub repository source, not a security concern.",
        "locations": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "title": "False positive: Documentation examples flagged as shell execution",
        "description": "Markdown inline code examples showing dotnet build, dotnet test, and npm commands were flagged as Ruby/shell backtick execution. These are documentation examples demonstrating proper verification commands, not executable code.",
        "locations": [
          {
            "file": "SKILL.md",
            "line_start": 35,
            "line_end": 159
          }
        ]
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 2,
    "total_lines": 493,
    "audit_model": "claude",
    "audited_at": "2026-01-21T15:42:55.570Z",
    "risk_factors": []
  },
  "content": {
    "user_title": "Verify Code Before Claiming Completion",
    "value_statement": "Claude often claims code works without verification. This skill enforces actual build and test execution before any completion claim, eliminating false positives and ensuring reliable code delivery.",
    "seo_keywords": [
      "Claude",
      "Codex",
      "Claude Code",
      "code verification",
      "build verification",
      "test automation",
      "quality assurance",
      "metacognitive guards",
      "test-driven development",
      "code quality gates"
    ],
    "actual_capabilities": [
      "Detects completion claim keywords before Claude declares code ready",
      "Provides verification checklist template for build and test execution",
      "Shows anti-patterns and correct verification workflows",
      "Enforces edge case testing before success claims",
      "Requires reproduction steps for bug fix verification",
      "Guides proper output demonstration to users"
    ],
    "limitations": [
      "Does not execute commands automatically",
      "Requires Claude or user to run actual verification steps",
      "Focuses on .NET and JavaScript examples",
      "Relies on keyword detection for trigger activation"
    ],
    "use_cases": [
      {
        "title": "Prevent Premature Completion Claims",
        "description": "Ensures Claude runs builds and tests before declaring code ready, catching compilation errors and test failures before users encounter them.",
        "target_user": "Software developers needing reliable code delivery"
      },
      {
        "title": "Quality Gate Enforcement",
        "description": "Acts as a checkpoint that verifies code compiles, tests pass, and edge cases are handled before code review or deployment begins.",
        "target_user": "Engineering teams enforcing quality standards"
      },
      {
        "title": "Bug Fix Verification",
        "description": "Ensures bugs are reproduced, fixed, and verified through testing before claiming resolution, preventing regression issues.",
        "target_user": "Developers fixing production issues"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Feature Implementation",
        "prompt": "Implement a JSON parser function. Use verification-before-completion to ensure it builds and tests pass before claiming done.",
        "scenario": "Simple coding task requiring build verification"
      },
      {
        "title": "Bug Fix with Verification",
        "prompt": "Fix the null reference exception in the user authentication service. Use verification-before-completion to reproduce, fix, and verify the bug no longer occurs.",
        "scenario": "Bug fixing requiring reproduction and regression testing"
      },
      {
        "title": "Feature with Edge Cases",
        "prompt": "Add input validation to the API endpoint. Use verification-before-completion to verify build, tests, empty input handling, and boundary cases.",
        "scenario": "Feature development with comprehensive verification"
      },
      {
        "title": "Multi-Step Integration",
        "prompt": "Create a data processing pipeline with error handling. Use verification-before-completion to show build passes, all tests pass, and error scenarios are handled correctly.",
        "scenario": "Complex workflow requiring full verification cycle"
      }
    ],
    "output_examples": [
      {
        "input": "I've implemented the feature. The implementation is complete.",
        "output": "Let me verify before claiming completion.\n\n## Verification Checklist\n\n### Build Status\n- [x] dotnet build - PASS\n- [x] dotnet test - PASS (24/24 tests)\n\n### Verification Steps Performed\n1. Ran dotnet build - succeeded with no errors\n2. Executed full test suite - all 24 tests passing\n3. Tested empty state and error handling\n\n### Confidence\nHIGH - Verified builds and tests pass\n\n### Ready to Claim Complete\nYES - The feature implementation is complete."
      },
      {
        "input": "The bug is fixed. You can use the API now.",
        "output": "Let me verify the fix works.\n\n## Verification Checklist\n\n### Build Status\n- [x] npm run build - PASS\n- [x] npm test - PASS (12/12 tests)\n\n### Verification Steps Performed\n1. Reproduced original bug - confirmed failure before fix\n2. Applied fix to authentication handler\n3. Ran tests - all passing\n4. Tested token expiration edge case\n\n### Confidence\nHIGH - Bug reproduced, fixed, and verified\n\n### Ready to Claim Complete\nYES - The bug is fixed."
      },
      {
        "input": "This React component should render correctly now.",
        "output": "Let me verify by running the development server.\n\n## Verification Checklist\n\n### Build Status\n- [x] npm run dev - PASS\n\n### Verification Steps Performed\n1. Started development server\n2. Checked browser console - no errors\n3. Tested component in different states:\n   - Initial load: renders correctly\n   - Empty state: shows placeholder\n   - Error state: displays error message\n\n### Confidence\nHIGH - Component verified in multiple states\n\n### Ready to Claim Complete\nYES - Component renders correctly."
      }
    ],
    "best_practices": [
      "Always run build commands before claiming code works",
      "Execute test suites and show passing results as evidence",
      "Test edge cases beyond happy path scenarios before completion claims"
    ],
    "anti_patterns": [
      "Claiming code works without running any verification commands",
      "Saying this should work instead of proving it does work",
      "Skipping tests and declaring implementation complete anyway"
    ],
    "faq": [
      {
        "question": "Does this skill automatically run build and test commands?",
        "answer": "No. This skill instructs Claude to run verification commands. Claude or the user must execute the actual build and test commands to verify the code."
      },
      {
        "question": "What keywords trigger the verification checklist?",
        "answer": "Keywords like done, complete, finished, works, fixed, implementation is ready, this should work, and similar completion claims trigger the verification requirement."
      },
      {
        "question": "Can I use this skill with languages other than .NET and JavaScript?",
        "answer": "Yes. The verification principle applies to all languages. The examples use dotnet and npm commands, but you can adapt the checklist to any language build system."
      },
      {
        "question": "What if my project does not have automated tests?",
        "answer": "The skill allows skipping tests with explicit justification. You must state why tests are not applicable or provide alternative verification methods."
      },
      {
        "question": "How does this improve code quality?",
        "answer": "By enforcing verification before completion claims, Claude catches build errors, test failures, and edge case bugs before presenting code, resulting in more reliable deliverables."
      },
      {
        "question": "Can I customize the verification checklist?",
        "answer": "Yes. The skill provides a template you can modify. You can add project-specific verification steps or customize commands for your development environment."
      }
    ]
  },
  "file_structure": [
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 165
    }
  ]
}
