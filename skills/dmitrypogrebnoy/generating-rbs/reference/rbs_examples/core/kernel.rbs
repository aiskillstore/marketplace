%a{annotate:rdoc:source:from=object.c}
module Kernel : BasicObject
  def self?.caller: (Integer start_or_range, ?Integer length) -> ::Array[String]?
                  | (::Range[Integer] start_or_range) -> ::Array[String]?
                  | () -> ::Array[String]

  def self?.caller_locations: (Integer start_or_range, ?Integer length) -> ::Array[Thread::Backtrace::Location]?
                            | (::Range[Integer] start_or_range) -> ::Array[Thread::Backtrace::Location]?
                            | () -> ::Array[Thread::Backtrace::Location]

  def self?.catch: [T] (T tag) { (T tag) -> untyped } -> untyped
                 | () { (Object tag) -> untyped } -> untyped

  def class: () -> Class

  def self?.eval: (string src, ?Binding? scope, ?string filename, ?int lineno) -> untyped

  def self?.block_given?: () -> bool

  def self?.local_variables: () -> ::Array[Symbol]

  def self?.srand: (?int number) -> Integer

  def self?.fork: () -> Integer?
                | () { () -> void } -> Integer

  def self?.Array: (nil) -> []
                 | [T] (array[T] | _ToA[T] array_like) -> Array[T]
                 | [T] (T ele) -> [T]

  def self?.Complex: (_ToC complex_like, ?exception: true) -> Complex
                   | (_ToC complex_like, exception: bool) -> Complex?
                   | (Numeric | String real, ?Numeric | String imag, ?exception: true) -> Complex
                   | (Numeric | String real, ?Numeric | String imag, exception: bool) -> Complex?
                   | (untyped, ?untyped, ?exception: bool) -> Complex?

  def self?.Float: (_ToF float_like, ?exception: true) -> Float
                 | (_ToF float_like, exception: bool) -> Float?
                 | (untyped, ?exception: bool) -> Float?

  def self?.Hash: [K, V] (nil | [] _empty) -> Hash[K, V]
                | [K, V] (hash[K, V] hash_like) -> Hash[K, V]

  def self?.Integer: (int | _ToI int_like, ?exception: true) -> Integer
                   | (int | _ToI int_like, exception: bool) -> Integer?
                   | (string str, int base, ?exception: true) -> Integer
                   | (string str, int base, exception: bool) -> Integer?
                   | (untyped, ?untyped, ?exception: bool) -> Integer?

  def self?.Rational: (int | _ToR rational_like, ?exception: true) -> Rational
                    | (int | _ToR rational_like, exception: bool) -> Rational?
                    | (int | _ToR numer, ?int | _ToR denom, ?exception: true) -> Rational
                    | (int | _ToR numer, ?int | _ToR denom, exception: bool) -> Rational?
                    | [T] (Numeric & _RationalDiv[T] numer, Numeric denom, ?exception: bool) -> T
                    | [T < Numeric] (T value, 1, ?exception: bool) -> T
                    | (untyped, ?untyped, ?exception: bool) -> Rational?

  interface _RationalDiv[T]
    def /: (Numeric) -> T
  end

  def self?.String: (string | _ToS string_like) -> String

  def self?.__callee__: () -> Symbol?

  def self?.__dir__: () -> String?

  def self?.__method__: () -> Symbol?

  def self?.`: (String arg0) -> String

  def self?.abort: (?string msg) -> bot

  def self?.at_exit: () { () -> void } -> Proc

  def self?.autoload: (interned _module, String filename) -> NilClass

  def self?.autoload?: (interned name) -> String?

  def self?.binding: () -> Binding

  def self?.exit: (?int | bool status) -> bot

  def self?.exit!: (?int | bool status) -> bot

  def self?.fail: () -> bot
                | (string message, ?cause: Exception?) -> bot
                | (_Exception exception, ?_ToS? message, ?String | Array[String] | Array[Thread::Backtrace::Location] | nil backtrace, ?cause: Exception?) -> bot
                | (_Exception exception, ?cause: Exception?, **untyped) -> bot

  alias raise fail

  alias self.raise self.fail

  def self?.format: (String format, *untyped args) -> String

  alias sprintf format

  alias self.sprintf self.format

  def self?.gets: (?String sep, ?Integer limit, ?chomp: boolish) -> String?

  def self?.global_variables: () -> ::Array[Symbol]

  def self?.load: (String filename, ?Module | bool) -> bool

  def self?.loop: () { () -> void } -> bot
                | () -> ::Enumerator[nil, bot]

  def self?.open: (String name, ?String mode, ?Integer perm) -> IO?
                | [T] (String name, ?String mode, ?Integer perm) { (IO) -> T } -> T

  def self?.print: (*_ToS args) -> nil

  def self?.printf: () -> nil
                  | (String fmt, *untyped args) -> nil
                  | (_Writer io, string fmt, *untyped args) -> nil

  def self?.proc: () { (?) -> untyped } -> Proc

  def self?.lambda: () { () -> untyped } -> Proc

  def self?.putc: [T < _ToInt] (T chr) -> T
                | (String chr) -> String

  def self?.puts: (*_ToS objects) -> nil

  def self?.p: [T < _Inspect] (T arg0) -> T
             | (_Inspect arg0, _Inspect arg1, *_Inspect rest) -> Array[_Inspect]
             | () -> nil

  def self?.pp: [T] (T arg0) -> T
              | (untyped, untyped, *untyped) -> Array[untyped]
              | () -> nil

  def self?.rand: (?0) -> Float
                | (int arg0) -> Integer
                | (::Range[Integer] arg0) -> Integer?
                | (::Range[Float] arg0) -> Float?

  def self?.readline: (?String arg0, ?Integer arg1, ?chomp: boolish) -> String

  def self?.readlines: (?string sep, ?int limit, ?chomp: boolish) -> ::Array[String]

  def self?.require: (String path) -> bool

  def self?.require_relative: (String feature) -> bool

  def self?.select: (::Array[IO] read, ?::Array[IO] write, ?::Array[IO] error, ?Time::_Timeout timeout) -> ::Array[String]

  def self?.sleep: (?nil) -> bot
                 | (Time::_Timeout duration) -> Integer

  %a{deprecated}
  interface _Divmod
    def divmod: (Numeric) -> [ Numeric, Numeric ]
  end

  def self?.syscall: (Integer num, *untyped args) -> untyped

  def self?.test: (String | Integer cmd, String | IO file1, ?String | IO file2) -> (TrueClass | FalseClass | Time | nil | Integer)

  def self?.throw: (untyped tag, ?untyped obj) -> bot

  def self?.warn: (*_ToS msg, ?uplevel: int?, ?category: Warning::category?) -> nil

  def self?.exec: (String command, *String args, ?unsetenv_others: bool, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: bool, ?chdir: String) -> bot
                | (Hash[string, string?] env, String command, *String args, ?unsetenv_others: bool, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: bool, ?chdir: String) -> bot

  type redirect_fd = Integer | :in | :out | :err | IO | String | [ String ] | [ String, string | int ] | [ String, string | int, int ] | [ :child, int ] | :close

  def self?.spawn: (String command, *String args, ?unsetenv_others: bool, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: bool, ?chdir: String) -> Integer
                 | (Hash[string, string?] env, String command, *String args, ?unsetenv_others: bool, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: bool, ?chdir: String) -> Integer

  def self?.system: (String command, *String args, ?unsetenv_others: bool, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: bool, ?chdir: String, ?exception: bool) -> (NilClass | FalseClass | TrueClass)
                  | (Hash[string, string?] env, String command, *String args, ?unsetenv_others: bool, ?pgroup: true | Integer, ?umask: Integer, ?in: redirect_fd, ?out: redirect_fd, ?err: redirect_fd, ?close_others: bool, ?chdir: String, ?exception: bool) -> (NilClass | FalseClass | TrueClass)

  def !~: (untyped other) -> bool

  def <=>: (untyped other) -> 0?

  alias === ==

  def clone: (?freeze: bool?) -> self

  def define_singleton_method: (interned name, Method | UnboundMethod | Proc method) -> Symbol
                             | (interned name) { (?) [self: self] -> untyped } -> Symbol

  def display: (?_Writer port) -> nil

  def dup: () -> self

  def enum_for: (?interned method, *untyped, **untyped) ?{ (*untyped, **untyped) -> Integer } -> Enumerator[untyped, untyped]

  alias to_enum enum_for

  def eql?: (untyped other) -> bool

  def extend: (Module module, *Module other_modules) -> self

  def freeze: () -> self

  def frozen?: () -> bool

  def hash: () -> Integer

  def inspect: () -> String

  def instance_of?: (Module | Class module_or_class) -> bool

  def instance_variable_defined?: (interned variable) -> bool

  def instance_variable_get: (interned variable) -> untyped

  def instance_variable_set: [T] (interned variable, T value) -> T

  def instance_variables: () -> Array[Symbol]

  def is_a?: (Module | Class module_or_class) -> bool

  alias kind_of? is_a?

  def itself: () -> self

  def method: (interned name) -> Method

  def methods: (?boolish regular) -> Array[Symbol]

  def nil?: () -> false

  alias object_id __id__

  def private_methods: (?boolish all) -> Array[Symbol]

  def protected_methods: (?boolish all) -> Array[Symbol]

  def public_method: (interned name) -> Method

  def public_methods: (?boolish all) -> Array[Symbol]

  def public_send: (interned name, *untyped, **untyped) ?{ (?) -> untyped } -> untyped

  def remove_instance_variable: (interned variable) -> untyped

  def respond_to?: (interned name, ?boolish include_all) -> bool

  private def respond_to_missing?: (Symbol | String name, bool include_all) -> bool

  alias send __send__

  def singleton_class: () -> Class

  def singleton_method: (interned name) -> Method

  def singleton_methods: (?boolish all) -> Array[Symbol]

  def tap: () { (self) -> void } -> self

  def to_s: () -> String

  def yield_self: () -> Enumerator[self, untyped]
                | [T] () { (self) -> T } -> T

  alias then yield_self

  private

  def initialize_copy: (self object) -> self

  def initialize_clone: (self object, ?freeze: bool?) -> self

  def initialize_dup: (self object) -> self
end
