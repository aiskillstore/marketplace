module Enumerable[unchecked out Elem] : _Each[Elem]
  %a{private}
  interface _Pattern
    def ===: (untyped) -> bool
  end

  def all?: () -> bool
          | (_Pattern) -> bool
          | () { (Elem) -> boolish } -> bool

  def any?: () -> bool
          | (_Pattern) -> bool
          | () { (Elem) -> boolish } -> bool

  def collect: [U] () { (Elem arg0) -> U } -> ::Array[U]
             | () -> ::Enumerator[Elem, ::Array[untyped]]

  def collect_concat: [U] () { (Elem) -> (::Array[U] | U) } -> ::Array[U]
                    | () -> ::Enumerator[Elem, ::Array[untyped]]

  def compact: () -> Array[Elem]

  def count: () -> Integer
           | (Elem) -> Integer
           | () { (Elem) -> boolish } -> Integer

  def cycle: (?Integer n) { (Elem arg0) -> untyped } -> NilClass
           | (?Integer n) -> ::Enumerator[Elem, NilClass]

  def detect: (?Proc ifnone) { (Elem) -> boolish } -> Elem?
            | (?Proc ifnone) -> ::Enumerator[Elem, Elem?]

  def drop: (Integer n) -> ::Array[Elem]

  def drop_while: () { (Elem) -> boolish } -> ::Array[Elem]
                | () -> ::Enumerator[Elem, ::Array[Elem]]

  def each_cons: (Integer n) { (::Array[Elem]) -> void } -> self
               | (Integer n) -> ::Enumerator[::Array[Elem], self]

  def each_with_index: () { (Elem, Integer index) -> untyped } -> self
                     | () -> ::Enumerator[[ Elem, Integer ], self]

  def each_with_object: [U] (U obj) { (Elem, U obj) -> untyped } -> U
                      | [U] (U obj) -> ::Enumerator[[ Elem, U ], U]

  def entries: () -> ::Array[Elem]

  def enum_for: (Symbol method, *untyped, **untyped) ?{ (?) -> Integer } -> Enumerator[untyped, untyped]
              | () ?{ () -> Integer } -> Enumerator[Elem, self]

  %a{annotate:rdoc:skip}
  alias to_enum enum_for

  def find_all: () { (Elem) -> boolish } -> ::Array[Elem]
              | () -> ::Enumerator[Elem, ::Array[Elem]]

  alias select find_all

  alias filter find_all

  def find_index: (untyped value) -> Integer?
                | () { (Elem) -> boolish } -> Integer?
                | () -> ::Enumerator[Elem, Integer?]

  def first: () -> Elem?
           | (_ToInt n) -> ::Array[Elem]

  def grep: (untyped arg0) -> ::Array[Elem]
          | [U] (untyped arg0) { (Elem arg0) -> U } -> ::Array[U]

  def grep_v: (untyped) -> ::Array[Elem]
            | [U] (untyped) { (Elem) -> U } -> ::Array[U]

  def group_by: [U] () { (Elem arg0) -> U } -> ::Hash[U, ::Array[Elem]]
              | () -> ::Enumerator[Elem, ::Array[Elem]]

  def include?: (Elem arg0) -> bool

  def inject: (untyped init, Symbol method) -> untyped
            | (Symbol method) -> untyped
            | [A] (A initial) { (A, Elem) -> A } -> A
            | () { (Elem, Elem) -> Elem } -> Elem

  def max: () -> Elem?
         | () { (Elem arg0, Elem arg1) -> Integer } -> Elem?
         | (Integer arg0) -> ::Array[Elem]
         | (Integer arg0) { (Elem arg0, Elem arg1) -> Integer } -> ::Array[Elem]

  def max_by: () -> ::Enumerator[Elem, Elem?]
            | () { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> Elem?
            | (Integer arg0) -> ::Enumerator[Elem, ::Array[Elem]]
            | (Integer arg0) { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> ::Array[Elem]

  def min: () -> Elem?
         | () { (Elem arg0, Elem arg1) -> Integer } -> Elem?
         | (Integer arg0) -> ::Array[Elem]
         | (Integer arg0) { (Elem arg0, Elem arg1) -> Integer } -> ::Array[Elem]

  def min_by: () -> ::Enumerator[Elem, Elem?]
            | () { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> Elem?
            | (Integer arg0) -> ::Enumerator[Elem, ::Array[Elem]]
            | (Integer arg0) { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> ::Array[Elem]

  def minmax: () -> [ Elem?, Elem? ]
            | () { (Elem arg0, Elem arg1) -> Integer } -> [ Elem?, Elem? ]

  def minmax_by: () -> [ Elem?, Elem? ]
               | () { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> [ Elem?, Elem? ]

  def none?: () -> bool
           | (_Pattern) -> bool
           | () { (Elem) -> boolish } -> bool

  def one?: () -> bool
          | (_Pattern) -> bool
          | () { (Elem) -> boolish } -> bool

  def partition: () { (Elem) -> boolish } -> [ ::Array[Elem], ::Array[Elem] ]
               | () -> ::Enumerator[Elem, [ ::Array[Elem], ::Array[Elem] ]]

  def reject: () { (Elem) -> boolish } -> ::Array[Elem]
            | () -> ::Enumerator[Elem, ::Array[Elem]]

  def reverse_each: () { (Elem arg0) -> untyped } -> void
                  | () -> ::Enumerator[Elem]

  def sort: () -> ::Array[Elem]
          | () { (Elem arg0, Elem arg1) -> Integer } -> ::Array[Elem]

  def sort_by: () { (Elem arg0) -> (Comparable | ::Array[untyped]) } -> ::Array[Elem]
             | () -> ::Enumerator[Elem, ::Array[Elem]]

  def take: (Integer n) -> ::Array[Elem]

  def take_while: () { (Elem) -> boolish } -> ::Array[Elem]
                | () -> ::Enumerator[Elem, ::Array[Elem]]

  def to_h: () -> ::Hash[untyped, untyped]
          | [T, U] () { (Elem) -> [ T, U ] } -> ::Hash[T, U]

  def each_slice: (Integer n) { (::Array[Elem]) -> void } -> self
                | (Integer n) -> ::Enumerator[::Array[Elem], self]

  interface _NotFound[T]
    def call: () -> T
  end

  def find: () { (Elem) -> boolish } -> Elem?
          | () -> ::Enumerator[Elem, Elem?]
          | [T] (_NotFound[T] ifnone) { (Elem) -> boolish } -> (Elem | T)
          | [T] (_NotFound[T] ifnone) -> ::Enumerator[Elem, Elem | T]

  def flat_map: [U] () { (Elem) -> (Array[U] | U) } -> Array[U]
              | () -> ::Enumerator[Elem, Array[untyped]]

  def map: [U] () { (Elem arg0) -> U } -> ::Array[U]
         | () -> ::Enumerator[Elem, ::Array[untyped]]

  def member?: (Elem arg0) -> bool

  alias reduce inject

  def to_a: () -> ::Array[Elem]

  def lazy: () -> Enumerator::Lazy[Elem]

  def uniq: () -> ::Array[Elem]
          | () { (Elem item) -> untyped } -> ::Array[Elem]

  def sum: () -> (Elem | Integer)
         | [T] () { (Elem arg0) -> T } -> (Integer | T)
         | [T] (?T arg0) -> (Elem | T)
         | [U] (?U arg0) { (Elem arg0) -> U } -> U

  def filter_map: [U] () { (Elem elem) -> (nil | false | U) } -> ::Array[U]
                | () -> ::Enumerator[Elem, ::Array[untyped]]

  def chain: [Elem2] (*_Each[Elem2] enumerables) -> ::Enumerator::Chain[Elem | Elem2]

  def tally: (?Hash[Elem, Integer] hash) -> ::Hash[Elem, Integer]

  def each_entry: () -> ::Enumerator[Elem, self]
                | () { (Elem arg0) -> untyped } -> self

  def zip: [Elem2] (_Each[Elem2] enum) -> Array[[ Elem, Elem2? ]]
         | (_Each[untyped], *_Each[untyped]) -> Array[Array[untyped]]
         | [Elem2] (_Each[Elem2]) { ([ Elem, Elem2? ]) -> void } -> nil
         | (_Each[untyped], *_Each[untyped]) { (Array[untyped]) -> void } -> nil

  def chunk: [U] () { (Elem elt) -> U } -> ::Enumerator[[ U, ::Array[Elem] ]]
           | () -> ::Enumerator[Elem, ::Enumerator[[ untyped, ::Array[Elem] ]]]

  def chunk_while: () { (Elem elt_before, Elem elt_after) -> boolish } -> ::Enumerator[::Array[Elem]]

  def slice_when: () { (Elem elt_before, Elem elt_after) -> boolish } -> ::Enumerator[::Array[Elem]]

  def slice_after: (untyped pattern) -> ::Enumerator[::Array[Elem]]
                 | () { (Elem elt) -> boolish } -> ::Enumerator[::Array[Elem]]

  def slice_before: (untyped pattern) -> ::Enumerator[::Array[Elem]]
                  | () { (Elem elt) -> boolish } -> ::Enumerator[::Array[Elem]]
end
