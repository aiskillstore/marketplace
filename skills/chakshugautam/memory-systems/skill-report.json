{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-16T21:19:10.093Z",
    "slug": "chakshugautam-memory-systems",
    "source_url": "https://github.com/ChakshuGautam/games/tree/main/.claude/skills/memory-systems",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "bd8b3cadecefd009cf2e5d3068ff5bfd60374a13d3909bb12fcabfe7cedb3620",
    "tree_hash": "f83cf59e0874d5248985b034ee3661ef4ce4d786ffdf65c648a4c4ccbc15c860"
  },
  "skill": {
    "name": "memory-systems",
    "description": "This skill should be used when the user asks to \"implement agent memory\", \"persist state across sessions\", \"build knowledge graph\", \"track entities\", or mentions memory architecture, temporal knowledge graphs, vector stores, entity memory, or cross-session persistence.",
    "summary": "This skill should be used when the user asks to \"implement agent memory\", \"persist state across sess...",
    "icon": "ðŸ§ ",
    "version": "1.0.0",
    "author": "ChakshuGautam",
    "license": "MIT",
    "category": "data",
    "tags": [
      "memory",
      "knowledge-graph",
      "vector-store",
      "persistence"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "external_commands",
      "network",
      "filesystem"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All 89 static findings are FALSE POSITIVES. The skill contains documentation and pure Python data structure implementations for memory system architecture. No network calls, filesystem access, external command execution, or sensitive data handling. The code runs entirely in-memory using standard libraries.",
    "risk_factor_evidence": [
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "references/implementation.md",
            "line_start": 9,
            "line_end": 80
          },
          {
            "file": "references/implementation.md",
            "line_start": 80,
            "line_end": 84
          },
          {
            "file": "references/implementation.md",
            "line_start": 84,
            "line_end": 134
          },
          {
            "file": "references/implementation.md",
            "line_start": 134,
            "line_end": 140
          },
          {
            "file": "references/implementation.md",
            "line_start": 140,
            "line_end": 244
          },
          {
            "file": "references/implementation.md",
            "line_start": 244,
            "line_end": 248
          },
          {
            "file": "references/implementation.md",
            "line_start": 248,
            "line_end": 320
          },
          {
            "file": "references/implementation.md",
            "line_start": 320,
            "line_end": 324
          },
          {
            "file": "references/implementation.md",
            "line_start": 324,
            "line_end": 386
          },
          {
            "file": "references/implementation.md",
            "line_start": 386,
            "line_end": 390
          },
          {
            "file": "references/implementation.md",
            "line_start": 390,
            "line_end": 457
          },
          {
            "file": "SKILL.md",
            "line_start": 154,
            "line_end": 166
          },
          {
            "file": "SKILL.md",
            "line_start": 166,
            "line_end": 169
          },
          {
            "file": "SKILL.md",
            "line_start": 169,
            "line_end": 179
          }
        ]
      },
      {
        "factor": "network",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "skill-report.json",
            "line_start": 6,
            "line_end": 6
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 4,
    "total_lines": 1280,
    "audit_model": "claude",
    "audited_at": "2026-01-16T21:19:10.093Z"
  },
  "content": {
    "user_title": "Implement persistent agent memory",
    "value_statement": "Agents lose all knowledge when sessions end. This skill provides patterns for layered memory architectures that preserve entity knowledge, track relationships, and enable temporal queries across sessions.",
    "seo_keywords": [
      "memory systems",
      "agent memory",
      "knowledge graph",
      "vector store",
      "Claude",
      "Codex",
      "Claude Code",
      "temporal knowledge graph",
      "entity tracking",
      "context engineering"
    ],
    "actual_capabilities": [
      "Design layered memory architectures from context to permanent storage",
      "Implement vector stores with metadata filtering and entity indexing",
      "Build property graphs for entity relationship tracking",
      "Create temporal knowledge graphs with validity periods",
      "Implement memory consolidation to manage growing knowledge bases",
      "Integrate memory retrieval with context systems"
    ],
    "limitations": [
      "Does not provide database infrastructure or hosting",
      "Does not include embedding model integration",
      "Requires separate implementation of persistence layer"
    ],
    "use_cases": [
      {
        "target_user": "AI Developers",
        "title": "Persistent user context",
        "description": "Build agents that remember user preferences and conversation history across sessions"
      },
      {
        "target_user": "Enterprise Teams",
        "title": "Knowledge base building",
        "description": "Create growing knowledge bases that agents can query and expand over time"
      },
      {
        "target_user": "Multi-Agent Systems",
        "title": "Shared memory across agents",
        "description": "Implement memory systems that enable multiple agents to share context"
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic Persistence",
        "scenario": "Remember across sessions",
        "prompt": "Implement a memory system that stores facts about entities and retrieves them in future sessions."
      },
      {
        "title": "Entity Tracking",
        "scenario": "Track entities",
        "prompt": "Create an entity memory pattern that maintains identity, properties, and relationships for entities mentioned across multiple conversations."
      },
      {
        "title": "Temporal Queries",
        "scenario": "Query at specific times",
        "prompt": "Build a temporal knowledge graph that supports queries like what was the users address on January 15, 2024."
      },
      {
        "title": "Consolidation",
        "scenario": "Manage growing memory",
        "prompt": "Implement memory consolidation that merges duplicate facts and removes outdated information."
      }
    ],
    "output_examples": [
      {
        "input": "Implement a memory system for a customer service agent that remembers user preferences.",
        "output": [
          "Architecture: 3-layer memory with session state, user profile memory, and resolution knowledge base",
          "Layer 1: Short-term memory stores current conversation context and active task state",
          "Layer 2: User memory tracks preferences, past issues, and resolution patterns",
          "Layer 3: Knowledge base grows with successful resolutions indexed by problem type"
        ]
      },
      {
        "input": "Create a temporal knowledge graph for tracking user address changes.",
        "output": [
          "Temporal validity periods track when each address was valid",
          "Time-aware queries reconstruct address at any historical point",
          "Relationships link users to addresses with from/until timestamps",
          "Consolidation merges outdated addresses while preserving history"
        ]
      }
    ],
    "best_practices": [
      "Match memory architecture complexity to actual query requirements",
      "Implement progressive disclosure showing only relevant memories",
      "Use temporal validity periods to prevent context clash from outdated information"
    ],
    "anti_patterns": [
      "Storing everything in context without any memory architecture",
      "Using simple vector stores for tasks requiring relationship reasoning",
      "Never consolidating memories leading to unbounded growth"
    ],
    "faq": [
      {
        "question": "What AI tools support this skill?",
        "answer": "Works with Claude, Codex, and Claude Code. Compatible with any LLM-based agent system."
      },
      {
        "question": "What are the memory size limits?",
        "answer": "Memory limits depend on implementation. In-memory systems scale to available RAM. Database-backed systems scale with storage."
      },
      {
        "question": "How does this integrate with existing systems?",
        "answer": "Provides patterns that work with any vector database, graph database, or storage layer. Implementation code is standalone."
      },
      {
        "question": "Is user data safe in persistent memory?",
        "answer": "Memory data stays within your infrastructure. Implement access controls and encryption for sensitive information."
      },
      {
        "question": "Why are my memory queries returning outdated results?",
        "answer": "Enable temporal filtering or run consolidation. Without validity periods, old facts remain in results."
      },
      {
        "question": "How does this compare to vector RAG?",
        "answer": "Vector RAG provides semantic search. Knowledge graphs add relationship structure. Temporal graphs add time validity."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "implementation.md",
          "type": "file",
          "path": "references/implementation.md",
          "lines": 459
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "memory_store.py",
          "type": "file",
          "path": "scripts/memory_store.py",
          "lines": 397
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 222
    }
  ]
}
