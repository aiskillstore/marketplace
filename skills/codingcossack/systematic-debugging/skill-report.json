{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-16T21:48:11.268Z",
    "slug": "codingcossack-systematic-debugging",
    "source_url": "https://github.com/CodingCossack/agent-skills-library/tree/main/skills/systematic-debugging",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "3.0.0",
    "source_type": "community",
    "content_hash": "d235d3e44157963fb51e9db52dacd524f27213741451158305bc6daa41f1eea3",
    "tree_hash": "ee27c5848735aced1cbbd64cb9659c9fdb8572ddfc8f9c17722bae2d5364d523"
  },
  "skill": {
    "name": "systematic-debugging",
    "description": "Root cause analysis for debugging. Use when bugs, test failures, or unexpected behavior have non-obvious causes, or after multiple fix attempts have failed.",
    "summary": "Root cause analysis for debugging. Use when bugs, test failures, or unexpected behavior have non-obv...",
    "icon": "üîç",
    "version": "1.0.0",
    "author": "CodingCossack",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "debugging",
      "testing",
      "root-cause",
      "analysis"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "safe",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "All static findings are FALSE POSITIVES. The 'external_commands' patterns are markdown documentation examples, not executable code. The 'find-polluter.sh' script is a legitimate debugging tool. Environment variable access is for defensive test guards. No malicious patterns confirmed after semantic evaluation.",
    "risk_factor_evidence": [
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "scripts/find-polluter.sh",
            "line_start": 1,
            "line_end": 75
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "scripts/find-polluter.sh",
            "line_start": 25,
            "line_end": 32
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "scripts/find-polluter.sh",
            "line_start": 53,
            "line_end": 53
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [],
    "dangerous_patterns": [],
    "files_scanned": 7,
    "total_lines": 1085,
    "audit_model": "claude",
    "audited_at": "2026-01-16T21:48:11.268Z"
  },
  "content": {
    "user_title": "Debug systematically and find root causes",
    "value_statement": "Stop guessing at fixes and start finding real root causes. This skill provides a systematic debugging methodology that prevents wasted time on symptom fixes and repeated failed attempts.",
    "seo_keywords": [
      "debugging",
      "root cause analysis",
      "systematic debugging",
      "Claude debugging",
      "Codex debugging",
      "Claude Code debugging",
      "flaky tests",
      "test failures",
      "debugging methodology"
    ],
    "actual_capabilities": [
      "Provides 4-phase systematic debugging methodology",
      "Includes shell script to identify test pollution sources",
      "Offers TypeScript utilities for condition-based waiting",
      "Teaches defense-in-depth validation patterns",
      "Explains backward tracing techniques for complex bugs"
    ],
    "limitations": [
      "Requires manual implementation of debugging steps",
      "Shell script only works with npm test environments",
      "Methodology works best with reproducible issues",
      "Does not automatically fix discovered root causes"
    ],
    "use_cases": [
      {
        "target_user": "Software developers",
        "title": "Fix persistent test failures",
        "description": "When tests fail inconsistently or after multiple attempted fixes, use systematic debugging to find the actual root cause instead of applying band-aid solutions."
      },
      {
        "target_user": "DevOps engineers",
        "title": "Debug multi-component system issues",
        "description": "Trace problems through CI pipelines, build systems, and deployment chains by adding diagnostic instrumentation at each component boundary."
      },
      {
        "target_user": "QA engineers",
        "title": "Investigate test pollution",
        "description": "Use the find-polluter script to identify which specific test is creating unwanted files or state that affects other tests."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic debugging",
        "scenario": "Test is failing inconsistently",
        "prompt": "Use systematic debugging to investigate this flaky test failure. The error occurs randomly about 30% of the time. Start by helping me reproduce it consistently and then trace the root cause."
      },
      {
        "title": "Multi-component issues",
        "scenario": "CI pipeline has mysterious failures",
        "prompt": "Our CI pipeline fails at the signing step, but only sometimes. The build and test steps pass. Use systematic debugging to help me add diagnostic instrumentation at each component boundary to find where the issue originates."
      },
      {
        "title": "Test pollution",
        "scenario": "Git repository appears in source directory",
        "prompt": "A .git directory keeps appearing in our packages/core directory during test runs. Use the find-polluter script to identify which test is creating it, then trace the root cause of why it is using the wrong directory."
      },
      {
        "title": "Complex debugging",
        "scenario": "After 3+ failed fix attempts",
        "prompt": "I have tried fixing this database connection issue 4 times already. Each fix reveals a new problem. Stop me from continuing this pattern and help question whether we are dealing with a fundamental architectural issue instead of a simple bug."
      }
    ],
    "output_examples": [
      {
        "input": "Help me debug why our integration tests are creating files in the wrong directory",
        "output": [
          "Phase 1: Investigation - Added diagnostic logging at each component boundary",
          "Discovered empty projectDir being passed to git init",
          "Traced back to test setup accessing tempDir before initialization",
          "Phase 2: Pattern Analysis - Found similar tests use lazy initialization pattern",
          "Identified that early access returns empty string",
          "Empty string as cwd resolves to process.cwd()",
          "Phase 3: Root Cause - The test initialization accessed tempDir before beforeEach, getting empty string that caused git init in source directory",
          "Phase 4: Fix - Made tempDir a getter that throws if accessed early, Added 4-layer validation, Bug now impossible to reproduce"
        ]
      },
      {
        "input": "Our API calls are failing intermittently in production but passing in staging",
        "output": [
          "Phase 1: Gather evidence at each layer",
          "CI environment variables, build configuration, deployment context",
          "Phase 2: Compare staging vs production configurations",
          "Found differences in connection pool settings",
          "Phase 3: Hypothesis - Connection pool exhaustion under load",
          "Phase 4: Test with increased pool size in staging first",
          "Verify hypothesis before full production deployment"
        ]
      }
    ],
    "best_practices": [
      "Always reproduce the issue consistently before attempting any fix",
      "Trace data flow backward through the call stack to find the original source",
      "Add validation at multiple layers to make bugs structurally impossible"
    ],
    "anti_patterns": [
      "Applying quick fixes without understanding the root cause",
      "Using arbitrary timeouts instead of waiting for actual conditions",
      "Continuing to apply fixes after multiple failed attempts without questioning fundamentals"
    ],
    "faq": [
      {
        "question": "Is this compatible with any testing framework?",
        "answer": "Yes, the systematic approach works with any framework. The shell script requires npm test but the principles are universal."
      },
      {
        "question": "How long does systematic debugging take?",
        "answer": "Initial investigation may take longer than quick fixes, but prevents wasted time on symptom fixes that do not work."
      },
      {
        "question": "Can I integrate this with my CI/CD pipeline?",
        "answer": "Yes, use the diagnostic instrumentation techniques to add logging at component boundaries in your pipeline."
      },
      {
        "question": "Is my code safe when using the debugging tools?",
        "answer": "Yes, the tools only read files and execute tests you specify. No data leaves your machine."
      },
      {
        "question": "What if I cannot reproduce the issue consistently?",
        "answer": "Gather more data instead of guessing. Add logging, run tests multiple times, collect environmental information."
      },
      {
        "question": "How is this different from regular debugging?",
        "answer": "Regular debugging often treats symptoms. This methodology forces you to find and fix the root cause systematically."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "condition-based-waiting.md",
          "type": "file",
          "path": "references/condition-based-waiting.md",
          "lines": 118
        },
        {
          "name": "defense-in-depth.md",
          "type": "file",
          "path": "references/defense-in-depth.md",
          "lines": 131
        },
        {
          "name": "root-cause-tracing.md",
          "type": "file",
          "path": "references/root-cause-tracing.md",
          "lines": 172
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "condition-based-waiting-example.ts",
          "type": "file",
          "path": "scripts/condition-based-waiting-example.ts",
          "lines": 173
        },
        {
          "name": "find-polluter.sh",
          "type": "file",
          "path": "scripts/find-polluter.sh",
          "lines": 75
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md",
      "lines": 142
    }
  ]
}
