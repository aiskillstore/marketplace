{
  "schema_version": "2.0",
  "meta": {
    "generated_at": "2026-01-10T12:40:59.471Z",
    "slug": "codingcossack-systematic-debugging",
    "source_url": "https://github.com/CodingCossack/agent-skills-library/tree/main/skills/systematic-debugging",
    "source_ref": "main",
    "model": "claude",
    "analysis_version": "2.0.0",
    "source_type": "community",
    "content_hash": "d235d3e44157963fb51e9db52dacd524f27213741451158305bc6daa41f1eea3",
    "tree_hash": "281f18b8907d999e03b52cec5322934a92a52fa504659480064620c8d6b5f473"
  },
  "skill": {
    "name": "systematic-debugging",
    "description": "Root cause analysis for debugging. Use when bugs, test failures, or unexpected behavior have non-obvious causes, or after multiple fix attempts have failed.",
    "summary": "Root cause analysis for debugging. Use when bugs, test failures, or unexpected behavior have non-obv...",
    "icon": "üîç",
    "version": "1.0.0",
    "author": "CodingCossack",
    "license": "MIT",
    "category": "coding",
    "tags": [
      "debugging",
      "testing",
      "root-cause",
      "analysis"
    ],
    "supported_tools": [
      "claude",
      "codex",
      "claude-code"
    ],
    "risk_factors": [
      "scripts",
      "filesystem",
      "external_commands"
    ]
  },
  "security_audit": {
    "risk_level": "low",
    "is_blocked": false,
    "safe_to_publish": true,
    "summary": "Skill contains legitimate debugging tools including a shell script for test pollution detection and TypeScript utilities for condition-based waiting. All capabilities align with stated debugging purpose. No malicious patterns detected.",
    "risk_factor_evidence": [
      {
        "factor": "scripts",
        "evidence": [
          {
            "file": "scripts/find-polluter.sh",
            "line_start": 1,
            "line_end": 75
          }
        ]
      },
      {
        "factor": "filesystem",
        "evidence": [
          {
            "file": "scripts/find-polluter.sh",
            "line_start": 24,
            "line_end": 32
          }
        ]
      },
      {
        "factor": "external_commands",
        "evidence": [
          {
            "file": "scripts/find-polluter.sh",
            "line_start": 53,
            "line_end": 53
          }
        ]
      }
    ],
    "critical_findings": [],
    "high_findings": [],
    "medium_findings": [],
    "low_findings": [
      {
        "title": "Shell script executes npm test commands",
        "description": "The find-polluter.sh script executes 'npm test' commands on user-provided test files. While this is legitimate for its debugging purpose, it could theoretically be misused if an attacker controls the test directory parameter. The script properly validates inputs and this represents minimal risk in normal usage.",
        "locations": [
          {
            "file": "scripts/find-polluter.sh",
            "line_start": 53,
            "line_end": 53
          }
        ]
      }
    ],
    "dangerous_patterns": [],
    "files_scanned": 6,
    "total_lines": 442,
    "audit_model": "claude",
    "audited_at": "2026-01-10T12:40:59.471Z"
  },
  "content": {
    "user_title": "Debug systematically and find root causes",
    "value_statement": "Stop guessing at fixes and start finding real root causes. This skill provides a systematic debugging methodology that prevents wasted time on symptom fixes.",
    "seo_keywords": [
      "debugging",
      "root cause analysis",
      "systematic debugging",
      "Claude debugging",
      "Codex debugging",
      "Claude Code debugging",
      "flaky tests",
      "test failures"
    ],
    "actual_capabilities": [
      "Provides 4-phase systematic debugging methodology",
      "Includes shell script to identify test pollution sources",
      "Offers TypeScript utilities for condition-based waiting",
      "Teaches defense-in-depth validation patterns",
      "Explains backward tracing techniques for complex bugs"
    ],
    "limitations": [
      "Requires manual implementation of debugging steps",
      "Shell script only works with npm test environments",
      "TypeScript examples need adaptation to specific codebases",
      "Methodology works best with reproducible issues"
    ],
    "use_cases": [
      {
        "target_user": "Software developers",
        "title": "Fix persistent test failures",
        "description": "When tests fail inconsistently or after multiple attempted fixes, use systematic debugging to find the actual root cause instead of applying band-aid solutions."
      },
      {
        "target_user": "DevOps engineers",
        "title": "Debug multi-component system issues",
        "description": "Trace problems through CI pipelines, build systems, and deployment chains by adding diagnostic instrumentation at each component boundary."
      },
      {
        "target_user": "QA engineers",
        "title": "Investigate test pollution",
        "description": "Use the find-polluter script to identify which specific test is creating unwanted files or state that affects other tests."
      }
    ],
    "prompt_templates": [
      {
        "title": "Basic debugging",
        "scenario": "Test is failing inconsistently",
        "prompt": "Use systematic debugging to investigate this flaky test failure. The error occurs randomly about 30% of the time. Start by helping me reproduce it consistently and then trace the root cause."
      },
      {
        "title": "Multi-component issues",
        "scenario": "CI pipeline has mysterious failures",
        "prompt": "Our CI pipeline fails at the signing step, but only sometimes. The build and test steps pass. Use systematic debugging to help me add diagnostic instrumentation at each component boundary to find where the issue originates."
      },
      {
        "title": "Test pollution",
        "scenario": "Git repository appears in source directory",
        "prompt": "A .git directory keeps appearing in our packages/core directory during test runs. Use the find-polluter script to identify which test is creating it, then trace the root cause of why it's using the wrong directory."
      },
      {
        "title": "Complex debugging",
        "scenario": "After 3+ failed fix attempts",
        "prompt": "I've tried fixing this database connection issue 4 times already. Each fix reveals a new problem. Stop me from continuing this pattern and help question whether we're dealing with a fundamental architectural issue instead of a simple bug."
      }
    ],
    "output_examples": [
      {
        "input": "Help me debug why our integration tests are creating files in the wrong directory",
        "output": [
          "Let's apply systematic debugging to find the root cause:",
          "",
          "Phase 1: Investigation",
          "- Added diagnostic logging at each component boundary",
          "- Discovered empty projectDir being passed to git init",
          "- Traced back to test setup accessing tempDir before initialization",
          "",
          "Phase 2: Pattern Analysis",
          "- Found similar tests use lazy initialization pattern",
          "- Identified that early access returns empty string",
          "- Empty string as cwd resolves to process.cwd()",
          "",
          "Phase 3: Root Cause",
          "The test's top-level variable initialization accessed tempDir before beforeEach() ran, getting empty string that caused git init in source directory.",
          "",
          "Phase 4: Fix",
          "- Made tempDir a getter that throws if accessed early",
          "- Added 4-layer validation (entry, business, environment, debug)",
          "- Bug now impossible to reproduce"
        ]
      }
    ],
    "best_practices": [
      "Always reproduce the issue consistently before attempting any fix",
      "Trace data flow backward through the call stack to find the original source",
      "Add validation at multiple layers to make bugs structurally impossible"
    ],
    "anti_patterns": [
      "Applying quick fixes without understanding the root cause",
      "Using arbitrary timeouts instead of waiting for actual conditions",
      "Continuing to apply fixes after multiple failed attempts without questioning fundamentals"
    ],
    "faq": [
      {
        "question": "Is this compatible with any testing framework?",
        "answer": "Yes, the systematic approach works with any framework. The shell script requires npm test but the principles are universal."
      },
      {
        "question": "How long does systematic debugging take?",
        "answer": "Initial investigation may take longer than quick fixes, but prevents wasted time on symptom fixes that don't work."
      },
      {
        "question": "Can I integrate this with my CI/CD pipeline?",
        "answer": "Yes, use the diagnostic instrumentation techniques to add logging at component boundaries in your pipeline."
      },
      {
        "question": "Is my code safe when using the debugging tools?",
        "answer": "Yes, the tools only read files and execute tests you specify. No data leaves your machine."
      },
      {
        "question": "What if I can't reproduce the issue consistently?",
        "answer": "Gather more data instead of guessing. Add logging, run tests multiple times, collect environmental information."
      },
      {
        "question": "How is this different from regular debugging?",
        "answer": "Regular debugging often treats symptoms. This methodology forces you to find and fix the root cause systematically."
      }
    ]
  },
  "file_structure": [
    {
      "name": "references",
      "type": "dir",
      "path": "references",
      "children": [
        {
          "name": "condition-based-waiting.md",
          "type": "file",
          "path": "references/condition-based-waiting.md"
        },
        {
          "name": "defense-in-depth.md",
          "type": "file",
          "path": "references/defense-in-depth.md"
        },
        {
          "name": "root-cause-tracing.md",
          "type": "file",
          "path": "references/root-cause-tracing.md"
        }
      ]
    },
    {
      "name": "scripts",
      "type": "dir",
      "path": "scripts",
      "children": [
        {
          "name": "condition-based-waiting-example.ts",
          "type": "file",
          "path": "scripts/condition-based-waiting-example.ts"
        },
        {
          "name": "find-polluter.sh",
          "type": "file",
          "path": "scripts/find-polluter.sh"
        }
      ]
    },
    {
      "name": "SKILL.md",
      "type": "file",
      "path": "SKILL.md"
    }
  ]
}
